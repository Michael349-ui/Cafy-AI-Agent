#**************************************************
# Copyright (c) 2024-2025 by Cisco Systems, Inc., and/or its affiliates.
# All rights reserved.
#**************************************************
import json
import re
import time,inspect
import csv
import datetime
import requests
import sys
import os,pdb
import tabulate
import urllib3 
import getpass
import netaddr
import ipaddress
import dpkt
from dpkt.utils import inet_to_str
from copy import deepcopy
import inspect
from zipfile import ZipFile
from itertools import islice, product
import functools
import random
import threading
from scapy.layers.l2 import Ether
from scapy.all import rdpcap
os.environ['OPENBLAS_NUM_THREADS'] = '1'
import pandas as pd
import numpy as np
from typing import List, Union, Optional, AnyStr, Dict, Any
from ixnetwork_restpy import BatchFind
from ixnetwork_restpy import SessionAssistant
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict
# from stubit.stubit import StubitUtil


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
# from requests.packages.urllib3.exceptions import InsecureRequestWarning
# requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

from logger.cafylog import CafyLog
from utils.cafyexception import CafyException
from utils.timer import Timer
from utils.helper import Helper
from tgn.ixia_utils import ScaleTraffic
from tgn.base import TGN
from tgn.ixia_ixnetwork import TrafficStats
try:
    from tgn.ixia_ixnetwork import VLAN, IPV46, IGMP, MLD, OSPFv2, OSPFv3, LDPv4, LDPv6, BGPv4, BGPv6 , ISIS
except:pass
log = CafyLog("ixia")

# Import Restpy library
from ixnetwork_restpy.testplatform.testplatform import TestPlatform
from ixnetwork_restpy.assistants.statistics.statviewassistant import StatViewAssistant
from ixnetwork_restpy.files import Files
from ixnetwork_restpy import BatchUpdate

class IxiaConfigException(Exception):
    """
    IXIA config exception
    """
    pass

class IxiaOperationException(Exception):
    """
    IXIA operation exception
    """
    pass

class IxiaStatsException(Exception):
    """
    IXIA stats exception
    """
    pass

def debug_log_decorator(func):
    """
    Decorator to download debug files on Ixia exception.
    :param None
    :return: None
    """
    @functools.wraps(func)
    def wrapper_decorator(*args, **kwargs):
        try:
            value = func(*args, **kwargs)
            return value
        except Exception as ex:
            try:
                args[0]._download_debug_files()
            except:
                pass
            log.error(ex)
            raise ex
    return wrapper_decorator

def timing_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        log.info(f"[TIME] {func.__qualname__} executed in {elapsed:.3f}s")
        return result
    return wrapper

def decorator_for_class(cls):
    """
    Class Decorator to apply decorator on all the public methods of Ixia class.
    :param None
    :return: None
    """
    for name, method in inspect.getmembers(cls):
        if (not inspect.ismethod(method) and not inspect.isfunction(method)) or inspect.isbuiltin(method):
            continue
        if name.startswith("_"):
            continue
        
        decorated = timing_decorator(debug_log_decorator(method))
        setattr(cls, name, decorated)

    return cls

@decorator_for_class
class IXIA(TGN):
    def get_handles(self):
        """
        get handles

        :return: list()
        """
        return list()

    def __init__(self, tgn_server_type='windows', server_ip=None, debug_print=False,
                 time_factor=1.0, verbose=True, timeout=300, api_version=1, session_name=None, user_name=None, topology='', **kwargs):
        """
        Initialize the REST API wrapper object.
        IxNetwork version should be 8.0 or above for REST api's to work.
        If the port to connect to is not specified by the port argument,then
        try connecting on the default port, 11009
        :param tgn_server_type (str): The type of IXIA lab server to be used
            e.g. 'windows', 'linux', 'windows_cm' (windows connection manager)
        :param use server_ip same as spirent lib
                server: Ixia REST Tcl server to connect to.
                    if None, raise IxiaConfigException
        :param port: HTTP port to connect to server on.
                    Default is '11009'
        :param debug_print: if True, enable debug print statements
        :param Use time_factor same as spirent lib
                    timer_scale_factor: multiplication factor for the methods using
        :param session_name: session_name for linux API server
        :param user_name: user_name for linux API server
        :param topology : Testbed name from topology file
        :param kwargs:
                    sessionId : sessionId for linux and windows
        :param verbose: verbose
        """
        self.log = CafyLog('IXIA')
        self.exception = CafyException()
        self.tgn_server_type = tgn_server_type
        if self.tgn_server_type == 'windows':
            self.port = kwargs.get('port', 11009)
        elif self.tgn_server_type == 'linux':
            self.port = kwargs.get('port', 443)
        self.tgn_server_user = kwargs.get('tgn_server_user', 'admin')
        self.tgn_server_pw = kwargs.get('tgn_server_pw', 'admin')

        self.topology_name = topology

        self._lab_servers = []
        if type(server_ip) in (list, tuple):
            self._lab_servers = server_ip
            self.server_ip = self._lab_servers[0].split(':')[0]
            if ':' in self._lab_servers[0]:
                self.port = self._lab_servers[0].split(':')[1]
        elif ':' in server_ip:
            self.port = server_ip.split(':')[1]
            self.server_ip = server_ip.split(':')[0]
        else:
            self.server_ip = server_ip

        if not user_name:
            self.user_name = getpass.getuser()
        else:
            self.user_name = user_name

        if not session_name:
            self.session_name = "testbed" + '_' + self.user_name
        else:
            self.session_name = session_name.replace('-', '_')
            self.session_name = ' - '.join((self.session_name, self.user_name))

        self.pxe = list()
        self.interfaces_info = kwargs.get('interfaces', [])
        self.interfaces = dict()
        self.interfaces_by_alias = dict()
        self.interfaces_in_zap = dict()
        self.links = dict()
        self.power_cycle_info = list()

        self.config_file = None
        self.timer_scale_factor = time_factor  # default timer  of 1s
        self.verbose = verbose
        self.device_type = kwargs.get('type')
        self.name = kwargs.get('name')
        self.alias = kwargs.get('alias')
        self.platform = kwargs.get('platform')
        self.chassis_ip = kwargs.get('chassis_ip')
        self.slave_chassis = kwargs.get('slave_chassis')
        self.primary = kwargs.get('primary')
        self.streamblockrds = {'ReturnedResultDataSet': None}
        self.timeout = timeout
        self.api_version = api_version
        self.session_id = None
        self.update_license = False
        self.bgp_devices = {}
        self.bgp_routes_startip_rid_v4 = {}
        self.bgp_routes_startip_device_name_v4 = {}
        self.bgp_routes_startip_port_name_v4 = {}
        self.bgp_routes_startip_rid_v6 = {}
        self.bgp_routes_startip_device_name_v6 = {}
        self.bgp_routes_startip_port_name_v6 = {}
        self.license_server = kwargs.get('license_server')
        self.disable_diag_log = False
        self.disable_trace_log = True

    def get_license_server(self):
        """
        Retrieve the license server for the IXIA TGEN device.
        :return: License server for IXIA TGEN
        """
        return self.license_server

    def _new_session(self, user_name=None, session_name=None, kill_existing=False):
        """
        API used internally

        :param user_name: user name
        :param session_name: session name for linux API server
        :param kill_existing: kill existing session in Linux API Server
        :return:
        """
        if self.tgn_server_type == 'windows':
            if isinstance(self._lab_servers, (list, tuple)) and len(self._lab_servers) > 1:
                # Multiple servers: try each until one works
                connected = False
                for srv in self._lab_servers:
                    try:
                        ip_addr, port = (srv.split(':') + [self.port])[:2]
                        self.server_ip, self.port = ip_addr, int(port)

                        self.log.info(f"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                        self.test_platform = TestPlatform(ip_address=self.server_ip,rest_port=self.port,platform='windows',
                                                         log_file_name=CafyLog.work_dir + '/restpy.log')
                        connected = True
                        break
                    except Exception as err:
                        self.log.warning(f"Failed to connect to {srv} ({err}). Trying next server...")
                        continue

                if not connected:
                    raise IxiaConfigException(f"Could not connect to any Ixia server: {self._lab_servers}")
            else:
                try:
                    self.log.info(f"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='windows',
                                                     log_file_name=CafyLog.work_dir + '/restpy.log')
                except:
                    self.log.info('Waiting before reconnecting to IxN API server')
                    time.sleep(100)
                    self.log.info(f"Reconnecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='windows',
                                                     log_file_name=CafyLog.work_dir + '/restpy.log')

            # Console output verbosity: None|request|'request response'
            if not self.disable_trace_log:
                self.test_platform.Trace = 'all'
            self.session = self.test_platform.Sessions.add()
            self.ixNetwork = self.session.Ixnetwork
            if kill_existing:
                self.ixNetwork.NewConfig()
            self.session_id = 1
            self.log.info("Ixia Lab Server - '%s'" % (self.server_ip))

        elif self.tgn_server_type == 'linux':
            if isinstance(self._lab_servers, (list, tuple)) and len(self._lab_servers) > 1:
                # Multiple servers: try each until one works
                connected = False
                for srv in self._lab_servers:
                    try:
                        ip_addr, port = (srv.split(':') + [self.port])[:2]
                        self.server_ip, self.port = ip_addr, int(port)
                        self.log.info(f"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                        self.test_platform = TestPlatform(ip_address=self.server_ip,rest_port=self.port,platform='linux',
                                                            log_file_name=CafyLog.work_dir + '/restpy.log')
                        connected = True
                        break
                    except Exception as err:
                        self.log.warning(f"Failed to connect to {srv} ({err}). Trying next server...")
                        continue

                if not connected:
                    raise IxiaConfigException(f"Could not connect to any Ixia server: {self._lab_servers}")
            else:
                try:
                    self.log.info(f"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='linux',
                                                     log_file_name=CafyLog.work_dir + '/restpy.log')
                except:
                    self.log.info('Waiting before reconnecting to IxN API server')
                    time.sleep(150)
                    self.log.info(f"Reconnecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'")
                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='linux',
                                                     log_file_name=CafyLog.work_dir + '/restpy.log')

            if not self.disable_trace_log:
                self.test_platform.Trace = 'all'
            self.test_platform.Authenticate(self.tgn_server_user, self.tgn_server_pw)

            self.log.info("Ixia Lab Server - '%s'" % (self.server_ip))
            self.get_sessions()

            if session_name and kill_existing == True:
                for session in self.test_platform.Sessions.find(Name=session_name):
                    session.remove()
                    Helper.sleep(15, msg='Waiting for Session Deletion')
                self.session = self.test_platform.Sessions.add(Name=session_name)
                self.log.info(f"Ixia Session Created - '{session_name}', Session ID - '{self.session.Id}'")
            elif session_name and kill_existing == False:
                if not self.test_platform.Sessions.find(Name=session_name):
                    raise IxiaConfigException("Session Name '%s' not configured or Failed to connect" % session_name)
                else:
                    self.session = self.test_platform.Sessions.find(Name=session_name)
            else:
                if self.test_platform.Sessions.find(Name=self.session_name):
                    self.session = self.test_platform.Sessions.find(Name=self.session_name)
                    self.log.info(f"Connecting to existing Ixia Session - '{self.session_name}', Session ID - '{self.session.Id}'")
                else:
                    self.session = self.test_platform.Sessions.add(Name=self.session_name)
                    self.log.info(f"Ixia Session Created - '{session_name}', Session ID - '{self.session.Id}'")
            self.ixNetwork = self.session.Ixnetwork
            self.session_name = self.session.Name

        # RestPy main entry point object self.ixNetwork

        self.ixNetworkSession = self.test_platform.Sessions

    def get_remote(self, link):
        """
        Get remote interface

        :param link: link in topology. Ex: 'R1_R2_1'
        :return: Remote interface of link in current device object

        :Example: get_remote('R1_R2_1')
        """
        int1 = link.interface1
        int2 = link.interface2

        if int1.device == self:
            return int2
        return int1

    def get_local(self, link):
        """
        Get local interface

        :param link: link in topology. Ex: 'R1_R2_1'
        :return: Local interface of link in current device object

        :Example: get_local('R1_R2_1')
        """
        int1 = link.interface1
        int2 = link.interface2

        if int1.device == self:
            return int1
        return int2

    def get_links(self, peer=None, link_type=None):
        """
        Returns links between IXIA and its peer

        :param peer: Peer device object
        :param link_type: Link type

        :Example: get_links()
        """
        if peer is None:
            return self.links
        links = {}
        for _interface, int_obj in self.interfaces.items():
            if int_obj.remote is not None and int_obj.remote.device.name == peer:
                if link_type is None:
                    links[int_obj.link.name] = int_obj.link
                else:
                    if int_obj.type == link_type:
                        links[int_obj.link.name] = int_obj.link
        return links

    def get_list_ports(self):
        """
        To get ports in config file

        :return: list of ports in configuration

        :Example: get_list_ports()
        """
        self.log.info("Getting List of Ports")
        return self.ixNetwork.Vport.find()

    def get_list_port_name(self):
        """
        Get list of port names in config

        :return: list of ports in user readable format in the session

        :Example: get_list_port_name()
        """
        self.log.info("vport name list")
        vport_name_list =[vport.Name for vport in self.ixNetwork.Vport.find()]
        return vport_name_list

    def new_blank_config(self):
        """
        Upload a new blank config file before loading a new config file

        :Example: new_blank_config()
        """
        self.log.info("Creating new blank config")
        self.ixNetwork.NewConfig()

    def get_traffic_items(self):
        """
        Get trafficItem Names available in the config

        :return: List of enabled traffic name.If failed, raise IxiaOperationException

        :Example: get_traffic_items()
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info("Available traffic Items")
        try:
            trafficItems = []
            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                trafficItems.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find()])
            if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
                trafficItems.append([quickFlow.Name for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find()])
            return trafficItems[0]
        except:
            raise IxiaOperationException("No Traffic Items Found")

    def get_active_streams(self):
        """
        Get list of enabled(active) streams in config

        :return: list of active stream names in config

        :Example: get_active_streams()
        """
        self.log.info("Streams in Active State")
        trafficItems = []
        try :
            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                trafficItems = self.ixNetwork.Traffic.TrafficItem.find(Enabled=True)
                return [trafficItem.Name for trafficItem in trafficItems if trafficItem]
        except:
            self.log.info("re-trying traffic config element")
            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                trafficItems = self.ixNetwork.Traffic.TrafficItem.find(Enabled=True)
                return [trafficItem.Name for trafficItem in trafficItems if trafficItem]
            elif self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
                if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True):
                    trafficItems = self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True)
                    return [trafficItem.Name for trafficItem in trafficItems if trafficItem]
        if not trafficItems:
            self.log.error("No Active Traffic Streams")

    def get_interface(self, alias=None, name=None):
        """
        Gets a single interface object based on a name or alias

        :param alias: Alias of interface
        :param name:  Name of the interface
        :return: Interface object

        :Example: get_interface()
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return        
        if name:
            return self.interfaces[name]
        return self.interfaces_by_alias[alias]

    def get_interfaces(self, peer=None, int_type=None, zap_only=False, by_name=False, sub_interfaces=False):
        """
        Gets a dict of interface objects based on a name or alias

        :param peer: Per device object
        :param int_type: Interface type
        :param zap_only: True if you want only interfaces defined in zap
        :param by_name: True if key needs to be interface name instead of alias in dictionary of interfaces returned
        :param sub_interfaces: True if sub interfaces are to be included
        :return: Dictionary of interfaces

        :Example: get_interfaces()
        """
        if zap_only:
            interfaces = self.interfaces_in_zap
        else:
            interfaces = self.interfaces

        new_interfaces = {}

        if by_name:
                intf_by_name = {}
                for intf,intf_obj in interfaces.items():
                    intf_by_name[intf_obj.name] = intf_obj
                interfaces = intf_by_name

        if int_type:
            int_type = int_type.upper()
            for intf, intf_obj in interfaces.items():
                if intf_obj.type == int_type:
                    new_interfaces[intf] = intf_obj
            interfaces = new_interfaces

        new_interfaces = {}

        if peer:
            for intf, intf_obj in interfaces.items():
                if intf_obj.remote is not None and intf_obj.remote.device == peer:
                    new_interfaces[intf_obj] = intf_obj.remote
            interfaces = new_interfaces

        for intf, intf_obj in interfaces.items():
                if intf_obj.type == 'vlan':
                    if sub_interfaces:
                        new_interfaces[intf] = intf_obj
                else:
                     new_interfaces[intf] = intf_obj
        interfaces = new_interfaces
        return interfaces

    def get_interfaces_by_name(self, peer=None, int_type=None, zap_only=False):
        """
        get interface by name

        :param peer: The name of the peer
        :param int_type: The interface type
        :param zap_only: Whether or not this interface is zap only

        :Example: get_interfaces_by_name()
        """
        new_interfaces = {}
        if zap_only:
            interfaces = self.interfaces_in_zap
        else:
            interfaces = self.interfaces
        if peer:
            for intf, intf_obj in interfaces.items():
                if intf_obj.remote is not None and intf_obj.remote.device == peer:
                    if int_type:
                        int_type = int_type.upper()
                        if intf_obj.type == int_type:
                            new_interfaces[intf] = intf_obj.remote.name
                    else:
                        new_interfaces[intf] = intf_obj.remote.name
            return list(new_interfaces.keys())
        return list(interfaces.keys())

    def connect_to_chassis(self, chassis_ip_list):
        """
        Connect to IXIA Chassis

        :param chassis_ip_list: list of chassis' IPs to which session has to connect
        :return: True if successful

        :Example: connect_to_chassis(["10.39.60.120"])
        """
        self.log.info("Connection to the Chassis:%s" % (chassis_ip_list))
        timeout = 300
        for chassisIp in chassis_ip_list:
            self.ixNetwork.AvailableHardware.Chassis.add(Hostname=chassisIp)
            for counter in range(1, timeout):
                if self.ixNetwork.AvailableHardware.Chassis.find(Hostname=chassisIp).State == 'ready':
                    self.log.info(f"Connected to chassis -'{chassisIp}' successfully")
                    break
                else:
                    time.sleep(1)
                if counter == 299:
                    raise IxiaConfigException('Connect Chassis: Connecting to chassis {0} failed'.format(chassisIp))
        return True

    def _update_media_type(self):
        """
        Internal function to update the ports media type to 'Fiber' for NOVUS10G Load Modules
        :return:
        """
        for vport in self.ixNetwork.Vport.find():
            cardType = vport.Type
            if cardType == 'novusTenGigLan':
                cardType = cardType[0].upper() + cardType[1:]
                cardObj = eval('vport.L1Config.' + cardType)
                cardObj.Media = 'fiber'
            if cardType == 'novusHundredGigLan':
                cardType = cardType[0].upper() + cardType[1:]
                cardObj = eval('vport.L1Config.' + cardType)
                cardObj.IeeeL1Defaults = True

    def _assign_ports(self, port_tuple, update_portname=False):
        """
        Function used internally by other APIS,Assign Ports and Verify

        :param port_tuple: [[chassisIP, card, port], [chassisIP, card, port],..]
        :param update_portname: True/False
        """
        forceTakePortOwnership = True
        # Forcefully take port ownership if the portList are owned by other users.
        testPorts = []
        self.ixNetwork.Vport.find().UnassignPorts(arg2=False)
        vportList = [vport.href for vport in self.ixNetwork.Vport.find()]
        for port in port_tuple:
            testPorts.append(dict(Arg1=port[0], Arg2=port[1], Arg3=port[2]))
        self.ixNetwork.AssignPorts(testPorts, [], vportList, forceTakePortOwnership)
        self._update_media_type()
        if update_portname:
            for portObj in self.ixNetwork.Vport.find():
                assignedCard = portObj.AssignedTo.split(":")[1]
                assignedPort = portObj.AssignedTo.split(":")[2]
                portObj.Name = assignedCard + '/' + assignedPort

    def _update_port_name(self):
        """
        update the port name accordingly as connected to Chassis

        :return:
        """
        for vport in self.ixNetwork.Vport.find():
            assignedCard = vport.AssignedTo.split(":")[1]
            assignedPort = vport.AssignedTo.split(":")[2]
            portName = vport.Name
            if re.search(r'//(\d+)/(\d+)', portName):
                existingCard = re.search(r'//(\d+)/(\d+)', portName).group(1)
                existingPort = re.search(r'//(\d+)/(\d+)', portName).group(2)

                existing = '//' + existingCard + '/' + existingPort
                assigned = '//' + assignedCard + '/' + assignedPort
                portName = portName.replace(existing, assigned)
                vport.Name = portName

    def load_config(self, config_file=None, port_tuple=None, debug_print=False, reserve_ports=True, **kwargs):
        """
        API used to load existing config file with extension .ixncfg or .json

        :param config_file: The full path including the saved config file
        :param port_tuple: [chassisIP/card/port,chassisIP/card/port,...]
        :param debug_print: Enables the debug - optional
        :param reserve_ports: Reserve the mapped ports in the config - optional
        :return: True if successful else raise Exception

        :Example: load_config(config_file='ospf_bgp_ldp_config.ixncfg', port_tuple=["10.39.60.120/1/1","10.39.60.120/1/2"])
        """
        # if StubitUtil.is_stubit_playback():
        #     log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
        #     return

        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)

        if self.update_license == False:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        if config_file:
            self.log.info("Loading config file {0}".format(config_file))
            self.ixNetwork.LoadConfig(Files(config_file, local_file=True))
        else:
            self.log.debug('No config file given, attaching to existing session')
            self.new_blank_config()
        self.ixNetwork.Traffic.UseRfc5952 = True
        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True
        if self.chassis_ip and ',' in self.chassis_ip:
            chassis_to_be_connected = self.chassis_ip.split(',')
            chassis_to_be_connected = [item.strip() for item in chassis_to_be_connected]
            self.connect_to_chassis(chassis_to_be_connected)
            self.chassis_ip = chassis_to_be_connected[0]
        if port_tuple:
            self.log.info('List of ports {0}'.format(port_tuple))
            chassis_list = []
            port_list = []
            for port in port_tuple:
                chassis_list_temp = port.split('/')
                port_list_temp = port.split('/')
                if len(chassis_list_temp) < 3 and self.chassis_ip:
                    chassis_list.append(self.chassis_ip)
                    port_list_temp.insert(0, self.chassis_ip)
                else:
                    chassis_list.append(port.split('/')[0])
                port_list.append(port_list_temp)
            chassis_list = list(set(chassis_list))
            if self.primary:
                self.connect_to_chassis([self.primary])
            self.connect_to_chassis(chassis_list)
            port_info_list = ['IsAvailable', 'IsBusy', 'IsLinkUp', 'IsUsable', 'Owner']
            aresone_info_list = ['IsAvailable', 'IsConnected', 'IsMapped', 'AdminMode', 'ConnectionState']
            port_name_list = self.get_list_ports()
            if len(port_tuple) > len(port_name_list):
                for _ in range(len(port_tuple) - len(port_name_list)):
                    self.ixNetwork.Vport.add()
                port_name_list = self.get_list_ports()
            if len(port_name_list) > len(port_tuple):
                raise IxiaConfigException(
                    f"Invalid port assignment, config has {len(port_name_list)} port but given "
                    f"only {len(port_tuple)} port")
            self.ixNetwork.Vport.find().UnassignPorts(arg2=False)
            share_info = True
            session_assistant = SessionAssistant(IpAddress=self.server_ip, RestPort=self.port,
                                                 UserName=self.tgn_server_user,
                                                 Password=self.tgn_server_pw,
                                                 SessionName=self.session_name, SessionId=None, ApiKey=None,
                                                 ClearConfig=False,
                                                 LogFilename='restpy.log')
            port_map = session_assistant.PortMapAssistant()
            for port in port_list:
                vport_info_dict = {}
                port_info_dict = {}
                port_index = port_list.index(port)
                port_name = ''.join([_ for _ in port_name_list[port_index].Name if _ not in '()[]$^?.*+'])
                port_name_list[port_index].Name = port_name
                chassis_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname=port[0])
                if re.search(r'aresOne', chassis_obj.ChassisType, re.IGNORECASE):
                    port_info_dict = {}
                    if share_info:
                        self.log.info(f'Assigning ports for {chassis_obj.ChassisType} chassis')
                        share_info = False
                    port_info_dict.update({port_tuple[port_index]: {}})
                    for aresone_info in aresone_info_list:
                        port_info_dict[port_tuple[port_index]].update(
                            {aresone_info: getattr(port_name_list[port_index], aresone_info)})
                    self.log.info(port_info_dict)
                    try:
                        location = f'{port[0]}/{port[1]}.{port[2]}'
                        vport_info_dict[port_name] = port_map.Map(Location=location,
                                                                  Name=port_name_list[port_index].Name)
                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)
                    except:
                        location = f'{port[0]};{port[1]};{port[2]}'
                        vport_info_dict[port_name] = port_map.Map(Location=location,
                                                                  Name=port_name_list[port_index].Name)
                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)
                else:
                    port_obj = chassis_obj.Card.find(
                        CardId='^' + port[1] + '$').Port.find(PortId='^' + port[2] + '$')
                    if port_obj:
                        port_info_dict.update({'/'.join(port): {}})
                        location = f'{port[0]};{port[1]};{port[2]}'
                        for port_info in port_info_list:
                            port_info_dict['/'.join(port)].update({port_info: eval('port_obj' + '.' + port_info)})
                            
                        # ---- NEW INFO ----
                        extra_info = {}

                        try:
                            extra_info["Port Type"] = port_obj.Description
                        except:
                            extra_info["Port Type"] = "N/A"

                        try:
                            extra_info["Card"] = chassis_obj.Card.find(
                                CardId='^' + port[1] + '$').Description
                        except:
                            extra_info["Card Speed"] = "N/A"

                        try:
                            extra_info["Chassis Version"] = chassis_obj.ChassisVersion
                        except:
                            extra_info["Chassis Version"] = "N/A"

                        port_info_dict.update(extra_info)
                        self.log.info(port_info_dict)
                        vport_info_dict[port_name] = port_map.Map(Location=location, Name=port_name)
                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)
                    else:
                        self.log.error(f'Port {port[1]}/{port[2]} not found in the chassis {port[0]}')
            self._update_media_type()
            self.log.info("Given ports are assigned and connected")
            if self.primary:
                self.set_chassis_mode(primary=self.primary, secondary=chassis_list)
            self._update_port_name()
            # Check if existing session is active
            if self.ixNetworkSession.find().Id == 0:
                raise IxiaConfigException("Existing session inactive")
        # if config_file:
        #     try:
        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Start()
        #         self.log.debug("Waiting for Ethernet to start completely")
        #         self._wait_for_protocol_action_complete(timeout=300,operation_name='Start Ethernet')
        #     except:
        #         pass
        #     try:
        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Start()
        #         self.log.debug("Waiting for IPv4 to start completely")
        #         self._wait_for_protocol_action_complete(timeout=300, operation_name='Start IPv4')
        #     except:
        #         pass
        #     try:
        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Start()
        #         self.log.debug("Waiting for IPv6 to start completely")
        #         self._wait_for_protocol_action_complete(timeout=300, operation_name='Start IPv6')            
        #     except:
        #         pass

        self.log.info("Loading config file complete")
        return True

    def _perform(self, clear_value=None, **kwargs):
        """
        Clears the traffic statistics on the chassis

        :param clear_value: NA for IXIA
        :return: True if success, false if error
        """

        self.clear_traffic_stats()

    def start_all_protocols(self, **kwargs):
        """
        Start all the configured protocols in config file

        :return: True if successful else Raise Exception

        :Example: start_all_protocols()
        """
        # if StubitUtil.is_stubit_playback():
        #     log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
        #     return
        # pdb.set_trace()
        self.log.info("Starting all Protocols")
        # try: self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().SendNs()
        # except: pass
        self.ixNetwork.StartAllProtocols(Arg1='sync')
        self._wait_for_protocol_action_complete(timeout=1000)
        return True

    def stop_all_protocols(self, **kwargs):
        """
        Stop all the configured protocols in config file

        :return: True if successful else Raise Exception

        :Example: stop_all_protocols()
        """
        self.log.info("Stopping all Protocols")
        self.ixNetwork.StopAllProtocols(Arg1='sync')
        return True

    def regenerate_traffic(self):
        """
        Regenerate all traffic items

        :return: True else Raise IxiaOperationException if failed

        :Example: regenerate_traffic()
        """
        try:
            self.log.info('Regenerating Traffic Items')
            if self.ixNetwork.Traffic.State == 'started':
                pass
            else:
                trafficItem = self.ixNetwork.Traffic.TrafficItem.find()
                trafficItem.Generate()
        except:
            raise IxiaOperationException("Failed to Re-Generate Traffic")
        return True

    def get_license_details(self):
        """
        Get the Chassis license details from global licensing settings

        :return: License details

        :Example: get_license_details()
        """

        self.log.info("Current License Info: {}".format(self.ixNetwork.Globals.Licensing))
        return self.ixNetwork.Globals.Licensing

    def update_license_server(self, server_ip=None, mode=None, tier=None, port='hw', **kwargs):
        """
        Update the license server ip, mode, tier

        :param server_ip: license server ip in list
        :param mode: license mode: subscription, perpetual,aggregation or mixed.
        :param tier: tier1, tier2, tier3, tier3-10g etc
        :param port: Port mode like hardware(hw) or virtual
        :param kwargs: optional arguments, new_session to create or connect to existing session

        :Examples:
        #tgnObj.update_license_server(server_ip=["10.36.237.189"],port='virtual',mode='aggregation')
        #tgnObj.update_license_server(server_ip=["10.36.237.189"],port='hw',mode='subscription')
        #tgnObj.update_license_server(server_ip=["10.36.237.189"],port='virtual',mode='perpetual')
        #tgnObj.update_license_server(server_ip=["10.36.237.189"],mode='subscription')
        #tgnObj.update_license_server(mode='subscription')
        #update_license_server(server_ip=server_ip, port='virtual', mode='subscription', tier='tier2', new_session=False)
        """
        kill = kwargs.get("new_session", True)
        self._new_session(self.user_name, self.session_name, kill_existing=kill)
        if not kill:
            ports = self.ixNetwork.Vport.find()
            ports.ReleasePort()
            Helper.sleep(5, msg='Waiting for ports to be released')
        if server_ip:
            self.log.info(f"setting license info for server: {server_ip}")
            self.ixNetwork.Globals.Licensing.LicensingServers = server_ip
        if port == 'hw':
            if mode:
                try:
                    self.log.info(f"setting hw license mode: {mode}")
                    self.ixNetwork.Globals.Licensing.HwMode = mode
                except:
                    self.log.error("HW Mode setting failed")
        elif port == 'virtual':
            if mode:
                try:
                    self.log.info(f"setting virtual license mode: {mode}")
                    self.ixNetwork.Globals.Licensing.VmMode = mode
                except:
                    self.log.error("Virtual Mode setting failed")
        else:
            self.log.warning("Please select valid mode")
        if tier:
            try:
                self.log.info(f"setting license tier: {tier}")
                self.ixNetwork.Globals.Licensing.Tier = tier
            except:
                self.log.error('License Tier Setting failed')
        if not kill:
            ports = self.ixNetwork.Vport.find()
            ports.ConnectPorts(arg2=True)
            Helper.sleep(5, msg='Waiting for ports to come up')
        self.update_license = True

    def _apply_traffic(self):
        """
        API to apply the traffic
        :return:
        """
        self.ixNetwork.Traffic.Apply()
        globals = self.ixNetwork.Globals
        for apperrors in globals.AppErrors.find():
            for error in apperrors.Error.find():
                if hasattr(error, 'Description'):
                    if "One or more destination MACs or VPNs are invalid" in error.Description:
                        try:
                            self.verify_arp()
                        except Exception as err:
                            self.log.info(f'{err}')
                        try:
                            self.verify_arp(ip_type='ipv6')
                        except Exception as err:
                            self.log.info(f'{err}')
                        raise IxiaOperationException("Failed to apply traffic as packets are not generated properly")
                else:
                    self.log.warning('No Errors: %s' % error)

    def start_traffic(self, traffic_list=None, **kwargs):
        """
        Starts traffic on streams on all Ports or selected Stream blocks

        :param traffic_list: Traffic stream list names on which traffic will be started.
                             If None traffic starts with streams that are already active in config
        :param kwargs: Spirent specific optional argument
                       start_object: Port or Stream
                       ignore_errors : Default is False, send True if want to avoid errors
                       duration : time duration in sec for traffic flow
        :return: True on success

        :Example: start_traffic()
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info('Starting traffic...')
        timeout = 200
        ignore_errors = kwargs.get("ignore_errors",False)
        quick_flow_group = kwargs.get("quick_flow_group", False)
        ignore_regenerate = kwargs.get("ignore_regenerate", False)
        start_only = kwargs.get("start_only", False)
        start_arp = kwargs.get("verify_arp", True)
        duration = kwargs.get("duration", 0)

        if start_arp:
            self.start_arp()
            Helper.sleep(5, msg='Waiting for Sending ARP/NS')
        if not start_only:
            if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:
                self.stop_traffic()

        if 'traffic_item_list' in kwargs:
            traffic_list = kwargs['traffic_item_list']
        start_object = kwargs.get('start_object', 'stream')
        if start_object.lower() != 'port':
            start_object = 'stream'

        if not start_only:
            for _ in range(1, timeout):
                if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:
                    time.sleep(1)
                else:
                    break

        if not start_only:
            if traffic_list:
                if not quick_flow_group:
                    self.enable_traffic_item(traffic_item_list=traffic_list)
                if quick_flow_group:
                    for traffic_stream in traffic_list:
                        traffic_stream = traffic_stream.replace('+', r'\+').replace('*', r'\*').replace('(',r'\(').replace(')',r'\)')
                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Name='^' + traffic_stream + '$').Enabled = True

        if not ignore_regenerate:
            self.log.info('Regenerate traffic items')
            self.regenerate_traffic()

        if not start_only:
            for _ in range(1, timeout):
                if self.ixNetwork.Traffic.State not in ['stopped','stoppedWaitingForStats','unapplied']:
                    time.sleep(1)
                else:
                    break

        if not start_only:
            self.log.info('Apply all traffic items')
            if ignore_errors:
                self.ixNetwork.Traffic.Apply()
            else:
                self._apply_traffic()

        if not start_only:
            for _ in range(1, timeout):
                if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:
                    time.sleep(1)
                else:
                    break

        if start_object == 'port':
            if 'port_list' in kwargs:
                for name in kwargs['port_list']:
                    self.ixNetwork.Vport.find(Name=name).StartStatelessTraffic()
            else:
                for vport in self.ixNetwork.Vport.find():
                    try:
                        vport.StartStatelessTraffic()
                    except:
                        pass
        elif traffic_list:
            self.log.info(f"Traffic streams list:{traffic_list}")
            try:
                for traffic_stream in traffic_list:
                    each_traffic = re.escape(traffic_stream)
                    try:
                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').StartStatelessTraffic()
                        self.log.info(f"Traffic started for: {traffic_stream}")
                    except:
                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(
                            Name=f'^{each_traffic}$').StartStatelessTraffic()
                        self.log.info(f"Traffic started for: {traffic_stream}")
            except Exception as err:
                raise IxiaConfigException(f"Failed to start Traffic on traffic_stream due to : {err}")
        else:
            try:
                if quick_flow_group:
                    self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find().StartStatelessTraffic()
                    self.log.info("Starting Traffic on all Enabled Quick Flow Groups")
                else:
                    self.ixNetwork.Traffic.Start()
                    self.log.info("Starting Traffic on all Enabled Traffic Items")
            except Exception as err:
                raise IxiaConfigException(f"Failed to start Traffic on traffic_stream due to : {err}")

        for _ in range(1, timeout):
            if self.ixNetwork.Traffic.State == 'started':
                self.log.info('Traffic started')
                break
            else:
                time.sleep(1)
        if duration != 0:
            self.log.info(f'Traffic will run for {duration} seconds...')
            time.sleep(duration)
        return True

    def stop_traffic(self,traffic_list=None,**kwargs):
        """
        To Stop traffic

        :param traffic_list: Traffic stream list names on which traffic will be stopped.
                     If None traffic stops with streams that are already active in config
        :return: True if successful else Raise Exception

        :Example: stop_traffic()
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        timeout = 60
        sleep_time = kwargs.get('sleep_time', 5)

        if 'traffic_item_list' in kwargs:
            traffic_list = kwargs['traffic_item_list']
        if traffic_list:
            self.log.info('Stopping traffic...')
            try:
                for traffic_stream in traffic_list:
                    each_traffic = re.escape(traffic_stream)
                    try:
                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').StopStatelessTraffic()
                        self.log.info(f"Stopping Traffic stream : {traffic_stream}")
                    except:
                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(
                            Name=f'^{each_traffic}$').StopStatelessTraffic()
                        self.log.info(f"Stopping Traffic stream: {traffic_stream}")
            except Exception as err:
                self.log.error(f'Traffic Stop For Stream: {each_traffic}, Failed with Exception: {err}')
                raise IxiaOperationException("Failed to stop Traffic")
        else:
            self.log.info('Stopping Traffic on All Traffic Items')
            try:
                self.ixNetwork.Traffic.Stop()
            except Exception as err:
                self.log.info(f'Traffic Stop Failed with Exception: {err}')
                self.log.info(f'Traffic State: {self.ixNetwork.Traffic.State}')
                self.log.warning("Traffic Stop retrying......")
                try:
                    Helper.sleep(sleep_time, msg='Waiting before Stopping the traffic')
                    self.ixNetwork.Traffic.Stop()
                except Exception as err:
                    self.log.error(f'Traffic Stop Retry Failed with Exception: {err}')
                    self.log.info(f'Traffic State: {self.ixNetwork.Traffic.State}')
                    raise IxiaOperationException("Failed to stop Traffic")
        self.log.info(f'Waiting for {sleep_time} seconds for traffic to fully stop...')
        time.sleep(sleep_time)
        for _ in range(1, timeout):
            if self.ixNetwork.Traffic.State == 'stopped':
                self.log.info("Traffic Stopped Successfully")
                break
            else:
                time.sleep(1)
        return True

    def check_traffic_state(self, expected='stopped', **kwargs):
        """
        Check the traffic current state.
        This is best used before getting stats when you want to assure
        that the traffic is completely stopped to get accurate stats
        Traffic states are:
        startedWaitingForStats, startedWaitingForStreams, started, stopped,
        stoppedWaitingForStats, txStopWatchExpected, locked, unapplied

        :param expected: expected traffic state
        :param kwargs: Optional
        :return: True if state is same as expected value, False otherwise

        :Example: check_traffic_state(expected='stopped')
                check_traffic_state(expected='started')
        """
        if self.ixNetwork.Traffic.State == "unapplied":
            trafficState = "stopped"
        else:
            trafficState = self.ixNetwork.Traffic.State
        self.log.info(trafficState)
        if trafficState.lower() != expected.lower():
            return False
        else:
            return True

    def _portname_location_mapping(self):
        """
        Internal API used by get_stats to map portname with location

        :return:
        """
        portnameLocationDict = {}
        for vport in self.ixNetwork.Vport.find():
            try:
                assignedChassis = vport.AssignedTo.split(":")[0]
                assignedCard = vport.AssignedTo.split(":")[1]
                assignedPort = vport.AssignedTo.split(":")[2]
                portnameLocationDict[vport.Name] = "//"+assignedChassis+"/"+assignedCard+"/"+assignedPort
            except:
                pass

        return portnameLocationDict

    def _change_to_int(self,value):
        """
        internal API used by get_stats to change type
        :param value: value whose datatype to be updated
        :return:
        """
        if value in ('' , ' ' , 'N/A'):
            value = 0
        elif (value != '' or value != ' ') and value != 'N/A':
            value = int(float(value))
        return value

    def get_stats(self, csv_file=None, csv_enable_file_timestamp=False,
                  view_name='Flow Statistics'):
        """
        Get flow statistics and save it in a csv file

        :param csv_file: None or <filename.csv>.
               None will not create a CSV file.
               Provide a <filename>.csv to record all stats to a CSV file.
               Example: getStats(csv_file='Flow_Statistics.csv')
        :param csv_enable_file_timestamp: True or False. If True, timestamp
                will be appended to the filename.
        :param view_name: view_name options (case sensitive):
                "Port Statistics",
                "Tx-Rx Frame Rate Statistics",
                "Port CPU Statistics",
                "Global Protocol Statistics",
                "Protocols Summary",
                "Port Summary",
                "OSPFv2-RTR Drill Down",
                "OSPFv2-RTR Per Port",
                "IPv4 Drill Down",
                "L2-L3 Test Summary Statistics",
                "Flow Statistics",
                "Traffic Item Statistics", \n
                Note: Not all of the view_names are listed here. You have to get the
                exact names from the IxNetwork GUI in statistics based on your
                protocol(s)
        :return:  A dictionary of all the stats: stat_dict[rowNumber][columnName]== stat_value

        :Example: get_stats() \n
                  get_stats(csv_file=None, csv_enable_file_timestamp=False,view_name='Port CPU Statistics') \n
                  get_stats(csv_file="TrafficItemStatistics.csv", csv_enable_file_timestamp=False,view_name='Traffic Item Statistics')
        """
        self.log.info('\ngetStats: %s' % (view_name))
        if csv_file:
            try:
                statsSummary = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)
            except:
                raise IxiaStatsException('getStats: Failed to get stats values')

            csv_filename = csv_file.replace(' ', '_')
            if csv_enable_file_timestamp:
                timestamp = datetime.datetime.now().strftime('%H%M%S')
                if '.' in csv_filename:
                    csv_filename_temp = csv_filename.split('.')[0]
                    csv_filename_extension = csv_filename.split('.')[1]
                    csv_filename = csv_filename_temp + '_' + timestamp + '.' + \
                                   csv_filename_extension
                else:
                    csv_filename = csv_filename + '_' + timestamp

            csv_file = open(csv_filename, 'w')
            csv_write_obj = csv.writer(csv_file)
            # Get the stat column names
            columnCaptions = statsSummary.ColumnHeaders
            if csv_file != None:
                csv_write_obj.writerow(columnCaptions)
                for rowNumber, stat in enumerate(statsSummary.Rows):
                    rowStats = stat.RawData
                for row in rowStats:
                    csv_write_obj.writerow(row)
            return statsSummary, csv_file.name
        else:
            portNameLocationMapping = self._portname_location_mapping()
            try:
                TrafficItemStats = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)
            except:
                Helper.sleep(10, msg=f'Retrying Traffic stats for - {view_name}')
                TrafficItemStats = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)
            column_list = TrafficItemStats.ColumnHeaders

            sequence_check = False
            if self.ixNetwork.Traffic.Statistics.SequenceChecking.Enabled:
                sequence_check = True

            # columns to be deleted from ColumnHeader
            if 'Gap' in column_list:
                column_list.remove('Gap')

            traffic_rows = TrafficItemStats.Rows
            try:
                flow_stats = pd.DataFrame(traffic_rows.RawData, columns=traffic_rows.Columns)
            except:
                self.log.info('printing stats first row')
                self.log.info(traffic_rows.RawData[0])
                self.log.info('printing column names')
                self.log.info(traffic_rows.Columns)
                raise IxiaOperationException("data and columns length doesn't match Exiting !!")

            if 'Packet Loss Duration (ms)' in flow_stats:
                flow_stats['Packet Loss Duration (ms)'] = flow_stats['Packet Loss Duration (ms)'].apply(
                    self._change_to_int)
            if 'Tx Frames' in flow_stats and 'Frames Tx.' not in flow_stats:
                flow_stats['Tx Frames'] = flow_stats['Tx Frames'].apply(self._change_to_int)
            elif 'Tx Frames' not in flow_stats and 'Frames Tx.' in flow_stats:
                flow_stats['Tx Frames'] = flow_stats['Frames Tx.'].apply(self._change_to_int)

            if 'Rx Frames' in flow_stats and 'Valid Frames Rx.' not in flow_stats:
                flow_stats['Rx Frames'] = flow_stats['Rx Frames'].apply(self._change_to_int)
            elif 'Rx Frames' not in flow_stats and 'Valid Frames Rx.' in flow_stats:
                flow_stats['Rx Frames'] = flow_stats['Valid Frames Rx.'].apply(self._change_to_int)

            if 'Tx Rate (Bps)' in flow_stats:
                flow_stats['Tx Rate (Bps)'] = flow_stats['Tx Rate (Bps)'].apply(self._change_to_int)
            if 'Rx Rate (Bps)' in flow_stats:
                flow_stats['Rx Rate (Bps)'] = flow_stats['Rx Rate (Bps)'].apply(self._change_to_int)

            if 'Tx Rate (bps)' in flow_stats and not 'Tx. Rate (bps)' in flow_stats:
                flow_stats['Tx Rate (bps)'] = flow_stats['Tx Rate (bps)'].apply(self._change_to_int)
            if not 'Tx Rate (bps)' in flow_stats and 'Tx. Rate (bps)' in flow_stats:
                flow_stats['Tx Rate (bps)'] = flow_stats['Tx. Rate (bps)'].apply(self._change_to_int)

            if 'Rx Rate (bps)' in flow_stats and not 'Rx. Rate (bps)' in flow_stats:
                flow_stats['Rx Rate (bps)'] = flow_stats['Rx Rate (bps)'].apply(self._change_to_int)
            if not 'Rx Rate (bps)' in flow_stats and 'Rx. Rate (bps)' in flow_stats:
                flow_stats['Rx Rate (bps)'] = flow_stats['Rx. Rate (bps)'].apply(self._change_to_int)

            if 'Rx L1 Rate (bps)' in flow_stats:
                flow_stats['Rx L1 Rate (bps)'] = flow_stats['Rx L1 Rate (bps)'].apply(self._change_to_int)
            if 'Tx L1 Rate (bps)' in flow_stats:
                flow_stats['Tx L1 Rate (bps)'] = flow_stats['Tx L1 Rate (bps)'].apply(self._change_to_int)

            if 'Loss %' in flow_stats:
                flow_stats['Loss %'] = np.where(flow_stats['Loss %'] == '', '0.00', flow_stats['Loss %'])

            if 'Tx Port' in flow_stats:
                flow_stats['Tx Port Location'] = [portNameLocationMapping[port] if 'Multiple Tx ports' not in port else ''
                                                    for port in flow_stats['Tx Port'].to_list()]
            if 'Rx Port' in flow_stats:
                flow_stats['Rx Port Location'] = [portNameLocationMapping[port] if 'Multiple Rx ports' not in port else ''
                                                    for port in flow_stats['Rx Port'].to_list()]

            if 'IPv4 :Source Address' in flow_stats:
                flow_stats['IP :Source Address'] = flow_stats['IPv4 :Source Address']
            if 'IPv4 :Destination Address' in flow_stats:
                flow_stats['IP :Destination Address'] = flow_stats['IPv4 :Destination Address']
            if 'IPv6 :Source Address' in flow_stats:
                flow_stats['IP :Source Address'] = flow_stats['IPv6 :Source Address']
            if 'IPv6 :Destination Address' in flow_stats:
                flow_stats['IP :Destination Address'] = flow_stats['IPv6 :Destination Address']

            if sequence_check:
                if 'Small Error' in flow_stats:
                    flow_stats['Small Error'] = flow_stats['Small Error'].apply(self._change_to_int)
                if 'Big Error' in flow_stats:
                    flow_stats['Big Error'] = flow_stats['Big Error'].apply(self._change_to_int)
                if 'Reverse Error' in flow_stats:
                    flow_stats['Reverse Error'] = flow_stats['Reverse Error'].apply(self._change_to_int)

                if 'Small Error' in flow_stats and 'Big Error' in flow_stats and \
                        'Reverse Error' in flow_stats:
                    flow_stats['ReorderedFrameCount'] = flow_stats['Small Error'] + flow_stats['Big Error'] + \
                                                        flow_stats['Reverse Error']
                    flow_stats['ReorderedFrameCount'] = flow_stats['ReorderedFrameCount'].apply(self._change_to_int)

                    flow_stats['InOrderFrameCount'] = flow_stats['Rx Frames'] - flow_stats['ReorderedFrameCount']
                    flow_stats['InOrderFrameCount'] = flow_stats['InOrderFrameCount'].apply(self._change_to_int)

                    flow_stats['OutSeqFrameCount'] = flow_stats['ReorderedFrameCount']
        flow_stats.index = np.arange(1, len(flow_stats) + 1)
        return flow_stats.to_dict('index')

    def _traffic_verify(self, RxFrames, TxFrames, FrameDelta, Loss):
        """
        Function used internally by API verify_traffic

        :param RxFrames: Received Frames
        :param TxFrames: Transmitted Frames
        :param FrameDelta: User Passed FrameDelta Value
        :param Loss: Traffic Loss
        """
        if self.expected != None and self.expected_mode == 'percent':
            self.verify_mode = 'Expected Percent'
            actualRate = 100.0 * RxFrames / TxFrames
            expectMax = float(self.expected) + float(self.tolerance)
            expectMin = float(self.expected) - float(self.tolerance)
            if expectMin < 0:
                expectMin = 0
            if actualRate > expectMax or actualRate < expectMin:
                verifyResults = False
            else:
                verifyResults = True
        elif self.expected and self.expected_mode == 'frame':
            self.verify_mode = 'Expected Frame'
            expectMax = TxFrames + int(self.tolerance)
            expectMin = TxFrames - int(self.tolerance)
            if int(RxFrames) > expectMax or int(RxFrames) < expectMin:
                verifyResults = False
            else:
                verifyResults = True
        elif self.tolerance_mode == 'percent':
            self.verify_mode = 'Loss Percent'
            if Loss.isdigit():
                actualRate = float(0)
            else:
                actualRate = float(Loss)
            if actualRate > float(self.tolerance):
                verifyResults = False
            else:
                verifyResults = True
        else:
            self.verify_mode = 'Loss Frame'
            expectMax = int(self.tolerance)
            actualRate = int(FrameDelta)
            if actualRate > expectMax:
                verifyResults = False
            else:
                verifyResults = True

        return verifyResults

    def _mode_flow_stats(self, port, flowStats, modeValue, flowStatHeaderValues, flowStatHeader, flowStatResults):
        """
        Function used internally by API verify_traffic

        :param port: port passed by user
        :param flowStats: Flow Statistics from csv file
        :param modeValue: Mode Value
        :param flowStatHeaderValues: Flow Statistics Header Values from csv file
        :param flowStatHeader: Flow Statistics Header
        :param flowStatResults: Flow Statistics Results
        """
        for rowNumber, flowStat in enumerate(flowStats.Rows):
            if flowStat[modeValue].lower() == port.lower():
                # flowStatHeaderValues.append([flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'],flowStat['Store-Forward Avg Latency (ns)'], flowStat['Frames Delta'], flowStat['Loss %']])
                flowStatHeaderValues.append(
                    [flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'], flowStat['Frames Delta'],
                     flowStat['Loss %']])
                RxFrames = flowStat['Rx Frames']
                TxFrames = flowStat['Tx Frames']
                FrameDelta = flowStat['Frames Delta']
                Loss = flowStat['Loss %']
                flowStatResults.append(self._traffic_verify(RxFrames, TxFrames, FrameDelta, Loss))
        flowStatTable = tabulate.tabulate(flowStatHeaderValues, headers=flowStatHeader, tablefmt='rst')
        self.log.info('Flow Stats for Port: %s',port)
        self.log.info(flowStatTable)

    def verify_traffic(self,
                       traffic_items=None,
                       mode='trafficItem',
                       ports=None,
                       debug=True,
                       tolerance_mode='percent',
                       tolerance=0,
                       expected_mode='percent',
                       expected=None,
                       verify_mode='tx_rx',
                       **kwargs):
        """
        API used to verify traffic

        :param traffic_items: CHOICES Nested dictionary for Traffic Item, tolerance and expect_loss.
                            Default value : {'all_traffic_items':True}
                            OR list of traffic items. Ex: ['traffic item1', 'traffic item2']
        :param mode: CHOICES 'trafficItem', 'rx_port', 'tx_port' Default is 'trafficItem'
        :param ports: A list of ports to verify against
        :param debug: CHOICES None, True (Default)
                    Debug value None is for traffic item or port level verification
                    Debug value is True, verify traffic loss in flow level, when
                    when traffic loss is seen in traffic item or port level, which defined in configuration for flow tracking
        :param tolerance_mode: CHOICES percent, frame. Default is percent
        :param tolerance: CHOICES 0, integer/float. Default is 0
        :param expected_mode: CHOICES percent, frame. Default is percent
        :param expected: CHOICES None, integer/float. Default is None
        :param verify_mode: The verify mode (Spirent only)
        :param kwargs: verify_mode, return_fromat, flow_per_stream
        :return: When no traffic loss,and None for debug option, return stats dictionary of STREAMBLOCK level
                When traffic loss or unexpected traffic, and None for debug option, raise Exception
                with stats dictionary of STREAMBLOCK level
                When traffic loss or unexpected traffic, and debug option is not None, raise Exception
                with 2 stats dictionary. First one is for STREAMBLOCK level and second one is for STREAM level

        :Example: verify_traffic() \n
                  verify_traffic(tolerance=10)
        """
        # hash_key_value = StubitUtil.stubit_sha256_hash_generator(self.verify_traffic.__name__,traffic_items)
        # if StubitUtil.is_stubit_playback():
        #     log.info("Playing traffic in stubit mode")
        #     return_data = StubitUtil.stubit_play(hash_key_value)
        #     if return_data:
        #         return_data = json.loads(return_data)
        #     return return_data

        traffic_dump = kwargs.get('traffic_dump',False)
        self.log.info("Traffic Verification Started")
        if 'tolerance_frame' in kwargs.keys():
            tolerance_mode = 'frame'
            tolerance = kwargs['tolerance_frame']
        elif 'tolerance_percent' in kwargs.keys():
            tolerance = kwargs['tolerance_percent']
        if traffic_items is None:
            traffic_items = {'all_traffic_items': True}
        elif isinstance(traffic_items, list):
            _tmp = {'all_traffic_items': False}
            for one_item in traffic_items:
                _tmp[one_item] = {}
            traffic_items = _tmp
        elif isinstance(traffic_items, dict):
            traffic_items['all_traffic_items'] = False

        # check if traffic items passed are present in config
        active_streams = self.get_active_streams()
        traffic_items_to_verify = list(traffic_items)
        if 'all_traffic_items' in traffic_items_to_verify:
            traffic_items_to_verify.remove('all_traffic_items')
        streams_not_in_config = []
        for traffic_item in traffic_items_to_verify:
            if traffic_item not in active_streams:
                streams_not_in_config.append(traffic_item)
        if streams_not_in_config:
            err_msg = 'Streams %s are not in config' % streams_not_in_config
            raise CafyException.InvalidValueError(err_msg)

        if traffic_items_to_verify == []:
            traffic_items_to_verify = active_streams
        if ports is None:
            ports = {'all_ports': True}
        item_stats = self.get_stats(view_name='Traffic Item Statistics')
        if mode == 'trafficItem' and debug == None:
            flow_stats = None
        else:
            flow_stats = self.get_stats()

        stats_objs = TrafficStats(debug=debug,
                                  item_stats=item_stats,
                                  flow_stats=flow_stats,
                                  tolerance_mode=tolerance_mode,
                                  tolerance=tolerance,
                                  expected=expected,
                                  expected_mode=expected_mode,
                                  **kwargs)

        if mode == 'trafficItem':
            stats_objs.drilldown(traffic_items=traffic_items)
        elif mode == 'rx_port' or mode == 'tx_port':
            stats_objs.port_drilldown(ports=ports,
                                      mode=mode,
                                      traffic_items=traffic_items)
        else:
            tmp_msg = "mode:%s not supported" % mode
            return tmp_msg

        item_tb = stats_objs.report(objs=stats_objs.item_objs,
                                    **kwargs)
        if debug:
            flow_tb = stats_objs.report(objs=stats_objs.flow_sorted_objs,
                                        **kwargs)
        if not stats_objs.verify_results:
            self.log.error('Traffic Item:\n' + item_tb)
            if debug:
                self.log.error('Flow:\n' + flow_tb)
            time.sleep(10)
            stats_dict = {}
            i = 1
            for obj in stats_objs.item_objs:
                stats_dict[i] = (obj.traffic_stats)
                i += 1
            max_flows = 10
            if flow_stats and len(flow_stats) > max_flows:
                self.log.debug(f"Flow stats has {len(flow_stats)} entries, limiting to first {max_flows} to avoid flooding logs")
                flow_stats_limited = dict(list(flow_stats.items())[:max_flows])
            else:
                flow_stats_limited = flow_stats
            if kwargs.get('full_logs', None):
                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()}
                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats, flow_stats_limited])
            else:
                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()
                                         if stats_dict[key]['Status'] == "fail"}
                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats])
            exception.item_stats = stats_objs.item_stats
            exception.flow_stats = flow_stats_limited
            # self._get_protocol_stats()
            self._get_port_stats()
            if traffic_dump:
                raise Exception("Traffic Verification Failed")
            else:
                raise exception

        self.log.info('Traffic Item:\n' + item_tb)
        if debug:
            self.log.info('Flow:\n' + flow_tb)
            for item in stats_objs.item_stats.values():
                if 'Traffic Item' in item:
                    if item['Traffic Item'] in traffic_items_to_verify:
                        if item['Tx Frames'] == 0:
                            msg = f"Tx frames of 0 found for traffic item {item['Traffic Item']}: A problem has occurred\n\
                                   Item Stats: {stats_objs.item_stats}\nFlow Stats: {next(iter(flow_stats.values()),{})}"
                            raise IxiaOperationException(msg)
                else:
                    if item['Tx Frames'] == 0:
                        msg = f"Tx frames of 0 found for traffic item {item['Rx Port']}: A problem has occurred\n\
                                                           Item Stats: {stats_objs.item_stats}"
                        raise IxiaOperationException(msg)

        # record the data
        # if StubitUtil.is_stubit_record():
        #     log.info("Recording traffic in stubit mode")
        #     return_value = json.dumps((stats_objs.item_stats, flow_stats))
        #     StubitUtil.stubit_record(hash_key_value,return_value)

        self.log.info("Traffic Verified Successfully")
        return stats_objs.item_stats, flow_stats

    def get_convergence_time(self,
                             traffic_control=False,
                             traffic_duration=None,
                             return_by='Traffic Item',
                             traffic_items=None,
                             tolerance=0.01,
                             retry_count=1,
                             report_mode='streams',
                             print_flows=True,
                             verify_mode='tx_rx',
                             **kwargs):
        """
        Calculates when the last flow converges in the traffic item and returns the convergence time in sec
        IXIA flow tracking is needed for traffic stats view

        :param traffic_control: optional, default set to False. Make sure the traffic is stopped before calling traffic_control
        :param traffic_duration: must have when traffic_control is set to True
        :param return_by: return convergence time by 'Traffic Item' or 'Source/Dest Port Pair', defaut set to 'Traffic Item'
                raise exceptions when return_by type is not existed in keys of flow.
        :param traffic_items: Traffic Item level stats view, if None is given, all the traffic item will be returned
        :param tolerance: Tolerance percentage for tx and rx rate comparison as rx rate might be a little less than tx
        :param retry_count: number of times to retry
        :param report_mode: (str) Determines the report output type e.g. 'streams', 'flows'
        :param print_flows: Print convergence times for each flow if True
        :param verify_mode: (str) Can be either tx_rx or dropped_frames
        :return: convergence time in ms (milli sec) and last convergence flow for each/given traffic_items.
                If None is returned by convergence time, the flow/traffic item is not converged yet with Loss % 100% loss

        :Example: get_convergence_time() \n
                  get_convergence_time(traffic_items=["Traffic Item 1", "Traffic Item 2"])
        """

        # updated as requested by Olivia(oliviaj@cisco.com)

        self.log.info("Calculating Convergence Time")
        if not traffic_items:
            traffic_items = {'all_traffic_items': True}
        elif isinstance(traffic_items, list):
            _tmp = {'all_traffic_items': False}
            for one_item in traffic_items:
                _tmp[one_item] = {}
            traffic_items = _tmp

        if not isinstance(return_by, str):
            msg = "Only take str for return_by. %s is %s" % (return_by, type(return_by))
            raise TypeError(msg)

        if not isinstance(retry_count, int) or retry_count < 0:
            msg = "Retry count should be int and >=0. %s is %s" % (retry_count, type(retry_count))
            raise TypeError(msg)

        trials = retry_count
        while (trials != 0):
            itemDict = {}
            if traffic_control:
                self.start_traffic()
                if traffic_duration:
                    time.sleep(int(traffic_duration))
                else:
                    msg = 'Cannot control traffic start/stop without duration'
                    self.log.error(msg)
                    raise IxiaOperationException(msg)
                self.stop_traffic()
            if report_mode == 'streams':
                flowStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics', LocalCsvStorage=CafyLog.work_dir)
            else:
                flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
            convergence = True
            flowHeadersList = flowStats.ColumnHeaders
            flowStatHeaderValues = []

            for rowNumber, stat in enumerate(flowStats.Rows):
                headerDict = {}
                for column in flowHeadersList:
                    headerDict[column] = stat[column]

                    # try:
                    #     headerDict[column] = stat[column]
                    # except (IndexError, KeyError):
                    #     headerDict[column] = None
                flowStatHeaderValues.append(headerDict)

            # pdb.set_trace()
            for flowDict in flowStatHeaderValues:
                if flowDict[return_by]:
                    item = flowDict[return_by]
                else:
                    msg = 'The return_by %s is not support in IXIA flow' % return_by
                    self.log.error(msg)
                    raise IxiaOperationException(msg)
                if return_by in 'Traffic Item' and not traffic_items['all_traffic_items']:
                    if item not in traffic_items:
                        continue
                itemDict.setdefault(item, []).append(flowStatHeaderValues.index(flowDict))

            for item, flow in itemDict.items():
                flowItemDict = {}
                for one_flow in flow:
                    flowValues = flowStatHeaderValues[one_flow]
                    firstTime = flowValues['First TimeStamp']
                    lastTime = flowValues['Last TimeStamp']
                    convergenceTime = float(flowValues['Packet Loss Duration (ms)'])
                    txFrames = int(float(flowValues['Tx Frames']))
                    rxFrames = int(float(flowValues['Rx Frames']))
                    rateDelta = txFrames - rxFrames
                    try:
                        loss = float('%.3f' % float(100 * rateDelta / txFrames))
                    except:
                        loss = float(0)
                    flowValues["Convergence Time"] = convergenceTime
                    flowValues["Loss %"] = loss

                    if not firstTime or not lastTime:
                        convergenceTime, convergence = None, False
                        self.log.error('"%s" Did NOT converge. Check if traffic is running.' % (item))
                    else:
                        if report_mode == 'streams':
                            self.log.info('"%s" Converges after %f ms' % (item, convergenceTime))
                        elif print_flows:
                            self.log.info('"Flow-%s" Converges after %f ms' % (one_flow+1, convergenceTime))
                    if report_mode == 'streams':
                        itemDict[item] = flowValues
                    else:
                        flowItemDict.update({"Flow-" + str(one_flow+1): flowValues})
                        itemDict[item] = flowItemDict

            if convergence:
                break
            trials -= 1
        self.clear_traffic_stats()
        return itemDict

    def disable_traffic_item(self, traffic_item_list=None):
        """
        Disable the given traffic items in the list, if no traffic
        items provided, then disable all traffic items instead.

        :param traffic_item_list: (list) list of traffic items to be disabled. if None, disable all
        :return: True if successful else raise exception

        :Example: disable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info("Disabling Traffic Item/Items")
        if traffic_item_list:
            self.log.info(f'Disabling the traffic items - {traffic_item_list}')
            if isinstance(traffic_item_list, list):
                try:
                    for each_traffic in traffic_item_list:
                        each_traffic = re.escape(each_traffic)
                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = False
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to disable")
            if isinstance(traffic_item_list, str):
                try:
                    each_traffic = re.escape(traffic_item_list)
                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = False
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to disable")
        else:
            self.log.info("Disabling all available Traffic Item/Items")
            try:
                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                    trafficItem.Enabled = False
            except:
                raise IxiaOperationException("Failed to disable TrafficItem")
        self.log.info("Traffic Item/Items Disabled Successfully")
        return True

    def enable_traffic_item(self, traffic_item_list=None):
        """
        Enable the given traffic items in the list, if None given enable all the traffic items

        :param traffic_item_list: list of traffic items to be enabled. if None, enable all
        :return: True if successful else raise Exception

        :Example: enable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info("Enabling Traffic Item/Items")
        if traffic_item_list:
            self.log.info(f'Enabling the traffic items - {traffic_item_list}')
            if isinstance(traffic_item_list, list):
                try:
                    for each_traffic in traffic_item_list:
                        each_traffic = re.escape(each_traffic)
                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = True
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Enable")
            if isinstance(traffic_item_list, str):
                try:
                    each_traffic = re.escape(traffic_item_list)
                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = True
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Enable")
        else:
            self.log.info("Enabling all available Traffic Item/Items")
            try:
                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                    trafficItem.Enabled = True
            except:
                raise IxiaOperationException("Failed to enable TrafficItem")
        self.log.info("Traffic Item/Items enabled Successfully")
        return True

    def delete_traffic_items(self,traffic_item_list=None):
        """
        API to deleted traffic items

        :param traffic_item_list: list of traffic items to be deleted. if None, delete all
        :return: True
        """
        if traffic_item_list:
            if isinstance(traffic_item_list, list):
                try:
                    for each_traffic in traffic_item_list:
                        each_traffic = re.escape(each_traffic)
                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').remove()
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Delete")
            elif isinstance(traffic_item_list, str):
                try:
                    each_traffic = re.escape(traffic_item_list)
                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').remove()
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Delete")
        else:
            trafficItems = self.ixNetwork.Traffic.TrafficItem.find()
            trafficItems.remove()
        self.log.info("Traffic Item/Items Deleted Successfully")
        return True

    def change_ipv4_tos(self, cfg_dict, traffic_item_list=None):
        """
        Changes the Type of Service (ToS) values in ipv4 stack for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified\n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',
                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \n
                Example: cfg_dict={'displayName':'unused','valueType':'increment','fieldValue':'000 Routine','startValue':'2','stepValue':'1','countValue':'15',
                'randomMask':'3','seed':'1','maxValue':'11','minValue':'0','onTheFlyMask':'6','singleValue':'10'}
        :param traffic_item_list: List of traffic Items name. All Items if it is None. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions

        :Example: change_ipv4_diff_serv(traffic_item_list=['Traffic Item 1'],
        cfg_dict={'displayName':'assuredForwarding','valueType':'singleValue','singleValue':'AF33'})
        """
        tos_config = cfg_dict.copy()

        if 'list' in tos_config.keys():
            tos_config['valueType'] = 'valueList'
            tos_config['valueList'] = tos_config['list']

        precedence_dict = {'00':0,'20':1,'40':2,'60':3,'80':4,'A0':5,'C0':6,'E0':7}
        diff_serve_af_dict = {'28': 10,'30': 12, '38': 14, '48': 18, '50': 20, '58': 22, '68': 26, '70': 28,
                                '78': 30,'88': 34, '90': 36, '98': 38}

        display_name = lambda value:'Precedence' if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) \
                                                    else ('assuredForwarding' if value in diff_serve_af_dict.keys() \
                                                        else 'expeditedForwarding')
        diff_serv_value = lambda value:precedence_dict[value.upper()] \
                                        if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) \
                                        else (diff_serve_af_dict[value] if value in diff_serve_af_dict.keys() else 46 )
        tos_value = lambda value:True if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) else False

        if 'singleValue' in tos_config:
            if tos_config['singleValue'].startswith('0x'):
                tos_value_modified = tos_config['singleValue'][2:]
                tos_config['singleValue'] = tos_value_modified
            tos_value = tos_value(tos_config['singleValue'])
            tos_config.update({'displayName': display_name(tos_config['singleValue'])})
            tos_config['singleValue'] = diff_serv_value(tos_config['singleValue'])
        elif 'valueList' in tos_config:
            if tos_config['valueList'][0].startswith('0x'):
                tos_value_modified = [value[2:] for value in tos_config['valueList']]
                tos_config['valueList'] = tos_value_modified
            tos_value = tos_value(tos_config['valueList'][0])
            tos_config.update({'displayName': display_name(tos_config['valueList'][0])})
            tos_config['valueList'] = list(map(diff_serv_value, tos_config['valueList']))
        elif 'startValue' in tos_config:
            if not 'stepValue' in tos_config:
                tos_config['stepValue'] = 1
            if not 'countValue' in tos_config:
                tos_config['countValue'] = 1
            if tos_config['startValue'].startswith('0x'):
                tos_value_modified = tos_config['startValue'][2:]
                tos_config['startValue'] = tos_value_modified
            tos_value = tos_value(tos_config['startValue'])
            tos_config.update({'displayName': display_name(tos_config['startValue'])})
            tos_config['startValue'] = diff_serv_value(tos_config['startValue'])
        elif 'minValue' in tos_config:
            tos_value = True
            tos_config.update({'displayName':'Precedence'})
            if not 'maxValue' in tos_config:
                tos_config['maxValue'] = 7

            if tos_config['minValue'].startswith('0x'):
                tos_value_modified = tos_config['minValue'][2:]
                tos_config['minValue'] = tos_value_modified
            tos_config['minValue'] = diff_serv_value(tos_config['minValue'])

        if tos_value:
            self.log.info("Changing TOS values in Ipv4")
            if 'header_index' not in tos_config:
                tos_config['header_index'] = 1
            header_index = tos_config['header_index'] - 1
            if 'displayName' not in tos_config:
                tos_config['displayName'] = 'Precedence'
            if not traffic_item_list:
                with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                    self.ixNetwork.Traffic.TrafficItem.find()
                traffic_item_list = list(map(lambda traffic_item:traffic_item.Name,getattr(traffic_item.results, 'trafficItem')))
            for traffic_item in traffic_item_list:
                traffic_item_modified = re.escape(traffic_item)
                traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_modified}$')
                if traffic_item_obj:
                    for config_element in traffic_item_obj.ConfigElement.find():
                        if config_element.Stack.find(DisplayName="IPv4"):
                            stack_obj = config_element.Stack.find(DisplayName="IPv4")[header_index]
                            setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),
                                    'ActiveFieldChoice',True)
                            for key in tos_config:
                                if key != 'displayName':
                                    stack_obj.Field.find(DisplayName=tos_config['displayName']).ValueType = tos_config[
                                        'valueType']
                                    if 'valueList' in tos_config['valueType']:
                                        setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),
                                                tos_config['valueType'][0].upper() + tos_config['valueType'][1:],
                                                tos_config['valueList'])
                                    if 'singleValue' in tos_config['valueType']:
                                        setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),
                                                tos_config['valueType'][0].upper() + tos_config['valueType'][1:],
                                                tos_config['singleValue'])
                                    if 'increment' in tos_config['valueType']:
                                        field_obj = stack_obj.Field.find(DisplayName=tos_config['displayName'])
                                        field_value = {'start': tos_config['startValue'], 'step': tos_config['stepValue'],
                                                       'count': tos_config['countValue']}
                                        self._update_field_values(field_obj,field_value)
                                    if 'random' in tos_config['valueType']:
                                        field_obj = stack_obj.Field.find(DisplayName=tos_config['displayName'])
                                        field_value = {'min':tos_config['minValue'],'max':tos_config['maxValue']}
                                        self._update_field_values(field_obj, field_value)
                        else:
                            raise IxiaConfigException(f"IPv4 stack not configured on {traffic_item}")
                else:
                    raise IxiaConfigException(f"{traffic_item} not configured")
            self.log.info("IPv4 TOS Values Updated in Traffic Items")
        else:
            self.change_ipv4_diff_serv(tos_config,traffic_item_list)
        return True

    def change_ipv6_traffic_class(self, cfg_dict, traffic_item_list=None):
        """
        Changes the IPv6 traffic class configuration for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified \n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',
                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \n
        :param traffic_item_list: List of traffic Items name. All Items if it is None. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions

        :Example: change_ipv6_traffic_class(traffic_item_list=["Traffic Item 3"],
                    cfg_dict={'singleValue':'5'})
        """
        self.log.info("Changing Ipv6 Traffic Class")
        if 'displayName' not in cfg_dict:
            cfg_dict['displayName'] = 'Traffic Class'
        if 'valueType' not in cfg_dict:
            if 'valueList' in cfg_dict:
                cfg_dict['valueType'] = 'valueList'
            elif 'singleValue' in cfg_dict:
                cfg_dict['valueType'] = 'singleValue'

        if not traffic_item_list:
            with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                self.ixNetwork.Traffic.TrafficItem.find()
            traffic_item_list = list(
                map(lambda traffic_item: traffic_item.Name, getattr(traffic_item.results, 'trafficItem')))

        for traffic_item in traffic_item_list:
            traffic_item_modified = re.escape(traffic_item)
            for config_obj in self.ixNetwork.Traffic.TrafficItem.find(
                    Name='^' + traffic_item_modified + '$').ConfigElement.find():
                if config_obj.Stack.find(StackTypeId='^' + 'ipv6' + '$'):
                    stack_obj = config_obj.Stack.find(StackTypeId='^' + 'ipv6' + '$')
                    field_value = stack_obj.Field.find(DisplayName=cfg_dict['displayName'])
                    field_value.ValueType = cfg_dict['valueType']

                    if 'valueList' in cfg_dict['valueType']:
                        if not cfg_dict['valueList'][0].startswith('0x'):
                            setattr(field_value,
                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                    cfg_dict['valueList'])
                        else:
                            cfg_dict['decValueList'] = [int(value, 16) for value in cfg_dict['valueList'] if value]
                            setattr(field_value,
                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                    cfg_dict['decValueList'])
                    if 'singleValue' in cfg_dict['valueType']:
                        if not cfg_dict['singleValue'].startswith('0x'):
                            setattr(field_value,
                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                    cfg_dict['singleValue'])
                        else:
                            cfg_dict['decSingleValue'] = int(cfg_dict['singleValue'], 16)
                            setattr(field_value,
                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                    cfg_dict['decSingleValue'])
                else:
                    raise IxiaConfigException(f"Ipv6 stack not configured on {traffic_item}")

        self.log.info(f"IPv6 Traffic Class updated in {traffic_item_list} Items")
        return True

    def _update_prefix_step(self, prefix_step:Union[str, int, dict], pool_handle):
        """
        Internal Method to Set Network group prefix step based on prefix step type and pool handle.
        :param prefix_step: Prefix step value Integer/String/dict
        Ex : to set single value int/str prefix_step = 1 or prefix_step = "1"
        dict type to prefix step in increment/decrement/random type
        Ex : prefix_step = {'mode' : 'increment','start' : 10, 'step' : '1'}
        :param pool_handle: PrefixPool Handle
        """
        if isinstance(prefix_step, (str, int)):
            pool_handle.PrefixAddrStep.Single(prefix_step)
        elif isinstance(prefix_step, dict):
            if 'mode' in prefix_step.keys():
                if prefix_step['mode'] == 'increment':
                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():
                        pool_handle.PrefixAddrStep.Increment(prefix_step['start'], prefix_step['step'])
                    else:
                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')
                elif prefix_step['mode'] == 'decrement':
                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():
                        pool_handle.PrefixAddrStep.Decrement(prefix_step['start'], prefix_step['step'])
                    else:
                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')
                elif prefix_step['mode'] == 'random':
                    pool_handle.PrefixAddrStep.Random()
            else:
                raise IxiaConfigException('Please pass Prefix Step Mode increment/decrement/random')

    def _set_bgp_network_group_options(self, pool_handle, route_count, prefix_ip=None, prefixlen=None, prefix_step=None, router_id=None):
        """
        Set Route count and prefix based on Protocol handle.
        :param pool_handle: PrefixPool Handle
        :param route_count: route_count to be updated
        :param prefix_ip: prefix_ip as reference
        :param prefixlen: prefixlen as reference
        :param prefix_step: prefix_step as reference
        :param router_id: router_id as reference
        :return:
        """
        # BuildNumber will return the ixNetwork API server version. Here we are interested in the major version of ixNetwork.
        # Ex: 10.00.2312.4 will be returned as BuildNumber. Hence, split('.')[0] will returns '10'.
        if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:
            if prefix_ip and router_id:
                if prefix_ip in pool_handle.NetworkAddress.Values:
                    ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)
                    value_list = pool_handle.NumberOfAddressesAsy.Values
                    value_list[ip_prefix_index] = route_count
                    pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
                    if prefixlen:
                        value_list = pool_handle.PrefixLength.Values
                        value_list[ip_prefix_index] = prefixlen
                        pool_handle.PrefixLength.ValueList(values=value_list)
                    if prefix_step:
                        value_list = pool_handle.PrefixAddrStep.Values
                        value_list[ip_prefix_index] = prefix_step
                        pool_handle.PrefixAddrStep.ValueList(values=value_list)
            elif router_id and prefix_ip is None:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            router_id_index = (deviceGroupObj.RouterData.find().RouterId.Values).index(router_id)
                            value_list = pool_handle.NumberOfAddressesAsy.Values
                            value_list[router_id_index] = route_count
                            pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
                            if prefixlen:
                                value_list = pool_handle.PrefixLength.Values
                                value_list[router_id_index] = prefixlen
                                pool_handle.PrefixLength.ValueList(values=value_list)
                            if prefix_step:
                                value_list = pool_handle.PrefixAddrStep.Values
                                value_list[router_id_index] = prefix_step
                                pool_handle.PrefixAddrStep.ValueList(values=value_list)
            else:
                pool_handle.NumberOfAddressesAsy.Single(route_count)
                if str(pool_handle.NumberOfAddressesAsy) == str(route_count):
                    self.log.info('Route count updated successfully')
                else:
                    self.log.error('Route count update failed')

                if prefixlen:
                    pool_handle.PrefixLength.Single(prefixlen)
                if prefix_step:
                    self._update_prefix_step(prefix_step, pool_handle)

        # This block for 8.50 version
        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
            pool_handle.NumberOfAddresses = route_count
            if str(pool_handle.NumberOfAddresses) == str(route_count):
                self.log.info('Route count updated successfully')
            else:
                self.log.error('Route count update failed')

            if prefixlen:
                pool_handle.PrefixLength.Single(prefixlen)
            if prefix_step:
                self._update_prefix_step(prefix_step, pool_handle)

    def _modify_bgp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix, prefix_step,
                                router_id, **kwargs):
        """
        Internal API to support setting route count and prefix length of BGP network group

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param prefix: prefix
        :param prefix_step: prefix step
        :param router_id: router ID
        :return: result
        """
        protocolStatus = False
        deviceGroupName = None
        nested_network_group = kwargs.get('nested_network_group')
        network_group_name_list = []
        deviceGrpList = self.ixNetwork.Topology.find().DeviceGroup.find()
        for deviceGroupObj in deviceGrpList:
            if deviceGroupObj.RouterData.find():
                for routerId in router_id:
                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceGroupName = deviceGroupObj.Name
                        break
        if network_group and not nested_network_group:
            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if nested_network_group and network_group:
            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass

            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).
                                            DeviceGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group == networkObj.Name]
            except:
                pass

            try:
                network_group_name_list = [networkObj.Name for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).
                            NetworkGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find() if nested_network_group in networkObj.Name]
            except:
                pass

        if network_group_name_list:
            for each_network_group in network_group_name_list:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + each_network_group + '$')
                if nested_network_group:
                    try:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + each_network_group + '$')
                    except:
                        pass
                    try:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).DeviceGroup.find().\
                            DeviceGroup.find().NetworkGroup.find(Name='^' + each_network_group + '$')
                    except:
                        pass
                    try:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find().\
                            DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + each_network_group + '$')
                    except:
                        pass
                if ip_type.lower() == "ipv4":
                    for network_group_obj in network_obj.Ipv4PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            protocolStatus = True
                            network_obj.Enabled.Single(True)
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
                if ip_type.lower() == "ipv6":
                    for network_group_obj in network_obj.Ipv6PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            network_obj.Enabled.Single(True)
                            protocolStatus = True
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
        elif router_id != None and deviceGroupName != None:
            networkGrpList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()
            if ip_type.lower() == "ipv4":
                for networkObj in networkGrpList:
                    for network_group_obj in networkObj.Ipv4PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            protocolStatus = True
                            networkObj.Enabled.Single(True)
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix,prefix_step=prefix_step, router_id=routerid)
            if ip_type.lower() == "ipv6":
                for networkObj in networkGrpList:
                    for network_group_obj in networkObj.Ipv6PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            networkObj.Enabled.Single(True)
                            protocolStatus = True
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
        else:
            raise IxiaConfigException("Router Id or network_group not found ")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("BGP protocol not configured or Configuration issue.")

    def set_bgp_route_count(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                router_id: Router ID of the device
                route_block_name: route block name from config
                start_ip: represents the first IP of the route block
                prefix: Integer/String representing the new prefix
                prefix_step: Prefix step value Integer/String Ex : 1 or "1"
                nested_network_group : if nested network group, Need to pass Nested Network Group Name
        :return: True if the operation is successful, False otherwise

        :Example: set_bgp_route_count(route_count=10, ports=["Ethernet - 001"], network_group="Network Group 9")
        """
        route_block_name = kwargs.get("route_block_name")
        router_id = kwargs.get("router_id")

        if isinstance(router_id, list) and isinstance(route_block_name, list) and isinstance(route_count, list):
            if not (len(router_id) == len(route_block_name) == len(route_count)):
                raise Exception("router_id, route_block_name, and route_count must all be the same length")

            for idx, dg_name in enumerate(router_id):
                try:
                    route_block_index = route_block_name[idx] - 1
                    count = route_count[idx]
                    self.log.debug(f" Updating DG '{dg_name}', block {route_block_index} to route count {count}")

                    # Find nested Device group (add dg.find().ng.find() combination according to the config)
                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dg_name + '$')
                    if not device_objs:
                        device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                            Name='^' + dg_name + '$')
                    if not device_objs:
                        self.log.warning(f"DeviceGroup '{dg_name}' not found. Skipping.")
                        continue

                    network_groups = device_objs.NetworkGroup.find()
                    if not network_groups:
                        self.log.warning(f"No NetworkGroups under '{dg_name}'. Skipping.")
                        continue

                    prefix_pool = None
                    for net_group in network_groups:
                        if ip_type[idx].lower() == "ipv4":
                            pool_list = net_group.Ipv4PrefixPools.find()
                        else:
                            pool_list = net_group.Ipv6PrefixPools.find()

                        if pool_list:
                            prefix_pool = pool_list[0]
                            break

                    if not prefix_pool:
                        self.log.warning(f"No prefix pool found under '{dg_name}'. Skipping.")
                        continue

                    count_values = prefix_pool.NumberOfAddressesAsy.Values
                    prefix_pool.NumberOfAddressesAsy.ClearOverlays()
                    if route_block_index >= len(count_values):
                        self.log.warning(f"Route-block index {route_block_index} out of range - '{dg_name}'.Found only {len(count_values)} blocks")
                        continue

                    count_values[route_block_index] = count
                    prefix_pool.NumberOfAddressesAsy.ValueList(values=count_values)
                    self.log.success(f" Updated DG '{dg_name}', index {route_block_index} to route count {count}")

                except Exception as err:
                    self.log.error(f" Error updating index {idx}: {err}")
                    continue

            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            self.log.info(" All route counts updated successfully.")
            return True
        else:
            network_group = kwargs.get('route_block_name')
            if 'network_group' in kwargs:
                network_group = kwargs.get('network_group')
            self.log.info(f"Setting Bgp Route Count for route_block_name: {network_group}")
            start_ip = kwargs.get('start_ip')
            prefix_length = kwargs.get('prefix')
            prefix_step = kwargs.get('prefix_step')
            router_id = kwargs.get('router_id')
            if not isinstance(router_id, list):
                router_id = [router_id]
            nested_group = kwargs.get('nested_network_group', False)
            if not network_group and router_id is None:
                raise IxiaConfigException('Please pass either Network group/Router Id')
            return self._modify_bgp_route_count(network_group, route_count, ip_type, start_ip_prefix=start_ip,
                                                prefix=prefix_length,prefix_step=prefix_step, router_id=router_id,
                                                nested_network_group=nested_group)

    def get_frame_l4_information(self):
        """
        Check if L4 header is in traffic stream. Infomation is in the log

        :return: True if all streams with L4 header. False if any stream without L4 header

        :Example: get_frame_l4_information()
        """
        self.log.info("Checking L4 Information is Available in TrafficItem")
        withL4 = []
        withoutL4 = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                stackTypeIdList = [stackObj.StackTypeId for stackObj in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find()]
                if "tcp" in stackTypeIdList:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId="tcp").DisplayName:
                        withL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])
                elif "udp" in stackTypeIdList:
                    if (self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId="udp").DisplayName):
                        withL4.append(trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName[0])
                else:
                    withoutL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])
            if withL4:
                result = True
                self.log.info('Stream with L4 Header:%s' % withL4)
            if withoutL4:
                result = False
                self.log.info('Stream without L4 Header:%s' % withoutL4)
            return result

    def get_ipv4_tos_information(self):
        """
        Get IPv4 Type of Service (ToS) configuration for a given traffic stream

        :return: True if all streams have a ToS configuration.
                False if there is at least one stream without
                a ToS configuration

        :Example: get_ipv4_tos_information()
        """
        self.log.info("Checking Ipv4 TOS information is available in TrafficItem")
        withTos = []
        withoutTos = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                try:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(Name='precedence').ActiveFieldChoice == True:
                        withTos.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(Name='precedence').ActiveFieldChoice)
                except:
                    withoutTos.append(trafficItemName)
        if withoutTos:
            result = False
            self.log.warning('Stream without IPv4 TOS:%s' % withoutTos)
        else:
            if withTos:
                result = True
                self.log.info(withTos)
        return result

    def get_ipv6_traffic_class_information(self):
        """
        Get IPv6 Traffic Class (TC) configuration for a given traffic stream

        :return: True if all streams have a TC configuration.
                False if there is at least one stream without
                a TC configuration

        :Example: get_ipv6_traffic_class_information()
        """

        withTrafficClass = []
        withoutTrafficClass = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                try:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(Name='trafficClass'):
                        withTrafficClass.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(Name='trafficClass'))
                except:
                    withoutTrafficClass.append(trafficItemName)
        if withoutTrafficClass:
            result = False
            self.log.warning('Stream without IPv6 Traffic Class:%s' % withoutTrafficClass)
        else:
            if withTrafficClass:
                result = True
                self.log.info(withTrafficClass)
        return result

    def _connect_ports(self, port, testPorts, vportList, assign_to_physical_port, device_obj, forceTakePortOwnership):
        """
        Connect ports
        :param port:  virtual port
        :param testPorts: physical ports
        :param vportList: vportList
        :param assign_to_physical_port:  True or False
        :param device_obj: Device object
        :param forceTakePortOwnership: True or False

        :return:
        """
        tmp = port.split('/')
        if len(tmp) == 2:
            chassis = self.chassis_ip
            card, port = tmp
        else:
            chassis = tmp[0]
            card = tmp[1]
            port = tmp[2]
        vportList.append(self.ixNetwork.Vport.add().href)
        if assign_to_physical_port:
            # Assign ports
            if self.chassis_ip == chassis:
                testPorts.append(dict(Arg1=self.chassis_ip, Arg2=card, Arg3=port))
            else:
                testPorts.append(dict(Arg1=chassis, Arg2=card, Arg3=port))
        # self.ixNetwork.Vport.find()[-1].Name = card + "/" + port - old
        self.ixNetwork.Vport.find()[-1].Name = f"{chassis}/{card}/{port}"
        if vportList and testPorts:
            device_obj['vport'] = self.ixNetwork.AssignPorts(testPorts, [], vportList,
                                                             forceTakePortOwnership)
        self._update_media_type()
        self.ixNetwork.Vport.find().ConnectPorts()

    def add_device(self,
                   port_list=None,
                   ipv4_address_start=None,
                   ipv6_address_start=None,
                   igmp_group_start=None,
                   mld_group_start=None,
                   new_config=False,
                   **kwargs):
        """
        Add new device to topology

        Mandatory Args:

        :param port_list: List of physical port name,Format of physical port name: 'chassisIP'/'card'/'port', 'card'/'port'
        :param ipv4_address_start: The starting address for ipv4 devices
        :param ipv6_address_start: The starting address for ipv6 devices
        :param igmp_group_start: The starting group for igmp devices
        :param mld_group_start: The starting group for mld devices
        :param new_config: True if you want to wipe out the old config, False to use the existing one

        Optional Args:

        :param assign_to_physical_port: CHOICES True, False. Default True
                True: Asign physical port to the vport created
                False: Create vport only
        :param port_name_list: CHOICES None, list of string. Default None
                None: use format 'card'/'port'
        :param device_name: Name of the device group name to be created
        :param interface_no_vlan_count: CHOICES integer. Default is 1 for main interface
        :param interface_vlan_disable: CHOICES integer - 0,1. To enable/disable Vlan. Default is 0
        :param vlan_count: CHOICES integer. Number of vlan per device. Default 1
        :param vlan_id_count: CHOICES 0, integer. Number of vlan per port.
        :param vlan_id_start: CHOICES List RANGE 0 - 4096.
                Default None for no change, Example: [<outer vlan start id>,<inner vlan start id>]
        :param vlan_id_step: CHOICES integer. Default 0
        :param vlan_id_port_step: CHOICES integer. Default 0
        :param vlan_id_sequence_length: CHOICES integer.
        :param vlan_id_repeat_value: CHOICES integer.
        :param vlan_id_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_id_step_enable: CHOICE bool.
        :param vlan_priority_start: CHOICES integer, list RANGE 0 - 7. Default 0
        :param vlan_priority_step: CHOICES integer. Default 0
        :param vlan_priority_port_step: CHOICES integer. Default 0
        :param vlan_priority_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_priority_step_enable: CHOICES bool.
        :param vlan_priority_sequence_length: CHOICES integer.
        :param vlan_priority_repeat_value: CHOICES integer.
        :param vlan_tpid: CHOICES '0x8100', '0x88a8', '0x9100', '0x9200', '0x9300'
        :param ipv4_address_start: IPv4 address for first interface
        :param ipv4_address_step: IPv4 address for step
        :param ipv4_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_prefix: CHOICES integer
        :param ipv4_address_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_address_repeat_value(int): repeat value Ex: 1
        :param ipv4_address_sequence_length: CHOICES integer
        :param ipv4_gateway_start: IPv4 address for first interface gateway
        :param ipv4_gateway_step: IPv4 address for step
        :param ipv4_gateway_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_port_step_enable: CHOICES bool.
        :param ipv4_gateway_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_gateway_repeat_value (int): repeat value Ex: 1
        :param ipv4_gateway_sequence_length: CHOICES integer
        :param ipv4_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv4_gateway_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv4_routerid = '192.0.0.1'
        :param ipv4_routerid_step = 2
        :param ipv6_address_repeat_increment (str): Ex: "0::1"
        :param ipv6_gateway_repeat_increment (str): Ex: "0::1"
        :param ipv6_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_start: IPv6 address for first interface
        :param ipv6_address_step: IPv6 address for step
        :param ipv6_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_prefix: CHOICES integer
        :param ipv6_address_repeat_value(int): repeat value Ex: 1
        :param ipv6_address_sequence_length: CHOICES integer
        :param ipv6_address_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_gateway_start: IPv6 address for first interface gateway
        :param ipv6_gateway_step: IPv6 address for step
        :param ipv6_gateway_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_port_step_enable: CHOICES bool.
        :param ipv6_gateway_repeat_value(int): repeat value Ex: 1
        :param ipv6_gateway_sequence_length: CHOICES integer
        :param ipv6_gateway_direction: CHOICES 'increment', 'decrement'
        :param ipv6_routerid: '192.0.0.1'
        :param ipv6_routerid_step: 2
        :param igmp_version: CHOICES string/list. 'version1','version2','version3'
        :param igmp_num_of_group_range: CHOICES integer
        :param igmp_group_start: IPv4 multicast address.Default None for no configure igmp
        :param igmp_group_step: IPv4 address. Default '0.0.0.1'
        :param igmp_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_group_port_step: CHOICES 'disable', 'enable', IPv4 address
        :param igmp_group_port_step_enable: CHOICES 'disable', 'enable'
        :param igmp_group_address_count: CHOICES integer.
        :param igmp_group_address_increment: CHOICES IPv4 address
        :param igmp_group_repeat_value(int): repeat value Ex: 1
        :param igmp_group_sequence_length: CHOICES integer.
        :param igmp_source_mode: CHOICES 'include', 'exclude'
        :param igmp_num_source_range: CHOICES integer
        :param igmp_source_start: IPv4 address
        :param igmp_source_step: IPv4 address. Default '0.0.0.1'
        :param igmp_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_source_port_step: CHOICES 'disabled', IPv4 address
        :param igmp_source_port_step_enable: CHOICES 'disabled','enabled'
        :param igmp_source_addree_increment: IPv4 address
        :param igmp_source_address_count: CHOICES integer
        :param igmp_source_repeat_value(int): repeat value Ex: 1
        :param igmp_source_sequence_length: CHOICES integer
        :param igmp_rate_interval: rate to be configured
        :param mld_version: CHOICES string/list. 'version1','version2'
        :param mld_num_of group_range: CHOICES integer
        :param mld_group_start: IPv6 multicast address, Default None for no configure mld
        :param mld_group_step: IPv6 address. Default '::1'
        :param mld_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_group_port_step: CHOICES 'disabled', IPv6 address
        :param mld_group_port_step_enable: CHOICES 'disabled', 'enabled'
        :param mld_group_address_count: CHOICES integer
        :param mld_group_address_increment: CHOICE IPv6 address
        :param mld_group_repeat_value(int): repeat value Ex: 1
        :param mld_group_sequence_length: CHOICES integer
        :param mld_source_mode: CHOICES 'include', 'exclude'
        :param mld_num_source_range: CHOICES integer
        :param mld_source_start: IPv6 address
        :param mld_source_step: IPv6 address. Default '::1'
        :param mld_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_source_port_step: CHOICES 'disabled', IPv6 address
        :param mld_source_port_step_enable: CHOICES 'disabled','enabled'
        :param mld_source_address_increment: IPv6 address
        :param mld_source_address_count: CHOICES integer
        :param mld_source_repeat_value(int): repeat value Ex: 1
        :param mld_source_sequence_length: CHOICES integer
        :param mld_rate_interval: rate to be configured
        :param multiple_ports_per_topo: CHOICES bool
        :return: device_obj dictionary {'vport':<obj>, 'ipv4':<obj>....}

        #Create device BGP config
        :param bgp_v4_active = True,
        :param bgp_v4_dut = '100.1.0.2',
        :param bgp_v4_dut_ip_address = '100.1.0.2',
        :param bgp_v4_2_byte_as = 100,
        :param bgp_v4_type = 'external'
        :param bgp_v4_enable_4_byte_as = 'True',
        :param bgp_v4_4_byte_as = 66000,
        :param bgp_v4_hold_time_interval = 60,
        :param bgp_v4_keep_alive_interval = 20,
        :param bgp_v4_configure_keep_alive_timer = True,
        :param bgp_v4_enable_graceful_restart = True,
        :param bgp_v4_route_count = 5,
        :param bgp_v4_route_start ='11.11.11.1',
        :param bgp_v4_route_prefix = 28,
        :param bgp_v4_route_prefix_step = 2,
        :param bgp_v4_route_active = True,
        :param bgp_v4_route_segment_type = 'assetconfederation',
        :param bgp_v4_ttl =32,
        :param bgp_v4_authentication = 'md5',
        :param bgp_v4_password = 'ixia1',
        :param bgp_v4_minimum_label =20
        :param bgp_v4_aspath = 200
        :param bgp_v4_asnum_stepvalue = 2

        #Create device BGPv6 config
        :param bgp_v6_active=True,
        :param bgp_v6_dut='2000:1:1:1::1',
        :param bgp_v6_dut_ip_address='2000:1:1:1::1',
        :param bgp_v6_type: 'external',
        :param bgp_v6_enable_2_byte_as = 100,
        :param bgp_v6_enable_4_byte_as=True,
        :param bgp_v6_4_byte_as=66000,
        :param bgp_v6_hold_time_interval=60,
        :param bgp_v6_keep_alive_interval=20,
        :param bgp_v6_configure_keep_alive_timer=True,
        :param bgp_v6_enable_graceful_restart=True,
        :param bgp_v6_route_count=10,
        :param bgp_v6_route_start='2000:1:1:1::1',
        :param bgp_v6_route_prefix = 28,
        :param bgp_v6_route_prefix_step = 2,
        :param bgp_v6_route_active=True,
        :param bgp_v6_route_segment_type='assetconfederation',
        :param bgp_v6_ttl=32,
        :param bgp_v6_authentication='md5',
        :param bgp_v6_password='ixia1',
        :param bgp_v6_minimum_label = 20
        :param bgp_v6_aspath = 200
        :param bgp_v6_asnum_stepvalue = 2


        :Example: add_device(port_list= ["10.39.60.2/1/1"])
        """
        self.log.info("Adding New Device to the Topology")
        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)
        device_obj = kwargs.get('device_obj', {})
        port_name_list = kwargs.get('port_name_list', None)
        assign_to_physical_port = kwargs.get('assign_to_physical_port', True)
        interface_no_vlan_count = kwargs.get('interface_no_vlan_count', 1)
        interface_vlan_disable = kwargs.get('interface_vlan_disable', 0)
        vlan_id_count = kwargs.get('vlan_id_count', 0)
        igmp_rate_interval = kwargs.get('igmp_rate_interval', 0)
        mld_rate_interval = kwargs.get('mld_rate_interval', 0)
        device_name = kwargs.get('device_name', None)
        devicegroup_name = kwargs.get('devicegroup_name', None)
        forceTakePortOwnership = True
        existingDeviceObj = None
        testPorts = []
        vportList = []
        if self.update_license == False and new_config == True:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        if new_config:
            self.ixNetwork.NewConfig()
        if not new_config:
            vportData = [(vportConnect.AssignedTo).replace(':', '/') for vportConnect in self.get_list_ports()]
            self._update_media_type()
        else:
            vportData = None
        if kwargs.get('multiple_vports_topo', None):
            port_list = [port_list]

        if not port_list:
            return True
        
        for port in port_list:
            if kwargs.get('multiple_vports_topo', None):
                for vport in port_list[0]:
                    if vportData:
                        if vportData:
                            vportInfo = [port[port.index('/') + 1:] for port in vportData]
                        else:
                            vportInfo = None
                        if vportInfo:
                            if vport in vportInfo:
                                for portObj in self.ixNetwork.Vport.find():
                                    portAssigned = (portObj.AssignedTo).replace(':', '/')
                                    if vport == portAssigned[portAssigned.index('/') + 1:]:
                                        portName = portObj.Name
                                        device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                        break
                                    existingDeviceObj = True
                            else:
                                self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                                    forceTakePortOwnership)
                    else:
                        self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)
            else:
                if 'vport' not in device_obj and existingDeviceObj is None:
                    if port_name_list:
                        if len(port_list) != len(port_name_list):
                            msg = 'port name:%s do not match ports:%s' % (port_name_list, port_list)
                            self.log.error(msg)
                            raise CafyException.TgenConfigMissingError(msg)

                    if vportData:
                        vportInfo = [port[port.index('/') + 1:] for port in vportData]
                    else:
                        vportInfo = None
                    if vportInfo:
                        temp_port = port
                        port = port[port.index('/') + 1:]
                        if port in vportInfo:
                            for portObj in self.ixNetwork.Vport.find():
                                if port in (portObj.AssignedTo).replace(':', '/'):
                                    portName = portObj.Name
                                    device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                    break
                            existingDeviceObj = True
                        else:
                            port = temp_port
                            self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                                forceTakePortOwnership)
                    else:
                        self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)

            if 'topology' not in device_obj:
                topologyObj = None
                if kwargs.get('multiple_vports_topo', None):
                    port = port[0]
                if vportData:
                    vportInfo = [port[port.index('/') + 1:] for port in vportData]
                    if port in vportInfo:
                        for topology in self.ixNetwork.Topology.find():
                            for portObj in self.ixNetwork.Vport.find():
                                portAssigned = (portObj.AssignedTo).replace(':', '/')
                                if port == portAssigned[portAssigned.index('/') + 1:]:
                                    portName = portObj.Name.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
                                    break
                            if self.ixNetwork.Vport.find(Name=portName).href in topology.Vports:
                                device_obj['topology'] = topology
                                topologyObj = True
                                break
                if not topologyObj:
                    if vportList == []:
                        for portObj in self.ixNetwork.Vport.find():
                            if temp_port in (portObj.AssignedTo).replace(':', '/'):
                                vportList.append(portObj.href)
                    device_obj['topology'] = self.ixNetwork.Topology.add(Vports=vportList)

            if 'interface_no_vlan_count' in kwargs:
                multiplier = interface_no_vlan_count + vlan_id_count
            elif 'interface_vlan_disable' in kwargs :
                multiplier = interface_vlan_disable + vlan_id_count
            elif vlan_id_count:
                multiplier = vlan_id_count
            else:
                multiplier = 1
            if 'devicegroup_name' not in kwargs:
                kwargs['devicegroup_name'] = None
            if 'device_name' in kwargs:
                kwargs['devicegroup_name'] = kwargs['device_name']
            if 'devicegroup' not in device_obj and existingDeviceObj is None:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            else:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            vlanIdKwargs = {key: kwargs[key] for key in kwargs if "id" in key and kwargs[key] != ""}
            vlanPriorityKwargs = {key: kwargs[key] for key in kwargs if "priority" in key and kwargs[key] != ""}
            if ('ethernet' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                device_obj['ethernet'] = device_obj['devicegroup'].Ethernet.add(Name=None,
                                                                                VlanCount=kwargs.get('vlan_count',
                                                                                                     None))
                if kwargs.get('vlan_count', None) or kwargs.get('vlan_id_step', None):
                    device_obj['ethernet'].UseVlans = True
                if 'interface_no_vlan_count' in kwargs:
                    valueList = ['false' if i <= interface_no_vlan_count else 'true' for i in
                                 range(1, interface_no_vlan_count + vlan_id_count + 1)]
                    device_obj['ethernet'].EnableVlans.ValueList(valueList)
                if 'interface_vlan_disable' in kwargs:
                    valueList = ['true'] * (interface_vlan_disable + vlan_id_count)
                    if 0 <= interface_vlan_disable < len(valueList):
                        valueList[interface_vlan_disable] = 'false'
                    device_obj['ethernet'].EnableVlans.ValueList(valueList)
                if 'vlan_id_start' in kwargs:
                    vlanIdKwargs['vlan_id_direction'] = kwargs.get('vlan_id_direction', 'increment')
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanIdKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Id Info configured successfully")

                if 'vlan_priority_start' in kwargs:
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanPriorityKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Priority Info configured successfully")

            if 'ipv4_address_direction' not in kwargs and 'ipv4_address_step' in kwargs:
                kwargs['ipv4_address_direction'] = 'increment'
            if 'ipv4_gateway_direction' not in kwargs and 'ipv4_gateway_step' in kwargs:
                kwargs['ipv4_gateway_direction'] = 'increment'
            if 'ipv6_address_direction' not in kwargs and 'ipv6_address_step' in kwargs:
                kwargs['ipv6_address_direction'] = 'increment'
            if 'ipv6_gateway_direction' not in kwargs and 'ipv6_gateway_step' in kwargs:
                kwargs['ipv6_gateway_direction'] = 'increment'
            ipv4Kwargs = {key: kwargs[key] for key in kwargs if "ipv4" in key and kwargs[key] != ""}
            ipv6Kwargs = {key: kwargs[key] for key in kwargs if "ipv6" in key and kwargs[key] != ""}
            igmpKwargs = {key: kwargs[key] for key in kwargs if "igmp" in key and kwargs[key] != ""}
            mldKwargs = {key: kwargs[key] for key in kwargs if "mld" in key and kwargs[key] != ""}
            bgpv4Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v4" in key and kwargs[key] != ""}
            bgpv6Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v6" in key and kwargs[key] != ""}

            if ('ipv4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv4_address_start:
                    device_obj['ipv4'] = device_obj['ethernet'].Ipv4.add()
                    ipv4Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv4_address_start=ipv4_address_start, **ipv4Kwargs)
                    ipv4Obj.config()
                    self.log.info("Ipv4 Info configured successfully")

            if ('ipv6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv6_address_start:
                    device_obj['ipv6'] = device_obj['ethernet'].Ipv6.add()
                    ipv6Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv6_address_start=ipv6_address_start, **ipv6Kwargs)
                    ipv6Obj.config()
                    self.log.info("IPv6 Info configured successfully")

            # Create IGMP
            if ('igmp' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if igmpKwargs:
                    if 'ipv4' in device_obj:
                        igmpObj = IGMP(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'],
                                       igmp_group_start=igmp_group_start,
                                       **igmpKwargs)
                        igmpObj.config()
                        self.log.info("Igmp Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
                    if igmp_rate_interval:
                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name,
                                               device_name=device_name)
            # Create MLD
            if ('mld' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if mldKwargs:
                    if 'ipv6' in device_obj:
                        mldObj = MLD(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], mld_group_start=mld_group_start,
                                     **mldKwargs)
                        mldObj.config()
                        self.log.info("Mld Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")
                    if mld_rate_interval:
                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name,
                                               device_name=device_name)
            # Create BGPv4
            if ('bgp_v4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv4Kwargs != {}:
                    if 'ipv4' in device_obj:
                        bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'], **bgpv4Kwargs)
                        bgpv4Obj.config()
                        self.log.info("BGPv4 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
            # Create BGPv6
            if ('bgp_v6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv6Kwargs != {}:
                    if 'ipv6' in device_obj:
                        bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], **bgpv6Kwargs)
                        bgpv6Obj.config()
                        self.log.info("BGPv6 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")

            #Create ipv4 routerId
            if kwargs.get('ipv4_routerid', None) != None:
                router_obj = device_obj['devicegroup'].RouterData.find().RouterId
                if kwargs.get('ipv4_router_step'):
                    router_obj.Increment(start_value = kwargs.get('ipv4_routerid'),
                                            step_value = '0.0.0.' + str(kwargs.get('ipv4_router_step')))
                else:
                    router_obj.Single(kwargs.get('ipv4_routerid'))

            #Create ipv6 routerId
            if kwargs.get('ipv6_routerid', None) != None:
                router_obj = device_obj['devicegroup'].RouterData.find().RouterId
                if kwargs.get('ipv6_router_step'):
                    router_obj.Increment(start_value = kwargs.get('ipv6_routerid'),
                                            step_value = '0.0.0.' + str(kwargs.get('ipv6_router_step')))
                else:
                    router_obj.Single(kwargs.get('ipv6_routerid'))

            retryCount = 0
            while True:
                if retryCount == 10: break
                try:
                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                    break
                except:
                    time.sleep(3)
                    retryCount = retryCount + 1

        if self.primary:
            self.connect_to_chassis([self.primary])
            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find() if
                                      chassis.Hostname != self.primary]
            if connected_chassis_list:
                self.set_chassis_mode(primary=self.primary, secondary=connected_chassis_list)
        return device_obj

    def _update_traffic_vlan_data(self, configElement, **kwargs):

        """
        Function used internally by API add_traffic_stream

        :param configElement: Config Element of Traffic Item, related to IXIA
        :param kwargs: optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="VLAN")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "VLAN-ID":
                if kwargs.get('vlan_mod_mode', None) == "INCR" or kwargs.get('vlan_mod_mode', None) is None:
                    kwargs['vlan_mod_mode'] = 'increment'
                if kwargs.get('vlan_count', None):
                    kwargs['vlan_mod_count'] = kwargs.get('vlan_count', None)
                if kwargs.get('vlan_id_count', None):
                    kwargs['vlan_mod_count'] = kwargs.get('vlan_id_count', None)
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get('vlan_mod_mode', None), \
                        kwargs.get('vlan_id_start',None), kwargs.get('vlan_mod_count', None), kwargs.get('vlan_id_start', None), kwargs.get('vlan_mod_step', 1)
            if fieldName == "Protocol-ID":
                if kwargs.get('vlan_type', None):
                    kwargs['vlan_type'] = kwargs.get('vlan_type', None)
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    field.ValueType, field.SingleValue, field.Auto, field.FieldValue = 'singleValue', kwargs.get(
                        'vlan_type', None), 'True', kwargs.get('vlan_type', None)

    def _ipv6_address_rfc5952(self, ip):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv6 address
        :return: ipv6 address in rfc5952 format
        """
        output=ipaddress.IPv6Address(ip)
        output=output.compressed
        return output

    def _endpoint_source_handles(self, ip, sourcesList, topology, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param ip:  ipv4,ipv6 address
        :param sourcesList: Traffic Endpoints
        :param topology: TopologyName/TopologyObj which is endpoint
        Optional kwargs :
        :param src_network_group_name (list): Network group name if source is route start address
        """
        sources_route_name = kwargs.get('sources_route_name', None)
        if isinstance(ip,str):
            ip = [ip]
        if isinstance(ip,list):
            for ip in ip:
                if topology:
                    if '.' in ip:
                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_list = ipv4.Address.Values
                            if ip in ipv4_list:
                                sourcesList.append(
                                    {"arg1": ipv4.href, "arg2": 1, "arg3": 1, "arg4": ipv4_list.index(ip) + 1, "arg5": 1})
                        try:
                            if sources_route_name:
                                for network_group in sources_route_name:
                                    for ipv4_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                                            Ipv4PrefixPools.find():
                                        ipv4_prefix_poolList = ipv4_prefix_pool.NetworkAddress.Values
                                        if ip in ipv4_prefix_poolList:
                                            sourcesList.append({"arg1": ipv4_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv4_prefix_poolList.index(ip) + 1,
                                                                "arg5": 1})
                            else:
                                for ipv4_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                    ipv4_prefix_poolList = ipv4_prefix_pool.NetworkAddress.Values
                                    if ip in ipv4_prefix_poolList:
                                        sourcesList.append({"arg1": ipv4_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                            "arg4": ipv4_prefix_poolList.index(ip) + 1,
                                                            "arg5": 1})
                        except:
                            pass
                    elif ':' in ip:
                        ip = self._ipv6_address_rfc5952(ip)
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            ipv6_list = ipv6.Address.Values
                            if ip in ipv6_list:
                                sourcesList.append(
                                    {"arg1": ipv6.href, "arg2": 1, "arg3": 1, "arg4": ipv6_list.index(ip) + 1, "arg5": 1})
                        try:
                            if sources_route_name:
                                for network_group in sources_route_name:
                                    for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')\
                                            .Ipv6PrefixPools.find():
                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                        if ip in ipv6_prefix_pool_list:
                                            sourcesList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                                "arg5": 1})
                            else:
                                for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                    if ip in ipv6_prefix_pool_list:
                                        sourcesList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                            "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                            "arg5": 1})
                        except:
                            pass
                    else:
                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                            sourcesList.append(device_group_obj)
                        else:
                            for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():
                                for vlan_obj in ethernet_obj.Vlan.find():
                                    vlan_obj_list = vlan_obj.VlanId.Values
                                    for value in vlan_obj_list:
                                        if value == ip:
                                            sourcesList.append({"arg1": ethernet_obj.href, "arg2": 1, "arg3": 1,
                                                                "arg4": vlan_obj_list.index(ip) + 1,
                                                                "arg5": 1})
                else:
                    if '.' in ip:
                        for ipv4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_list = ipv4.Address.Values
                            if ip in ipv4_list:
                                sourcesList.append(
                                    {"arg1": ipv4.href, "arg2": 1, "arg3": 1, "arg4": ipv4_list.index(ip) + 1, "arg5": 1})
                        try:
                            if sources_route_name:
                                for network_group in sources_route_name:
                                    for ipv4_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find\
                                                (Name='^' + network_group + '$').Ipv4PrefixPools.find():
                                        ipv4_prefix_pool_list = ipv4_prefix_pool.NetworkAddress.Values
                                        if ip in ipv4_prefix_pool_list:
                                            sourcesList.append({"arg1": ipv4_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv4_prefix_pool_list.index(ip) + 1,
                                                                "arg5": 1})
                            else:
                                for ipv4_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                    ipv4_prefix_pool_list = ipv4_prefix_pool.NetworkAddress.Values
                                    if ip in ipv4_prefix_pool_list:
                                        sourcesList.append({"arg1": ipv4_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                            "arg4": ipv4_prefix_pool_list.index(ip) + 1,
                                                            "arg5": 1})
                        except:
                            pass
                    elif ':' in ip:
                        ip = self._ipv6_address_rfc5952(ip)
                        for ipv6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                            ipv6_list = ipv6.Address.Values
                            if ip in ipv6_list:
                                sourcesList.append(
                                    {"arg1": ipv6.href, "arg2": 1, "arg3": 1, "arg4": ipv6_list.index(ip) + 1, "arg5": 1})
                        try:
                            if sources_route_name:
                                for network_group in sources_route_name:
                                    for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find()\
                                    .NetworkGroup.find(Name = '^' + network_group + '$').Ipv6PrefixPools.find():
                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                        if ip in ipv6_prefix_pool_list:
                                            sourcesList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                                "arg5": 1})
                            else:
                                for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                    if ip in ipv6_prefix_pool_list:
                                        sourcesList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                            "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                            "arg5": 1})
                        except:
                            pass
                    else:
                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                            sourcesList.append(device_group_obj)
                        elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):
                            networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href
                            sourcesList.append(networkGroupObj)
                        else:
                            for ethernet_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():
                                for vlan_obj in ethernet_obj.Vlan.find():
                                    vlan_obj_list = vlan_obj.VlanId.Values
                                    for value in vlan_obj_list:
                                        if value == ip:
                                            sourcesList.append({"arg1": ethernet_obj.href, "arg2": 1, "arg3": 1,
                                                                "arg4": vlan_obj_list.index(ip) + 1,
                                                                "arg5": 1})
        return sourcesList

    def _endpoint_destination_handles(self, ip, destinationsList, topology, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv4,ipv6 address
        :param destinationsList: Traffic Endpoints
        :param topology: TopologyName/TopologyObj which is endpoint
        Optional kwargs :
        :param dst_network_group_name (list): Network group name if destination is route start address
        """
        destinations_route_name = kwargs.get('destinations_route_name', None)
        if isinstance(ip,str):
            ip = [ip]
        if isinstance(ip,list):
            for ip in ip:
                if topology:
                    if '.' in ip:
                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_list = ipv4.Address.Values
                            if ip in ipv4_list:
                                destinationsList.append(
                                    {"arg1": ipv4.href, "arg2": 1, "arg3": 1, "arg4": ipv4_list.index(ip) + 1, "arg5": 1})
                        try:
                            if destinations_route_name:
                                for network_group in destinations_route_name:
                                    for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$')\
                                            .Ipv4PrefixPools.find():
                                        ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                        if ip in ipv4PrefixPoolList:
                                            destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": ipv4PrefixPoolList.index(ip) + 1, "arg5": 1})
                            else:
                                for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                    ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                    if ip in ipv4PrefixPoolList:
                                        destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv4PrefixPoolList.index(ip) + 1, "arg5": 1})
                        except:
                            pass

                    elif ":" in ip:
                        ip = self._ipv6_address_rfc5952(ip)
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            ipv6_list = ipv6.Address.Values
                            if ip in ipv6_list:
                                destinationsList.append(
                                    {"arg1": ipv6.href, "arg2": 1, "arg3": 1, "arg4": ipv6_list.index(ip) + 1, "arg5": 1})
                        try:
                            if destinations_route_name:
                                for network_group in destinations_route_name:
                                    for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')\
                                            .Ipv6PrefixPools.find():
                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                        if ip in ipv6_prefix_pool_list:
                                            destinationsList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": ipv6_prefix_pool_list.index(ip) + 1, "arg5": 1})
                            else:
                                for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                    if ip in ipv6_prefix_pool_list:
                                        destinationsList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv6_prefix_pool_list.index(ip) + 1, "arg5": 1})

                        except:
                            pass
                    else:
                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                            destinationsList.append(device_group_obj)
                        else:
                            for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():
                                for vlan_obj in ethernet_obj.Vlan.find():
                                    vlan_obj_list = vlan_obj.VlanId.Values
                                    for value in vlan_obj_list:
                                        if value == ip:
                                            destinationsList.append({"arg1": ethernet_obj.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": vlan_obj_list.index(ip) + 1, "arg5": 1})

                else:
                    if '.' in ip:
                        for ipv4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_list = ipv4.Address.Values
                            if ip in ipv4_list:
                                destinationsList.append(
                                    {"arg1": ipv4.href, "arg2": 1, "arg3": 1, "arg4": ipv4_list.index(ip) + 1, "arg5": 1})
                        try:
                            if destinations_route_name:
                                for network_group in destinations_route_name:
                                    for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().\
                                            NetworkGroup.find(Name='^'+network_group+'$').Ipv4PrefixPools.find():
                                        ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                        if ip in ipv4PrefixPoolList:
                                            destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                                    "arg5": 1})
                            else:
                                for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                    ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                    if ip in ipv4PrefixPoolList:
                                        destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                                "arg5": 1})
                        except:
                            pass

                    elif ":" in ip:
                        ip = self._ipv6_address_rfc5952(ip)
                        for ipv6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                            ipv6_list = ipv6.Address.Values
                            if ip in ipv6_list:
                                destinationsList.append(
                                    {"arg1": ipv6.href, "arg2": 1, "arg3": 1, "arg4": ipv6_list.index(ip) + 1, "arg5": 1})
                        try:
                            if destinations_route_name:
                                for network_group in destinations_route_name:
                                    for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().\
                                            NetworkGroup.find(Name='^'+network_group+'$').Ipv6PrefixPools.find():
                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                        if ip in ipv6_prefix_pool_list:
                                            destinationsList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                                    "arg5": 1})
                            else:
                                for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values
                                    if ip in ipv6_prefix_pool_list:
                                        destinationsList.append({"arg1": ipv6_prefix_pool.href, "arg2": 1, "arg3": 1,
                                                                "arg4": ipv6_prefix_pool_list.index(ip) + 1,
                                                                "arg5": 1})
                        except:
                            pass
                    else:
                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                            destinationsList.append(device_group_obj)
                        elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):
                            network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href
                            destinationsList.append(network_group_obj)
                        else:
                            for ethernet_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():
                                for vlan_obj in ethernet_obj.Vlan.find():
                                    vlan_obj_list = vlan_obj.VlanId.Values
                                    for value in vlan_obj_list:
                                        if value == ip:
                                            destinationsList.append({"arg1": ethernet_obj.href, "arg2": 1, "arg3": 1,
                                                                    "arg4": vlan_obj_list.index(ip) + 1,
                                                                    "arg5": 1})
        return destinationsList

    def _update_traffic_ipv4_data(self, configElement, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param configElement:  Traffic Item Config Element
        :param kwargs: Optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="IPv4")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "Source Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v4_src_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v4_src_value']
                        field.StepValue = kwargs.get('v4_src_step', "0.0.0.1")
                        field.CountValue = kwargs.get('v4_src_count', 1)
                    if isinstance(kwargs.get('v4_src_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v4_src_value']
            if fieldName == "Destination Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v4_dst_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v4_dst_value']
                        field.StepValue = kwargs.get('v4_dst_step', "0.0.0.1")
                        field.CountValue = kwargs.get('v4_dst_count', 1)
                    if isinstance(kwargs.get('v4_dst_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v4_dst_value']
            if fieldName == 'TTL (Time to live)':
                field_obj_list = stackObj.Field.find(Name='ttl')
                for field in field_obj_list:
                    if isinstance(kwargs.get('v4_ttl', None), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v4_ttl')
                        field.StepValue = kwargs.get('v4_ttl_step', 1)
                        field.CountValue = kwargs.get('v4_ttl_count', 1)
                    if isinstance(kwargs.get('v4_ttl', None), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v4_ttl')
            if fieldName == "Protocol":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v4_protocol', None), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v4_protocol', None)
                        field.StepValue = kwargs.get('v4_protocol_step', 1)
                        field.CountValue = kwargs.get('v4_protocol_count', 1)
                    if isinstance(kwargs.get('v4_protocol', None), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v4_protocol', None)
                    if isinstance(kwargs.get('v4_protocol', None), str):
                        field.Auto = False
                        field.ValueType = 'singleValue'
                        field.FieldValue = kwargs.get('v4_protocol', None)


    def _update_traffic_ipv6_data(self, configElement, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param configElement:  Traffic Item Config Element
        :param kwargs: Optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="IPv6")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "Source Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v6_src_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v6_src_value']
                        field.StepValue = kwargs.get('v6_src_step', "0::1")
                        field.CountValue = kwargs.get('v6_src_count', 1)
                    if isinstance(kwargs.get('v6_src_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_src_value']
            if fieldName == "Destination Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v6_dst_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v6_dst_value']
                        field.StepValue = kwargs.get('v6_dst_step', "::1")
                        field.CountValue = kwargs.get('v6_dst_count', 1)
                    if isinstance(kwargs.get('v6_dst_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_dst_value']
            if fieldName == "Flow Label":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v6_flow_label'), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v6_flow_label', None)
                        field.StepValue = kwargs.get('v6_label_step', 1)
                        field.CountValue = kwargs.get('v6_label_count', 1)
                    if isinstance(kwargs.get('v6_flow_label'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v6_flow_label', None)
            if fieldName == "Hop Limit":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v6_ttl'), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v6_ttl')
                        field.StepValue = kwargs.get('v6_ttl_step', 1)
                        field.CountValue = kwargs.get('v6_ttl_count', 1)
                    if isinstance(kwargs.get('v6_ttl'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_ttl']

    def _expand_ipv6_address(self, ip):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv6 address
        :return: expanded ipv6 address
        """
        if "::" in ip:
            match = re.search("^([a-fA-F0-9]+):([a-fA-F0-9]+):([a-fA-F0-9]+)::([a-fA-F0-9]+)$", ip)
            ip = match.group(1) + ":" + match.group(2) + ":" + match.group(3) + ":0:0:0:0:" + match.group(4)
        if "::" in ip:
            match = re.search("^([a-fA-F0-9]+)::([a-fA-F0-9]+)$", ip)
            ip = match.group(1) + ":0:0:0:0:0:0:" + match.group(2)
        return ip

    def add_traffic_stream(self,
                           sources,
                           destinations,
                           mcast_destinations=None,
                           traffic_type='ipv4',
                           **kwargs):
        """
        API for adding a new L2/L3 traffic item in IXIA config
        :param sources: A list of sources
        :param destinations: A list of destinations
        :param mcast_destinations: A list of mcast destinations
        :param mcast_destinations_index : A list of mcast destinations index. Default is all
        :param traffic_type: The traffic type to use (ipv4/ipv6)
        Mandatory Args:
        :param sources (list): A list of address sources
            e.g. ['172.16.0.1', '172.16.50.1', '172.16.100.1']
        :param destinations (list): A list of addresses or route ranges
            e.g. ['225.0.0.1', '225.1.0.1', '225.1.0.21']
        Optional Args:
        :param traffic_type (str): The address family that you wish to use for
            this traffic item ['ipv4'|'ipv6']
        :param is_mcast_dest (bool): Designates if this
        Optional kwargs (for creating stream objects via zap):
        :param src_ports (list): Source ports. Ex: src_ports = ['2/9']
        :param dst_ports (list): Destionation ports. Ex: dst_ports = ['2/10']
        Traffic
        :param traffic_item_name (str): The traffic items name
        :param src_dest_mesh_type (str): Options are fullMesh,manyToMany,none,oneToOne
        :param route_mesh_type (str): Options are fullMesh,oneToOne
        :param bidirectional (bool): If true, enables bidirectional for a traffic item
        :param transmit_mode (str): Options are interleaved,sequential
        :param enabled (boo): If true, enable the traffic item
        Frame Payload
        :param payload_type (str): Options are CJPAT,CRPAT,custom,decrementByte,
                decrementWord,incrementByte,incrementWord,random
        :param payload_custom_pattern (str): The custom pattern in hex format
        :param payload_custom_repeat (bool): If true, repeat the custom pattern
        Frame Rate
        :param rate_type (str): Options are bitsPerSecond,framesPerSecond,
                interPacketGap,percentLineRate
        :param bit_rate_units (str): Options are bitsPerSec,bytesPerSec,kbitsPerSec,
                kbytesPerSec,mbitsPerSec,mbytesPerSec
        :param frame_rate (int): The frame transmission rate
        :param enforce_min_inter_packet_gap (int): Sets the minimum inter-packet gap
        :param inter_packet_gap_units_type (str): Options are bytes,nanoseconds
        Frame Rate Distribution
        :param port_distribution (str): applyRateToAll,splitRateEvenly
        :param stream_distribution (str): applyRateToAll,splitRateEvenly
        Frame Size
        :param frame_size_type (str): Options are auto,fixed,increment,presetDistribution,
                 quadGaussian,random,weightedPairs
        :param frame_size_fixed_size (int): Sets a fixed frame size
        :param frame_size_increment_start (int): Specifies the Start Value if the Frame
                Size is incremented
        :param frame_size_increment_stop (int): Specifies the Final Value if the Frame
                Size is Incremented
        :param frame_size_increment_step (int): Specifies the Step Value if the Frame
                Size is Incremented
        :param frame_size_preset_distribution (str): Options are cisco,imix,ipSecImix,ipV6Imix,
                prQuar,rprTri,standardImix,tcpImix,tolly
        :param frame_size_quad_gaussian (list): Please reference the below address for details
                <IXIA_API_SERVER>:25445/api/v1/meta/traffic/trafficItem/configElement/frameSize
        :param frame_size_random_min (int): Minimum frame size length (in bytes). Max is 64
        :param frame_size_random_max (int): Maximum frame size length (in bytes). Max is 1518
        :param frame_size_weighted_pairs (list): Defines the values for a list of weighted pairs
        :param frame_size_weighted_pairs_range (list): Defines the range for a list of weighted pairs
        :param sources_route_name (list): source network group name
        :param ipv4_precedence_full_mesh (bool): ipv4 precedence full meshed
        :param destinations_route_name (list): destination network group name
        :param stats_track_by (list): track the traffic item by  ['customOverride', 'sourceDestValuePair0',
                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',
                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',
                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',
                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',
                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',
                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',
                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']
        :return: (obj): The stream object
        :Example: add_traffic_stream(sources=['109.1.0.2'],destinations=['109.1.0.1'],mcast_destinations=['225.0.0.1'], rate_type='framesPerSecond', frame_rate=20, frame_size_fixed_size=128)
        """
        # if StubitUtil.is_stubit_playback():
        #     log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
        #     return

        sources_route_name = kwargs.get('sources_route_name', None)
        destinations_route_name = kwargs.get('destinations_route_name', None)
        stats_track_by = kwargs.get('stats_track_by', None)
        mcast_destinations_index = kwargs.get('mcast_destinations_index', 'all')
        traffic_stream_type = kwargs.get('traffic_stream_type', None)
        if traffic_stream_type and traffic_stream_type != 'bound':
            traffic_type = traffic_stream_type
        if 'port_name' in kwargs:
            if kwargs['port_name'].startswith("Port"):
                kwargs['port_name'] = kwargs['port_name'].split("Port //")[1]

        if 'src_ports' in kwargs:
            temp_src_ports = []
            for src_port in kwargs['src_ports']:
                if src_port.startswith("Port"):
                    temp_src_ports.append(src_port.split("Port //")[1])
            if temp_src_ports:
                kwargs['src_ports'] = temp_src_ports
            if sources:
                sources = None

        if 'dst_ports' in kwargs:
            temp_dst_ports = []
            for dst_port in kwargs['dst_ports']:
                if dst_port.startswith("Port"):
                    temp_dst_ports.append(dst_port.split("Port //")[1])
            if temp_dst_ports:
                kwargs['dst_ports'] = temp_dst_ports
            if destinations:
                destinations = None

        self.log.info("Adding New Traffic Stream")
        self.ixNetwork.Traffic.UseRfc5952 = True
        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True
        stream_obj = kwargs.get('stream_obj', {})
        if 'traffic' not in stream_obj and 'traffic_item' not in stream_obj:
            if traffic_type == 'eth' or traffic_type == 'ethernetVlan':
                traffic_type = 'ethernetVlan'
                if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None):
                    traffic_type = 'raw'
                if sources is None or destinations is None:
                    traffic_type = 'raw'
            elif traffic_type == "ipv4" and kwargs.get("v4_src_value", None) is None and kwargs.get("v4_src_count",
                                                                                                    None) is None:
                traffic_type = 'ipv4'
            elif traffic_type == "ipv6" and kwargs.get("v6_src_value", None) is None and kwargs.get("v6_src_count",
                                                                                                    None) is None:
                traffic_type = 'ipv6'
            else:
                traffic_type = 'raw'
            if traffic_type == 'ethernetVlan':
                if sources or destinations:
                    for source in sources:
                        if '.' in source or ':' in source:
                            raise IxiaConfigException(
                                "For Ethernet stream please pass deviceGroup name instead of Ip address")
                    for destination in destinations:
                        if '.' in destination or ':' in destination:
                            raise IxiaConfigException(
                                "For Ethernet stream please pass deviceGroup name instead of Ip address")
            trafficItem = self.ixNetwork.Traffic.TrafficItem.add(TrafficType=traffic_type,
                                                                 SrcDestMesh=kwargs.get('src_dest_mesh_type', None),
                                                                 RouteMesh=kwargs.get('route_mesh_type', None),
                                                                 BiDirectional=kwargs.get('bidirectional', None),
                                                                 TransmitMode=kwargs.get('transmit_mode', None),
                                                                 Enabled=kwargs.get('enabled', True))
            self.ixNetwork.Traffic.EnableMinFrameSize = 'True'
            if 'traffic_item_name' in kwargs:
                trafficItem.Name = kwargs['traffic_item_name']
            stream_obj['traffic'] = trafficItem
        # self.log.info("Adding Endpoints for Traffic stream %s" % stream_obj['traffic'])
        self.log.info("Added Traffic Stream %s" % stream_obj['traffic'])
        self.log.info("Adding Endpoints for Traffic stream - '%s'" % trafficItem.Name) # Change the log info to TI Name
        if 'endpoint_sets' not in stream_obj:
            sourcesList = []
            destinationsList = []
            multicastDestinations = []
            multicast_address = []
            if traffic_type == 'raw':
                if kwargs.get('src_ports', None):
                    portName = kwargs.get("port_name", None)
                    for srcPort in kwargs['src_ports']:
                        portNameList = self._get_port_name_list([srcPort])
                        for portName in portNameList:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            sourcesList.append(vportHref + '/protocols')
                else:
                    portName = kwargs.get("port_name", None)
                    vportHref = self.ixNetwork.Vport.find(Name=portName).href
                    sourcesList.append(vportHref + '/protocols')
            else:
                if kwargs.get('src_ports', None):
                    portNameList = self._get_port_name_list(kwargs['src_ports'])
                    portName = kwargs.get("port_name", None)
                    if portName in portNameList:
                        for topology in self.ixNetwork.Topology.find():
                            if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                if sources:
                                    for sourceIp in sources:
                                        self._endpoint_source_handles(sourceIp, sourcesList, topology)
                                else:
                                    for srcPort in kwargs['src_ports']:
                                        portNameList = self._get_port_name_list([srcPort])
                                        if portName in portNameList:
                                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                            sourcesList.append(vportHref + '/protocols')
                else:
                    if sources:
                        for sourceIp in sources:
                            self._endpoint_source_handles(sourceIp, sourcesList, topology=None, sources_route_name=sources_route_name)
                    if kwargs.get('src_ports', None):
                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                        portName = kwargs.get("port_name", None)
                        if portName in portNameList:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            sourcesList.append(vportHref + '/protocols')
                    if kwargs.get("v4_src_addr", None):
                        self._endpoint_source_handles(kwargs["v4_src_addr"], sourcesList, topology=None)
                    if kwargs.get("v6_src_addr", None):
                        self._endpoint_source_handles(kwargs["v6_src_addr"], sourcesList, topology=None)
            if traffic_type == 'raw':
                if kwargs.get('dst_ports', None):
                    portname = kwargs.get("port_name", None)
                    for dstPort in kwargs['dst_ports']:
                        portNameList = self._get_port_name_list([dstPort])
                        for portName in portNameList:
                            if portName != portname:
                                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                destinationsList.append(vportHref + '/protocols')
                else:
                    portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                    portname = kwargs.get("port_name", None)
                    for portName in portNameList:
                        if portName != portname:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            destinationsList.append(vportHref + '/protocols')
            else:
                if kwargs.get('dst_ports', None):
                    portNameList = self._get_port_name_list(kwargs['dst_ports'])
                    portname = kwargs.get("port_name", None)
                    for portName in portNameList:
                        if portName != portname:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                    if destinations:
                                        for dstIp in destinations:
                                            self._endpoint_destination_handles(dstIp, destinationsList, topology)
                                    else:
                                        if kwargs.get('dst_ports', None):
                                            for dstPort in kwargs['dst_ports']:
                                                portNameList = self._get_port_name_list([dstPort])
                                                for portName in portNameList:
                                                    if portName != portname:
                                                        vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                                        destinationsList.append(vportHref + '/protocols')
                else:
                    if destinations:
                        for dstIp in destinations:
                            self._endpoint_destination_handles(dstIp, destinationsList, topology=None, destinations_route_name=destinations_route_name)
                    if kwargs.get('dst_ports', None):
                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                        portname = kwargs.get("port_name", None)
                        for portName in portNameList:
                            if portName != portname:
                                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                destinationsList.append(vportHref + '/protocols')
                    if kwargs.get("v4_dst_addr", None):
                        self._endpoint_destination_handles(kwargs["v4_dst_addr"], destinationsList, topology=None)
                    if kwargs.get("v6_dst_addr", None):
                        self._endpoint_destination_handles(kwargs["v6_dst_addr"], destinationsList, topology=None)

            if kwargs.get('src_ports', None) is None and sources is None:
                if traffic_type == 'raw':
                    if kwargs.get('v4_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    if '.' in kwargs['v4_src_addr']:
                                        nameList = [name.Name for name in
                                                    topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]
                                        for name in nameList:
                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(
                                                Name=name).Address
                                            if kwargs['v4_src_addr'] in address.Values:
                                                sourcesList.append(self.ixNetwork.Vport.find(
                                                    Name=kwargs.get('port_name', None)).href + '/protocols')
                    if kwargs.get('v6_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    if ':' in kwargs['v6_src_addr']:
                                        nameList = [name.Name for name in
                                                    topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]
                                        for name in nameList:
                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(
                                                Name=name).Address
                                            if kwargs['v6_src_addr'] in address.Values:
                                                sourcesList.append(self.ixNetwork.Vport.find(
                                                    Name=kwargs.get('port_name', None)).href + '/protocols')
                else:
                    if kwargs.get('v4_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    self._endpoint_source_handles(kwargs['v4_src_addr'], sourcesList, topology)
                    if kwargs.get('v6_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    self._endpoint_source_handles(kwargs['v6_src_addr'], sourcesList, topology)
            if kwargs.get('dst_ports', None) is None and destinations is None:
                if traffic_type == 'raw':
                    if kwargs.get('v4_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        if '.' in kwargs['v4_dst_addr']:
                                            nameList = [name.Name for name in
                                                        topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]
                                            for name in nameList:
                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(
                                                    Name=name).Address
                                                if kwargs['v4_dst_addr'] in address.Values:
                                                    destinationsList.append(self.ixNetwork.Vport.find(
                                                        Name=kwargs.get('port_name', None)).href + '/protocols')
                                                    break
                    if kwargs.get('v6_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        if ':' in kwargs['v6_dst_addr']:
                                            nameList = [name.Name for name in
                                                        topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]
                                            for name in nameList:
                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(
                                                    Name=name).Address
                                                if kwargs['v6_dst_addr'] in address.Values:
                                                    destinationsList.append(self.ixNetwork.Vport.find(
                                                        Name=kwargs.get('port_name', None)).href + '/protocols')
                                                    break
                else:
                    if kwargs.get('v4_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        self._endpoint_source_handles(kwargs['v4_dst_addr'], destinationsList, topology)
                    if kwargs.get('v6_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        self._endpoint_source_handles(kwargs['v6_dst_addr'], destinationsList, topology)
            if mcast_destinations:
                # search igmp/mld
                if traffic_type == 'ipv4':
                    try:
                        for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find():
                            igmpStartMcastAddressList = igmpMcastObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in igmpStartMcastAddressList:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_dest_ip, "arg4": str(
                                                igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrIncr),
                                                                 'arg5': str(
                                                                     igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrCnt)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv4/\d+/igmpHost/\d+', '',
                                                                   igmpMcastObj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier

                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": igmpMcastObj.IgmpMcastIPv4GroupList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})

                        for pimv4_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find():
                            pimv4_group_address_list = pimv4_obj.PimV4JoinPruneList.GroupV4Address.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in pimv4_group_address_list:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_dest_ip, "arg4": "0.0.0.1", 'arg5': str(
                                                pimv4_obj.PimV4JoinPruneList.GroupAddressCount)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv4/\d+/pimV4Interface/\d+', '',
                                                                   pimv4_obj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier

                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": pimv4_obj.PimV4JoinPruneList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                    except:
                        pass
                if traffic_type == 'ipv6':
                    try:
                        for mldMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find():
                            mldStartMcastAddressList = mldMcastObj.MldMcastIPv6GroupList.StartMcastAddr.Values
                            for mcast_dest_ip in mcast_destinations:
                                mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)
                                if mcast_ip in mldStartMcastAddressList:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_ip, "arg4": str(
                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrIncr), 'arg5': str(
                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrCnt)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv6/\d+/mldHost/\d+', '',
                                                                   mldMcastObj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier
                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": mldMcastObj.MldMcastIPv6GroupList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                        for pimv6_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find():
                            pimv6_group_address_list = pimv6_obj.PimV6JoinPruneList.GroupV6Address.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in pimv6_group_address_list:
                                    mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)
                                    if mcast_destinations_index == 'all':
                                        if mcast_ip in pimv6_group_address_list:
                                            multicast_address.append({"arg1": False, "arg2": "none",
                                                                     "arg3": mcast_ip, "arg4": "::0.0.0.1", 'arg5': str(
                                                    pimv6_obj.PimV6JoinPruneList.GroupAddressCount)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv6/\d+/pimV6Interface/\d+', '',
                                                                   pimv6_obj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier
                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": pimv6_obj.PimV6JoinPruneList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                    except:
                        pass
                if not kwargs.get('src_dest_mesh_type', '') == 'manyToMany':
                    for source in sourcesList:
                        for destination in multicastDestinations:
                            if source['arg1'] in destination['arg1']:
                                del multicastDestinations[multicastDestinations.index(destination)]
            if sourcesList == []:
                self.log.error('sourcesList are empty')
                raise IxiaConfigException('sourcesList are empty')

        if destinationsList:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if 'src_ports' in kwargs and 'dst_ports' in kwargs or \
                isinstance(sourcesList[0], str) and isinstance(destinations_list[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          Destinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            elif isinstance(destinations_list[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            elif isinstance(destinations_list[0], str) and isinstance(sourcesList[0], dict):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,
                                                                          Destinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
        if multicastDestinations:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if isinstance(multicastDestinations[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                          ScalableSources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
        if multicast_address:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if isinstance(multicast_address[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                if mcast_destinations_index == 'all':
                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                              ScalableSources=sourcesList,
                                                                              ScalableDestinations=destinations_list,
                                                                              MulticastDestinations=multicast_address)
                else:
                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                              ScalableSources=sourcesList,
                                                                              ScalableDestinations=destinations_list,
                                                                              MulticastReceivers=multicastDestinations)
        # self.log.info("Added Endpoints %s" % stream_obj['endpoint_sets'])
        self.log.info("Added Endpoints for Traffic stream - '%s'" % trafficItem.Name)
        configElement = trafficItem.ConfigElement.find()[0]

        if kwargs.get('vlan_id_start', None) or kwargs.get('vlan_id_count', None):
            ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
            vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
            if ethernetStack and not vlanStack:
                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                self._update_traffic_vlan_data(configElement, **kwargs)
            else:
                self._update_traffic_vlan_data(configElement, **kwargs)
        vlanEnable = True
        if kwargs.get('vlan_mod_dict', None):
            vlanList = kwargs.get('vlan_mod_dict', None)
            count = 0
            for key, value in vlanList.items():
                kwargs['vlan_id_start'] = key
                kwargs['stack_id'] = count
                for vlanParam, vlanValue in value.items():
                    kwargs[vlanParam] = vlanValue
                portName = kwargs.get('port_name', None)
                if traffic_type !='raw':
                    if self.ixNetwork.Topology.find():
                        for topology in self.ixNetwork.Topology.find():
                            if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():
                                    for value in ethernet_obj.EnableVlans.Values:
                                        if value == "false":
                                            vlan_enable = False
                                    if traffic_type == 'raw':
                                        vlan_enable = False
                                if count == 0:
                                    if vlan_enable == False:
                                        ethernet_stack = configElement.Stack.find(StackTypeId='^ethernet$')
                                        vlan_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                                        configElement.Stack.read(ethernet_stack.AppendProtocol(vlan_template))
                                else:
                                    if vlan_enable == False:
                                        vlan_stack = configElement.Stack.find(StackTypeId='^vlan$')
                                        vlan_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                                        configElement.Stack.read(vlan_stack.AppendProtocol(vlan_template))
                else:
                    if vlanEnable == True and count == 0:
                        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                    else:
                        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                        configElement.Stack.read(vlanStack.AppendProtocol(vlanTemplate))
                count = count + 1
                self._update_traffic_vlan_data(configElement, **kwargs)
            self.log.info("Added Ethernet/Vlan for Stream %s" % stream_obj['traffic'])

        if traffic_type == 'raw':
            if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',
                                                                                                None) is None or kwargs.get(
                'eth_dst_mac', None) is None:
                stream_obj['field'] = configElement.Stack.find().Field.find()
                if kwargs.get('eth_dst_mac_mode', None) == "INCR" or kwargs.get('eth_dst_mac_mode', None) is None:
                    kwargs['eth_dst_mac_mode'] = 'increment'
                field = configElement.Stack.find().Field.find(DisplayName="Destination MAC Address")
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'eth_dst_mac_mode', None), \
                                                                                                         kwargs.get(
                                                                                                             'eth_dst_mac',
                                                                                                             "00:00:00:00:01:01"), kwargs.get(
                    'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', "00:00:00:00:01:01"), kwargs.get(
                    'eth_dst_mac_step', "00:00:00:00:00:01")

                if kwargs.get('eth_src_mac_mode', None) == "INCR" or kwargs.get('eth_src_mac_mode', None) is None:
                    kwargs['eth_src_mac_mode'] = 'increment'
                field = configElement.Stack.find().Field.find(DisplayName="Source MAC Address")
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'eth_src_mac_mode', None), \
                                                                                                         kwargs.get(
                                                                                                             'eth_src_mac',
                                                                                                             "00:00:00:00:00:01"), kwargs.get(
                    'eth_src_mac_count', 1), kwargs.get('eth_src_mac', "00:00:00:00:00:01"), kwargs.get(
                    'eth_src_mac_step', "00:00:00:00:00:01")
            if kwargs.get('v4_src_addr', None):
                kwargs['v4_src_value'] = kwargs['v4_src_addr']
            if kwargs.get('v4_dst_addr', None):
                kwargs['v4_dst_value'] = kwargs['v4_dst_addr']
            if kwargs.get('v4_src_value', None) or kwargs.get('v4_src_count', None):
                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
                if ipv4Stack:
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv4_data(configElement, **kwargs)
                else:
                    if ethernetStack and vlanStack and not ipv4Stack:
                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                        configElement.Stack.read(vlanStack.AppendProtocol(ipv4Template))
                    if ethernetStack and not vlanStack and not ipv4Stack:
                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv4Template))
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv4_data(configElement, **kwargs)
            if kwargs.get('v6_src_addr', None):
                kwargs['v6_src_value'] = kwargs['v6_src_addr']
            if kwargs.get('v6_dst_addr', None):
                kwargs['v6_dst_value'] = kwargs['v6_dst_addr']
            if kwargs.get('v6_src_value', None) or kwargs.get('v6_src_count', None):
                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
                if ipv6Stack:
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv6_data(configElement, **kwargs)
                else:
                    if ethernetStack and vlanStack and not ipv6Stack:
                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                        configElement.Stack.read(vlanStack.AppendProtocol(ipv6Template))
                    if ethernetStack and not vlanStack and not ipv6Stack:
                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv6Template))
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv6_data(configElement, **kwargs)

            if kwargs.get('tcp_src_port', None) or kwargs.get('tcp_dst_port', None):
                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
                tcpStack = configElement.Stack.find(StackTypeId='^tcp$')
                if tcpStack:
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Source-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', 'singleValue'), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_src_port',
                                                                                                                             None), kwargs.get(
                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', 'singleValue'), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_dst_port',
                                                                                                                             None), kwargs.get(
                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)

                else:
                    if ipv4Stack and not tcpStack:
                        tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^tcp$")
                        configElement.Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Source-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', 'singleValue'), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_src_port',
                                                                                                                             None), kwargs.get(
                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', 'singleValue'), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_dst_port',
                                                                                                                             None), kwargs.get(
                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)
            if kwargs.get('mpls_label', None) or kwargs.get('mpls_exp', None) or kwargs.get('mpls_bos',None) or kwargs.get('mpls_ttl', None):
                ethernet_stack = configElement.Stack.find(StackTypeId='^ethernet$')
                ipv4_stack = configElement.Stack.find(StackTypeId='^ipv4$')
                mpls_stack = configElement.Stack.find(StackTypeId='^mpls$')
                if mpls_stack:
                    field = configElement.Stack.find().Field.find(DisplayName="Label Value")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'mpls_label_mode', 'singleValue'), kwargs.get('mpls_label', None), kwargs.get(
                    'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'mpls_exp_mode', 'singleValue'), kwargs.get('mpls_exp', None), kwargs.get(
                    'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Bottom of Stack Bit")[0]
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_bos_auto', True), kwargs.get(
                        'mpls_bos_mode', 'singleValue'), kwargs.get('mpls_bos', 1), kwargs.get(
                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Time To Live")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_ttl_mode', 'singleValue'), kwargs.get('mpls_ttl', None), kwargs.get(
                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)
                else:
                    mpls_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^mpls$")
                    if ipv4_stack and not mpls_stack:
                        if kwargs.get('mpls_stack_top', True):
                            for _ in range(kwargs.get('mpls_count', 1)):
                                configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))
                        else:
                            for _ in range(kwargs.get('mpls_count', 1)):
                                configElement.Stack.read(ipv4_stack.AppendProtocol(mpls_template))
                    elif not ipv4_stack and not mpls_stack:
                        for _ in range(kwargs.get('mpls_count', 1)):
                            configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))
                    field = configElement.Stack.find().Field.find(DisplayName="Label Value")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_label_mode', 'singleValue'), kwargs.get('mpls_label', None), kwargs.get(
                        'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_exp_mode', 'singleValue'), kwargs.get('mpls_exp', None), kwargs.get(
                        'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Bottom of Stack Bit")[0]
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_bos_auto', True), kwargs.get(
                        'mpls_bos_mode', 'singleValue'), kwargs.get('mpls_bos', 1), kwargs.get(
                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Time To Live")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_ttl_mode', 'singleValue'), kwargs.get('mpls_ttl', None), kwargs.get(
                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)

        frameRateDict = {'rate_type': 'Type', 'frame_rate': 'Rate', 'bit_rate_units': 'BitRateUnitsType',
                         'enforce_min_inter_packet_gap': 'InterPacketGapUnitsType'}
        frameRateOptions = list(set(frameRateDict.keys()).intersection(kwargs.keys()))
        if frameRateOptions:
            for key in kwargs:
                if key in frameRateDict:
                    setattr(configElement.FrameRate, frameRateDict[key], kwargs[key])

        frameSizeDict = {'frame_size_type': 'Type', 'frame_size_fixed_size': 'FixedSize',
                         'frame_size_increment_start': 'IncrementFrom', 'frame_size_increment_stop': 'IncrementTo',
                         'frame_size_increment_step': 'IncrementStep',
                         'frame_size_preset_distribution': 'PresetDistribution',
                         'frame_size_quad_gaussian': 'QuadGaussian',
                         'frame_size_random_min': 'RandomMin', 'frame_size_random_max': 'RandomMax',
                         'frame_size_weighted_pairs': 'WeightedPairs',
                         'frame_size_weighted_pairs_range': 'WeightedRangePairs'}
        frameSizeOptions = list(set(frameSizeDict.keys()).intersection(kwargs.keys()))
        if frameSizeOptions:
            for key in kwargs:
                if key in frameSizeDict:
                    setattr(configElement.FrameSize, frameSizeDict[key], kwargs[key])

        payLoadDict = {'payload_type': 'Type', 'payload_custom_pattern': 'CustomPattern',
                       'payload_custom_repeat': 'CustomRepeat'}
        payLoadOptions = list(set(payLoadDict.keys()).intersection(kwargs.keys()))
        if payLoadOptions:
            for key in kwargs:
                if key in payLoadDict:
                    setattr(configElement.FramePayload, payLoadDict[key], kwargs[key])

        rateDistributionDict = {'port_distribution': 'PortDistribution', 'stream_distribution': 'StreamDistribution'}
        rateDistributionOptions = list(set(rateDistributionDict.keys()).intersection(kwargs.keys()))
        if rateDistributionOptions:
            for key in kwargs:
                if key in rateDistributionDict:
                    setattr(configElement.FrameRateDistribution, rateDistributionDict[key], kwargs[key])

        if stats_track_by:
            stats_track_by.append('trackingenabled0')
        else:
            stats_track_by = ['trackingenabled0']
        ipv4_precedence_full_mesh = kwargs.get("ipv4_precedence_full_mesh", False)
        self.change_traffic_flow_tracking(traffic_item_list=[trafficItem.Name], cfg_dict={'trackBy': stats_track_by},
                                          ipv4_precedence_full_mesh=ipv4_precedence_full_mesh)

        if 'ip_priority' in kwargs:
            ip_priority = kwargs['ip_priority']
            protocol = ip_priority["priority"]["protocol"]
            if protocol == "ipv4":
                del ip_priority["priority"]["protocol"]
                self.change_ipv4_tos(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority["priority"])
            if protocol == "ipv6":
                del ip_priority["priority"]["protocol"]
                self.change_ipv6_traffic_class(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority["priority"])
        if traffic_type == "raw":
            if 'dst_ports' in kwargs:
                if len(kwargs.get('dst_ports')) > 1:
                    self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItem.Name).RawTrafficRxPortsBehavior = 'loadBalanced'
        if kwargs.get("v4_ttl", None):
            self.set_ipv4_traffic_ttl(traffic_item=trafficItem.Name, ttl=kwargs['v4_ttl'])
        if kwargs.get("v6_ttl", None):
            self.set_ipv6_traffic_hop_limit(traffic_item=trafficItem.Name, hop_limit=kwargs['v6_ttl'])

        return stream_obj

    def _set_route_count(self, pool_handle, routecount, prefix_ip=None, prefix_step_value=None):
        """
        Set Route count based on Protocol handle.

        :param pool_handle: PrefixPool Handle
        :param routecount: routecount to be updated
        :param prefix_ip: prefix_ip as reference
        :param prefix_step_value: prefix step to be updated
        :return:
        """
        if prefix_ip:
            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:
                # This block for 9.0 version
                ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)
                value_list = pool_handle.NumberOfAddressesAsy.Values
                value_list[ip_prefix_index] = routecount
                pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) <= 8:
                pool_handle.NumberOfAddresses = routecount
        else:
            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:
                # This block for 9.0 version
                pool_handle.NumberOfAddressesAsy.Single(routecount)
                if str(pool_handle.NumberOfAddressesAsy) == str(routecount):
                    self.log.info('Route count updated successfully')
                else:
                    self.log.error('Route count update failed')
            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) <= 8:
                # This block for 8.50 version
                pool_handle.NumberOfAddresses = routecount
                if str(pool_handle.NumberOfAddresses) == str(routecount):
                    self.log.info('Route count updated successfully')
                else:
                    self.log.error('Route count update failed')
        if prefix_step_value:
            self._update_prefix_step(prefix_step_value, pool_handle)

    def _modify_route_count(self, network_group, route_count, ports, ip_type, start_ip_prefix, protocol, prefix,
                            router_id,prefix_step, **kwargs):
        """
        Modifying address count for protocols. Internal API to support setting route count APIs

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param protocol: protocol
        :param prefix: prefix
        :param router_id: router ID
        :param prefix_step: prefix step
        :return: result
        """
        protocol_status = False
        deviceGroupName = None
        if (network_group and start_ip_prefix and prefix and router_id) or (
                network_group and start_ip_prefix and router_id) or (
                network_group is None and start_ip_prefix and router_id):
            networkGroupNameList = []
            if "." in router_id and protocol.lower() != 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if "." not in router_id and protocol.lower() == 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.Name == router_id:
                        deviceGroupName = router_id
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            else:
                try:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group:
                            if network_group in networkGroup.Name:
                                networkGroupNameList.append(networkGroup.Name)
                                break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if (network_group and start_ip_prefix is None and ports is None and prefix is None and router_id) or (
                network_group is None and start_ip_prefix is None and prefix is None and router_id):
            if "." in router_id:
                if protocol == "ISIS":
                    raise IxiaConfigException(
                        "ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')")
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + deviceGroupName + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]
            else:
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + router_id + '$').NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if network_group and ports is None and start_ip_prefix is None and router_id is None:
            networkGroupNameList = []
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                for networkGroupObj in deviceGroupObj.NetworkGroup.find():
                    if network_group in networkGroupObj.Name:
                        networkGroupNameList.append(networkGroupObj.Name)
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + networkGroupName + '$'):
                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv4PoolObj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv4PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                if protocol == "OSPF":
                                    if ipv4PoolObj.OspfRouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv4PoolObj, route_count)
                    else:
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + networkGroupName + '$'):
                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv6PoolObj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv6PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                if protocol == "OSPF":
                                    if ipv6PoolObj.Ospfv3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv6PoolObj, route_count)
            else:
                raise IxiaConfigException(
                    "Network group name '%s' not found for Ip version '%s'" % (network_group, ip_type))
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            for port in ports:
                if port in vportNameList:
                    for topologyObj in self.ixNetwork.Topology.find():
                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                            if ip_type.lower() == "ipv4":
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv4PoolObj.IsisL3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv4PoolObj, route_count,
                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if protocol == "OSPF":
                                            if ipv4PoolObj.OspfRouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv4PoolObj, route_count)
                            else:
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv6PoolObj.IsisL3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv6PoolObj, route_count,
                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if protocol == "OSPF":
                                            if ipv6PoolObj.Ospfv3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv6PoolObj, route_count)
        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (
                start_ip_prefix and network_group and ports is None and router_id is None):
            networkGroupNameList = []
            if network_group and start_ip_prefix:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if
                                        network_group in networkObj.Name]
                # This condition for compact version
                if networkGroupNameList == []:
                    networkGroupNameList = [networkObj.Name for networkObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if start_ip_prefix and network_group is None:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.OspfRouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
                    else:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.Ospfv3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)
        if protocol_status:
            return protocol_status
        else:
            raise IxiaConfigException("%s protocol not configured or Configuration issue." % protocol)

    def _ospf_routes_control(self, ports, ip_type, address_list, action, active, devices):
        """
        Function used internally by API ospf_routes_start & ospf_routes_stop

        :param ports: ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: Start/Stop
        :param active: Active/ Deactive
        :param devices: Name of the devices in the config

        :return: True on success and raise exception if any failures
        """
        self.log.info('OSPF Routes Control:%s' % (action) )
        if ports==None and address_list==None and devices==None:
            if ip_type.lower() == "ipv4":
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).Active.Single(active)
            else:
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).Active.Single(active)
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for ospfRoute in ipv4Pools.OspfRouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):
                                        eval('ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')
                                        ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)
                        else:
                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                for ospfRoute in ipv6Pools.Ospfv3RouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):
                                        eval('ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')
                                        ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)
        if address_list:
            for lastaddress in address_list:
                if ':' not in lastaddress:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().Active.Single(active)
                else:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().Active.Single(active)
        if devices:
            for eachDevice in devices:
                eachDevice = '^' + eachDevice.replace('+', r'\+').replace('*', r'\*') + '$'
                if ip_type.lower() == "ipv4":
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().Active.Single(
                        active)
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().' + action + '(None)')
                else:
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().Active.Single(
                        active)
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().' + action + '(None)')
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def ospf_routes_start(self, ports=None, ip_type="ipv4", address_list=None, devices=None):
        """
        Start OSPF route ranges

        :param ports: list of port names e.g. ["Ethernet - 001"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for OSPF in TGN
        :param devices: Name of the devices in the config
        :return: True on success else raises exception

        :Example: ospf_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
                  ospf_routes_start(devices=["Device1"], ip_type="ipv6")
        """
        return self._ospf_routes_control(ports, ip_type, address_list, "Start", "true", devices)

    def ospf_routes_stop(self, ports=None, ip_type="ipv4", address_list=None, devices=None):
        """
        Stopping OSPF route ranges

        :param ports: list of port names e.g. ["Ethernet - 001"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: The list of network addresses in the route range defined for OSPF in TGN. In Spirent, the first address should be included per network range.
                In IXIA, the last address should be included.
        :param devices: Name of the devices in the config
        :return: True on success else raises exception

        :Example: ospf_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
                  ospf_routes_stop(devices=["Device1"], ip_type="ipv6")
        """
        return self._ospf_routes_control(ports, ip_type, address_list, "Stop", "false", devices)

    def set_ospf_route_count(self, route_count,router_id, ip_type="ipv4", lsa_id=None, start_ip_prefix=None, **kwargs):
        """
        Modifying address count for OSPF protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param router_id: Represents the Router ID of the router.
        :param lsa_id: NA for IXIA
        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional
        :return: True if the operation is successful, False otherwise

        :Example: set_ospf_route_count(route_count=300, network_group='Network Group 2', ports=["Ethernet - 001"])
        """
        self.log.info("Setting OSPF Route Count")
        network_group = kwargs.get('network_group')
        ports = kwargs.get('ports')
        prefix_step = kwargs.get('prefix_step')
        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix, protocol="OSPF",
                                        prefix=None, router_id=router_id, prefix_step=prefix_step)

    def _ldp_routes_control(self, ports, ip_type, address_list, action, active):
        """
        Function used internally by API ldp_routes_start & ldp_routes_stop

        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param address_list: address_list: list of last network address in the route range defined for LDP in TGN
        :param action: start/stop
        :param active: active/deactive
        :return: True/Exception
        """
        self.log.info('LDP Route Control:%s' % (action))
        if ports == None and  address_list== None:
            if ip_type.lower() == "ipv4":
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).Active.Single(active)
            else:
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).Active.Single(active)

        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for ldpRoute in ipv4Pools.LdpFECProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):
                                        eval('ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')
                                        ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)
                        else:
                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                for ldpRoute in ipv6Pools.LdpIpv6FECProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):
                                        eval('ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')
                                        ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)
        if address_list:
            for lastaddress in address_list:
                if ':' not in lastaddress:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().Active.Single(active)
                else:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().Active.Single(active)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True


    def ldp_routes_start(self, ports=None, ip_type="ipv4", address_list=None):
        """
        Starting LDP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for LDP in TGN
        :return: True on success else raises exception

        :Example: ldp_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
        """

        return self._ldp_routes_control(ports, ip_type, address_list, "Start", "true")

    def ldp_routes_stop(self, ports=None, ip_type="ipv4", address_list=None):
        """
        Starting LDP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for LDP in TGN
        :return: True on success else raises exception

        :Example: ldp_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
        """

        return self._ldp_routes_control(ports, ip_type, address_list, "Stop", "false")

    def _bgp_routes_control(self, ports, ip_type, address_list, action, active, devices, nested_nework_group):
        """
        Function used internally by API bgp_routes_start & bgp_routes_stop

        :param ports: list of ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: Start/Stop
        :param active: Active/ Deactive
        :param devices: list of Names of the devices in the config
        :param nested_nework_group: Nested network group name
        """
        self.log.info('BGP Routes Control:%s' % (action))
        if ports == None and address_list == None and devices == None:
            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    try:
                        group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
                else:
                    try:
                        group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
                    try:
                        group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
        if (ports and devices == None and address_list == None):
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                portName = '^' + portName.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                            if nested_nework_group:
                                try:
                                    for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                        for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                                eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')
                                                ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)
                                except:
                                    pass
                                try:
                                    for ipv4_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().DeviceGroup.find().\
                                            NetworkGroup.find().Ipv4PrefixPools.find():
                                        for route in ipv4_pools.BgpIPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', route.href):
                                                eval('ipv4_pools.BgpIPRouteProperty.find(DescriptiveName=route.DescriptiveName).'+ action + '(None)')
                                                ipv4_pools.BgpIPRouteProperty.find(DescriptiveName=route.DescriptiveName).Active.Single(active)
                                except:
                                    pass

                            for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                        eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')
                                        ipv4Pools.BgpIPRouteProperty.find( DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)
                        else:
                            if nested_nework_group:
                                try:
                                    for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                        for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                                route_name = '^' + bgpRoute.DescriptiveName.replace('+', r'\+').replace('*', r'\*') + '$'
                                                eval( 'ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).' + action + '(None)')
                                                ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).Active.Single(active)
                                except:
                                    pass

                                try:
                                    for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().\
                                            NetworkGroup.find().Ipv6PrefixPools.find():
                                        for bgp_route in ipv6_pools.BgpV6IPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgp_route.href):
                                                route_name = '^' + bgp_route.DescriptiveName.replace('+', r'\+').replace('*', r'\*') + '$'
                                                eval( 'ipv6_pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).' + action + '(None)')
                                                ipv6_pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).Active.Single(active)
                                except:
                                    pass

                                try:
                                    for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().\
                                            DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                        for bgp_route in ipv6_pools.BgpIPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgp_route.href):
                                                eval(
                                                'ipv6_pools.BgpIPRouteProperty.find(DescriptiveName=bgp_route.DescriptiveName).' + action + '(None)')
                                                ipv6_pools.BgpIPRouteProperty.find(
                                                DescriptiveName=bgp_route.DescriptiveName).Active.Single(active)
                                except:
                                    pass

                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                try:
                                    for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():
                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', r'\+').replace('*',r'\*') + '$'
                                            eval('ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')
                                            ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).Active.Single(active)
                                except:
                                    pass
                                try:
                                    for bgpRoute in ipv6Pools.BgpIPRouteProperty.find():
                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', r'\+').replace('*',r'\*') + '$'
                                            eval( 'ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')
                                            ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).Active.Single(active)
                                except:
                                    pass
        if (devices and ports and address_list) or (devices == None and ports and address_list) or (
                devices and ports == None and address_list) or (devices == None and ports == None and address_list):
            for startaddress in address_list:
                if ':' not in startaddress:
                    nameList = [name.Name for name in
                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()
                                if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(
                            Name='^' + name + '$').NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass
                else:
                    nameList = [name.Name for name in
                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()
                                if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active
                                bgpIpv6Obj.ClearOverlays()
                                bgpIpv6Obj.ValueList(values=valuesList)
                            except:
                                pass

                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active
                                bgpIpv6Obj.ClearOverlays()
                                bgpIpv6Obj.ValueList(values=valuesList)

                            except:
                                pass
        if (devices and ports == None and address_list == None) or (devices and ports and address_list == None):
            for eachDevice in devices:
                eachDevice = '^' + eachDevice.replace('+', r'\+').replace('*', r'\*') + '$'
                for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find():
                    if ip_type.lower() == "ipv4":
                        try:
                            group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        # for nested network groups
                        try:
                            group.DeviceGroup.find( Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = group.DeviceGroup.find().NetworkGroup.find(Name='^'+nested_nework_group+'$')
                            device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            #eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find().\
                                DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$')
                            device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                    else:
                        try:
                            group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        # for nested network groups
                        try:
                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = group.DeviceGroup.find().\
                                        NetworkGroup.find(Name='^' + nested_nework_group + '$')
                            device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = group.NetworkGroup.find().DeviceGroup.find().\
                                        NetworkGroup.find(Name='^' + nested_nework_group + '$')
                            device_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('device_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find().\
                                DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$')
                            device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            eval('device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass

        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def bgp_routes_start(self, ports=None, ip_type="ipv4", address_list=None, devices=None, **kwargs):
        """
        Start BGP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of start network addresses of network group
        :param devices: list of Names of the devices in the config
        :param nested_nework_group : True if nested network group
        :param nested_device : List of nested devices / if passing address_list, one nested device(str)
        :return: True on success else raises exception

        :Example: bgp_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
                  bgp_routes_start(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])
                  bgp_routes_start(nested_device= ['NG_PEER_1_IPv6'],devices=['ISIS_PEER_1'],ip_type='ipv6')
                  bgp_routes_start(nested_device="NG_PEER_1_IPv4", address_list=['20.1.0.0','90.0.0.0'])
        """
        nested_nework_group = kwargs.get('nested_nework_group', None)
        action = kwargs.get("action", "Start")
        flag = 'true'
        nested_device = kwargs.get('nested_device', None)

        if isinstance(nested_device, list) and not address_list:
            for device_group in nested_device:
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_group + '$')

                if not device_objs:
                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                        Name='^' + device_group + '$')

                if not device_objs:
                    self.log.warning(f"NetworkGroup '{device_group}' not found.")
                    continue

                for dev_group in device_objs:
                    if ip_type.lower() == 'ipv4':
                        for pool in dev_group.NetworkGroup.find().Ipv4PrefixPools.find():
                            try:
                                values_list = pool.BgpIPRouteProperty.find().Active.Values
                                values_list = [flag] * len(values_list)
                                bgp_active = pool.BgpIPRouteProperty.find().Active
                                bgp_active.ClearOverlays()
                                bgp_active.ValueList(values=values_list)
                                self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                                eval(f'pool.BgpIPRouteProperty.find().{action}(None)')
                                self.log.debug(f"{action} on {device_group} done successfully for IP type : {ip_type}")
                            except Exception as err:
                                self.log.warning(f"Failed to apply {flag} to BGP IPv4 routes in {device_group}: {err}")

                    elif ip_type.lower() == 'ipv6':
                        for pool in dev_group.NetworkGroup.find().Ipv6PrefixPools.find():
                            for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:
                                try:
                                    route_obj = getattr(pool, route_type).find()
                                    if route_obj:
                                        active_obj = route_obj.Active
                                        values_list = active_obj.Values
                                        values_list = [flag] * len(values_list)
                                        active_obj.ClearOverlays()
                                        active_obj.ValueList(values=values_list)
                                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                                        eval(f'route_obj.{action}(None)')
                                        self.log.debug(f"{action} on {device_group} done successfully for IP type : {ip_type}")
                                except Exception as err:
                                    self.log.warning(f"Failed to apply {flag} to {route_type} in {device_group}: {err}")

            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return True

        if isinstance(nested_device, str) and address_list:
            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + nested_device + '$')

            if not device_objs:
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                    Name='^' + nested_device + '$')

            if not device_objs:
                self.log.warning(f"DeviceGroup '{nested_device}' not found.")

            network_groups = device_objs.NetworkGroup.find()
            for net_group in network_groups:
                if ip_type.lower() == 'ipv4':
                    for pool in net_group.Ipv4PrefixPools.find():
                        route_props = pool.BgpIPRouteProperty.find()
                        if not route_props:
                            continue

                        active_obj = route_props.Active
                        addresses = pool.NetworkAddress.Values
                        if not addresses:
                            continue

                        values_list = list(active_obj.Values)

                        for i, addr in enumerate(addresses):
                            if addr in address_list:
                                values_list[i] = 'true' if action.lower() == "start" else "false"

                        active_obj.ClearOverlays()
                        active_obj.ValueList(values=values_list)
                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                        if action.lower() == "start":
                            route_props.Start()
                        else:
                            route_props.Stop()
                        self.log.debug(
                            f"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}")

                elif ip_type.lower() == 'ipv6':
                    for pool in net_group.Ipv6PrefixPools.find():
                        for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:
                            route_props = getattr(pool, route_type).find()
                            if not route_props:
                                continue

                            active_obj = route_props.Active
                            addresses = pool.NetworkAddress.Values
                            if not addresses:
                                continue

                            values_list = list(active_obj.Values)

                            for i, addr in enumerate(addresses):
                                if addr in address_list:
                                    values_list[i] = 'true' if action.lower() == "start" else "false"

                            active_obj.ClearOverlays()
                            active_obj.ValueList(values=values_list)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            if action.lower() == "start":
                                route_props.Start()
                            else:
                                route_props.Stop()
                            self.log.debug(
                                f"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}")

            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return True
        return self._bgp_routes_control(ports, ip_type, address_list, action, "true", devices, nested_nework_group)

    def bgp_routes_stop(self, ports=None, ip_type="ipv4", address_list=None, devices=None, **kwargs):
        """
        Stop BGP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of start network addresses of network group
        :param devices: list of Names of the devices in the config
        :param nested_nework_group : True if nested network group
        :param nested_device : List of nested devices / if passing address_list, one nested device(str)
        :return: True on success else raises exception

        :Example: bgp_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
                  bgp_routes_stop(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])
                  bgp_routes_stop(nested_device= ['NG_PEER_1_IPv6'],devices=['ISIS_PEER_1'],ip_type='ipv6')
                  bgp_routes_stop(nested_device="NG_PEER_1_IPv4", address_list=['20.1.0.0','90.0.0.0'])
        """
        nested_nework_group = kwargs.get('nested_nework_group')
        flag = 'false'
        action = kwargs.get("action", "Stop")
        nested_device = kwargs.get('nested_device', None)

        if isinstance(nested_device, list) and not address_list:
            for device_group in nested_device:
                device=re.escape(device_group)
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_group + '$')
                if not device_objs:
                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(Name='^' + device + '$')
                if not device_objs:
                    self.log.warning(f"NetworkGroup '{device_group}' not found.")
                    continue

                for dev_group in device_objs:
                    if ip_type.lower() == 'ipv4':
                        for pool in dev_group.NetworkGroup.find().Ipv4PrefixPools.find():
                            try:
                                values_list = pool.BgpIPRouteProperty.find().Active.Values
                                values_list = [flag] * len(values_list)
                                bgp_active = pool.BgpIPRouteProperty.find().Active
                                bgp_active.ClearOverlays()
                                bgp_active.ValueList(values=values_list)
                                self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                                eval(f'pool.BgpIPRouteProperty.find().{action}(None)')
                                self.log.debug(f"{action} on {device_group} done successfully for IP type : {ip_type}")
                            except Exception as err:
                                self.log.warning(f"Failed to apply {flag} to BGP IPv4 routes in {device_group}: {err}")

                    elif ip_type.lower() == 'ipv6':
                        for pool in dev_group.NetworkGroup.find().Ipv6PrefixPools.find():
                            for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:
                                try:
                                    route_obj = getattr(pool, route_type).find()
                                    if route_obj:
                                        active_obj = route_obj.Active
                                        values_list = active_obj.Values
                                        values_list = [flag] * len(values_list)
                                        active_obj.ClearOverlays()
                                        active_obj.ValueList(values=values_list)
                                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                                        eval(f'route_obj.{action}(None)')
                                        self.log.debug(f"{action} on {device_group} done successfully for IP type : {ip_type}")
                                except Exception as err:
                                    self.log.warning(f"Failed to apply {flag} to {route_type} in {device_group}: {err}")

            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return True

        if isinstance(nested_device, str) and address_list:
            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + nested_device + '$')

            if not device_objs:
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')

            if not device_objs:
                self.log.warning(f"DeviceGroup '{nested_device}' not found.")

            network_groups = device_objs.NetworkGroup.find()
            for net_group in network_groups:
                if ip_type.lower() == 'ipv4':
                    for pool in net_group.Ipv4PrefixPools.find():
                        route_props = pool.BgpIPRouteProperty.find()
                        if not route_props:
                            continue

                        active_obj = route_props.Active
                        addresses = pool.NetworkAddress.Values
                        if not addresses:
                            continue

                        values_list = list(active_obj.Values)

                        for i, addr in enumerate(addresses):
                            if addr in address_list:
                                values_list[i] = 'false' if action.lower() == "stop" else "true"

                        active_obj.ClearOverlays()
                        active_obj.ValueList(values=values_list)
                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                        if action.lower() == "stop":
                            route_props.Stop()
                        else:
                            route_props.Start()
                        self.log.debug(f"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}")

                elif ip_type.lower() == 'ipv6':
                    for pool in net_group.Ipv6PrefixPools.find():
                        for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:
                            route_props = getattr(pool, route_type).find()
                            if not route_props:
                                continue

                            active_obj = route_props.Active
                            addresses = pool.NetworkAddress.Values
                            if not addresses:
                                continue

                            values_list = list(active_obj.Values)

                            for i, addr in enumerate(addresses):
                                if addr in address_list:
                                    values_list[i] = 'false' if action.lower() == "stop" else "true"

                            active_obj.ClearOverlays()
                            active_obj.ValueList(values=values_list)
                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                            if action.lower() == "stop":
                                route_props.Stop()
                            else:
                                route_props.Start()
                            self.log.debug(f"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}")

            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return True

        return self._bgp_routes_control(ports, ip_type, address_list, "Stop", "false", devices, nested_nework_group)

    def _isis_routes_control(self, ports: List[str], ip_type: str, address_list: List[str], devices: List[str], network_group: str,
                             action: str = 'Start', active: str = 'true'):
        """
        Function used internally by API isis_routes_start & isis_routes_stop

        :param ports: list of ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: takes 'true' to start or 'false' to stop
        :param active: takes 'Start' or 'Stop'
        :param devices: list of Names of the devices in the config
        :param network_group: ISIS network group name
        """
        self.log.info(f"ISIS Routes Control {action}")
        result = False
        if ports is None and address_list is None and devices is None and network_group is None:
            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    try:
                        group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                        eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        result = True
                    except:
                        pass
                elif ip_type.lower() == "ipv6":
                    try:
                        group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        result = True
                    except:
                        pass
            if not result:
                raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')

        if (ports and devices is None and address_list is None and network_group is None):
            vport_name_list = [vport.Name for vport in self.ixNetwork.Vport.find()]
            port_name_list = [port_name for port_name in ports if port_name in vport_name_list]
            for port_name in port_name_list:
                port_name = '^' + port_name.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port_name).href:
                        topology_obj = topology.href
                        if ip_type.lower() == "ipv4":
                            for ipv4_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for isis_route in ipv4_pools.IsisL3RouteProperty.find():
                                    try:
                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):
                                            name = '^' + isis_route.DescriptiveName.replace('+', r'\+').replace('*',r'\*') + '$'
                                            eval('ipv4_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')
                                            ipv4_pools.IsisL3RouteProperty.find( DescriptiveName=isis_route.DescriptiveName).Active.Single(active)
                                    except:
                                        raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')
                        else:
                            for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                try:
                                    for isis_route in ipv6_pools.IsisL3RouteProperty.find():
                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):
                                            name = '^' + isis_route.DescriptiveName.replace('+', r'\+').replace('*',r'\*') + '$'
                                            eval('ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')
                                            ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).Active.Single(active)
                                except:
                                    raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')

        if address_list and (devices or ports or network_group):
            for lastaddress in address_list:
                namelist = list()
                if ':' not in lastaddress:
                    if devices:
                        for device in devices:
                            if network_group:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()
                                                 if name])
                            else:
                                namelist.extend([name.Name for name in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').
                                                NetworkGroup.find().Ipv4PrefixPools.find()
                                            if name])

                    elif devices is None and network_group:
                        namelist.extend([name.Name for name in
                                    self.ixNetwork.Topology.find().DeviceGroup.find().
                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()
                                    if name])
                    else:
                        namelist.extend([name.Name for name in
                                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()
                                    if name])

                    for name in namelist:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find(). \
                            NetworkGroup.find().Ipv4PrefixPools.find(
                            Name='^' + name + '$').LastNetworkAddress
                        if lastaddress in address:
                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]
                            for index in ip_index_list:
                                try:
                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'
                                         'Ipv4PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')
                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv4PrefixPools.find(
                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values
                                    valueslist[index] = active.lower()
                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv4PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active
                                    isis_obj.ClearOverlays()
                                    isis_obj.ValueList(values=valueslist)
                                except:
                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv4')

                else:
                    if devices:
                        for device in devices:
                            if network_group:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()
                                                 if name])
                            else:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find().Ipv6PrefixPools.find()
                                                 if name])

                    elif devices is None and network_group:
                        namelist.extend([name.Name for name in
                                         self.ixNetwork.Topology.find().DeviceGroup.find().
                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()
                                         if name])
                    else:
                        namelist.extend([name.Name for name in
                                         self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()
                                         if name])
                    for name in namelist:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                            Ipv6PrefixPools.find(Name='^' + name + '$').LastNetworkAddress
                        if lastaddress in address:
                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]
                            for index in ip_index_list:
                                try:
                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'
                                         'Ipv6PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')
                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv6PrefixPools.find(
                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values
                                    valueslist[index] = active.lower()
                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv6PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active
                                    isis_obj.ClearOverlays()
                                    isis_obj.ValueList(values=valueslist)
                                except:
                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv6')

        if devices and address_list is None and (ports or network_group):
            for each_device in devices:
                each_device = '^' + each_device.replace('+', r'\+').replace('*', r'\*') + '$'
                if network_group:
                    for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$'):
                        try:
                            if ip_type.lower() == "ipv4":
                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                            else:
                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        except Exception as err_msg:
                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)
                else:
                    for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device).NetworkGroup.find():
                        try:
                            if ip_type.lower() == "ipv4":
                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                            else:
                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        except Exception as err_msg:
                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)

        if devices is None and ports is None and address_list is None and network_group:
            try:
                network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')
                if ip_type.lower() == "ipv4":
                    network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                    eval('network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                else:
                    network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                    eval('network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
            except Exception as err_msg:
                raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)

        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def isis_routes_start(self, ports: Optional[List[str]] = None,  address_list: Optional[List[str]] = None,
                          devices: Optional[List[str]] = None, ip_type: str = 'ipv4',**kwargs):
        """
        Starting ISIS route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.
        :param devices: list of Names of the devices in the config
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param kwargs :
            network_group : ISIS network group name
        :return: True on success else raises exception

        :Example: isis_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
        """
        network_group = kwargs.get('network_group',None)
        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, "Start", "true")

    def isis_routes_stop(self, ports: Optional[List[str]] = None, address_list: Optional[List[str]] = None,
                         devices: Optional[List[str]] = None, ip_type: str = 'ipv4', **kwargs):
        """
        Stopping ISIS route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.
        :param devices: list of Names of the devices in the config
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param kwargs :
            network_group : ISIS network group name
        :return: True on success else raises exception

        :Example: isis_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
        """
        network_group = kwargs.get('network_group',None)
        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, "Stop", "false")

    def set_isis_route_count(self, route_count, router_id=None, ip_type="ipv4", lsp_id=None, start_ip_prefix=None, **kwargs):
        """
        Modifying address count for ISIS protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param router_id: NA for IXIA
        :param lsp_id: NA for IXIA
        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, network_group has to be included in the kwargs as a
                       mandatory parameter and ports is optional
                       network_group: ISIS network group name
                       ports:  port name
                       prefix_step:  prefix step to be updated
        :return: True if the operation is successful, False otherwise

        :Example: set_isis_route_count(route_count=300,router_id=None, network_group='Network Group 8')
        """
        self.log.info("Setting ISIS route count")
        network_group = kwargs.get('network_group')
        ports = kwargs.get('ports')
        prefix_step = kwargs.get('prefix_step')
        if router_id:
            if "." in router_id:
                router_id = None
        if not network_group and start_ip_prefix is None and router_id is None and ports is None:
            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')
        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix,
                                        prefix_step=prefix_step,protocol="ISIS", prefix=None, router_id=router_id)

    def get_port_mtu(self, port):
        """
        Get MTU value for Ether PORT

        :param port: portName, Location or Interface of PORT\n
            Example: portName: (str): The virtual port name. Ex: '1/2/9'\n
            Example: port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)] , Ex: ['10.34.57.60', '2', '9']\n
            Example: location (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'
        :return: A list of one or more (if sub-interface exists) MTU values for a given port

        :Example: get_port_mtu("10.39.60.120/2/9")
        """
        self.log.info("Getting MTU on the port:%s" % (port))
        if type(port) == list:
            port = ':'.join(port)
        elif type(port) == str and re.search('\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', port):
            port = port.replace('/', ':')
        else:
            port = self.ixNetwork.Vport.find(Name=port).AssignedTo

        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
            for vport in vportList:
                assignedVport = self.ixNetwork.Vport.find(Name=vport)
                if assignedVport.AssignedTo == port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == assignedVport.href:
                            topologyObj = topology.href
                            for deviceGroup in topology.DeviceGroup.find():
                                mtuValues = []
                                for ethernet in deviceGroup.Ethernet.find():
                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                        mtuValues.append(ethernet.Mtu.Values)
                                return [mtu for mtuSubList in mtuValues for mtu in mtuSubList]
        else:
            raise IxiaConfigException("Port %s is invalid or not configured" % port)

    def set_port_mtu(self, port, mtu, **kwargs):
        """
        Change MTU value in port Ethernet configuration

        :param port: portName, Location or Interface of PORT\n
            Example:
               portName: (str): The virtual port name. Ex: '1/2/9' \n
               port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)], Ex: ['10.34.57.60', '2', '9']\n
               location: (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'
        :param mtu: (int): User preferred MTU value for Ethernet PORT. (RANGE 68 - 9216)
        :kwargs_param direction: (str): increment|decrement MTU value.
        :kwargs_param step: (int): Number of steps to increment/decrement MTU value, default is 0
        :return: True on success

        :Example: set_port_mtu(portList[0],1300,direction='increment',step=2)
        """
        self.log.info("Setting MTU on the port:%s" % (port))
        step = kwargs.get('step', 0)
        if type(port) == list:
            port = ':'.join(port)
        elif type(port) == str and re.search('\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', port):
            port = port.replace('/', ':')
        else:
            port = self.ixNetwork.Vport.find(Name=port).AssignedTo

        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
            for vport in vportList:
                vports = self.ixNetwork.Vport.find(Name=vport)
                if vports.AssignedTo == port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == vports.href:
                            topologyObj = topology.href
                            for deviceGroup in topology.DeviceGroup.find():
                                for ethernet in deviceGroup.Ethernet.find():
                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                        if kwargs:
                                            if kwargs['direction'].lower() == 'increment':
                                                ethernet.Mtu.Increment(start_value=mtu, step_value=step)
                                            if kwargs['direction'].lower() == 'decrement':
                                                ethernet.Mtu.Decrement(start_value=mtu, step_value=step)
                                        else:
                                            ethernet.Mtu.Single(mtu)
            time.sleep(2)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("Port %s is invalid or not configured" % port)
        return True

    def get_all_traffic_streams(self, getEnabledTrafficItemsOnly=True):
        """
        Retrieves all traffic items for a given session

        :param getEnabledTrafficItemsOnly: (bool): Retrieve the traffic items which are enabled|disabled.
                                                    Valid values True or False, default is False.
        :return: List of one or more traffic item objects in configuration

        :Example: get_all_traffic_streams(getEnabledTrafficItemsOnly=True)
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return
        self.log.info("Available traffic streams")
        trafficStreams = [trafficItem for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Enabled == getEnabledTrafficItemsOnly]
        return trafficStreams

    def _modify_ipv4_ipv6_address(self,ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed):
        """
        This function is used internally

        :param ip_config: (str|list): Config IP address value(single/list).
        :param pattern:(str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter
        :param ipObj: IP Object to modify the parameters
        :param gateway_config: (str): Config with gateway address, count, step, seed
        :param maximum: Maximum IPv4/IPv6 addresses
        :param step: (str): Increment step value if needed
        :param gw_step: (str): Increment gateway step value if needed
        :param direction: (str): Counter direction increment|decrement.
        :param ngpfEndpoint: IXIA NGPF Endpoints
        :param mask: IPv4/IPv6 address Mask
        :param count: IPv4/IPv6 address count
        :param seed: IPv4/IPv6 seed values
        """
        if ngpfEndpoint == "ipv4":
            if type(ip_config) == list:
                ipObj.Address.ValueList(values=ip_config)
            elif pattern == 'random':
                ipObj.Address.Random()
                if gateway_config:
                    ipObj.GatewayIp.Random()
            elif pattern == 'repeatableRandomRange':
                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)
                if gateway_config:
                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)
            elif pattern == 'repeatableRandom':
                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)
                if gateway_config:
                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)
            elif pattern == 'custom':
                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)
                if gateway_config:
                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)
            else:
                if direction.lower() == "increment":
                    ipObj.Address.Increment(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)
                else:
                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            self.log.info("Device IP Address configured successfully")
            return True
        if ngpfEndpoint == "ipv6":
            if type(ip_config) == list:
                ipObj.Address.ValueList(values=ip_config)
            elif pattern == 'random':
                ipObj.Address.Random()
                if gateway_config:
                    ipObj.GatewayIp.Random()
            elif pattern == 'repeatableRandomRange':
                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)
                if gateway_config:
                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)
            elif pattern == 'repeatableRandom':
                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)
                if gateway_config:
                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)
            elif pattern == 'custom':
                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)
                if gateway_config:
                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)
            else:
                if direction.lower() == "increment":
                    ipObj.Address.Increment(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)
                else:
                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            self.log.info("Device IP Address configured successfully")
            return True

    def set_device_ip_address(self, router_id, address_family, ip_config, gateway_config=None, advanced_config=None, **kwargs):
        """
        Modifies IP address configuration for requested routerId and address family if provided

        :param router_id: (str): The router ID IP address.
        :param address_family: (str) The IP address belongs to IPv4|IPv6
        :param ip_config: (str|list): Config IP address value(single/list).
        :param gateway_config: (str): Config with gateway address, count, step, seed
        :param advanced_config: stack count, repeat, recycle count in Modifier
        :param kwargs:
               pattern: (str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter \n
               direction: (str): Counter direction increment|decrement. \n
               step: (str): Increment step value if needed \n
               gw_step: (str): Increment gateway step value if needed \n
               prefix: (int): Prefix for IPv4|IPv6 (24 or 64) \n
               resolveGateway: (bool): Resolve gateway True|False, default is True. \n
               multiplier: (int): Increment Multiplier value if needed
        :return: True on success

        :Example: set_device_ip_address(router_id ='192.0.0.1', address_family='IPv4', ip_config='120.1.1.1', gateway_config='120.1.1.2', name="ipv4", step='0.0.1.0')
        """
        self.log.info("Setting Device IP Address")
        pattern = kwargs.get('pattern','counter')
        if address_family.lower() == 'ipv4':
            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')
            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)
            gw_step = kwargs.get('gw_step', None)
            count, seed = kwargs.get('count', None), kwargs.get('seed', None)
            ngpfEndpoint = 'ipv4'

        if address_family.lower() == 'ipv6':
            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')
            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)
            gw_step = kwargs.get('gw_step', None)
            count, seed = kwargs.get('count', None), kwargs.get('seed', None)
            ngpfEndpoint = 'ipv6'
        protocols = ['Ospfv3', 'BgpIpv4Peer', 'LdpConnectedInterface', 'Ospfv2', 'BgpIpv6Peer','Ldpv6ConnectedInterface']
        if ngpfEndpoint == 'ipv4':
            for protocol in protocols:
                try:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().'+ protocol +'.find()'):
                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction,ngpfEndpoint, mask, count, seed)
                except:
                    pass
        if ngpfEndpoint == 'ipv6':
            for protocol in protocols:
                try:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().'+ protocol +'.find()'):
                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed)
                except:
                    pass

        return True


    def _modify_ethernet_address(self, value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernet_obj):
        """
        Modify Ethernet mac address

        :param router_id: (str): The router ID IP address.
        :param value: (str): Mac address for requested router ID.
        :param value_mode: (str): Mac address pattern.
        :param step: (str): Increment step value if needed
        :param repeat_count: (int): Number of times to be repeated
        :param seed: (int): Random see value for Source MAC address
        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier
        :param direction: (str): Counter direction increment|decrement.
        :param maximum: (str): Max value for repeatableRandomRange
        :param mask: (str): Mask for repeatableRandom
        :param ethernetObj: Ethernet Object on which address to be modified
        :return:True
        """
        if type(value) == list:
            ethernetObj.Mac.ValueList(values=value)
        elif value_mode == 'random':
            ethernetObj.Mac.Random()
        elif value_mode == 'repeatableRandomRange':
            ethernetObj.Mac.RandomRange(min_value=value, max_value=maximum, step_value=step, seed=seed)
        elif value_mode == 'repeatableRandom':
            ethernetObj.Mac.RandomMask(fixed_value=value, mask_value=mask, seed=seed, count=repeat_count)
        elif value_mode == 'custom':
            ethernetObj.Mac.Custom(start_value=value, step_value=step, increments=None)
        else:
            if direction.lower() == "increment":
                ethernetObj.Mac.Increment(start_value=value, step_value=step)
            else:
                ethernetObj.Mac.Decrement(start_value=value, step_value=step)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Device MAC Address set successfully")
        return True

    def set_device_mac_address(self, router_id, value_mode='counter', value='', step='00:00:00:00:00:01',repeat_count='0', seed=1, advanced_config=None, **kwargs):
        """
        Modifies mac address configuration for requested routerId if provided

        :param router_id: (str): The router ID IP address.
        :param value: (str): Mac address for requested router ID.
        :param value_mode: (str): Mac address pattern.
        :param step: (str): Increment step value if needed
        :param repeat_count: (int): Number of times to be repeated
        :param seed: (int): Random see value for Source MAC address
        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier
        :param kwargs:
               direction: (str): Counter direction increment|decrement. \n
               maximum: (str): Max value for repeatableRandomRange \n
               mask: (str): Mask for repeatableRandom
        :return: True on Success

        :Example: set_device_mac_address(router_id='194.0.0.1', value='00:16:01:00:00:20')
        """
        self.log.info("Setting Device MAC Address")
        direction, maximum = kwargs.get('direction','increment'), kwargs.get('maximum', None)
        mask = kwargs.get('mask', None)
        ethernetNameList = [ethernetObj.Name for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find()]
        protocols = ['Ospfv2','BgpIpv4Peer','LdpConnectedInterface','Ospfv3','BgpIpv6Peer','Ldpv6ConnectedInterface']
        for protocol in protocols:
            try:
                for ethernetName in ethernetNameList:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv4.find().'+ protocol +'.find()'):
                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):
                            if router_id in eval('ethernetObj.Ipv4.find().'+protocol+'.find().LocalRouterID'):
                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)
            except:
                pass
            try:
                for ethernetName in ethernetNameList:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv6.find().'+ protocol +'.find()'):
                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):
                            if router_id in eval('ethernetObj.Ipv6.find().'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)
            except:
                pass
        return True

    def _start_stop_protocols(self, protocols, port_list, host_ip_list, action, active, devices, nested_device, nested=False):
        """
        Function used internally by start_protocol/stop_protocol API'S

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp'])
                                Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.

        :param port_list: one or more portNames in list on which device can be started.
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']
                            port: The virtual port name.

        :param host_ip_list: one or more hostip in list of type ipv4 or ipv6.
                            Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']
                            host_ip: The source IP address to query for the object.
        :param action: 'start' or 'stop'
        :param active: 'True' or 'False'
        :param devices: Name of the devices in the config
        :param nested_device: Nested device name to set action
        :param nested: boolean value to start/stop nested devices
        """
        classicprotocol = False
        if isinstance(protocols, str):
            protocols = protocols.split(",")
        for each_protocol in protocols:
            if each_protocol in ('lacp', 'lldp', 'dcbx'):
                classicprotocol = True
        if action == 'start':
            self.start_arp()
        if type(protocols) is dict:
            protocols = set(protocols)
        protocolsList = {'isis': 'IsisL3', 'dhcpv4client': 'Dhcpv4client', 'dhcpv6client': 'Dhcpv6client',
                        'pppoxclient': 'Pppoxclient', 'pppoxserver': 'Pppoxserver', 'mpls': 'Mpls',
                        'dotonex': 'DotOneX', 'bfdv4interface': 'Bfdv4Interface', 'bgp': 'BgpIpv4Peer',
                        'dhcpv4server': 'Dhcpv4server', 'igmp': 'IgmpHost', 'rsvp': 'RsvpteLsps',
                        'rsvpteif': 'Rsvpteif', 'bgpevpn': 'BgpIPv4EvpnEvi', 'bgpv6evpn': 'BgpIPv6EvpnEvi',
                        'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',
                        'ldptargetedrouter': "LdpTargetedRouter", 'bgpevpnvpws': "BgpIPv4EvpnVpws",
                        'ldpconnectedinterface': 'LdpConnectedInterface', 'ospfv2': 'Ospfv2',
                        'bfdv6interface': 'Bfdv6Interface', 'bgpv6': 'BgpIpv6Peer', 'dhcpv6server': 'Dhcpv6server',
                        'ldpbasicrouterv6': 'LdpBasicRouterV6', 'ldpv6connectedinterface': 'Ldpv6ConnectedInterface',
                        'mld': 'MldHost', 'mldquerier': 'MldQuerier', 'pimv6interface': 'PimV6Interface',
                        'ospfv3': 'Ospfv3','ipv4':'Ipv4','ipv6':'Ipv6','rocev2':'Rocev2','roce6v2':'Roce6v2'}
        protocolsListV6 = ['mld', 'ospfv3', 'bfdv6interface', 'ldpbasicrouterv6', 'pimv6interface''dhcpv6client',
                        'bgpipv6peer', 'dhcpv6server', 'bgpv6','roce6v2']
        for protocol in protocols:
            if port_list:
                if isinstance(port_list, str):
                    port_list = port_list.split(",")
                port_name_dict = {}
                for vport in self.ixNetwork.Vport.find():
                    if vport.AssignedTo.replace(":", "/") in port_list or vport.Name in port_list:
                        port_name_dict.update({vport.Name: vport.href})
                for port_name in port_name_dict.keys():
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == port_name_dict[port_name]:
                            topologyObj = topology.href
                            for ethernet in topology.DeviceGroup.find().Ethernet.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocol_obj in eval('ethernet.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):
                                                eval('ethernet.' + protocolsList[protocol.lower()] + '.find().' + action + '(async_operation=True)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

                            for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocolObj in eval('ipv4.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):
                                                eval('ipv4.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

                            for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocolObj in eval('ipv6.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):
                                                eval('ipv6.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

                            for ipv4_loopback in topology.DeviceGroup.find().Ipv4Loopback.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocol_obj in eval(
                                                'ipv4_loopback.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):
                                                eval('ipv4_loopback.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')
                                    except AttributeError:
                                        self.log.error(f'IPv4 Loopback Not Found - {ipv4_loopback.Name}')
                                    except:
                                        raise IxiaConfigException(f"Failed to start protocol - {protocol}")
                            for ipv6_loopback in topology.DeviceGroup.find().Ipv6Loopback.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocol_obj in eval(
                                                'ipv6_loopback.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):
                                                eval('ipv6_loopback.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')
                                    except AttributeError:
                                        self.log.error(f'IPv6 Loopback Not Found - {ipv6_loopback.Name}')
                                    except:
                                        raise IxiaConfigException(f"Failed to start protocol - {protocol}")

            if host_ip_list:
                protocol = protocol.lower()
                ipv4_host_ips = [hostIp for hostIp in host_ip_list if ":" not in hostIp]
                ipv6_host_ips = [hostIp for hostIp in host_ip_list if ":" in hostIp]
                if protocol in protocolsList and protocol not in protocolsListV6:
                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                        ipindices = []
                        for ipaddress in ipv4_host_ips:
                            if ipaddress in ipv4Obj.Address.Values:
                                ipindices.append((ipv4Obj.Address.Values).index(ipaddress) + 1)
                        try:
                            eval('ipv4Obj.' + protocolsList[protocol] + '.find().' + action + '(ipindices)')
                        except:
                            pass
                else:
                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                        ipv6indices = []
                        for ipv6address in ipv6_host_ips:
                            if ipv6address in ipv6Obj.Address.Values:
                                ipv6indices.append((ipv6Obj.Address.Values).index(ipv6address) + 1)
                        try:
                            eval('ipv6Obj.' + protocolsList[protocol] + '.find().' + action + '(ipv6indices)')
                        except:
                            pass

            if devices and nested_device is None:
                deviceNameList = [deviceGroupObj.Name for deviceGroupObj in
                                self.ixNetwork.Topology.find().DeviceGroup.find()]
                for each_device in devices:
                    if each_device in deviceNameList:
                        each_device = '^' + each_device.replace('+', r'\+').replace('*', r'\*') + '$'
                        protocol = protocol.lower()
                        if protocol in protocolsList:
                            device_object = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)
                            self._start_stop_protocol_action(device_obj=device_object,
                                                            protocol_name=protocolsList[protocol],
                                                            protocol_action=action, activate=active)
                    else:
                        self.log.warning(f"Device - {each_device}, not found in the Ixia config")

            if devices and nested_device:
                device_name_list = [deviceGroupObj.Name for deviceGroupObj in
                                    self.ixNetwork.Topology.find().DeviceGroup.find()]
                for each_device in devices:
                    if each_device in device_name_list:
                        device = '^' + each_device.replace('+', r'\+').replace('*', r'\*') + '$'
                        dev_object = self.ixNetwork.Topology.find().DeviceGroup.find(Name = device)
                        if protocol.lower() in protocolsList:
                            if dev_object.NetworkGroup.find().DeviceGroup.find():
                                if dev_object.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):
                                    device_object = dev_object.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                                elif dev_object.NetworkGroup.find().DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):
                                    device_object = dev_object.NetworkGroup.find().DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                            elif dev_object.DeviceGroup.find():
                                if dev_object.DeviceGroup.find(Name='^' + nested_device + '$'):
                                    device_object = dev_object.DeviceGroup.find(Name='^' + nested_device + '$')
                                elif dev_object.DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):
                                    device_object = dev_object.DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                            else:
                                self.log.error(f'Device Group {nested_device} Not found')
                            self._start_stop_protocol_action(device_obj=device_object,
                                                            protocol_name=protocolsList[protocol],
                                                            protocol_action=action, activate=active)
                    else:
                        self.log.warning(f"Device - {each_device}, not found in the Ixia config")

            if port_list is None and host_ip_list is None and devices is None and classicprotocol is False:
                if protocol.lower() in protocolsList:
                    device_object = self.ixNetwork.Topology.find().DeviceGroup.find()
                    self._start_stop_protocol_action(device_obj=device_object, protocol_name=protocolsList[protocol],
                                                    protocol_action=action, activate=active)

                    if nested == True:
                        try:
                            device_object = device_object.NetworkGroup.find().DeviceGroup.find()
                            self._start_stop_protocol_action(device_obj=device_object,
                                                            protocol_name=protocolsList[protocol],
                                                            protocol_action=action, activate=active)
                        except:
                            device_object = device_object.DeviceGroup.find()
                            self._start_stop_protocol_action(device_obj=device_object,
                                                            protocol_name=protocolsList[protocol],
                                                            protocol_action=action, activate=active)

            if classicprotocol:
                if protocol.lower() == 'lacp':
                    try:
                        eval('self.ixNetwork.Vport.find().Protocols.find().Lacp.' + action + '()')
                    except:
                        pass
                if protocol.lower() == 'lldp' or protocol.lower() == 'dcbx':
                    try:
                        eval(
                            'self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().DcbxEndpoint.find().' + action + '()')
                    except:
                        pass
        return True

    def get_arp_status_on_streams(self):
        """
        Get ARP status for All streams
        Ex: get_arp_status_on_streams()
        :return: arp status for each streams. Ex: {'Traffic Item 1': True, 'Traffic Item 2': False}
        """
        arp_status = {}
        trafficitems = self.ixNetwork.Traffic.TrafficItem.find()
        for trafficitem in trafficitems:
            self.log.info(f"Checking ARP status on stream {trafficitem.Name}")
            if trafficitem.FlowGroupCount == 0:
                arp_status[trafficitem.Name] = False
            else:
                highlevelstream = trafficitem.HighLevelStream.find()
                output = highlevelstream.PreviewFlowPackets(0, 1)
                l3Info = dict(zip(output['arg3'], output['arg4'][0]))
                destination_mac_address = l3Info.get('Destination MAC Address')
                if destination_mac_address == 'removePacket[Unresolved]':
                    arp_status[trafficitem.Name] = False
                else:
                    arp_status[trafficitem.Name] = True
        return arp_status

    def arp_on_object_list(self, object_type=None, object_list=None, action='start'):
        """
        Start/Stop ARP on specific (ports/devices/streams)

        :param object_type: "devices" or "streams" or "ports"
        :param object_list: List of Device names or Stream names or Port names
        :param action: "start" or "stop"
        :return: True on success
        :Examples:
        tgn.arp_on_object_list(object_type="devices", object_list=["Device-1", "Device-2"], action='start')
        tgn.arp_on_object_list(object_type="ports", object_list=["port_1", "port_2"], action='start')
        """
        if object_type == None or object_list == None:
            raise IxiaConfigException(
                'object_type must be ports/devices/streams and object_list cannot be empty')

        elif object_type.lower() == 'devices':
            device_list = self.get_device_names()
            for each_object in object_list:
                if each_object in device_list:
                    each_object = re.escape(each_object)
                    device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f'^{each_object}$')
                    for each_ipv4 in device_obj.Ethernet.find().Ipv4.find():
                        obj_count = each_ipv4.Count
                        obj_count_list = list(range(1, obj_count + 1))
                        if action == 'start':
                            each_ipv4.SendArp(SessionIndices=obj_count_list)
                else:
                    raise IxiaConfigException(f"{each_object} not found in configuration")

        elif object_type.lower() == 'ports':
            vport_list = [vport.Name for vport in self.get_list_ports() if vport]

            for port in object_list:
                if port in vport_list or self.get_port_name_from_location(port) in vport_list:
                    if action == 'start':
                        if not re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', port):
                            port = re.escape(port)
                        self.start_arp(ports=port)
                else:
                    raise IxiaConfigException(f"{port} not found in configuration")
        else:
            raise IxiaConfigException("object_type must be ports/devices/streams")
        return True

    def _start_stop_protocol_action(self, device_obj, protocol_name, protocol_action, activate):
        """
        This is internal function to start/stop the protocols
        :param device_obj:Device Object where protocols will be started/stopped
        :param protocol_name:Protocol to be started/stopped
        :param protocol_action:Start/Stop
        :param activate: True or False
        :return: True on success
        """
        loopback_protocol_dict = {'BgpIPv4EvpnEvi': 'BgpIpv4Peer', 'BgpIPv6EvpnEvi': 'BgpIpv6Peer',
                                    'BgpIPv4EvpnVpws': 'BgpIpv4Peer'}
        try:
            eval('device_obj' + '.Ethernet.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass
        try:
            eval('device_obj' + '.Ethernet.find().'+'DotOneX.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass
        try:
            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().Active.Single' + '(' + activate + ')')
            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass

        try:
            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().Active.Single' + '(' + activate + ')')
            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass

        try:
            if protocol_name in loopback_protocol_dict.keys():
                eval('device_obj' + '.Ipv4Loopback.find().' +
                    loopback_protocol_dict[protocol_name] + '.find().' +
                    protocol_name + '.find().' + protocol_action + '(async_operation=True)')
            else:
                eval('device_obj' + '.Ipv4Loopback.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass

        try:
            if protocol_name in loopback_protocol_dict.keys():
                eval('device_obj' + '.Ipv6Loopback.find().' + loopback_protocol_dict[protocol_name] + '.find().' +
                    protocol_name + '.find().' + protocol_action + '(async_operation=True)')
            else:
                eval('device_obj' + '.Ipv6Loopback.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')
        except:
            pass
        return True

    def start_protocols(self, protocols, port=None, host_ip=None, protocol_only=False, devices=None, **kwargs):
        """
        To start devices configured with a protocol or a list of protocols

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']). \n
                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.
        :param port: one or more portNames in list on which device can be started. \n
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10'].
                            port: The virtual port name.
        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \n
                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2'].
                               host_ip: The source IP address to query for the object.
        :param protocol_only: NA for Ixia. Added to follow Tgn Vendor Agnostic.
        :param devices: Name of the devices in the config
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA nested Device name if nested DG to be started
        :return: True on success

        :Example: start_protocols(['ospfv2', 'ospfv3'])
                  start_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])
                  start_protocols(protocols=["rsvp"],devices=["D8_5"],nested_device="D8_5_RSVP")
        """
        self.log.info(f"Starting protocols: {protocols}")
        port_list = port
        host_ip_list = host_ip
        nested_device = kwargs.get('nested_device', None)
        nested = kwargs.get('nested', False)
        return self._start_stop_protocols(protocols, port_list, host_ip_list, "Start", "True", devices, nested_device, nested)

    def stop_protocols(self, protocols, port=None, host_ip=None, devices=None, **kwargs):
        """
        To stop devices configured with a protocol or a list of protocols

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']) \n
                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.
        :param port: one or more portNames in list on which device can be started. \n
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']
                            port: The virtual port name.
        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \n
                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']
                               host_ip: The source IP address to query for the object.
        :param devices: Name of the devices in the config
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: nested_device: For IXIA nested Device name if nested DG to be stopped

        :Example: stop_protocols(protocols=['ospfv2', 'ospfv3'], devices=['DG1'])
                  stop_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])
                  stop_protocols(protocols=["rsvp"],devices=["D8_5"],nested_device="D8_5_RSVP")

        :return: True on Success,else raises exception
        """
        self.log.info(f"Stopping protocols: {protocols}")
        port_list = port
        host_ip_list = host_ip
        nested_device = kwargs.get('nested_device', None)
        nested = kwargs.get('nested', False)
        return self._start_stop_protocols(protocols, port_list, host_ip_list, "Stop", "True", devices, nested_device, nested)

    def connect_to_session(self, sid=None, **kwargs):
        """
        Connect to an existing session on the TGN.

        :param sid: The session ID on the Linux API server or Windows Connection Mgr to connect to.
        :param kwargs: optional
        :return: True if successful else raises exception

        :Example: connect_to_session(sId=1)
        """
        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)
        if not sid:
            self.log.info(f"Connecting to Session - '{self.session_name}'")
        else:
            self.log.info(f"Connecting to Session - '{sid}'")
        kill_existing = kwargs.get('kill_existing', False)
        self._new_session(session_name=sid, kill_existing=kill_existing)
        return True

    def delete_session(self):
        """
        Deletes the TGN session

        :return: True on success, exception on failure

        :Example: delete_session()
        """
        if self.tgn_server_type == "linux":
            try:
                sId = self.session.Id
                self.session.remove()
                self.log.info("Deleted Session %s" %sId)
                return True
            except:
                self.log.error("Failed to delete the Session")

    def tgn_disconnect(self, port_list=None):
        """
        Release the ports and delete the session.

        :param port_list: (list): format = [[(str(chassisIp), str(slotNumber), str(portNumber)]] \n
                Example: [ ['192.168.70.10', '1', '1'] ] \n
                Example: [ ['192.168.70.10', '1', '1'], ['192.168.70.10', '2', '1'] ]
        :return: True on success, exception on failure

        :Example: tgn_disconnect(port_list=['Ethernet - 001','Ethernet - 002'])
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info("Disconnecting TGN Session")
        if port_list:
            self.release_ports(port_list)
            results = True
        else:
            self.release_ports()
            results = True

        # If OS is linux, delete the session
        if self.tgn_server_type == 'linux':
            self.session.remove()
            results = True
        return results

    def _ldp_start_stop(self, port, hostip, action):
        """
        Function used internally by APIS ldp_start and ldp_stop

        :param port: one or more port names in a list. If 'None', all the ports.
                Ex: port = ['1/1/2']
                     port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address
                    Ex : hostip = ['1.1.1.1']
                        hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :param action: 'start' or 'stop'
        """
        self.log.info('LDP action %s' % (action))
        if (port and hostip):
            if type(port) is str:
                port = port.split(",")
            for portName in port:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href

                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_temp = []
                            ipv6_temp = []
                            ipv4Address = []
                            ipv6Address = []
                            [ipv4_temp.append(ipv4.Address.Values) for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find()]

                            for ip in ipv4_temp:
                                for eachIp in ip:
                                    ipv4Address.append(eachIp)

                            if len(hostip) == len(ipv4Address):
                                if action == "Start":
                                    for ldp in ipv4.LdpConnectedInterface.find():
                                        if re.match(topologyObj + '/deviceGroup', ldp.href):
                                            Name = ldp.DescriptiveName.replace('+', r'\+').replace('*',r'\*').replace('(', r'\(').replace(')', r'\)')
                                            eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                                else:
                                    for ldp in ipv4.LdpBasicRouter.find():
                                        if re.match(topologyObj + '/deviceGroup', ldp.href):
                                            Name= ldp.DescriptiveName.replace('+', r'\+').replace('*', r'\*').replace('(', r'\(').replace(')', r'\)')
                                            eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            [ipv6_temp.append(ipv6.Address.Values) for ipv6 in
                             topology.DeviceGroup.find().Ethernet.find().Ipv6.find()]

                            for ip in ipv6_temp:
                                for eachIp in ip:
                                    ipv6Address.append(eachIp)
                            if len(hostip) == len(ipv6Address):
                                for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                    if action == "Start":
                                        for ldp in ipv6.Ldpv6ConnectedInterface.find():
                                            if re.match(topologyObj + '/deviceGroup', ldp.href):
                                                Name = ldp.DescriptiveName.replace('+', r'\+').replace('*',r'\*').replace('(', r'\(').replace(')', r'\)')
                                                eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                                    else:
                                        for ldp in ipv6.LdpBasicRouterV6.find():
                                            if re.match(topologyObj + '/deviceGroup', ldp.href):
                                                Name = ldp.DescriptiveName.replace('+', r'\+').replace('*',r'\*').replace('(', r'\(').replace(')', r'\)')
                                                eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')

        if (port and hostip is None):
            if type(port) is str:
                port = port.split(",")
            for portName in port:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            if action == "Start":
                                for ldp in ipv4.LdpConnectedInterface.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', r'\+').replace('*',r'\*').replace('(', r'\(').replace(')', r'\)')
                                        eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                            else:
                                for ldp in ipv4.LdpBasicRouter.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name= ldp.DescriptiveName.replace('+', r'\+').replace('*', r'\*').replace('(', r'\(').replace(')', r'\)')
                                        eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            if action == "Start":
                                for ldp in ipv6.Ldpv6ConnectedInterface.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', r'\+').replace('*', r'\*').replace('(',')', r'\)')
                                        eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                            else:
                                for ldp in ipv6.LdpBasicRouterV6.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', r'\+').replace('*', r'\*').replace('(',')',r'\)')
                                        eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')

        if hostip and port is None:
            for ipAddress in hostip:
                if ':' not in ipAddress:
                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                       if ipAddress in ipv4Obj.Address.Values:
                            ipIndex = (ipv4Obj.Address.Values).index(ipAddress)+1
                            if action == "Start":
                                eval('ipv4Obj.LdpConnectedInterface.find().'+action+'(ipIndex)')
                            else:
                                eval('ipv4Obj.LdpBasicRouter.find().'+action+'(ipIndex)')
                            break
                else:
                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                        if ipAddress in ipv6Obj.Address.Values:
                            ipIndex = (ipv6Obj.Address.Values).index(ipAddress) + 1
                            if action == "Start":
                                eval('ipv6Obj.Ldpv6ConnectedInterface.find().'+action+'(ipIndex)')
                            else:
                                eval('ipv6Obj.LdpBasicRouterV6.find().'+action+'(ipIndex)')
                            break
        if port is None and hostip is None:
            if action == "Start":
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpConnectedInterface.find().'+action+'(None)')
                except:pass
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ldpv6ConnectedInterface.find().'+action+'(None)')
                except:pass
            else:
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpBasicRouter.find().'+action+'(None)')
                except:pass
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().LdpBasicRouterV6.find().'+action+'(None)')
                except:pass

        return True

    def ldp_start(self, port=None, hostip=None):
        """
        Starts LDP emulation

        :param port: one or more port names in a list. If 'None', all the ports. \n
                    Ex : port = ['1/1/2']
                    Ex : port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \n
                    Ex : hostip = ['1.1.1.1']
                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :return: True. raise exception if False/error

        :Example: ldp_start(hostip=['100.1.0.1','100.1.0.2'])
        """

        return self._ldp_start_stop(port, hostip, "Start")

    def ldp_stop(self, port=None, hostip=None):
        """
        Stops LDP emulation

        :param port: one or more port names in a list. If 'None', all the ports. \n
                    Ex : port = ['1/1/2']
                    Ex : port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \n
                    Ex : hostip = ['1.1.1.1']
                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :return: True. raise exception if False/error

        :Example: ldp_stop(hostip=['100.1.0.1','100.1.0.2'])
        """

        return self._ldp_start_stop(port, hostip, "Stop")

    def clear_traffic_stats(self):
        """
        Clears the traffic statistics on the chassis

        :return: True if success, false if error

        :Example: clear_traffic_stats()
        """
        # if StubitUtil.is_stubit_playback():
        #     log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
        #     return

        self.log.info("Clearing Stats")
        try:
            self.ixNetwork.ClearPortsAndTrafficStats(Arg1=["waitForTrafficStatsRefresh"])
        except:
            pass
        self.log.info("Traffic Stats Cleared")
        return True

    def _change_mac_format(self,inputMac):
        """
        Internal function to change MAC address format

        :param inputMac: MAC Address in any format
                        EX:'008a.9695.748c'
        :return: MAC Address in actual format
                OutputMac: '00:8a:96:95:74:8c'
        """
        outputMac = netaddr.EUI(inputMac)
        outputMac.dialect = netaddr.mac_unix_expanded
        return str(outputMac)

    def change_traffic_mac(self,
                           traffic_item_name=None,
                           endpoint_name='EndpointSet-1',
                           mac_dst_mode=None,
                           mac_dst='00:00:00:00:00:01',
                           mac_dst_count=1,
                           mac_dst_step='00:00:00:00:00:01',
                           mac_dst_mask='FF:FF:FF:FF:FF:FF',
                           mac_dst_seed=1,
                           mac_src_mode=None,
                           mac_src='00:00:00:00:00:01',
                           mac_src_count=1,
                           mac_src_step='00:00:00:00:00:01',
                           mac_src_mask='FF:FF:FF:FF:FF:FF',
                           mac_src_seed=1,
                           eth_header_index=None):
        """
        API used to change MAC Address on Traffic Item/Stream

        :param traffic_item_name: The traffic item name
        :param endpoint_name: The endpoint name
        :param mac_dst_mode: The mac destination mode
        :param mac_dst: The mac destination address
        :param mac_dst_count: The mac destination count
        :param mac_dst_step: The mac destination step
        :param mac_dst_mask: The mac destination mask
        :param mac_dst_seed: The mac destination seed
        :param mac_src_mode: The mac source mode
        :param mac_src: The mac source address
        :param mac_src_count: The mac source count
        :param mac_src_step: The mac source step
        :param mac_src_mask: The mask source mask
        :param mac_src_seed: The mask source seed
        :param eth_header_index: Index of ethernet header
        :return: True on success else raises exception

        :Example: change_traffic_mac(traffic_item_name="Traffic Item 4")
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        self.log.info("Changing Mac Parameters for Traffic Item/Items")
        mac_mode_dict = {None: 'singleValue', 'fixed': 'singleValue', 'discovery': 'singleValue', 'increment': 'increment', 'list': 'valueList',
                         'decrement': 'decrement', 'random': 'nonRepeatableRandom', 'repeatable_random': 'repeatableRandomRange'}
        mac_updated = False
        mac_src_list = []
        mac_dst_list = []

        if isinstance(mac_dst, list):
            for mac_dst_value in mac_dst:
                mac_dst_list.append(self._change_mac_format(mac_dst_value))
            mac_dst = mac_dst_list[0]
        else:
            mac_dst = self._change_mac_format(mac_dst)
            mac_dst_list = [mac_dst]
        mac_dst_step = self._change_mac_format(mac_dst_step)
        mac_dst_mask = self._change_mac_format(mac_dst_mask)

        if isinstance(mac_src, list):
            for mac_src_value in mac_src:
                mac_src_list.append(self._change_mac_format(mac_src_value))
            mac_src = mac_src_list[0]
        else:
            mac_src = self._change_mac_format(mac_src)
            mac_src_list = [mac_src]
        mac_src_step = self._change_mac_format(mac_src_step)
        mac_src_mask = self._change_mac_format(mac_src_mask)

        if traffic_item_name:
            self.log.info(f"Changing MAC Parameters for Traffic Item/Items - {traffic_item_name}")
        else:
            self.log.info("Changing MAC Parameters for all available Traffic Item/Items")
        if isinstance(traffic_item_name, str):
            traffic_item_name_list = [traffic_item_name]
        elif isinstance(traffic_item_name, list):
            traffic_item_name_list = traffic_item_name
        else:
            traffic_item_name_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]

        all_traffic_items = self.ixNetwork.Traffic.TrafficItem.find()
        all_traffic_names = [ti.Name for ti in all_traffic_items]

        for traffic_name in traffic_item_name_list:
            if traffic_name not in all_traffic_names:
                self.log.warning(f"Traffic item '{traffic_name}' not found.")
                continue
            traffic_stream = re.escape(traffic_name)
            config_elems = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_stream}$').ConfigElement.find()
            eth_header_matched = False
            eth_header_count = 0

            for stack in config_elems.Stack.find():
                if stack.DisplayName != "Ethernet II":
                    continue
                eth_header_count += 1
                if eth_header_index is not None and eth_header_count != eth_header_index:
                    continue

                eth_header_matched = True

                for field in stack.Field.find():
                    # Destination MAC
                    if field.DisplayName == "Destination MAC Address":
                        if hasattr(field, 'Auto'):
                            field.Auto = False
                        field.ValueType = mac_mode_dict[mac_dst_mode]
                        if field.ValueType == 'singleValue':
                            field.FieldValue = mac_dst
                        elif field.ValueType in ['increment', 'decrement']:
                            field.StartValue = mac_dst
                            field.StepValue = mac_dst_step
                            field.CountValue = mac_dst_count
                        elif field.ValueType == 'valueList':
                            field.ValueList = mac_dst_list
                        elif field.ValueType == 'repeatableRandomRange':
                            field.StartValue = mac_dst
                            field.StepValue = mac_dst_step
                            field.CountValue = mac_dst_count
                            field.RandomMask = mac_dst_mask
                            field.Seed = mac_dst_seed
                        elif field.ValueType == 'nonRepeatableRandom':
                            field.CountValue = mac_dst_count
                            field.RandomMask = mac_dst_mask

                        field.update()

                    # Source MAC
                    elif field.DisplayName == "Source MAC Address":
                        if hasattr(field, 'Auto'):
                            field.Auto = False

                        field.ValueType = mac_mode_dict[mac_src_mode]
                        if field.ValueType == 'singleValue':
                            field.FieldValue = mac_src
                        elif field.ValueType in ['increment', 'decrement']:
                            field.StartValue = mac_src
                            field.StepValue = mac_src_step
                            field.CountValue = mac_src_count
                        elif field.ValueType == 'valueList':
                            field.ValueList = mac_src_list
                        elif field.ValueType == 'repeatableRandomRange':
                            field.StartValue = mac_src
                            field.StepValue = mac_src_step
                            field.CountValue = mac_src_count
                            field.RandomMask = mac_src_mask
                            field.Seed = mac_src_seed
                        elif field.ValueType == 'nonRepeatableRandom':
                            field.CountValue = mac_src_count
                            field.RandomMask = mac_src_mask
                        field.update()
                mac_updated = True
            if eth_header_index is not None and not eth_header_matched:
                self.log.warning(f"Traffic item '{traffic_name}': Ethernet II header index {eth_header_index} "
                                 f"is out of range (only {eth_header_count} Ethernet II headers found).")
                continue
        if mac_updated:
            self.log.info("MAC address update completed successfully.")
            return True
        else:
            self.log.warning("No MAC addresses were updated. traffic items were invalid or skipped.")
            return False

    def change_traffic_transmission_mode(self, config, traffic_item_list='all', port='all', **kwargs):
        """
        Changes the transmission control mode for a given set of traffic items.

        :param config: Dict including the transmission control data to be modified. \n
            valid Options:\n
            type: auto,continuous,custom,fixedDuration, fixedFrameCount,fixedIterationCount \n
            duration: The duration of time (in seconds) for traffic to run for applicable transmission control types \n
            extra options (case-sensitive): iterationCount,frameCount,startDelay,startDelayUnits,minGapBytes, burstPacketCount,repeatBurst,interBurstGap,interStreamGap,interBurstGapUnits \n
        :param traffic_item_list: List of traffic Items name.
        :param port: NA for IXIA
        :param kwargs:
                    - split_port_rate : (False by default) To be used for even distribution of load across Traffic Items
        :return: True on success, else reverts the config

        :Example: change_traffic_transmission_mode(config={'type': 'custom', 'interBurstGap': 25, 'burstPacketCount': 25}, traffic_item_list=["Traffic Item 3"])
        """

        self.log.info("Changing Traffic Transmission Mode")
        split_port_rate = kwargs.get('split_port_rate', False)
        rate_map_dict = {'fps': 'framesPerSecond', 'bps': 'bitsPerSecond',
                         'kps': 'kilobitsPerSecond', 'mps': 'megabitsPerSecond', 'percent': 'percentLineRate'}
        if traffic_item_list and traffic_item_list != 'all':
            if 'mode' in config.keys():
                if config['mode'] in ['stream_rate', 'port_rate']:
                    traffic_rate_dict = {}
                    if 'load' in config.keys():
                        if split_port_rate == False:
                            traffic_rate_dict.update({'rate': config['load']})
                        else:
                            src_groups = defaultdict(list)
                            for item in self.ixNetwork.Traffic.TrafficItem.find():
                                src_desc = item.EndpointSet.find().SourcesDescription
                                if src_desc:
                                    key = (src_desc,)
                                    src_groups[key].append(item)
                            total_load = config.get('load')
                            unit = config.get('load_unit')
                            for group, ti_list in src_groups.items():
                                per_ti_load = int(total_load / len(ti_list))
                                self.log.info(
                                    f"Source group {group} has {len(ti_list)} TIs. Per-TI load: {per_ti_load} {unit}")
                                for item in ti_list:
                                    try:
                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')
                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)
                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)
                                    except Exception as err:
                                        self.log.error(f"Failed to set load on TI '{item.Name}': {err}")
                    if 'load_unit' in config.keys():
                        if config['load_unit'] in rate_map_dict.keys():
                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})
                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():
                        self.change_traffic_rate(cfg_dict=traffic_rate_dict, traffic_item_list=traffic_item_list)
                    if 'duration_mode' in config.keys():
                        if config['duration_mode'] == 'seconds':
                            config['type'] = 'fixedDuration'
                            config['startDelayUnits'] = config['duration_mode']
                        elif config['duration_mode'] == 'continuous':
                            config['type'] = 'continuous'
            for traffic_item in traffic_item_list:
                traffic_item = re.escape(traffic_item)
                for transmission_control in self.ixNetwork.Traffic.TrafficItem.find(
                        Name=f'^{traffic_item}$').ConfigElement.find().TransmissionControl:
                    for key in config:
                        if 'interBurstGap' in key:
                            setattr(transmission_control, 'EnableInterBurstGap', True)
                        try:
                            setattr(transmission_control, key[0].upper() + key[1:], config[key])
                        except:
                            pass
        else:
            if 'mode' in config.keys():
                if config['mode'] in ['stream_rate', 'port_rate']:
                    traffic_rate_dict = {}
                    if 'load' in config.keys():
                        if split_port_rate == False:
                            traffic_rate_dict.update({'rate': config['load']})
                        else:
                            src_groups = defaultdict(list)
                            for item in self.ixNetwork.Traffic.TrafficItem.find():
                                src_desc = item.EndpointSet.find().SourcesDescription
                                if src_desc:
                                    key = (src_desc,)
                                    src_groups[key].append(item)
                            total_load = config.get('load')
                            unit = config.get('load_unit')
                            for group, ti_list in src_groups.items():

                                per_ti_load = int(total_load / len(ti_list))
                                self.log.info(f"Port {group} has {len(ti_list)} TIs. Per-TI load: {per_ti_load} {unit}")
                                for item in ti_list:
                                    try:
                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')

                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)
                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)
                                    except Exception as err:
                                        self.log.error(f"Failed to set load on TI '{item.Name}': {err}")
                    if 'load_unit' in config.keys():
                        if config['load_unit'] in rate_map_dict.keys():
                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})
                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():
                        self.change_traffic_rate(cfg_dict=traffic_rate_dict)
                    if 'duration_mode' in config.keys():
                        if config['duration_mode'] == 'seconds':
                            config['type'] = 'fixedDuration'
                            config['startDelayUnits'] = config['duration_mode']
                        elif config['duration_mode'] == 'continuous':
                            config['type'] = 'continuous'
            for transmission_control in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().TransmissionControl:
                for key in config:
                    if 'interBurstGap' in key:
                        setattr(transmission_control, 'EnableInterBurstGap', True)
                    try:
                        setattr(transmission_control, key[0].upper() + key[1:], config[key])
                    except:
                        pass
        self.log.info("Traffic Transmission mode updated in Traffic Items")
        return True

    def _igmp_mld_multicast(self, vportList, ipVersion, HostObj,srcObj, groupObj, proto, action, state,
                             igmp_mld_mcastList, hostIpList=None, versionType=None, groupDict=None, protocolType='mld'):
        """
        Function used internally by APIs igmp_join_leave,mld_join_leave

        :param vportList: List of Vports
        :param ipVersion: IP version , Ex:IPv4/IPv6
        :param HostObj: Host Object
        :param srcObj: Source Object
        :param groupObj: Group Object
        :param proto: Protocol
        :param action: Action
        :param state: State
        :param igmp_mld_mcastList: IGMP MLD Multicast
        :param hostIpList: Host IP List
        :param versionType: IGMP Version type.
        :param groupDict: IGMP Group value
        :param protocolType: Protocol Type
        """

        for vport in vportList:
            vport = vport.replace("(", r"\(").replace(")", r"\)")
            if self.ixNetwork.Vport.find(Name=vport + r'\s'):
                vports = self.ixNetwork.Vport.find(Name=vport + r'\s')
            else:
                vports = self.ixNetwork.Vport.find(Name=vport)
            for topology in self.ixNetwork.Topology.find():
                if vports.href in topology.Vports:
                    portIndex = topology.Vports.index(vports.href)
                    for deviceGroup in topology.DeviceGroup.find():
                        multiplier = deviceGroup.Multiplier
                        mcastList = {'igmp_mld_host_obj': '', 'action_list': '', 'new_active_state': '', 'port_ips': '', 'selected_index': '', 'selected_info': ''}
                        if eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()'):
                            groupList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()')
                            if groupList.Status == "notStarted":
                                eval('groupList.' + proto +'StartHost()')
                                time.sleep(10)
                                eval('groupList.' + groupObj + '.' + proto + 'Leave' + 'Group(None)')
                                time.sleep(10)
                            else:
                                pass

                            groupRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges
                            groupRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges

                            sourceRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')
                            sourceRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')

                            if hostIpList:
                                ipAddressList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().Address.Values')
                                for ip in hostIpList:
                                    if ip in ipAddressList:
                                        ipIndex = ipAddressList.index(ip)
                                        ipGroupRangeStartIndex = ipIndex * groupList.NoOfGrpRanges + 1
                                        ipGroupRangeEndIndex = (ipIndex + 1) * groupList.NoOfGrpRanges
                                        if ipGroupRangeStartIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1):
                                            groupRange = str(ipGroupRangeStartIndex)+"-"+str(ipGroupRangeEndIndex)
                                            eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find().' + groupObj
                                                 + '.' + proto + action + 'Group(SessionIndices=groupRange)')

                            elif groupDict:
                                for group in groupDict:
                                    mcastGroupsList = eval('groupList.' + groupObj + '.StartMcastAddr.Values')
                                    if ipVersion.lower() == "ipv4":
                                        sourcesList = eval('groupList.' + groupObj +'.IgmpUcastIPv4SourceList.StartUcastAddr.Values')
                                    else:
                                        sourcesList = eval('groupList.' + groupObj +'.MldUcastIPv6SourceList.StartUcastAddr.Values')

                                    mcastGroupsIndices = [index + 1 for index in range(len(mcastGroupsList)) if group ==
                                                          mcastGroupsList[index] and index in range(groupRangeStartIndex, groupRangeEndIndex)]

                                    #version and group combination
                                    versionTypeValues = groupList.VersionType.Values
                                    indices = [index + 1 for index, version in enumerate(versionTypeValues) if version == versionType]
                                    groupRanges = eval('groupList.NoOfGrpRanges')
                                    joinLeaveList = []
                                    for index in indices:
                                        endIndex = index * groupRanges
                                        startIndex = endIndex - groupRanges
                                        GroupIndexList = [index for index in range(endIndex, startIndex, -1)]
                                        GroupIndexList = GroupIndexList[::-1]
                                        joinLeaveList.append(GroupIndexList)
                                    joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index
                                                     if joinIndex in range(groupRangeStartIndex + 1, groupRangeEndIndex + 1)]

                                    mcastGroupSourceIndices = list(set(joinLeaveList).intersection(mcastGroupsIndices))

                                    if mcastGroupSourceIndices != []:
                                        if '*' in groupDict[group]:
                                            eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')
                                        else:
                                            sourcesListindices = []
                                            for source in groupDict[group]:
                                                sourcesListindices.append([index + 1 for index in range(len(sourcesList)) if source ==
                                                                           sourcesList[index] and index in range(sourceRangeStartIndex, sourceRangeEndIndex)])

                                            sourcesListindices = [ele for subele in sourcesListindices for ele in subele]

                                            sources = eval('groupList.' + groupObj + '.NoOfSrcRanges')
                                            mcastGroupIndex = mcastGroupsIndices[0]
                                            srcRangeStartIndex = (mcastGroupIndex - 1) * sources + 1
                                            srcRangeEndIndex = (mcastGroupIndex) * sources + 1
                                            sourcesListindices = [sourceIndex for sourceIndex in sourcesListindices
                                                                  if sourceIndex in range(srcRangeStartIndex, srcRangeEndIndex)]

                                            if action == "Join":
                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')
                                                sourceRange = str(srcRangeStartIndex) + "-" + str(srcRangeEndIndex-1)
                                                eval('groupList.' + groupObj + '.' + srcObj + '.' + proto + 'LeaveSource(SessionIndices=sourceRange)')

                                            eval('groupList.' + groupObj + '.' + srcObj + '.'+ proto + action + 'Source(SessionIndices=sourcesListindices)')

                                            time.sleep(2)
                                            if ipVersion.lower() == "ipv4":
                                                stateList = eval('groupList.' + groupObj + '.IgmpUcastIPv4SourceList.State')
                                            else:
                                                stateList = eval('groupList.' + groupObj + '.MldUcastIPv6SourceList.State')

                                            stateList = stateList[(mcastGroupIndex - 1)*sources:(mcastGroupIndex)*sources]
                                            if len(set(stateList)) == 1:
                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')

                            elif versionType:
                                versionTypeValues = groupList.VersionType.Values
                                indices = [index+1 for index, version in enumerate(versionTypeValues) if version == versionType]
                                groupRanges = eval('groupList.NoOfGrpRanges')
                                joinLeaveList = []
                                for index in indices:
                                    endIndex = index * groupRanges
                                    startIndex = endIndex - groupRanges
                                    GroupIndexList = [index for index in range(endIndex, startIndex, -1)]
                                    GroupIndexList = GroupIndexList[::-1]
                                    joinLeaveList.append(GroupIndexList)
                                joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index
                                                 if joinIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1)]
                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(joinLeaveList)')
                            else:
                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(None)')

                        igmp_mld_mcastList.append(mcastList)

    def _igmp_mld_join_leave(self, protocol, port, action, version, hostIp, groups):
        """
        Function used internally by APIs igmp_join_leave,mld_join_leave

        :param protocol: Protocol Type
        :param port: IXIA Port
        :param action: Action , Ex: Join/Leave
        :param version: IGMP version
        :param hostIp: Host IP
        :param groups: IGMP Groups
        """

        if protocol.lower() == 'mld':
            HostObj = "MldHost"
            ipVersion = "Ipv6"
            groupObj = "MldMcastIPv6GroupList"
            proto = "Mld"
            srcObj = "MldUcastIPv6SourceList"
        else :
            HostObj = "IgmpHost"
            ipVersion ="Ipv4"
            groupObj = "IgmpMcastIPv4GroupList"
            proto = "Igmp"
            srcObj = "IgmpUcastIPv4SourceList"
        if action.lower() == "leave":
            action = "Leave"
            state = "notJoined"
        else:
            action = "Join"
            state = "joined"
        igmp_mld_mcastList = []

        if version == 'v1':
            version = "version1"
        elif version == 'v2':
            version = "version2"
        elif version == 'v3':
            version = "version3"
        else:
            if protocol.lower() == 'mld':
                version = "version1"
            else:
                version = "version2"

        if port == None and hostIp == None and groups == None and version == None:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList)

        elif port:
            if type(port) is str:
                port = port.split(",")
            vportNameList = [vport.Name.split("//")[0].rstrip() for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in port if portName in vportNameList]
            if groups:
                groupsOnly = list(set([group[1] for group in groups]))
                groupDict = {}
                for groupOnly in groupsOnly:
                    groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]
                self._igmp_mld_multicast(portNameList, ipVersion, HostObj,srcObj, groupObj, proto,
                                         action, state, igmp_mld_mcastList,hostIpList=hostIp,
                                         versionType=version,groupDict=groupDict, protocolType=protocol)
            else:
                self._igmp_mld_multicast(portNameList, ipVersion, HostObj, srcObj, groupObj, proto,
                                         action, state, igmp_mld_mcastList, hostIpList=hostIp,
                                         versionType=version)

        elif hostIp:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList, hostIpList=hostIp)

        elif groups:
            groupsOnly = list(set([group[1] for group in groups]))
            groupDict = {}
            for groupOnly in groupsOnly:
                groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,
                                     action, state, igmp_mld_mcastList, groupDict=groupDict, protocolType=protocol, versionType=version)

        elif version:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList, versionType=version)

        return igmp_mld_mcastList

    def igmp_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):
        """
        Igmp join or leave for multicast groups

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param action: "join" or "leave". Default value is "join"
        :param version: CHOICES 'v1', 'v2', 'v3'
        :param hostIp: list of host ip. E.g. ['1.1.1.1', '1.2.1.1']
        :param groups: list of ipv4 multicast groups.

        :Example: igmp_join_leave(port=["Ethernet - 001", "Ethernet - 002"], hostIp=["105.1.1.2","105.1.2.2"],action='join')
        """
        self.log.info('igmp %s' % action)
        return self._igmp_mld_join_leave('igmp', port, action, version, hostIp, groups)


    def _igmp_mld_control(self, port, hostip, protocol, action):
        """
        Function used internally by APIS igmp_stop,igmp_start,mld_start,mld_stop

        :param port: Port
        :param hostip: Host IP
        :param protocol: Protocol
        :param action: Action , Ex : start/stop
        """
        if protocol.lower() == 'mld':
            HostObj = "MldHost"
            ipVersion = "Ipv6"
        else :
            HostObj = "IgmpHost"
            ipVersion ="Ipv4"
        if port == None and hostip == None:
            for host in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find().'+HostObj+'.find()'):
                eval('host.' + action + '(None)')
        if port:
            for eachPort in port:
                assignedPort = eachPort.replace('/', ':')
                vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                if assignedPort in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
                    for vport in vportList:
                        assignedVport = self.ixNetwork.Vport.find(Name=vport)
                        if assignedVport.AssignedTo == assignedPort:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == assignedVport.href:
                                    topologyObj = topology.href
                                    for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()'):
                                        for hostObj in eval('ipObj.'+HostObj+'.find()'):
                                            if re.match(topologyObj + '/deviceGroup', hostObj.href):
                                                eval('ipObj.'+HostObj+'.find(DescriptiveName=hostObj.DescriptiveName).'+action +'(None)')
                else:
                    raise IxiaConfigException("Port %s is invalid or not configured"%assignedPort)

        if hostip:
            for ip in hostip:
                ipNameList = [address.Name for address in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()') if address]
                for ipName in ipNameList:
                    address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ ipVersion +'.find(Name=ipName).Address')
                    if ip in address.Values:
                        ipIndex = address.Values.index(ip) + 1
                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find(Name=ipName).'+HostObj+'.find().'+action+'(ipIndex)')
        return True

    def igmp_start(self,port=None,hostip=None):
        """
        To  start igmp emulation

        :param port: List of ports. If 'None', all the ports
        :param hostip: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: igmp_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Starting IGMP")
        return self._igmp_mld_control(port, hostip, 'igmp', 'Start')

    def igmp_stop(self,port=None,hostip=None):
        """
        To  stop igmp emulation

        :param port: List of ports. If 'None', all the ports
        :param hostip: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: igmp_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Stopping IGMP")
        return self._igmp_mld_control(port, hostip, 'igmp', 'Stop')

    def mld_start(self,port=None,hostIp=None):
        """
        To  start mld emulation

        :param port: List of ports. If 'None', all the ports
        :param hostIp: List of hostip. If 'None' all the mld hosts
        :return: raise exception if False/error

        :Example: mld_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Starting MLD")
        return self._igmp_mld_control(port, hostIp, 'mld', 'Start')

    def mld_stop(self,port=None,hostIp=None):
        """
        To  stop mld emulation

        :param port: List of ports. If 'None', all the ports
        :param hostIp: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: mld_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Stopping MLD")
        return self._igmp_mld_control(port, hostIp, 'mld', 'Stop')

    def mld_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):
        """
        Mld join or leave for multicast groups

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param action: "join" or "leave". Default value is "join"
        :param version: CHOICES 'v1', 'v2'
        :param hostIp: list of host ip. E.g. ['1001::1', '1002:2']
        :param groups: list of ipv6 multicast groups.

        :Example: mld_join_leave(action='join') \n
                  mld_join_leave(action='leave')
        """
        self.log.info('mld %s' % action)
        return self._igmp_mld_join_leave('mld', port, action, version, hostIp, groups)

    def _pim_stop_start_control(self, port, mode, af, neighbor_ip, groups, action):
        """
        Function used internally by APIs pim_start,pim_stop

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param mode: PIM Mode , Ex: sm/ssm
        :param af: ipv4,ipv6
        :param neighbor_ip: PIM neighbor ip
        :param groups: list of ipv6 multicast groups.
        :param action: "start" or "stop". Default value is "start"
        """
        self.log.info('PIM {}'.format(action))

        if action.lower() == "start":
            action = 'Start'
        elif action.lower() == "stop":
            action = "Stop"

        if af.lower() == "ipv4":
            af = "Ipv4"
            pimObj = "PimV4Interface"
            joinPruneObj = "PimV4JoinPruneList"
            groupAddress = "GroupV4Address"
        elif af.lower() == "ipv6":
            af = "Ipv6"
            pimObj = "PimV6Interface"
            joinPruneObj = "PimV6JoinPruneList"
            groupAddress = "GroupV6Address"
        try:
            if port == None and neighbor_ip == None and groups == None and mode == None:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().'+action+'(None)')

            if port:
                for portName in port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                            eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().' + action + '(None)')

            if neighbor_ip:
                for ip in neighbor_ip:
                    ipNameList = [address.Name for address in
                                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find()') if address]
                    for ipName in ipNameList:
                        address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).Address')
                        if ip in address.Values:
                            ipIndex = address.Values.index(ip) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).'+pimObj+'.find().'+action+'(ipIndex)')

            if mode:
                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+pimObj+'.find()'):
                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')
                    if mode.lower() == "sm":
                        mode ="startogroup"
                    elif mode.lower() == "ssm":
                        mode = "sourcetogroup"
                    indices = [index for index in range(0,len(rangeTypeList)) if rangeTypeList[index] == mode]
                    for index in indices:
                        indexVal = index + 1
                        eval('pimInterface.' + action + '(indexVal)')
            if groups:
                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+ pimObj + '.find()'):
                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')
                    mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')
                    for rangeType in rangeTypeList:
                        for group in groups:
                            if "*" in group:
                                if rangeType == "startogroup":
                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]
                                    for index in indices:
                                        indexVal = index + 1
                                        eval('pimInterface.'+action+'(indexVal)')
                            else:
                                if rangeType == "sourcetogroup":
                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]
                                    for index in indices:
                                        indexVal = index + 1
                                        eval('pimInterface.'+ action + '(indexVal)')
            self.log.info('PIM {} action Success'.format(action))
        except:
            msg = 'PIM {} failed: no entry is matched'.format(action)
            self.log.error(msg)
            raise CafyException.TgenConfigMissingError(msg)
        return True

    def pim_start(self, port=None, mode=None, af="ipv4", neighbor_ip=None, groups=None):
        """
        To start the PIM

        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports
        :param mode: List/String sm or ssm. If None, both modes
        :param af: String ipv4 or ipv6
        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.
            If None, all the neighbors
        :param groups: List of groups. Apply the action to these groups only. If None, all the groups
            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])
        :return: raise exception if there is an error

        :Example: pim_start(port="Ethernet - 001", mode="sm")
        """
        self.log.info("Starting PIM")
        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='start')

    def pim_stop(self, port=None, mode=None, af="ipv4", neighbor_ip=None, groups=None):
        """
        To stop the PIM

        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports
        :param mode: List/String sm or ssm. If None, both modes
        :param af: String ipv4 or ipv6
        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.
            If None, all the neighbors
        :param groups: List of groups. Apply the action to these groups only. If None, all the groups
            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])
        :return: raise exception if there is an error

        :Example: pim_stop(port="Ethernet - 001", mode="sm")
        """
        self.log.info("Stopping PIM")
        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='stop')

    def pim_join_prune(
            self,
            port=None,
            action='join',
            mode=None,
            af='ipv4',
            neighborIp=None,
            groups=None):
        """
        Send Join/Prune for the specified sparse mode groups.

        :param port: The name string/list of the port (e.g 'MyPort1')
            port handle (e.g <slotID>/<portID>
            interface name from topologyfile
            (e.g <chassisIP>/<slotID>/<portID>)
        :param action:  Join or Prune
        :param mode: PIM Mode , Ex : 'sm','ssm'
        :param af: ipv4 or ipv6
        :param neighborIp: Apply the action to device with this neighbor address only.
        :param groups: Apply the action to these groups only. (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])

        :Example:
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1")
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1",groups=[["*","232.0.0.1"]])
            pim_join_prune("pim_port_1","prune","ssm","ipv4","10.1.1.1",groups=[["*","232.0.0.1"]])
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1",groups=[["200.200.200.200","232.0.0.1"]])
            pim_join_prune("pim_port_1","prune","sm","ipv6")
            pim_join_prune("pim_port_1","join","sm","ipv6","10::1",groups=[["*","ff1e::1"]])
            pim_join_prune("pim_port_1","join","sm","ipv6","10::2",groups=[["*","ff1e::1"]])
        """
        self.log.info('PIM action: %s' % (action))
        if action.lower() == "leave" or action.lower() == 'prune':
            action = 'Leave'
        elif action.lower() == "join":
            action = "Join"

        if af.lower() == "ipv4":
            af = "Ipv4"
            HostObj = "PimV4Interface"
            joinPruneObj="PimV4JoinPruneList"
            groupAddress = "GroupV4Address"
            sourceAddress = "SourceV4Address"
        elif af.lower() == "ipv6":
            af = "Ipv6"
            HostObj = "PimV6Interface"
            joinPruneObj = "PimV6JoinPruneList"
            groupAddress = "GroupV6Address"
            sourceAddress = "SourceV6Address"

        if port:
            if isinstance(port, str):
                ports = [port]
            else:
                ports = port
        else:
            ports = [vport.Name for vport in self.ixNetwork.Vport.find()]

        for port in ports:
            port = port.replace("(", r"\(").replace(")", r"\)")
            vports = self.ixNetwork.Vport.find(Name=port)
            for topology in self.ixNetwork.Topology.find():
                if topology.Vports[0] == vports.href:
                    if groups:
                        for pimInterface in eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):
                            mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')
                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')
                            for group in groups:
                                if mode == 'ssm':
                                    sourceList = eval('pimInterface.' + joinPruneObj + '.' + sourceAddress + '.Values')
                                    indices = [index + 1 for index in range(0, len(mcastIpList)) and
                                               range(0,len(sourceList)) if mcastIpList[index] == group[1] and
                                               sourceList[index] == group[0] and rangeTypeList[index] == "sourcetogroup"]
                                else:
                                    indices = [index + 1 for index in range(0, len(mcastIpList)) if
                                               mcastIpList[index] == group[1] and rangeTypeList[index] == "startogroup"]
                                eval('pimInterface.' + joinPruneObj + '.' + action + '(indices)')
                    elif neighborIp:
                        if isinstance(neighborIp, str):
                            neighborIpList = [neighborIp]
                        else:
                            neighborIpList = neighborIp
                        for neighborIp in neighborIpList:
                            for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find()'):
                                addressValues = ipObj.Address.Values
                                if neighborIp in addressValues:
                                    ipIndex = addressValues.index(neighborIp) + 1
                                    eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipObj.Name).'+HostObj+'.find().'+joinPruneObj+'.'+action+'([ipIndex] )')
                    else:
                        for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):
                            indexcount = pimInterface.Count
                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')
                            if mode == 'ssm':
                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == "sourcetogroup"]
                            else:
                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == "startogroup"]
                            eval('pimInterface.' + joinPruneObj + '.' + action + '(indexList)')
        return True

    def _get_port_name_list(self, ports):
        """
        Function used internally by APIs

        :param ports: List of ports
        :return: port list
        """
        portList = []
        for port in ports:
            if '.' in port and '/' in port:
                vportObj = self.ixNetwork.Vport.find(AssignedTo='^' + port.replace('/', ':') + '$')
                portList.append(vportObj.Name)
            elif '/' in port:
                assignedList = [vport.AssignedTo for vport in self.ixNetwork.Vport.find()]
                for assigned in assignedList:
                    if re.search(':' + port.replace('/', ':') + '$', assigned):
                        portList.append(self.ixNetwork.Vport.find(AssignedTo='^' + assigned + '$').Name)
            else:
                portList.append(port)
        return portList

    def start_arp(self, ports=None, **kwargs):
        """
        Send arp based on port list, In NGPF ARP is default once IPV4 stack is up, so no need to start_arp again

        :param ports: list of port name or port handle or interface name from Json file.Default is None for all ports
        :return: True

        :Example: start_arp()
                  start_arp(ports = ['10.85.99.38/7/17', '10.85.99.38/7/19'])
                  start_arp(ports = '10.85.99.38/7/17')
        """
        if ports:
            if type(ports) == str:
                ports = [ports]
            for portname in ports:
                if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', portname)):
                    portname = portname.replace("/", ":")
                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + portname + '$')
                else:
                    vport = self.ixNetwork.Vport.find(Name='^' + portname + '$')
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == vport.href:
                        try:
                            for ipv4Obj in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                                objCount = ipv4Obj.Count
                                objCountList = [device for device in range(1, objCount + 1)]
                                ipv4Obj.SendArp(SessionIndices=objCountList)
                        except:
                            pass
                        try:
                            for ipv6Obj in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                objCount = ipv6Obj.Count
                                objCountList = [device for device in range(1, objCount + 1)]
                                ipv6Obj.SendNs(SessionIndices=objCountList)
                        except:
                            pass
        else:
            topology = self.ixNetwork.Topology.find()
            if topology:
                with BatchFind(topology) as ipv4_list:
                    self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find()
                try:
                    ipv4_obj_list = getattr(ipv4_list.results, 'ipv4')
                except:
                    ipv4_obj_list = []
                if ipv4_obj_list:
                    threads_arp = []
                    for ipv4_obj in ipv4_obj_list:
                        try:
                            thread_arp = threading.Thread(target=self._start_arp_ns, args=(ipv4_obj, 'ipv4'))
                            thread_arp.start()
                            threads_arp.append(thread_arp)
                        except:
                            pass
                    for thread_arp in threads_arp:
                        thread_arp.join()
                else:
                    self.log.warning('IPv4 block is not configured')
                with BatchFind(topology) as ipv6_list:
                    self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find()
                try:
                    ipv6_obj_list = getattr(ipv6_list.results, 'ipv6')
                except:
                    ipv6_obj_list = []
                if ipv6_obj_list:
                    threads_ns = []
                    for ipv6_obj in ipv6_obj_list:
                        try:
                            thread_ns = threading.Thread(target=self._start_arp_ns, args=(ipv6_obj, 'ipv6'))
                            thread_ns.start()
                            threads_ns.append(thread_ns)
                        except:
                            pass
                    for thread_ns in threads_ns:
                        thread_ns.join()
                else:
                    self.log.warning('IPv6 block is not configured')
            else:
                self.log.warning('Topology not found')
        return True

    def _start_arp_ns(self, ip_obj, ip_type):
        """
        Internal function to start_arp

        :param ip_obj: IP Object where Arp/Ns to be started
        :param ip_type: IP type for IPv4/IPv6
        :return: True if successful
        """
        obj_count = ip_obj.Count
        obj_count_list = list(range(1, obj_count + 1))
        if ip_type == 'ipv4':
            try:
                ip_obj.SendArp(SessionIndices=obj_count_list)
            except:
                pass
        else:
            try:
                ip_obj.SendNs(SessionIndices=obj_count_list)
            except:
                pass
        return True

    def send_ping(self, src_ip_address, dest_ip_address, port=None, ip_version="ipv4"):
        """
        Send ping from src_ip_address to dest_ip_address

        :param src_ip_address: string demonstrating the source IP address for ping
        :param dest_ip_address: string demonstrating the destination IP address for ping
        :param port: String showing the port through which the port is sent out in IXIA, if None, the port corresponding to the source IP address is extracted dynamically
        :param ip_version: String representing the IP version, default will be IPv4
        :return: True if the ping is successful, False otherwise

        :Example: send_ping(src_ip_address='103.1.2.2',dest_ip_address='103.1.2.1')
        """
        self.log.info("Sending ping for ip: %s" % dest_ip_address)
        pingStatus = False
        if ip_version.lower() == 'ipv4':
            ipVersion = "Ipv4"
        elif ip_version.lower() == 'ipv6':
            ipVersion = "Ipv6"

        if port:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            if port in vportNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                        for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):
                            ipAddressList = ipObj.Address.Values
                            if src_ip_address in ipAddressList:
                                index = ipAddressList.index(src_ip_address) + 1
                                pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')
                                if pingStatus ==[]:
                                    raise IxiaOperationException("Not able to ping, DeviceGroup not started")
                                else:
                                    pingStatus = pingStatus[0]['arg2']
        else:
            for ipObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):
                ipAddressList = ipObj.Address.Values
                if src_ip_address in ipAddressList:
                    index = ipAddressList.index(src_ip_address) + 1
                    pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')
                    if pingStatus == []:
                        raise IxiaOperationException("Not able to ping, DeviceGroup not started")
                    else:
                        pingStatus = pingStatus[0]['arg2']
        if (pingStatus==True):
            self.log.info("Ping success for:%s"  % dest_ip_address)
        else:
            self.log.info("Ping fail for:%s" % dest_ip_address)
        return pingStatus

    def _verifyDhcpClientBind(self, deviceGroupName=None, protocol=None, **kwargs):
        """
        Function used internally by API verify_dhcp_client_bind, get_dhcp_client_bound_count

        :param deviceGroupName: Device Group Name
        :param protocol: Protocol , Ex: IPv4/IPv6
        :param kwargs: optional arguments
        """
        portName = kwargs.get('portName', None)
        if protocol == None:
            protocols = ['ipv4', 'ipv6']
        else:
            protocols = [protocol]
        boundCount = 0
        idleBoundDict = {}
        ibList = []
        for protocol in protocols:
            if portName and deviceGroupName is None:
                # Get all deviceGroups configured with Port
                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                for topology in self.ixNetwork.Topology.find():
                    if topology.Ports[0] == vportHref:
                        deviceList = [deviceGroupName.Name for deviceGroupName in topology.DeviceGroup.find() if deviceGroupName]
            elif deviceGroupName == None:
                # Get all deviceGroups in all topology lists
                deviceList = [deviceGroupName.Name for deviceGroupName in self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
            else:
                deviceList = [deviceGroupName]
            for eachDevice in deviceList:
                ethObjList = self.ixNetwork.Topology.find().DeviceGroup.find(DescriptiveName=eachDevice).Ethernet.find()
                for ethObj in ethObjList:
                    idleDhcpDict = {}
                    boundDhcpDict = {}
                    if protocol == 'ipv6':
                        # raise an exception if no DHCPv6 client
                        try:
                            for dhcpObjName in ethObj.Dhcpv6client.find():
                                dhcpName = dhcpObjName.Name
                                dhcpClientObjDeviceCount = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).Count
                                discoveredAddressList = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).DiscoveredAddresses
                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]
                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]
                                boundCount += len(boundList)
                                if idleList:
                                    idleDhcpDict[dhcpName] = idleList
                                    ibList.append(["Idle", eachDevice, idleDhcpDict])
                                if boundList:
                                    boundDhcpDict[dhcpName] = boundList
                                    ibList.append(["Bound", eachDevice, boundDhcpDict])
                        except:
                            raise IxiaConfigException("no dhcpv6 client found")
                    else:
                        try:
                            for dhcpObjName in ethObj.Dhcpv4client.find():
                                dhcpName =  dhcpObjName.Name
                                dhcpClientObjDeviceCount = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).Count
                                discoveredAddressList = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).DiscoveredAddresses
                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]
                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]
                                if idleList:
                                    idleDhcpDict[dhcpName] = idleList
                                    ibList.append(["Idle", eachDevice, idleDhcpDict])
                                if boundList:
                                    boundDhcpDict[dhcpName] = boundList
                                    ibList.append(["Bound", eachDevice, boundDhcpDict])
                                boundCount += len(boundList)
                        except:
                            raise IxiaConfigException("ERROR: No DHCP V4 Client Found")
        self.log.info(boundCount)
        idleBoundDict['Idle'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Idle', ibList)}
        idleBoundDict['Bound'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Bound', ibList)}
        idleBoundDict['boundCount'] = boundCount
        return idleBoundDict

    def verify_dhcp_client_bind(self, device, protocol, **kwargs):
        """
        DHCP client bind verifier - check if client received IP from the server.
        :param device: (str): Device Group name, If none passed check for all device group names
        :param protocol: (str): ipv4/ipv6, If none passed check for both ipv4 and ipv6
        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')
        :param expected_blockstate: 'IDLE'/'BOUND'
        :return: Idle and Bound items of deviceGroup in dictionary format. Return Exception when device is not present in config

        :Example: verify_dhcp_client_bind(device="Device Group 23")
        """
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        if protocol.lower() == "ipv4":
            discoveredAddressList = deviceObj.Dhcpv4client.find().DiscoveredAddresses
        elif protocol.lower() == "ipv6":
            discoveredAddressList = deviceObj.Dhcpv6client.find().DiscoveredAddresses
        idleList = [client for client in discoveredAddressList if '[Unresolved]' in client]
        if idleList:
            actual_blockstate = "IDLE"
        else:
            actual_blockstate = "BOUND"
        expected_blockstate = kwargs.get('expected_blockstate', None)
        if expected_blockstate:
            if expected_blockstate.upper() == actual_blockstate:
                log.info('Blockstate of client %s is %s as expected (%s)' \
                         % (device, actual_blockstate, expected_blockstate))
            else:
                err_msg = "Blockstate of client %s is %s. NOT as expected (%s)" \
                          % (device, actual_blockstate, expected_blockstate)
                raise CafyException.VerificationError(err_msg)
        return actual_blockstate

    def get_dhcp_client_bound_count(self, device=None, protocol=None, **kwargs):
        """"
        To retrieve number of DHCP sessions currently bound to the interface/device

        :param device: Device Group name, If none passed check for all device group names
        :param protocol: ipv4/ipv6, If none passed check for both ipv4 and ipv6
        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')
        :return: Number of sessions Bound. Return Exception when device is not present in config

        :Example: get_dhcp_client_bound_count()
        """
        self.log.info("Getting DHCP Client Bound Count")
        if 'port_name' in kwargs:
            kwargs['portName'] = kwargs['port_name']
        boundDict = self._verifyDhcpClientBind(deviceGroupName=device, protocol=protocol, **kwargs)
        return boundDict['boundCount'],boundDict['boundCount']

    def verify_arp(self,ports=(), ip_type='ipv4'):
        """
        This method requires:  _device_group_protocolstack_ngpf()
        It will verify for ARP session resolvement on
        every Device Group including inner Device Groups.

        How it works?
        Each device group has a list of $sessionStatus: up, down or notStarted.
        If the deviceGroup has sessionStatus as "up", then ARP will be verified.
        It also has a list of $resolved_gateway_mac: MacAddress or removePacket
        [Unresolved]
        These two $sessionStatus and $resolved_gateway_mac lists are aligned.
        If lindex 0 on $sessionSatus is up, then $resolved_gateway_mac on index 0 expects
        to have a mac address.  Not removePacket[Unresolved].
        If not, then arp is not resolved.

        :param ports: port or list of ports
        :param ip_type: default is ipv4
        :return: 0 if ARP passes, 1 if device group is not started
                Returns a list of unresolved ARPs (src ip)

        :Example: verify_arp()
        """

        self.log.info("Arp Verification on All interfaces")
        unresolvedArpList = []
        gatewayIpList = []
        timeout = 25
        start_flag = 0
        for deviceGroupObj in (self.ixNetwork.Topology.find().DeviceGroup.find()):
            for counter in range(1, 30):
                if deviceGroupObj.Status in ['started', 'mixed']:
                    start_flag = 1
                    break
                elif (counter >= timeout and deviceGroupObj.Status not in ['started', 'mixed']):
                    raise IxiaConfigException('\nDevice Group failed to come up: {0}.'.format(deviceGroupObj.href))
        if (ip_type.lower() == 'ipv6'):
            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find()):
                for index, eachState in enumerate(ipObj.SessionStatus):
                    if eachState != "up":
                        unresolvedArpList.append(ipObj.Address.Values[index])
                        gatewayIpList.append(ipObj.GatewayIp.Values[index])
            try:
                for ipObj in ([x for x in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv6.find() if x]):
                    for index, eachState in enumerate(ipObj.SessionStatus):
                        if eachState != "up":
                            unresolvedArpList.append(ipObj.Address.Values[index])
                            gatewayIpList.append(ipObj.GatewayIp.Values[index])
            except:
                pass
        else:
            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):
                for index, eachState in enumerate(ipObj.SessionStatus):
                    if eachState != "up":
                        unresolvedArpList.append(ipObj.Address.Values[index])
                        gatewayIpList.append(ipObj.GatewayIp.Values[index])
            try:
                for ipObj in (
                        self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):
                    for index, eachState in enumerate(ipObj.SessionStatus):
                        if eachState != "up":
                            unresolvedArpList.append(ipObj.Address.Values[index])
                            gatewayIpList.append(ipObj.GatewayIp.Values[index])
            except:
                pass
        if unresolvedArpList == [] and start_flag == 1:
            self.log.info(f'\t{ip_type} - ARP is resolved')
            return 0
        if unresolvedArpList != [] and start_flag == 0:
            self.log.info('Device Group not started')
            return 1
        if unresolvedArpList != [] and start_flag == 1:
            raise IxiaConfigException("\nFailed to resolve ARP: srcIp: {0} gateway: {1}".format(unresolvedArpList, gatewayIpList))
        return unresolvedArpList

    def neighbor_discovery(self, *args):
        """
        neighbor discovery for IPv6

        :Example: neighbor_discovery()
        """
        if len(args):
            self.log.debug("unused options %s" % args)
        self.verify_arp(ip_type='ipv6')

    def change_traffic_frame_size(self, cfg_dict, traffic_item_list=None, **kwargs):
        """
        This API is used for changing traffic item frame size.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                type: auto, fixed, increment, random, weightedPairs, presetDistribution,
                quadGaussian\n
                fixedSize: frame size for type of fixed\n
                more options see: <IP of IxNetwork>:25445/api/v1/meta
        :param kwargs :
                dynamic_frame_size : True/False dynamic frame size , Frame size to be set on the fly
                                    supported frame type is "fixed" and "random
        :return: True or Exception

        :Example: change_traffic_frame_size(cfg_dict={'type': 'presetDistribution', 'presetDistribution': 'cisco'})
                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'random','fixedSize': '10'})
                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'fixed', 'fixedSize': '100'},traffic_item_list=['Traffic ipv4'])
        """
        self.log.info("Changing Traffic Frame Size")
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        frame_size_dict = {'type': 'Type', 'fixedSize': 'FixedSize', 'incrementFrom': 'IncrementFrom',
                         'incrementTo': 'IncrementTo', 'incrementStep': 'IncrementStep',
                         'presetDistribution': 'PresetDistribution', 'weightedPairs': 'WeightedPairs',
                         'randomMax': 'RandomMax', 'randomMin': 'RandomMin',
                         'weightedRangePairs': 'WeightedRangePairs'}

        for traffic_name in traffic_item_list:
            traffic_name = '^' + traffic_name.replace('+', r'\+').replace('*', r'\*') + '$'
            if kwargs.get('dynamic_frame_size'):
                for trafficitemname in self.ixNetwork.Traffic.DynamicFrameSize.find(TrafficItemName=traffic_name):
                    for key in cfg_dict:
                        setattr(trafficitemname, frame_size_dict[key], cfg_dict[key])
            else:
                if 'weightedPairs' in cfg_dict.keys():
                    if ':' in str(cfg_dict['weightedPairs'][0]):
                        wp_tmp = []
                        for i in cfg_dict['weightedPairs']:
                            wp_tmp.append(int(i.split(':')[0]))
                            wp_tmp.append(int(i.split(':')[1]))
                        cfg_dict['weightedPairs'] = wp_tmp

                for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name):
                    Streams = traffic.ConfigElement.find()
                    for Stream in Streams:
                        for frameSize in Stream.FrameSize:
                            for key in cfg_dict:
                                setattr(frameSize, frame_size_dict[key], cfg_dict[key])
        self.log.info("Frame Size in Traffic Items Updated")
        return True

    def change_traffic_rate(self, cfg_dict, traffic_item_list=None, **kwargs):
        """
        Changes the rate of traffic.

        :param cfg_dict: Dict including the data need to be modified
                   type: 'bitsPerSecond','kilobitsPerSecond','megabitsPerSecond','framesPerSecond','percentLineRate'
                   rate: The rate at which packet is transmitted.
                Example: percent Line Rate: cfg_dict = {'type':'percentLineRate','rate':25.0}
                         frame Per Second: cfg_dict = {'type':'framesPerSecond','rate':200000.0}
        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param kwargs :
                dynamic_traffic_rate : True/False dynamic traffic rate to be set on the fly
        :return: True on success else raises exception.

        :Example:
            change_traffic_rate(cfg_dict={'type': 'megabitsPerSecond', 'rate': 20}, traffic_item_list=['Traffic Item 1'])\n
            change_traffic_rate(cfg_dict = {'type':'framesPerSecond','rate':200.0})
            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type':'percentLineRate','rate':10},
            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type': 'megabitsPerSecond', 'rate': 20})
        """
        self.log.info("Changing Traffic Rate")

        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        rateTypeDict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',
                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',
                        'percentLineRate': 'lineRate'}

        for traffic_name in traffic_item_list:
            traffic_name_modified = re.escape(traffic_name)
            traffic_name_modified = f'^{traffic_name_modified}$'

            if cfg_dict.get('type') in rateTypeDict.keys():
                if kwargs.get('dynamic_traffic_rate'):
                    if self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name_modified):
                        for trafficitemname in self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name_modified):
                            if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:
                                trafficitemname.RateType = 'bitsPerSecond'
                                trafficitemname.BitRateUnitsType = rateTypeDict[cfg_dict['type']]
                            else:
                                trafficitemname.RateType = cfg_dict['type']
                            trafficitemname.Rate = cfg_dict.get('rate', None)
                            self.log.info(f"Traffic Rate updated for Traffic item '{traffic_name}'")
                    else:
                        self.log.error(f"Traffic Item '{traffic_name}' not found in config")
                else:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name_modified):
                        for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name_modified):
                            streams = traffic.ConfigElement.find()
                            for each_stream in streams:
                                for frame_rate in each_stream.FrameRate:
                                    if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:
                                        frame_rate.Type = 'bitsPerSecond'
                                        frame_rate.BitRateUnitsType = rateTypeDict[cfg_dict['type']]
                                    else:
                                        frame_rate.Type = cfg_dict['type']
                                    frame_rate.Rate = cfg_dict.get('rate', None)
                            self.log.info(f"Traffic Rate updated for Traffic item '{traffic_name}'")
                    else:
                        self.log.error(f"Traffic Item '{traffic_name}' not found in config")
            else:
                log.error('Unknown/Unsupported rate type.')
                raise CafyException.InvalidValueError('Unknown/Unsupported rate type provided in change_traffic_rate')
        return True

    def set_traffic_mpls_exp_bits(self, exp_value, traffic_item_list=None):
        """
        Sets the MPLS headers Experimental Bits (bits) field to the specified value

        :param exp_value: The exp bit field value to be used. Accepted values are 0-7
            e.g. exp_bit_value=4 or [1,4,6]
        :param traffic_item_list: A list of streamblocks to be modified. If None,
            set exp_bit_value for all streamblocks.
        :return: True if no exceptions were thrown

        :Example: set_traffic_mpls_exp_bits(exp_value = 1, traffic_item_list=["Traffic Item 2"])
                  set_traffic_mpls_exp_bits(exp_value = [1,2,3], traffic_item_list=["Traffic Item 2"])
        """
        self.log.info("Setting MPLS EXP Bits in Traffic Item/Items")
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                    try:
                        if type(exp_value) is not list:
                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                            fieldValue.ValueType = 'singleValue'
                            fieldValue.SingleValue = exp_value
                        if type(exp_value) is list:
                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                            fieldValue.ValueType = 'valueList'
                            fieldValue.ValueList = exp_value
                    except:
                        pass
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if type(exp_value) is not list:
                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                        fieldValue.ValueType = 'singleValue'
                        fieldValue.SingleValue = exp_value
                    if type(exp_value) is list:
                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                        fieldValue.ValueType = 'valueList'
                        fieldValue.ValueList = exp_value
                except:
                    pass
        return True

    def get_traffic_mpls_exp_bits(self, traffic_item_list=None):
        """
        Gets the value of the MPLS headers exp field for the specified traffic items

        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.
        :return: A list of results containing the exp field value for the specified streams

        :Example: get_traffic_mpls_exp_bits(traffic_item_list=["Traffic Item 2"])
        """

        self.log.info("Getting MPLS EXP Bits For Traffic Items")
        results = []
        if traffic_item_list:
            for trafficName in traffic_item_list:
                try:
                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(
                        StackTypeId='mpls').Field.find(Name='mpls_exp'):
                        results.append(fieldValue.SingleValue)
                except:
                    self.log.info("MPLS Stack Not Available in %s" % trafficName)
                    raise IxiaOperationException("MPLS Stack Not Available in %s" % trafficName)
        else:
            try:
                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(
                            StackTypeId='mpls').Field.find(Name='mpls_exp'):
                    results.append(fieldValue.SingleValue)
            except:pass
        return results

    def change_vlan_priority(self, device_name, vlan_number, priority=7):
        """
        Change VLAN priority on a device group

        :param device_name: Name of device group on which VLAN Priority need to be changed
        :param vlan_number:  VLAN Number on which priority needs to be changed.
        :param priority: Range 0 to 7. Default is 7

        :Example: change_vlan_priority(device_name='Device Group 13' , vlan_number=10, priority=4)
        """
        self.log.info("Changing VLAN Priority for Vlan {0} in {1}".format(vlan_number,device_name))
        try:
            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values
        except:
            raise IxiaOperationException("Device Group not Found")
        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().Priority.Values
        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
        if indexList:
            for index in indexList:
                priorityList.pop(index)
                priorityList.insert(index, str(priority))

            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():
                vlan.Priority.ValueList(values=priorityList)
            self.log.info("VLAN Priority Changed for Vlan {0} in {1}".format(vlan_number,device_name))
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("VLAN Number not Found")

    def change_traffic_flow_tracking(self, cfg_dict, traffic_item_list=None, **kwargs):
        """
        This API is used for changing traffic item flow tracking.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                trackBy: []\n
                availableTrackBy: ['customOverride', 'sourceDestValuePair0',
                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',
                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',
                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',
                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',
                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',
                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',
                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']\n
                more options see: <IP of IxNetwork>:25445/api/v1/meta

        :Example: change_traffic_flow_tracking(cfg_dict = {'trackBy':['ipv4SourceIp0','sourcePort0']},traffic_item_list =['Traffic Item 2'])
        """

        self.log.info("Changing Traffic Flow Tracking")
        ipv4_precedence_full_mesh = kwargs.get("ipv4_precedence_full_mesh", False)
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():
                    tracking.TrackBy = cfg_dict['trackBy']
                if ipv4_precedence_full_mesh:
                    self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find().Field.find(DisplayName='Precedence')\
                        .FullMesh = ipv4_precedence_full_mesh
        else:
            for traffic in self.ixNetwork.Traffic.TrafficItem.find():
                for tracking in traffic.Tracking.find():
                    tracking.TrackBy = cfg_dict['trackBy']

        self.log.info("Flow Tracking Updated for Traffic Items")

    def change_traffic_egress_tracking(self, cfg_dict, traffic_item_list=None):
        """
        This API is used for changing traffic item egress tracking.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                enabled: True or False

                availableEncapsulations: ['Any: Use Custom Settings', 'Ethernet',
                'LLC/Snap Routed Protocol', 'LLC Encapsulated PPP',
                'LLC Bridged Ethernet/802.3', 'LLC Bridged Ethernet/802.3 no FCS',
                'VC Multiplexed PPP', 'VC Mux Routed Protocol',
                'VC Mux Bridged Ethernet/802.3', 'VC Mux Bridged Ethernet/802.3 no FCS',
                'PPP', 'CISCO HDLC', 'Frame Relay', 'Cisco Frame Relay']

                availableOffsets: ['Outer VLAN Priority (3 bits)', 'Outer VLAN ID (4 bits)',
                'Outer VLAN ID (6 bits)', 'Outer VLAN ID (8 bits)',
                'Outer VLAN ID (10 bits)', 'Outer VLAN ID (12 bits)',
                'Inner VLAN Priority (3 bits)', 'Inner VLAN ID (4 bits)',
                'Inner VLAN ID (6 bits)', 'Inner VLAN ID (8 bits)',
                'Inner VLAN ID (10 bits)', 'Inner VLAN ID (12 bits)',
                'VNTag Direction Bit (1 bit)', 'VNTag Pointer Bit (1 bit)',
                'VNTag Looped Bit (1 bit)', 'MPLS Exp (3 bits)',
                'IPv4 TOS Precedence (3 bits)', 'IPv4 DSCP (6 bits)',
                'IPv6 Traffic Class (8 bits)', 'IPv6 Traffic Class Bits 0-2 (3 bits)',
                'IPv6 Traffic Class Bits 0-5 (6 bits) ']

        :Example: change_traffic_egress_tracking(cfg_dict={'enabled': True, 'encapsulation': 'Ethernet'})
        """
        self.log.info("Changing Traffic Egress Tracking")
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():
                    tracking.Egress.Enabled = cfg_dict.get('enabled', True)
                    tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)
                    tracking.Egress.Offset = cfg_dict.get('offset', None)
        else:
            for tracking in self.ixNetwork.Traffic.TrafficItem.find().Tracking.find():
                tracking.Egress.Enabled = cfg_dict.get('enabled', True)
                tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)
                tracking.Egress.Offset = cfg_dict.get('offset', None)
        self.log.info("Egress Tracking Updated for Traffic Items")

    def get_port_name_from_location(self, location):
        """
        Get name of port in config based on location

        :param location: port (str) location in chassis/card/port format.
         Ex: location="172.29.126.16/5/7"
        :return: Name of the port

        :Example: get_port_name_from_location(location = "172.29.126.16/5/7")
        """
        self.log.info("Getting Port Name from Location")
        for vport in self.ixNetwork.Vport.find():
            locationUpdated = location.replace("/", ":")
            if vport.AssignedTo == locationUpdated:
                return vport.Name

        raise IxiaConfigException("No Port found for location : '%s' " % location)

    def set_chassis_mode(self, **kwargs):
        """
        Designates a chassis with a given IP as either the primary or a secondary for a given IXIA config

        :kwargs :
                :param primary: Primary Chassis IP
                :param secondary: secondary Chassis IP
        :return: True if successful
        :Example: set_chassis_mode()
                set_chassis_mode(primary='172.21.179.238',secondary='172.21.179.239')
        """
        self.log.info("Setting Chassis Mode")
        primary_ip = kwargs.get('primary', None)
        secondary_ip_list = kwargs.get('secondary', None)
        if isinstance(secondary_ip_list, str):
            secondary_ip_list = [secondary_ip_list]
        if primary_ip and secondary_ip_list:
            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find()]
            if primary_ip not in connected_chassis_list:
                self.connect_to_chassis([primary_ip])
            primary_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + primary_ip + '$')
            if primary_obj:
                for secondary_ip in secondary_ip_list:
                    if secondary_ip not in connected_chassis_list:
                        self.connect_to_chassis([secondary_ip])
                    secondary_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + secondary_ip + '$')
                    if secondary_obj:
                        if not secondary_obj.IsPrimary:
                            secondary_obj.PrimaryChassis = primary_ip
                            self.log.info(f'Added Primary chassis ip {primary_ip} to Secondary chassis {secondary_ip}')
                    else:
                        self.log.warning(f'Secondary chassis {secondary_ip} not present in config')
            else:
                self.log.warning(f'Primary chassis {primary_ip} not present in config')
        else:
            for chassis in self.ixNetwork.AvailableHardware.Chassis.find():
                if chassis.Ip == self.chassis_ip:
                    chassis.IsMaster = True
                else:
                    chassis.IsMaster = False
                    chassis.MasterChassis = self.chassis_ip
        return True

    def _bgp_neighbor_control(self, bgp_peer_name_list, local_ip_list, ip_type, action):
        """
        Function used internally by APIs bgp_start and bgp_stop

        :param bgp_peer_name_list: BGP Peer Name list
        :param local_ip_list: BGP Local IP list
        :param ip_type: IP type , IPv4/IPv6
        :param action: Action, "start/stop"
        """
        self.log.info("BGP action {}".format(action))
        if ip_type not in ['ipv4', 'v4', 'ipv6', 'v6']:
            msg = 'ip_type %s can only be ipv4 or ipv6' % ip_type
            raise IxiaOperationException(msg)
        for bgpPeerName in bgp_peer_name_list:
            bgpPeerName = '^' + bgpPeerName.replace('+', r'\+').replace('*', r'\*') + '$'
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(Name="' + bgpPeerName + '").' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(Name="' + bgpPeerName + '").' + action + '(None)')
            except:
                pass
        for localIp in local_ip_list:
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(LocalIpv4Ver2="' + localIp + '").' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(LocalIpv6Ver2="' + localIp + '").' + action + '(None)')
            except:
                pass
        if bgp_peer_name_list == [] and local_ip_list == []:
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find().BgpIpv4Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find().BgpIpv6Peer.find().' + action + '(None)')
            except:
                pass
        return True

    def bgp_start(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):
        """
        Start bgp emulation

        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type
        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.
        :param ip_type: ipv4 or ipv6, default set to ipv4
        :return: raise exception if False/error

        :Example: bgp_start(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"], local_ip_list=["103.1.1.2","103.1.1.1"])
        """
        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action="Start")

    def bgp_stop(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):
        """
        Stop bgp emulation

        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type
        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.
        :param ip_type: ipv4 or ipv6, default set to ipv4
        :return: raise exception if False/error

        :Example: bgp_stop(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"], local_ip_list=["103.1.1.2","103.1.1.1"])
        """
        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action="Stop")

    def link_up_down(self, port, action='up'):
        """
        Flap a port Up and Down

        :param port: list of port names\n
                Example : port = ['10.30.20.140/1/5','10.30.20.140/1/6']\n
                Example : port = ['Ethernet 01' , Ethernet 02']
        :param action: CHOICES up, down
        :return: True

        :Example: link_up_down(port=["Ethernet - 001", "Ethernet - 002"], action='down')
        """
        self.log.info("Simulation Link :%s" % (action))
        action = action.lower()
        for eachPort in port:
            if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                eachPort = eachPort.replace("/", ":")
                for vport in self.ixNetwork.Vport.find(AssignedTo = eachPort):
                    vport.LinkUpDn(action)
                    time.sleep(30)
                for vport in self.ixNetwork.Vport.find(AssignedTo=eachPort):
                    if vport.State != action:
                        msg = 'Port "%s" Link "%s" Simulatin not Successful' % (eachPort, action)
                        self.log.info(msg)

            else:
                for vport in self.ixNetwork.Vport.find(Name=eachPort):
                    vport.LinkUpDn(action)
                    time.sleep(30)
                for vport in self.ixNetwork.Vport.find(Name=eachPort):
                    if vport.State != action:
                        msg = 'Port "%s" Link "%s" Simulation Failed' % (eachPort,action)
                        self.log.info(msg)
        return True

    def release_ports(self, port_list=None):
        """
        Release ports

        :param port_list: list of port names\n
               port_list can be port_list = ['10.30.20.140/1/5','10.30.20.140/1/6']
               port_list = ['Ethernet 01' , Ethernet 02']\n
               port_list = [[ixChassisIp, 1, 2], [ixChassisIp, 1, 3], ...]
        :return: True

        :Example: release_ports(port_list=['10.30.20.140/1/5','10.30.20.140/1/6'])
        """
        self.log.info("Releasing Ports")
        if port_list is None:
            try:
                ports = self.ixNetwork.Vport.find()
                ports.ResetPortCpuAndFactoryDefault()
                time.sleep(5)
                ports.ReleasePort()
            except:
                pass
        else:
            vportNames = []
            for port in port_list:
                regexString = ''
                if isinstance(port, list):
                    # Construct the regex string format = '(1.1.1.1:2:3)'
                    regexString = regexString + '(' + str(port[0]) + ':' + str(port[1]) + ':' + str(port[2]) + ')'
                elif isinstance(port, str):
                    if '.' in port:
                        regexString = port.replace('/',':')
                    else:
                        try:
                            regexString = self.ixNetwork.Vport.find(Name=port).AssignedTo
                        except:
                            raise IxiaConfigException("Port not configured or Failed to release")
                vport = self.ixNetwork.Vport.find(AssignedTo=regexString)
                if vport:
                    vportNames.append(vport.Name)
                    self.log.info('\nReleasing port: {0}:{1}'.format(port, vport.href))
                    vport.ResetPortCpuAndFactoryDefault()
                    time.sleep(5)
                    vport.ReleasePort()
                    time.sleep(5)
            for vport in self.ixNetwork.Vport.find():
                if vport.ConnectionStatus != 'Port Released':
                    msg = 'Release Port "%s" not Successful' % (vport.Name)
                    raise IxiaOperationException(msg)
        return True

    def verify_arp_status(self, ipType='ipv4', device=None, **kwargs):
        """
        verifies the ARP status of all device groups on the TGN session

        :param ipType: IP type , ipv4/ipv6
        :param device: Device Group name
        :return: True or Exception

        :Example: verify_arp_status(ipType='ipv6', device='Device Group 3')
        """
        # if StubitUtil.is_stubit_playback():
        #     log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
        #     return
        scale_traffic = kwargs.get("scale_traffic",False)

        self.log.info("Verification of Arp Started")
        if isinstance(device, str):
            device = [device]
        unresolved_arp_list = []
        gateway_ip_list = []
        timeout = 20
        result = True
        ip_type = ipType

        if device:
            device_obj_list = list(map(lambda device_obj: device_obj if device_obj.Name in device else None,
                                    self.ixNetwork.Topology.find().DeviceGroup.find()))
            device_obj_list = list(filter(None, device_obj_list))
        else:
            topology = self.ixNetwork.Topology.find()
            if topology:
                with BatchFind(topology) as device_group:
                    self.ixNetwork.Topology.find().DeviceGroup.find()
                device_obj_list = getattr(device_group.results, 'deviceGroup')
            else:
                self.log.warning('Topology not found in the config')
                return result

        if device_obj_list:
            for device_obj in device_obj_list:
                for counter in range(0, timeout, 2):
                    if device_obj.Status == 'notStarted':
                        msg = f'\n Device Group {device_obj.Name} is not started'
                        self.log.warning(msg)
                    if counter < timeout and device_obj.Status == 'starting':
                        time.sleep(2)
                        continue
                    if counter < timeout and device_obj.Status in ['started', 'mixed']:
                        break
                    if counter == timeout and device_obj.Status not in ['started', 'mixed']:
                        msg = f'\n Device Group failed to come up: {device_obj.Name}'
                        raise IxiaOperationException(msg)

            for device_obj in device_obj_list:
                unresolved_mac = False
                with BatchFind(device_obj) as ip_obj_list:
                    eval('device_obj.Ethernet.find().' + ip_type[0].upper() + ip_type[1:] + '.' + 'find()')
                if device_obj.Status == 'notStarted':
                    self.log.info(f'Device {device_obj.Name} is not started')
                else:
                    try:
                        ip_obj_list = getattr(ip_obj_list.results, ip_type)
                    except:
                        ip_obj_list = []
                        self.log.info(f'{ip_type} block is not configured in device {device_obj.Name}')

                    for ip_obj in ip_obj_list:
                        if scale_traffic == True:
                            count = 0
                            session_info = ip_obj.SessionInfo
                            for not_started in session_info:
                                if not_started == "resolveMacFailed":
                                    count = count + 1
                            if count > 1:
                                self.log.warning(f"[{device_obj.Name}] Found {count} count of IPs that have the MAC Resolution failed")
                            elif count < 1:
                                self.log.info(f"[{device_obj.Name}] ARP Verification passed for scale traffic")
                        else:
                            for index, each_state in enumerate(ip_obj.SessionStatus):
                                if each_state != "up":
                                    unresolved_arp_list.append(ip_obj.Address.Values[index])
                                    gateway_ip_list.append(ip_obj.GatewayIp.Values[index])
                                    unresolved_mac = True
                        if unresolved_mac:
                            self.log.info(f'Arp Verification Failed for {ip_type} in - "{device_obj.Name}"')
                        else:
                            msg = f'\n Device Group "{device}" not found'
                            raise IxiaOperationException(msg)
                        

            if unresolved_arp_list:
                self.log.info(f"\n Failed to Resolve ARP: srcIp: {unresolved_arp_list} gateway: {gateway_ip_list}")
                result = False

            if result:
                self.log.info(f'Arp Verification Successful for {ip_type}')
            return result


    def start_arp_and_verify(self,**kwargs):
        """
        starts the ARP and verifies the ARP status

        :return: true if successful else false if verify fails or exception in case error occurs

        :Example: start_arp_and_verify()
        """
        result_list = []
        scale_config = kwargs.get("scale_config",True)
        topology = self.ixNetwork.Topology.find()
        with BatchFind(topology) as device_group:
            topology.DeviceGroup.find()

        device_obj_list = getattr(device_group.results, "deviceGroup")
        try:
            for device_obj in device_obj_list:
                self.log.info(f'Starting Arp on: {device_obj.Name}')
                if device_obj.Ethernet.find().Ipv4.find():
                    for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():
                        obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))
                        ipv4_obj.SendArp(SessionIndices=obj_count_list)
                        result_list.append(self.verify_arp_status1(device=device_obj.Name, scale_config = True))
                else:
                    self.log.info(f'IPv4 block not found in {device_obj.Name}')
        except:
            self.log.error(f'Device Group {device_obj.Name} is not started')

        if not False in result_list:
            result = True
        else:
            result = False
        return result

    def bgp_ngp_flap(self, bgp_peer_name_list, action='True', up_time_in_sec=0, down_time_in_sec=0):
        """
        Enable/disable flapping on all the BGP interfaces.

        :param bgp_peer_name_list: BGP peer name List
        :param action: string format. Not boolean
               'True' = enable BGP flap
               'False' = disable BGP flap
        :param up_time_in_sec: Up Time In Seconds.
        :param down_time_in_sec: Down Time In Seconds.
        :return: True on success else raise exception.

        :Example: bgp_ngp_flap(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"])
        """

        self.log.info('BGP Neighbor Flapping for %s' % bgp_peer_name_list)
        if not type(bgp_peer_name_list) == list:
            msg = 'bgp_peer_name_list type can not be %s. It should be a list' \
                        % type(bgp_peer_name_list)
            raise IxiaConfigException(msg)
        for bgpPeerName in bgp_peer_name_list:
            for version in ['v4', 'v6']:
                try:
                    peerNameList = [bgpObj.Name for bgpObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find()')]
                except:
                    pass
                for peerName in peerNameList:
                    if peerName == bgpPeerName:
                        peerName = '^' + bgpPeerName + '$'
                        if '+' or '*' in peerName:
                            peerName = peerName.replace('+', r'\+').replace('*', r'\*')
                        try:
                            for bgpPeerObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find(DescriptiveName=peerName)'):
                                bgpPeerObj.Flap.Single(action)
                                bgpPeerObj.UptimeInSec.Single(up_time_in_sec)
                                bgpPeerObj.DowntimeInSec.Single(down_time_in_sec)
                        except:
                            pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def igmp_active_deactive(self, **kwargs):
        """
        Igmp active or deactive for multicast groups

        :param kwargs: optional arguments

        :Example: igmp_active_deactive(port=["Ethernet - 001", "Ethernet - 002"], hostIp=["105.1.1.2","105.1.2.2"],action=False)
        """
        kwargs['ports'] = kwargs.get('ports', None)
        kwargs['hostIp'] = kwargs.get('hostIp', None)
        kwargs['groups'] = kwargs.get('groups', None)
        kwargs['action'] = kwargs.get('action', True)

        if ('ports' in kwargs and kwargs['ports'] == None) and ('hostIp' in kwargs and kwargs['hostIp'] == None ) \
                and ('groups' in kwargs and kwargs['groups'] == None):
           for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.\
                   find().IgmpMcastIPv4GroupList:
               igmpMcastObj.Active.Single(str(kwargs['action']).lower())

        if 'ports' in kwargs and kwargs['ports'] is not None:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in kwargs['ports'] if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for ipv4 in topologyObj.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            for igmpHost in ipv4.IgmpHost.find():
                                if re.match(topologyObj + '/deviceGroup', igmpHost.href):
                                    for igmpObj in ipv4.IgmpHost.find(DescriptiveName=igmpHost.DescriptiveName).IgmpMcastIPv4GroupList:
                                        igmpObj.Active.Single(str(kwargs['action']).lower())

        if 'hostIp' in kwargs and kwargs['hostIp'] is not None:
            for ip in kwargs['hostIp']:
                ipNameList = [address.Name for address in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find() if address]
                for ipName in ipNameList:
                    address = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).Address
                    if ip in address.Values:
                        ipIndex = address.Values.index(ip)
                        valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active.Values
                        valuesList[ipIndex] = str(kwargs['action']).lower()
                        igmpMcastObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active
                        igmpMcastObj.ValueList(values=valuesList)

        if 'groups' in kwargs and kwargs['groups'] is not None:
            for igmpMcast in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList:
                multicastIpList = igmpMcast.StartMcastAddr.Values
                for group in kwargs['groups']:
                    if group[1] in multicastIpList:
                        indices = [index for index in range(0, len(multicastIpList)) if multicastIpList[index] == group[1]]
                        for index in indices:
                            valuesList = igmpMcast.Active.Values
                            valuesList[index] = str(kwargs['action']).lower()
                            igmpMcastObj = igmpMcast.Active
                            igmpUcastObj = igmpMcast.IgmpUcastIPv4SourceList.Active
                            if "*" in group:
                                igmpMcastObj.ValueList(values=valuesList)
                            else:
                                igmpMcastObj.ValueList(values=valuesList)
                                igmpUcastObj.ValueList(values=valuesList)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _update_bgp_flap_values(self,bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime):
        """
        Internal API used by bgp_routes_flap

        :param bgpRoutePropertyObj: bgpRoutePropertyObj
        :param ipv4PrefixPoolObj: ipv4PrefixPoolObj
        :param address: address
        :param action: action
        :param uptime: uptime
        :param downtime: downtime
        :return:
        """
        if address in ipv4PrefixPoolObj.NetworkAddress.Values:
            addressIndex = (ipv4PrefixPoolObj.NetworkAddress.Values).index(address)
            enableFlappingValues = bgpRoutePropertyObj.EnableFlapping.Values
            enableFlappingValues[addressIndex] = str(action).lower()
            bgpRoutePropertyObj.EnableFlapping.ValueList(enableFlappingValues)
            UptimeValues = bgpRoutePropertyObj.Uptime.Values
            UptimeValues[addressIndex] = uptime
            bgpRoutePropertyObj.Uptime.ValueList(UptimeValues)
            DowntimeValues = bgpRoutePropertyObj.Downtime.Values
            DowntimeValues[addressIndex] = downtime
            bgpRoutePropertyObj.Downtime.ValueList(DowntimeValues)

    def bgp_routes_flap(self, port_list=None, IP_type='ipv4', action='False', uptime=0, downtime=0, address_list=None, **kwargs):
        """
        Enable/disable BGP routes flapping based on port_list and last_address_list

        :param port_list: list of port name. Default is None
        :param IP_type: 'ipv4' or 'ipv6'
        :param action: 'true' or 'false'
        :param uptime: uptime in seconds. Default is 0
        :param downtime: downtime in seconds. Default is 0
        :param address_list: list for start network address. Default is None
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, device_list list of devices
        :return: True on success else raises exception

        :Example: bgp_routes_flap(port_list=['Ethernet - 001'],action='true',uptime=0,downtime=0)
                  bgp_routes_flap(port_list=["Ethernet - 002"], IP_type='ipv6', action='True', address_list=["1001::1"])
                  bgp_routes_flap(device_list=["Device 1"],address_list=["10.1.1.1"], IP_type='ipv4', action='True', uptime=5, downtime=5)
        """
        self.log.info('BGP Route Flapping')
        device_list = kwargs.get('device_list',None)
        if (device_list and address_list and port_list == None) or (device_list and port_list and address_list):
            for device in device_list:
                for address in address_list:
                    if IP_type.lower() == "ipv4":
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():
                            for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                                if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime)
                    if IP_type.lower() == "ipv6":
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():
                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv6PrefixPoolObj,address,action,uptime,downtime)
                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
        if (device_list and address_list == None and port_list == None):
            for device in device_list:
                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').NetworkGroup.find():
                        if IP_type.lower() == "ipv4":
                            for bgpIpRoute in networkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        if IP_type.lower() == "ipv6":
                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                bgpRoutePropertyObj.Uptime.Single(uptime)
                                bgpRoutePropertyObj.Downtime.Single(downtime)
        if (device_list == None and port_list and address_list) or (device_list == None and port_list == None and address_list):
            for address in address_list:
                if IP_type.lower() == "ipv4":
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                        for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                            if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv4PrefixPoolObj, address, action, uptime, downtime)
                if IP_type.lower() == "ipv6":
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                        for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                            if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
                            if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
        if (port_list and device_list == None and address_list == None):
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in port_list if portName in vportNameList]
            for portName in portNameList:
                portName = '^' + portName.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                            if IP_type.lower() == "ipv4":
                                for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                                    if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
                            else:
                                for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                    if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
                                    if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
        if (port_list == None and address_list== None and device_list ==None):
            for device in self.ixNetwork.Topology.find().DeviceGroup.find():
                for group in device.find().NetworkGroup.find():
                    if IP_type.lower() == 'ipv4':
                        try:
                            for bgpIpRoute in group.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
                    if IP_type.lower() == "ipv6":
                        try:
                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
                        try:
                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def _get_dict_traffic_streams(self):
        """
        Get traffic streams mapped to streamblock

        :return: Dictionary of traffic streams
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        dictTrafficStreams = {}
        streamblockList = self.get_all_traffic_streams()
        for stream in streamblockList:
            streamblockName = stream.Name
            dictTrafficStreams[streamblockName] = stream
        return dictTrafficStreams

    def set_stream_mpls_label(self, cfg_dict, traffic_item_list=None):
        """
        Sets the MPLS label field to the specified value

        :param cfg_dict: The exp bit field value to be used.
        :param mpls_label_index: Mpls label index , default value is 0.
        :param traffic_item_list: A list of streamblocks to be modified. If None,
                set mplsbit for all streamblocks.
        :return: True if no exceptions were thrown

        :Example: set_stream_mpls_label(cfg_dict = {'valueType':'singleValue', 'value' : 20})
                  set_stream_mpls_label1(cfg_dict = {'valueType':'singleValue', 'value' : 20, 'mpls_label_index': 0 }, traffic_item_list= ['Traffic Item 1'])
        """
        self.log.info("Setting MPLS label for Traffic Items")
        if not 'mpls_label_index' in cfg_dict is None:
            cfg_dict['mpls_label_index'] = 0
        if traffic_item_list is None:
            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]
        for trafficName in traffic_item_list:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                try:
                    fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='label_value')
                    for index in range(len(fieldValue)):
                        if index == cfg_dict['mpls_label_index']:
                            try:
                                if cfg_dict['valueType'].lower() in ['increment', 'decrement']:
                                    fieldValue[index].ValueType = cfg_dict['valueType'].lower()
                                    fieldValue[index].StepValue = 1
                                    fieldValue[index].StartValue = cfg_dict['value']
                                else:
                                    fieldValue[index].ValueType = cfg_dict['valueType']
                                    fieldValue[index].SingleValue = cfg_dict['value']
                                result = True

                            except:
                                result = False
                except:
                    result = False
        return result

    def get_stream_mpls_label(self, traffic_item_list=None):
        """
        Gets the value of the MPLS headers exp field for the specified traffic items

        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.
        :return: A list of results containing the exp field value for the specified streams

        :Example: get_stream_mpls_label()
        """
        self.log.info("Getting MPLS EXP Bits For Traffic Items")
        results = []
        if traffic_item_list:
            for trafficName in traffic_item_list:
                try:
                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(
                        StackTypeId='mpls').Field.find(Name='mpls_exp'):
                        results.append(fieldValue.SingleValue)
                except:
                    self.log.info("MPLS Stack Not Available in %s" % trafficName)
                    raise IxiaOperationException("MPLS Stack Not Available in %s" % trafficName)
        else:
            try:
                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(
                            StackTypeId='mpls').Field.find(Name='mpls_exp'):
                    results.append(fieldValue.SingleValue)
            except:pass
        return results

    def get_traffic_transmission_mode(self, traffic_item_list=None, port='all'):
        """
        Returns the traffic transmission mode with respective values configured

        :param traffic_item_list: List of traffic items
        :param port: port on which traffic is generated
        :return: Dictionary of the traffic transmission mode configured

        :Example: get_traffic_transmission_mode()
        """
        self.log.info("Getting Traffic Transmission Mode")
        result = {}
        if traffic_item_list:
            for trafficName in traffic_item_list:
                result[trafficName] = self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).TransmitMode
        else:
            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                result[trafficItem.Name] = trafficItem.TransmitMode
        return result

    def _get_route_count(self, poolHandle, routeCount, prefixIp=None):
        """
        Get Route count based on Protocol handle.

        :param poolHandle: network pool handle
        :param routeCount: routecount
        :param prefixIp: Ip prefix value as reference
        :return:
        """
        if prefixIp:
            try:
                # This block for 9.0 version
                ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)
                routeCount = (poolHandle.NumberOfAddressesAsy.Values)[ipPrefixIndex]
            except:
                # This block for 8.50 version
                routeCount = poolHandle.NumberOfAddresses
                pass
        else:
            try:
                # This block for 9.0 version
                addressCountList = poolHandle.NumberOfAddressesAsy.Values
                routeCount = int(addressCountList[0]) + routeCount
            except:
                # This block for 8.50 version
                addressCount = poolHandle.NumberOfAddresses
                routeCount = routeCount + addressCount
                pass
        return routeCount

    def _get_isis_ospf_route_count(self, network_group, ports, ip_type, start_ip_prefix, protocol, router_id):
        """
        getting address count for protocols.
        :param network_group: Network Group for which Route Count should be modified
        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: ipv4/ipv6 perfix ip
        :param protocol: ISIS/OSPF
        :param router_id: router ID
        :return: result
        """
        route_count = 0
        protocol_status = False
        deviceGroupName = None
        if (network_group and start_ip_prefix and router_id) or (
                network_group is None and start_ip_prefix and router_id):
            networkGroupNameList = []
            if "." in router_id and protocol.lower() != 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if "." not in router_id and protocol.lower() == 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.Name == router_id:
                        deviceGroupName = router_id
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            else:
                try:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group:
                            if network_group in networkGroup.Name:
                                networkGroupNameList.append(networkGroup.Name)
                                break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        protocol_status = True
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        protocol_status = True
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if (network_group and start_ip_prefix is None and ports is None and router_id) or (
                network_group is None and start_ip_prefix is None and router_id):
            if "." in router_id:
                if protocol == "ISIS":
                    raise IxiaConfigException("ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')")
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                            # networkGroupNameList = networkGroupNameList
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]

            else:
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + router_id + '$').NetworkGroup.find()]

            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if network_group and ports is None and start_ip_prefix is None and router_id is None:
            networkGroupNameList = []
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                for networkGroupObj in deviceGroupObj.NetworkGroup.find():
                    if network_group in networkGroupObj.Name:
                        networkGroupNameList.append(networkGroupObj.Name)
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):
                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv4PoolObj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv4PoolObj,route_count)
                                if protocol == "OSPF":
                                    if ipv4PoolObj.OspfRouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv4PoolObj,route_count)
                    else:
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):
                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv6PoolObj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv6PoolObj,route_count)
                                if protocol == "OSPF":
                                    if ipv6PoolObj.Ospfv3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv6PoolObj,route_count)
            else:
                raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'" % (network_group,ip_type))
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            for port in ports:
                if port in vportNameList:
                    for topologyObj in self.ixNetwork.Topology.find():
                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                            if ip_type.lower() == "ipv4":
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv4PoolObj.IsisL3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv4PoolObj,route_count)
                                        if protocol == "OSPF":
                                            if ipv4PoolObj.OspfRouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv4PoolObj,route_count)
                            else:
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv6PoolObj.IsisL3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv6PoolObj,route_count)
                                        if protocol == "OSPF":
                                            if ipv6PoolObj.Ospfv3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv6PoolObj,route_count)
        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (
                start_ip_prefix and network_group and ports is None and router_id is None):
            networkGroupNameList = []
            if network_group and start_ip_prefix:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if
                                        network_group in networkObj.Name]
                # This condition for compact version
                if networkGroupNameList == []:
                    networkGroupNameList = [networkObj.Name for networkObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]

            if start_ip_prefix and network_group is None:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.OspfRouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
                    else:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.Ospfv3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
        if protocol_status and route_count != 0:
            return route_count
        else:
            raise IxiaConfigException("%s protocol not configured or Configuration issue." % protocol)

    def get_isis_route_count(self,router_id=None, ip_type="ipv4", lsp_id=None, start_ip_prefix=None, **kwargs):
        """
        Get the route count for ISIS protocol.

        :param router_id: It's mandatory value for spirent and represents the Router ID of the router.
        :param ip_type: String demonstrating the IP version
        :param lsp_id: It's optional value specific to Spirent and represents the LSP Name.
        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                        For IXIA, network_group has to be included in the kwargs
                        as a mandatory parameter and ports is optional
        :return: route count value/dictionary.

        :Example: get_isis_route_count(network_group='Network Group 8',ip_type="ipv4")
        """
        self.log.info("Getting ISIS Route Count")
        ports = kwargs.get('ports', None)
        network_group = kwargs.get('network_group', None)
        if router_id:
            if "." in router_id:
                router_id = None
        if not network_group and start_ip_prefix is None and router_id is None and ports is None:
            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')
        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol="ISIS",router_id=router_id)
        return routeCount

    def get_ospf_route_count(self, router_id, ip_type="ipv4", lsa_id=None, start_ip_prefix=None, **kwargs):
        """
        Get the route count for OSPF protocol.

        :param router_id: It's mandatory value and represents the Router ID of the router.
        :param ip_type: String demonstrating the IP version
        :param lsa_id: It's optional value specific to Spirent and represents the LSA Name.
        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                        For IXIA, network_group has to be included in the kwargs
                        as a mandatory parameter and ports is optional
        :return: route count value/dictionary.

        :Example: get_ospf_route_count(router_id="192.0.0.1",ip_type="ipv6",network_group='Network Group 2'))
        """
        self.log.info("Getting OSPF Route Count")
        ports = kwargs.get('ports')
        network_group = kwargs.get('network_group', None)
        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol="OSPF",router_id=router_id)
        return routeCount

    def verify_dhcp_client_bound_count(self, client_dict):
        """
        To verify number of DHCP sessions currently bound to the interface/device

        :param client_dict: {'device1':{'protocol': 'ipv4', 'total_bound_count':'100', 'current_bound_count':'10'}}
        :return: True if successful

        :Example: verify_dhcp_client_bound_count(client_dict={'Device Group 23':{'protocol': 'ipv4', 'total_bound_count':10, 'current_bound_count':10}})
        """
        self.log.info("Verifying DHCP Client Bound Count")
        error_flag = False
        err_msg = ""
        for device in client_dict:
            protocol = client_dict[device]['protocol']
            totalBoundCount, currentBoundCount = self.get_dhcp_client_bound_count(device, protocol)

            expectedTotalBoundCount = client_dict[device]['total_bound_count']
            expectedCurrentBoundCount = client_dict[device]['current_bound_count']

            if totalBoundCount == expectedTotalBoundCount and \
                    currentBoundCount == expectedCurrentBoundCount:
                log.info('Actual and expected bound count for client/device %s match' % device)
            else:
                error_flag = True
                err_msg += 'For device %s:\n' % device
                err_msg += 'Actual values: (totalBoundCount)=%s, (currentBoundCount)=%s \n' \
                           % (totalBoundCount, currentBoundCount)
                err_msg += 'Expected values: (totalBoundCount)=%s, (currentBoundCount)=%s\n\n' \
                           % (expectedTotalBoundCount, expectedCurrentBoundCount)

        if error_flag:
            raise CafyException.VerificationError(err_msg)

        return True

    def ospf_start(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):
        """
        To start OSPFv2/OSPFv3 emulation

        :param version: Version
        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts
        :param devices: Name of the devices in the config
        :return: True on success. raise exception if False/error

        :Example: ospf_start(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])
        """
        self.log = CafyLog('Starting OSPF protocol')
        action = 'Start'
        protocol = []
        if version.lower() not in ('v2', 'v3'):
            CafyException.InvalidValueError('%s not a valid OSPF version' % version)
        protocol.append('ospf' + version)
        nested_device = kwargs.get('nested_device', None)
        self._start_stop_protocols(protocol, port, host_ip, "Start", "True", devices, nested_device)
        return True

    def ospf_stop(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):
        """
        To start OSPFv2/OSPFv3 emulation

        :param version: Version
        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts
        :param devices: Name of the devices in the config
        :return: True on success. raise exception if False/error

        :Example: ospf_stop(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])
        """
        self.log = CafyLog('Starting OSPF protocol')
        action = 'Stop'
        protocol = []
        if version.lower() not in ('v2', 'v3'):
            CafyException.InvalidValueError('%s not a valid OSPF version' % version)
        protocol.append('ospf' + version)
        nested_device = kwargs.get('nested_device', None)
        self._start_stop_protocols(protocol, port, host_ip, "Stop", "False", devices, nested_device)
        return True
    
    def _igmp_configure(self, igmp_group_start, count, step, prefix, group_name=None, match_all=True, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name: Device group name (optional)
        :param igmp_group_start: IGMP host start address
        :param count: Group address count
        :param step: Group address increment
        :param prefix: IGMP Prefix
        :param match_all: If True, match exact group name
                        If False, match names like "<group_name> 1", "<group_name> 2", etc.
                        (not ones like "<group_name>_VRF")
        """
        result = False
        value_type = kwargs.get('value_type', 'increment')
        no_group_ranges = kwargs.get('no_group_ranges', 1)
        custom_count = kwargs.get('custom_count', 1)
        custom_step = kwargs.get('custom_step', step)

        if group_name:
            self.log.info(f"Configuring IGMP host : {group_name}")
            if match_all == False:
                # exact match
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=f"^{re.escape(group_name)}$")
            elif match_all == True:
                # partial match numeric suffix
                all_hosts = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find()
                pattern = re.compile(rf"^{re.escape(group_name)}(\s*\d+)?$", re.IGNORECASE)
                device_objs = [igmp for igmp in all_hosts if pattern.match(igmp.Name or "")]
        elif 'device_name' in kwargs:
            device_objs = self.ixNetwork.Topology.find() \
                .DeviceGroup.find(Name=kwargs['device_name']).Ethernet.find().Ipv4.find().IgmpHost.find()
            
        for igmp_host_obj in device_objs:
            if 'device' not in kwargs:
                if igmp_group_start and step:
                    igmp_host_obj.NoOfGrpRanges = no_group_ranges
                    if value_type.lower() == 'custom':
                        igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Custom(
                            start_value=igmp_group_start,
                            step_value=step,
                            increments=[(custom_step, custom_count, [])]
                        )
                    else:
                        igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Increment(
                            start_value=igmp_group_start,
                            step_value=step
                        )
                elif igmp_group_start and not step:
                    igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Single(igmp_group_start)

            if 'device' in kwargs:
                device_id = kwargs['device']
                if count:
                    mcast_grp_list = igmp_host_obj.IgmpMcastIPv4GroupList
                    group_count_list = mcast_grp_list.McastAddrCnt.Values
                    group_count_list[device_id - 1] = count
                    mcast_grp_list.McastAddrCnt.ValueList(group_count_list)
                if igmp_group_start:
                    mcast_start_list = igmp_host_obj.IgmpMcastIPv4GroupList
                    start_addr_list = mcast_start_list.StartMcastAddr.Values
                    start_addr_list[device_id - 1] = igmp_group_start
                    mcast_start_list.StartMcastAddr.ValueList(start_addr_list)
            else:
                igmp_host_obj.IgmpMcastIPv4GroupList.McastAddrCnt.Single(count)

            if 'igmp_version' in kwargs:
                igmp_host_obj.VersionType.Single(kwargs['igmp_version'])

            result = True

        if result:
            self.log.info("Multicast group successfully configured")
            return result
        else:
            raise IxiaConfigException(f"Passed invalid group name {group_name}")

    def _mld_configure(self, mld_group_start, count, step, prefix, group_name=None, match_all1=True, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name: MLD host group name (optional)
        :param mld_group_start: MLD host start address
        :param count: Group address count
        :param step: Group address increment
        :param prefix: 128 for IPv6
        :param match_all1: If True, match exact group name
                        If False, match names like "<group_name> 1", "<group_name> 2", etc.
                        (not ones like "<group_name>_VRF")
        """
        result = False
        value_type = kwargs.get('value_type', 'increment')
        no_group_ranges = kwargs.get('no_group_ranges', 1)
        custom_count = kwargs.get('custom_count', 1)
        custom_step = kwargs.get('custom_step', step)

        if group_name:
            self.log.info(f"Configuring MLD host : {group_name}")
            if match_all1 is False:
                # exact match
                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=f"^{re.escape(group_name)}$")
            else:
                # partial match with optional numeric suffix
                all_hosts = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find()
                pattern = re.compile(rf"^{re.escape(group_name)}(\s*\d+)?$", re.IGNORECASE)
                device_objs = [mld for mld in all_hosts if pattern.match(mld.Name or "")]
        elif 'device_name' in kwargs:
            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=kwargs['device_name']).Ethernet.find().Ipv6.find().MldHost.find()
        else:
            device_objs = []

        for mld_host_obj in device_objs:
            if 'device' not in kwargs:
                if mld_group_start and step:
                    mld_host_obj.NoOfGrpRanges = no_group_ranges
                    if value_type.lower() == 'custom':
                        mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Custom(
                            start_value=mld_group_start,
                            step_value=step,
                            increments=[(custom_step, custom_count, [])]
                        )
                    else:
                        mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Increment(
                            start_value=mld_group_start,
                            step_value=step
                        )
                elif mld_group_start and not step:
                    mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Single(mld_group_start)

            if 'device' in kwargs:
                device_id = kwargs['device']
                if count:
                    mcast_grp_list = mld_host_obj.MldMcastIPv6GroupList
                    group_count_list = mcast_grp_list.McastAddrCnt.Values
                    group_count_list[device_id - 1] = count
                    mcast_grp_list.McastAddrCnt.ValueList(group_count_list)
                if mld_group_start:
                    start_addr_list = mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Values
                    start_addr_list[device_id - 1] = mld_group_start
                    mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.ValueList(start_addr_list)
            else:
                mld_host_obj.MldMcastIPv6GroupList.McastAddrCnt.Single(count)

            if 'mld_version' in kwargs:
                mld_host_obj.VersionType.Single(kwargs['mld_version'])

            result = True
        if result:
            self.log.info("MLD multicast group successfully configured")
            return result
        else:
            raise IxiaConfigException(f"Passed invalid group name {group_name}")

    def _pimv4_configure(self, group_name, pimv4_group_start, count, step, prefix, match_all1=True, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name:Device group name
        :param ip_version: IP Version
        :param pimv4_group_start:pimv4 host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: PIMv4 Prefix
        """
        result = False
        self.log.info(f"Configuring PIMv4 group : {group_name}")

        if match_all1 is False:
            # exact match
            pim_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find(Name=f"^{re.escape(group_name)}$")
        else:
            # partial match numeric suffix only
            all_pims = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find()
            pattern = re.compile(rf"^{re.escape(group_name)}(\s*\d+)?$", re.IGNORECASE)
            pim_objs = [pim for pim in all_pims if pattern.match(pim.Name or "")]

        for pimv4Obj in pim_objs:
            if 'device' not in kwargs:
                if pimv4_group_start and step:
                    pimv4Obj.PimV4JoinPruneList.GroupV4Address.Increment(
                        start_value=pimv4_group_start, step_value=step)
                elif pimv4_group_start and not step:
                    pimv4Obj.PimV4JoinPruneList.GroupV4Address.Single(pimv4_group_start)

            if 'device' in kwargs:
                device_id = kwargs['device']
                if count:
                    mcastGrpList = pimv4Obj.PimV4JoinPruneList
                    group_count_list = mcastGrpList.GroupAddressCount.Values
                    group_count_list[device_id - 1] = count
                    mcastGrpList.GroupAddressCount.ValueList(group_count_list)
                if pimv4_group_start:
                    group_start_list = mcastGrpList.GroupV4Address.Values
                    group_start_list[device_id - 1] = pimv4_group_start
                    mcastGrpList.GroupV4Address.ValueList(group_start_list)
            else:
                pimv4Obj.PimV4JoinPruneList.GroupAddressCount.Single(count)

            result = True

        if result:
            self.log.info("PIMv4 multicast group successfully configured")
            return result
        else:
            raise IxiaConfigException(f"Passed invalid group name {group_name}")

    def _pimv6_configure(self, group_name, pimv6_group_start, count, step, prefix, match_all1=True, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name:Device group name
        :param ip_version: IP Version
        :param pimv4_group_start:pimv4 host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: PIMv4 Prefix
        """
        result = False
        self.log.info(f"Configuring PIMv6 group : {group_name}")

        if match_all1 is False:
            # exact match
            pim_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find(Name=f"^{re.escape(group_name)}$")
        else:
            # partial match numeric suffix only
            all_pims = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find()
            pattern = re.compile(rf"^{re.escape(group_name)}(\s*\d+)?$", re.IGNORECASE)
            pim_objs = [pim for pim in all_pims if pattern.match(pim.Name or "")]

        for pimv6Obj in pim_objs:
            if 'device' not in kwargs:
                if pimv6_group_start and step:
                    pimv6Obj.PimV6JoinPruneList.GroupV6Address.Increment(
                        start_value=pimv6_group_start, step_value=step)
                elif pimv6_group_start and not step:
                    pimv6Obj.PimV6JoinPruneList.GroupV6Address.Single(pimv6_group_start)

            if 'device' in kwargs:
                device_id = kwargs['device']
                if count:
                    mcastGrpList = pimv6Obj.PimV6JoinPruneList
                    group_count_list = mcastGrpList.GroupAddressCount.Values
                    group_count_list[device_id - 1] = count
                    mcastGrpList.GroupAddressCount.ValueList(group_count_list)
                if pimv6_group_start:
                    group_start_list = mcastGrpList.GroupV6Address.Values
                    group_start_list[device_id - 1] = pimv6_group_start
                    mcastGrpList.GroupV6Address.ValueList(group_start_list)
            else:
                pimv6Obj.PimV6JoinPruneList.GroupAddressCount.Single(count)

            result = True

        if result:
            self.log.info("PIMv6 multicast group successfully configured")
            return result
        else:
            raise IxiaConfigException(f"Passed invalid group name {group_name}")

    def config_multicast_group(self, ip_version, start_ip='', count='', step='',
                               prefix='', group_name=None, **kwargs):
        """
        Config ipv4/ipv6 multi cast group

        :param group_name: igmp group name
        :param ip_version: IP version of multicast group
        :param start_ip: Starting IP address of the group
        :param count: Number of Groups
        :param step: Increment step in case of more that one group
        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)
        :param kwargs :
                protocol: Multicast protocol to config Ex igmp/mld/pimv4/pimv6
        :return: True on Success

        :Example: config_multicast_group('ipv6',group_name='MLD Host 2',start_ip='ff03::2', count='13',mld_version='version1')
        """
        self.log.info("Configuring Multicast Group")
        match_all = kwargs.get("match_all",True)
        device_name = kwargs.get('device_name')
        if group_name is None and device_name is None:
            raise IxiaOperationException("Multicast group name or device name not provided by user")
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")
        if ip_version.lower() == 'ipv4':
            protocol = kwargs.get('protocol', 'igmp')
            if protocol.lower() == 'igmp':
                self._igmp_configure(start_ip, count, step, prefix, group_name ,match_all = match_all,**kwargs)
            if protocol.lower() == 'pimv4':
                self._pimv4_configure(group_name, start_ip, count, step, prefix,match_all1 = match_all, **kwargs)

        if ip_version.lower() == 'ipv6':
            protocol = kwargs.get('protocol', 'mld')
            if protocol.lower() == 'mld':
                self._mld_configure(start_ip, count, step, prefix,group_name,match_all1 = match_all, **kwargs)
            if protocol.lower() == 'pimv6':
                self._pimv6_configure(group_name, start_ip, count, step, prefix,match_all1 = match_all, **kwargs)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def ldp_neighbor_flap(self, ldp_peer_name_list, action='True'):
        """
        Enable/disable LDP on interfaces and also starts/stops LDP protocol
        Flapping LDP router and LDP connected Interface

        :param ldp_peer_name_list: LDP device name List
        :param action: string format. Not boolean
                       'True' = enable LDP flap
                       'False' = disable LDP flap
        :return: True on success else raise exception.

        :Example: ldp_neighbor_flap(['Device 1','Device 2'],action='false')
        """
        self.log.info("Performing LDP neighbor flap")
        if not isinstance(ldp_peer_name_list, list):
            msg = 'ldpPeerNameList type can not be %s. It should be a list' \
                  % type(ldp_peer_name_list)
            raise TypeError(msg)
        if action.lower() == 'true':
            protocolAction = 'Start'
        else:
            protocolAction = 'Stop'
        for ldpRouter in ldp_peer_name_list:
            try:
                for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=ldpRouter):
                    if deviceObj.LdpBasicRouter.find():
                        ldpv4Obj = deviceObj.LdpBasicRouter.find()
                        ldpv4Obj.Active.Single(action.lower())
                        eval('ldpv4Obj.find().' + protocolAction + '()')
                    if deviceObj.LdpBasicRouterV6.find():
                        ldpv6Obj = deviceObj.LdpBasicRouterV6.find()
                        ldpv6Obj.Active.Single(action.lower())
                        eval('ldpv6Obj.find().' + protocolAction + '()')
                    if deviceObj.Ethernet.find().Ipv4.find():
                        ipv4Obj = deviceObj.Ethernet.find().Ipv4.find()
                        if ipv4Obj.find().LdpBasicRouter.find():
                            eval('ipv4Obj.find().LdpBasicRouter.find().Active.Single(action.lower())')
                            eval('ipv4Obj.find().LdpBasicRouter.find().' + protocolAction + '()')
                        if ipv4Obj.find().LdpConnectedInterface.find():
                            eval('ipv4Obj.find().LdpConnectedInterface.find().Active.Single(action.lower())')
                            eval('ipv4Obj.find().LdpConnectedInterface.find().' + protocolAction + '()')
                    if deviceObj.Ethernet.find().Ipv6.find():
                        ipv6Obj = deviceObj.Ethernet.find().Ipv6.find()
                        if ipv6Obj.find().LdpBasicRouterV6.find():
                            eval('ipv6Obj.find().LdpBasicRouterV6.find().Active.Single(action.lower())')
                            eval('ipv6Obj.find().LdpBasicRouterV6.find().' + protocolAction + '()')
                        if ipv6Obj.find().Ldpv6ConnectedInterface.find():
                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().Active.Single(action.lower())')
                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().' + protocolAction + '()')
            except:
                raise IxiaOperationException("LDP flap failed")
        try:
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        except:
            pass
        return True

    def start_arp_on_streams(self, ports=()):
        """
        Starts ARP on all the streams under specified ports

        :param ports: port or list of ports Default all ports
        :return: True on success
        :Example: start_arp_on_streams()
        """
        self.log.info("Starting ARP at stream level")
        traffic_items_port_dict = {}
        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):
                with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')
                traffic_item_list = getattr(traffic_item.results, 'trafficItem')
                for traffic_item in traffic_item_list:
                    stream_list = traffic_item.HighLevelStream.find()
                    for count, stream in enumerate(stream_list):
                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)
                is_traffic_item = True
            else:
                self.log.warning('No Raw Traffic Streams in the configuration')
                return False
        else:
            with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                self.ixNetwork.Traffic.TrafficItem.find()
            is_traffic_item = False
            traffic_item_list = getattr(traffic_item.results, 'trafficItem')
            for traffic_item in traffic_item_list:
                stream_list = traffic_item.HighLevelStream.find()
                for count, stream in enumerate(stream_list):
                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)

        vport_dest_mac_dict = {}
        vports = [vport.href for vport in self.ixNetwork.Vport.find()]

        for vport in vports:
            dest_gateway_mac = []
            for topology in self.ixNetwork.Topology.find():
                if topology.Ports[0] == vport:
                    try:
                        ipv4_block = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()
                        for each_ipv4_block in ipv4_block:
                            each_ipv4_block_mac = list(
                                filter(lambda ipv4_mac: None if ipv4_mac == 'removePacket[Unresolved]' else ipv4_mac,
                                       each_ipv4_block.ResolvedGatewayMac))
                            dest_gateway_mac.extend(each_ipv4_block_mac)

                        ipv6_block = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()
                        for each_ipv6_block in ipv6_block:
                            each_ipv6_block_mac = list(
                                filter(lambda ipv6_mac: None if ipv6_mac == 'removePacket[Unresolved]' else ipv6_mac,
                                       each_ipv6_block.ResolvedGatewayMac))
                            dest_gateway_mac.extend(each_ipv6_block_mac)
                    except:
                        self.log.warning('Mac address collection failed')
            if dest_gateway_mac:
                vport_dest_mac_dict[vport] = dest_gateway_mac[0]

        if vport_dest_mac_dict:
            traffic_name_mac_mapping = {}
            for traffic_item_name in traffic_items_port_dict:
                try:
                    for flow in traffic_items_port_dict[traffic_item_name]:
                        traffic_name_mac_mapping.setdefault(traffic_item_name, []).append(vport_dest_mac_dict[flow])
                except:
                    pass
            try:
                if is_traffic_item:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').ConfigElement.find()
                            for count, config_element in enumerate(config_element_list):
                                if config_element.Stack.find(DisplayName='Ethernet II'):
                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        existing_mac = None
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,
                                                                                                         'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field,
                                                                                                        'SingleValue',
                                                                                                        None)
                                        except Exception:
                                            existing_mac = None

                                        if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                            skip = True
                                        else:
                                            try:
                                                ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')
                                                ipv4_field = None
                                                if ipv4_stackobj and ipv4_stackobj.href:
                                                    ipv4_field = ipv4_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')
                                                ipv6_field = None
                                                if ipv6_stackobj and ipv6_stackobj.href:
                                                    ipv6_field = ipv6_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                for ip_field in [ipv4_field, ipv6_field]:
                                                    if ip_field and ip_field.StartValue:
                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:
                                                            skip = True
                                            except Exception:
                                                pass
                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})")
                                            continue

                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
                else:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').HighLevelStream.find()
                            for count, high_stream in enumerate(high_stream_list):
                                if high_stream.Stack.find(DisplayName='Ethernet II'):
                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,
                                                                                                         'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field,
                                                                                                        'SingleValue',
                                                                                                        None)
                                        except Exception:
                                            existing_mac = None

                                        if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                            skip = True
                                        else:
                                            try:

                                                ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')
                                                ipv4_field = None
                                                if ipv4_stackobj and ipv4_stackobj.href:
                                                    ipv4_field = ipv4_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')
                                                ipv6_field = None
                                                if ipv6_stackobj and ipv6_stackobj.href:
                                                    ipv6_field = ipv6_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                for ip_field in [ipv4_field, ipv6_field]:
                                                    if ip_field and ip_field.StartValue:
                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:
                                                            skip = True
                                            except Exception:
                                                pass
                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac}) ")
                                            continue
                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
            except Exception as err_msg:
                self.log.error(f'MAC Update failed in Traffic streams {err_msg}')
                return False
            self.log.info('Starting ARP on Streams is done')
            return True
        else:
            self.log.error("Ip stack is down")
            return False

    def get_port_traffic_streams(self, port):
        """
        Get Traffic stream list with respect to port

        :param port: Port(source) under which streams are created
        :return: Stream list for the given port

        :Example: get_port_traffic_streams('10.39.65.156/2/1')
        """
        self.log.info("Getting Traffic Streams based on Port")
        trafficItemsPortDict = {}
        streamList = []
        if port:
            for vport in self.ixNetwork.Vport.find():
                if vport.AssignedTo.replace(":", "/") == port:
                    port = vport.Name
        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                if trafficItem.FlowGroupCount > 0:
                    trafficItemsPortDict[trafficItem.Name] = trafficItem.HighLevelStream.find()[0].TxPortId
                else:
                    streamList.append(trafficItem.Name)
        else:
            for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
                trafficItemsPortDict[quickFlow.Name] = quickFlow.TxPortId

        portHref = self.ixNetwork.Vport.find(Name=port).href
        for traffic in trafficItemsPortDict:
            if trafficItemsPortDict[traffic] == portHref:
                streamList.append(traffic)
        if not streamList:
            self.log.warning(f"No Traffic Streams found on {port}")
        self.log.info(streamList)
        return streamList

    def get_multicast_group(self, ip_version, group_name):
        """
        Get Multicast's group network block config

        :param ip_version: IP version of multi-cast group
        :param group_name: Multicast's group name
        :return: Network block config in Multicast group

        :Example: get_multicast_group('ipv4','IGMP Host 2')
        """
        self.log.info("Getting Multicast Group")
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid ip version")
        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}

        groupConfig = {}
        try:
            if ip_version.lower() == 'ipv4':
                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.StartMcastAddr
                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrIncr
                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrCnt
            else:
                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)
                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.StartMcastAddr
                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrIncr
                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrCnt
        except:
            raise IxiaOperationException("%s not configured on %s' %(protocol.upper(), device)")

        return groupConfig

    def add_stream_header(self, traffic_item, headerType, headerName):
        """
        Add specific header to a trafficItem/stream

        :param traffic_item: Stream name for which header should be configured
        :param headerType: Type of header
                           Example: "DHCP", "MPLS"
        :param headerName: Header name which should be configured
                           Example: "DhcpClientMsg", "DhcpServerMsg"
                                    "icmp0"   - ICMP Msg Types: 0,8,13,14,15,16
                                    "icmp3"   - ICMP Msg Types: 3,4,5,11,12
                                    "icmp9"   - ICMP Msg Type: 9
                                    "icmpv6"  - ICMPV6, "igmv1" - IGMPv1, "igmpv2" - IGMPv2
                                    "igmpv3q" - IGMPv3 Membership Query
                                    "igmpv3r" - IGMPv3 Membership Report
        :return: True if header is configured else raise exception

        :Example: add_stream_header('Traffic Item 2','ICMP', 'icmp3')
                  add_stream_header('Traffic Item 1','MPLS','mpls')
                  add_stream_header('Traffic Item 2','IGMP', 'igmpv2')
        """
        self.log.info("Adding Stream Header")
        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)
        # add all supported header types and corresponding layer info to headerToLayerMapping dict
        # headerToLayerMapping = {'DHCP':'L5','IPV4':'L3','IPV6':'L3','TCP':'L4','UDP':'L4','ICMP':'L3'}
        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)
        configElement = trafficItem.ConfigElement.find()[0]
        stackIndex = configElement.find().Stack.find().index
        stackTop = configElement.Stack.find()[stackIndex - 1]
        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
        tcpStack = configElement.Stack.find(StackTypeId='^tcp$')
        udpStack = configElement.Stack.find(StackTypeId='^udp$')
        ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
        ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
        if not streamObj:
            raise IxiaConfigException("stream not found")
        try:
            if headerType.upper() == 'IPV4':
                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv4Template))
            elif headerType.upper() == 'IPV6':
                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6Template))
            elif headerType.upper() == 'DHCP' and not configElement.Stack.find(StackTypeId='^dhcp$'):
                dhcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^dhcp$")
                if tcpStack:
                    configElement.Stack.read(tcpStack.AppendProtocol(dhcpTemplate))
                elif udpStack:
                    configElement.Stack.read(udpStack.AppendProtocol(dhcpTemplate))
                else:
                    configElement.Stack.read(ipv4Stack.AppendProtocol(dhcpTemplate))
                if re.search('dhcpserver', headerName, re.IGNORECASE):
                    configElement.Stack.find(DisplayName='DHCP').Field.find(
                        DisplayName='Message op code').FieldValue = 'BOOTREPLY'
                if re.search('dhcpclient', headerName, re.IGNORECASE):
                    configElement.Stack.find(DisplayName='DHCP').Field.find(
                        DisplayName='Message op code').FieldValue = 'BOOTREQUEST'
            elif headerType.upper() == 'IGMP':
                igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmp$")
                if headerName.upper() == 'IGMPV1':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv1$")
                if headerName.upper() == 'IGMPV2':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv2$")
                if headerName.upper() == 'IGMPV3R':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv3MembershipReport$")
                if headerName.upper() == 'IGMPV3Q':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv3MembershipQuery$")
                configElement.Stack.read(stackTop.AppendProtocol(igmpTemplate))
            elif headerType.upper() == 'ICMP':
                icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmp$")
                if headerName.upper() == 'ICMP3':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv1$")
                if headerName.upper() == 'ICMP0':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv2$")
                if headerName.upper() == 'ICMP9':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv9$")
                if headerName.upper() == 'ICMPV6':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv6$")
                configElement.Stack.read(stackTop.AppendProtocol(icmpTemplate))
            elif headerType.upper() == 'MPLS':
                mplsTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^mpls$")
                configElement.Stack.read(stackTop.AppendProtocol(mplsTemplate))
            elif headerType.upper() == "OSPFV2" and not configElement.Stack.find(StackTypeId='^ospfv2$'):
                if re.search('ospfv2 Hello Packet', headerName, re.IGNORECASE):
                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ospfv2Hello$")
                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))
            elif headerType.upper() == "OSPFV3" and not configElement.Stack.find(StackTypeId='^ospfv3$'):
                if re.search('ospfv3 Hello', headerName, re.IGNORECASE):
                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="ospfv3Hello")
                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))
            elif headerType.upper() == "CUSTOM" and not configElement.Stack.find(StackTypeId='^custom$'):
                if re.search('Custom', headerName, re.IGNORECASE):
                    customTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^custom$")
                    configElement.Stack.read(stackTop.AppendProtocol(customTemplate))
            elif headerType.upper() == 'VLAN':
                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                configElement.Stack.read(stackTop.AppendProtocol(vlanTemplate))
            elif headerType.upper() == 'IPV6FRAGMENT':
                ipv6FragmentTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Fragment$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6FragmentTemplate))
            elif headerType.upper() == 'GRE':
                greTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^gre$")
                configElement.Stack.read(stackTop.AppendProtocol(greTemplate))
            elif headerType.upper() == 'L2TP':
                l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2tpv3$")
                if headerName.upper() == 'L2TPV3IPC':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3ControlIP$")
                if headerName.upper() == 'L2TPV3IPD':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3DataIP$")
                if headerName.upper() == 'L2TPV3UDPC':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3ControlUDP$")
                if headerName.upper() == 'L2TPV3UDPD':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3DataUDP$")
                configElement.Stack.read(stackTop.AppendProtocol(l2tpv3Template))
            elif headerType.upper() == 'IPV6ROUTE':
                ipv6RoutingTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Routing$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6RoutingTemplate))
            elif headerType.upper() == 'IPV6AUTH':
                ipv6AuthTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Authentication$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6AuthTemplate))
            else:
                protocolTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId='^' + headerType.lower() + '$')
                configElement.Stack.read(stackTop.AppendProtocol(protocolTemplate))
        except:
            raise IxiaConfigException("Adding header failed")
        return True

    def add_multicast_group(self, ip_version, group_name='', start_ip='', count='', step='',
                            prefix='', **kwargs):
        """
        Create ipv4/ipv6 multi cast group

        :param ip_version: IP version of multicast group
        :param group_name: User defined group name
        :param start_ip: Starting IP address of the group
        :param count: Number of Groups
        :param step: Increment step in case of more that one group
        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)
        :param group_name: User defined group name
        :return: Unique Group name

        :Example: add_multicast_group('ipv4',group_name='IGMP Host 1',start_ip='227.0.0.0', count='13',igmp_version='version2',deviceName='Device Group 13')
        """
        self.log.info("Adding Multicast Group")
        deviceName = kwargs.get('deviceName')
        igmp_version = kwargs.get('igmp_version','version3')
        mld_version = kwargs.get('mld_version','version2')
        if not deviceName:
            raise IxiaOperationException("Device name is must for IXIA")
        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+deviceName+'$').Stop
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")
        if not group_name:
            group_name = ip_version + 'group'
        if ip_version.lower() == 'ipv4':
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^'+deviceName+'$').Ethernet.find().Ipv4.find().IgmpHost.add(Name=group_name)
                if start_ip or count or step:
                    self.config_multicast_group('ipv4', group_name=group_name, start_ip=start_ip, count=count,igmp_version=igmp_version)
            except:
                raise IxiaOperationException("Not able to configure igmp multicast group")
        if ip_version.lower() == 'ipv6':
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^'+deviceName+'$').Ethernet.find().Ipv6.find().MldHost.add(Name=group_name)
                if start_ip or count or step:
                    self.config_multicast_group('ipv6', group_name=group_name, start_ip=start_ip, count=count,mld_version=mld_version)
            except:
                raise IxiaOperationException("Not able to configure mld multicast group")
        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceName + '$').Start
        return group_name

    def get_stream_header(self, traffic_items='all'):
        """
        Get the dictionary of headers configured for a stream

        :param traffic_items: List of stream names whose headers should be retrieved
        :return: Dictionary of Stream headers

        :Example: get_stream_header(['Traffic Item 4'])
        """
        streamList = self.ixNetwork.Traffic.TrafficItem.find()
        if traffic_items != 'all':
            if type(traffic_items) not in (list, tuple):
                traffic_items = [traffic_items]
        result = {}
        for streamName in traffic_items:
            streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=streamName)
            headers = streamObj.ConfigElement.find().Stack.find()
            update_headers = []
            for header in headers:
                update_headers.append(header.DisplayName)
            for headerName in update_headers:
                fields = streamObj.ConfigElement.find().Stack.find(DisplayName=headerName).Field.find()
                fieldNames = re.findall('DisplayName: (.*)', str(fields))
                fieldValues = re.findall('FieldValue: (.*)', str(fields))
                result[headerName] = list(zip(fieldNames, fieldValues))
        return result

    def config_igmp_group_member(self, router_id , mcast_group_config, mcast_source_config, **kwargs):
        """
        Allows user to change source count/list for device configured with IGMP_V3 and
        group count/list for device configured with IGMP_V2 or IGMP_V3

        :param router_id: NA for IXIA
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param kwargs: optional
        :return: True on Success

        :Example: config_igmp_group_member("192.0.0.1",{'count':'2'},{'count':'2'},device_name ='Device Group 27')
        """
        deviceName = kwargs.get("device_name",None)
        if deviceName is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Configuring multicast group {0}".format(deviceName))
        try:
            self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'igmp')
        except:
            raise IxiaOperationException("igmp host not configured for the device group provided")

        return True

    def config_mld_group_member(self, router_id, mcast_group_config, mcast_source_config, **kwargs):
        """
        Allows user to change source count/list for device configured with IGMP_V3 and
        group count/list for device configured with IGMP_V2 or IGMP_V3

        :param router_id: NA for IXIA
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param kwargs: device_name - Mandatory for IXIA
        :return: True on Success

        :Example: config_mld_group_member("192.0.0.1",{'count':'3'},{'count':'3'},device_name= 'Device Group 7')
        """
        deviceName = kwargs.get("device_name",None)
        if deviceName is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Configuring multicast group {0}".format(deviceName))
        try:
            self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()
        except:
            raise IxiaOperationException("igmp host not configured for the device group provided")
        self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'mld')

        return True

    def _config_group_member(self, device_name, mcast_group_config, mcast_source_config, protocol):
        """
        config Source & Group multi-cast config for IGMP or MLD on a device.

        :param device_name: device name of the host configured with multicast group
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param protocol: IGMP or MLD
        :return: Group and Source config for IGMP/MLD
        """
        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if not device_name:
            self.log.info('No matching device found with device name: %s' % device_name)
        if protocol not in ('igmp', 'mld'):
            raise IxiaOperationException("Invalid protocol")
        for key, groupCount in mcast_group_config.items():
            self._config_group(device_name, groupCount, protocol)
        for key, sourceCount in mcast_source_config.items():
            self._config_source(device_name, sourceCount, protocol)

    def _config_group(self, device_name, group_count, protocol):
        """
        Function used internally by other API's

        :param device_name: Device Group Name
        :param group_count: Device Group count
        :param protocol: Protocol . Ex : IGMP/MLD
        """
        if protocol == 'igmp':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType
            if version == 'version2' or version == 'version3':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Single(group_count)
            else:
                raise IxiaOperationException("Invalid version")

        elif protocol == 'mld':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType
            if version == 'version1' or version == 'version2':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Single(
                    group_count)
            else:
                raise IxiaOperationException("Invalid mld version")
        else:
            raise IxiaOperationException("Not able to configure group member")
        return True
    def _config_source(self, device_name, source_count, protocol):
        """
        Function used internally by other API's

        :param device_name: Device Group Name
        :param source_count: Source count
        :param protocol: Protocol , Ex: 'igmp','mld'
        """
        if protocol == 'igmp':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType
            if version == 'version3':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt.Single(source_count)
        elif protocol == 'mld':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType
            if version == 'version1':
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt.Single(source_count)
        else:
            raise IxiaOperationException("Not able to configure group member")

        return True

    def get_stream_frame(self, stream_name, header, fields=()):
        """
        Get header field value of specific stream frame

        :param stream_name: stream on which header is configured
        :param header: name of the header configured
        :param fields: field or list of fields in the header for which value should be returned
        :return: Dictionary of requested fields and values in the given header.

        :Example: get_stream_frame('Traffic Item 1', 'IP', fields=['Version','Source Address','Destination Address','Flags'])
        """
        self.log.info("Getting Stream Frame")
        field_value_dict ={}
        ipv4_map_dict = {'checksum': 'checksum', 'destAddr': 'dest_ip', 'fragOffset': 'fragment_offset',
                        'totalLength': 'total_len', 'protocol': 'protocol', 'sourceAddr': 'source_ip',
                        'identification': 'identification', 'ttl': 'ttl', 'version': 'version'}
        ipv6_map_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit', 'flowLabel': 'flowLabel',
                        'sourceAddr': 'source_ip', 'trafficClass': 'trafficClass', 'version': 'version',
                        'destAddr': 'dest_ip', 'nextHeader': 'nextHeader'}
        udp_map_dict = {'sourcePort': 'udp_src_prt', 'destPort': 'udp_dst_prt'}
        tcp_map_dict = {'urgBit': 'u_bit', 'protocolType': 'protocol', 'synBit': 's_bit', 'rstBit': 'r_bit',
                        'cwrBit': 'c_bit', 'pshBit': 'p_bit', 'ackBit': 'a_bit', 'finBit': 'f_bit', 'ecnBit': 'e_bit',
                        'ackNum': 'ack_num', 'reserved': 'reserved', 'seq_num': 'seqNum', 'offset': 'data_offset',
                        'sourcePort': 'tcp_src_prt', 'destPort': 'tcp_dst_prt', 'window': 'tcp_window',
                        'checksum': 'tcp_checksum', 'urgentPtr': 'urgent_ptr'}
        ethernet_map_dict = {'dstMac': 'destinationAddress', 'etherType': 'ether_type', 'srcMac': 'sourceAddress'}
        regex_dict = {'ipv4': ipv4_map_dict,'ipv6':ipv6_map_dict,'udp':udp_map_dict,'tcp':tcp_map_dict,'ethernet':ethernet_map_dict}

        key_map = {'valueType': 'ValueType', 'value': 'FieldValue', 'step': 'StepValue', 'count': 'CountValue'}
        result = {}
        stream_name = re.escape(stream_name)
        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{stream_name}$')
        if not streamObj:
            raise IxiaConfigException("stream not found")

        if header in regex_dict.keys():
            field_value_dict = regex_dict[header]
        else:
            raise IxiaConfigException(f'Invalid header name {header}')

        header_handle = streamObj.ConfigElement.find().Stack.find(StackTypeId=f'{header.lower()}')
        if not header_handle:
            raise IxiaConfigException("header not found")

        for header_field in fields:
            if header_field in field_value_dict:
                for key in key_map:
                    result.update({key:eval('headerHandle.Field.find(Name=field_value_dict[headerField]).'+key_map[key])})
            else:
                self.log.info(f'Invalid header field for header {header}')
        return result

    def rsvp_te_stop(self, port=None, host_ip=None):
        """
        RSVP TE Stop

        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts
        :return: True. raise exception if False/error

        :Example: rsvp_te_stop()
        """
        self.log = CafyLog('Stopping rsvpte protocol')
        action = 'Stop'
        protocol = ['rsvp','rsvptelf']
        return self._start_stop_protocols(protocol, port, host_ip, action)

    def rsvp_te_start(self, port=None, host_ip=None):
        """
        RSVP TE Start

        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts
        :return: True. raise exception if False/error

        :Example: rsvp_te_start()
        """
        self.log = CafyLog('Stopping rsvpte protocol')
        action = 'Start'
        protocol = ['rsvp','rsvptelf']
        return self._start_stop_protocols(protocol, port, host_ip, action)

    def delete_stream_header(self, traffic_item, headerType, headerName, **kwargs):
        """
        Delete specific header from a stream

        :param traffic_item: Stream name for which header should be deleted
        :param headerType: Type of header\n
                           Example: "DHCP"
        :param headerName: Header name which should be configured\n
                           Example: "DhcpClientMsg", "DhcpServerMsg"
                           "icmp0"   - ICMP Msg Types: 0,8,13,14,15,16
                           "icmp3"   - ICMP Msg Types: 3,4,5,11,12
                           "icmp9"   - ICMP Msg Type: 9
                           "icmpv6"  - ICMPV6
        :return: True if header is deleted else raise exception

        :Example: tgnObj.delete_stream_header('Traffic Item 12','L2TP',headerName='L2TPV3IPD')
                  tgnObj.delete_stream_header('Traffic Item 1','IPv6')
                  tgnObj.delete_stream_header('Traffic Item 1','gre',header_index=1)
                  tgnObj.delete_stream_header('Traffic Item 1','icmp','icmp3')
        """
        self.log.info('Deleting Stream Header')
        headerIndex = kwargs.get('headerIndex', 1)
        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$')
        if not trafficItem:
            raise IxiaConfigException("{} is not found".format(traffic_item))
        try:
            configElement = trafficItem.ConfigElement.find()[0]
            headerObj = None
            if headerType.upper() == 'IPV6':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6$')[headerIndex - 1]
            elif headerType.upper() == 'IPV6ROUTE':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Routing$')[headerIndex - 1]
            elif headerType.upper() == 'IPV6AUTH':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Authentication$')[headerIndex - 1]
            elif headerType.upper() == 'GRE':
                headerObj = configElement.Stack.find(StackTypeId='^gre$')[headerIndex - 1]
            elif headerType.upper() == 'L2TP':
                if headerName.upper() == 'L2TPV3IPC':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3ControlIP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3IPD':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3DataIP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3UDPC':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3ControlUDP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3UDPD':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3DataUDP$")[headerIndex - 1]
                else:
                    self.log.error('Incorrect L2TP header name')
            elif headerType.upper() == 'IPV6FRAGMENT':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Fragment$')[headerIndex - 1]
            elif headerType.upper() == 'ICMP':
                if headerName.upper() == 'ICMP3':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv1$')[headerIndex - 1]
                if headerName.upper() == 'ICMP0':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv2$')[headerIndex - 1]
                if headerName.upper() == 'ICMP9':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv9$')[headerIndex - 1]
                if headerName.upper() == 'ICMPV6':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv6$')[headerIndex - 1]
            else:
                headerObj = configElement.Stack.find(StackTypeId='^' + headerType.lower() + '$')[headerIndex - 1]
            if headerObj:
                headerObj.Remove()
                self.log.info('Stream header {} deleted successfully'.format(headerType))
            else:
                self.log.error('Stream header deletion failed')
        except:
            self.log.error('{} Header is not found in traffic stream {}'.format(headerType, traffic_item))
        return True

    def get_stream_dhcp_client_mac(self, stream_name):
        """
        get the mac_addr of dhcpclientmsg

        :param stream_name: stream on which dhcpclientmsg is configured
        :return: mac_addr of dhcpclientmsg

        :Example: get_stream_dhcp_client_mac('Traffic Item 4')
        """
        self.log.info("Getting Stream DHCP Client MAC")
        clientMac = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(
            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue
        clientMac = ':'.join(format(s, '02x') for s in bytes.fromhex(clientMac))
        return clientMac

    def get_sessions(self):
        """
        Get sessions on the server

        :return: list of sessions on the server

        :Example: get_sessions()
        """
        sessions = []
        if self.tgn_server_type == "linux":
            for eachSession in self.test_platform.Sessions.find():
                sessions.append(eachSession.Name)
            self.log.info("Existing Sessions on Ixia Lab server '%s' : %s" %(self.server_ip,sessions))

        if self.tgn_server_type == 'windows':
            self.log.warning("Get Sessions is Not Supported on Ixia Windows Lab Server")

        return sessions

    def delete_session_by_name(self, session_name, end_tcsession=True):
        """
        Deletes the TGN session

        :param session_name: Session name to be deleted
        :param end_tcsession: NA for IXIA
        :return: True on success, exception on failure

        :Example: delete_session_by_name("session1")
        """
        if self.tgn_server_type == "linux":
            if self.test_platform.Sessions.find(Name=session_name):
                if self.test_platform.Sessions.find(Name=session_name).State == 'ACTIVE':
                    self.test_platform.Sessions.find(Name=session_name).remove()
                    self.log.info("Deleted Session - '%s'" % session_name)
                    return True
            else:
                self.log.error("Session - '%s' Not Found" % session_name)
                return False

        if self.tgn_server_type == 'windows':
            self.log.warning("Sessions Delete is Not Supported in Ixia Windows Lab Server")
            return False

    def get_igmp_group_member(self, router_id, **kwargs):
        """
        API to get Source & Group multi-cast config for IGMP on a device.

        :param router_id: IGMP Router ID:
        :param device_name: device group name
        :return: Group and Source config for IGMP

        :Example: get_igmp_group_member('1.1.1.1',device_name='Device Group 13')
        """
        deviceName = kwargs.get('device_name')

        return self._get_group_member(deviceName, router_id, 'igmp', )

    def get_mld_group_member(self, router_id, **kwargs):
        """
        API to get Source & Group multi-cast config for MLD on a device.

        :param router_id: IGMP Router ID
        :param device_name: device group name
        :return: Group and Source config for MLD

        :Example: get_mld_group_member('1.1.1.1',device_name='Device Group 16')
        """
        deviceName = kwargs.get('device_name')
        return self._get_group_member(deviceName, router_id, 'mld')

    def _get_group_member(self, deviceName, router_id, protocol):
        """
        Get Source & Group multi-cast config for IGMP or MLD on a device.

        :param deviceName: device group name
        :param router_id: Router ID of a device
        :param protocol: IGMP or MLD
        :return: Group and Source config for IGMP/MLD
        """
        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName)
        if not deviceName:
            self.log.info('No matching device found with device name: %s' % deviceName)
            raise IxiaOperationException("Invalid Ip version")
        if protocol not in ('igmp', 'mld'):
            raise IxiaOperationException("Invalid protocol")
        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}

        key_map = {'StartIpList': 'start_ip', 'AddrIncrement': 'step', 'NetworkCount': 'count'}
        try:
            if protocol.lower() == 'igmp':
                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find()
            else:
                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()
        except:
            self.log.info('%s not configured on %s' % (protocol.upper(), device))
            raise IxiaOperationException("%s not configured on %s' %(protocol.upper(), device)")
        groupConfig = self._get_group_config(deviceName, protocol)
        groupConfig = updateKey(groupConfig, key_map)
        mcastConfig = {'group': groupConfig}
        sourceConfig = self._get_source_config(deviceName, protocol)
        sourceConfig = updateKey(sourceConfig, key_map)
        mcastConfig['source'] = sourceConfig
        return mcastConfig

    def _get_group_config(self, deviceName, protocol):
        """
        Function used internally by other API's

        :param deviceName: device group name
        :param protocol: Protocol , Ex: 'igmp'
        """
        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}
        if protocol == 'igmp':
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt
        else:
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt
        return keyMap

    def _get_source_config(self, deviceName, protocol):
        """
        Function used internally by other API's

        :param deviceName: device group name
        :param protocol: Protocol , Ex: 'igmp'
        """
        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}
        if protocol == 'igmp':
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt
        else:
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt
        return keyMap

    def reserve_ports(self, ports=None):
        """
        Reserve all or user specified ports

        :param ports: ports to be reserved (Default: all ports)
        :return: True on success

        :Example: reserve_ports()
        """
        update_portname = True
        if ports:
            for port in ports:
                port_modified = port.split('/')
                #To be checked
                if len(port_modified) < 3:
                    port_modified.insert(1,'1')
                ports[ports.index(port)] = port_modified
            try:
                self._assign_ports(ports, update_portname)
            except Exception as err:
                self.log.error('Failed to reserve ports')
                raise IxiaOperationException(err)
        return True

    def start_arp_on_ports(self, ports=None):
        '''
        Send arp based on port list

        :param ports: list of port name or port handle or interface name from Json file.
                      Default is None for all ports
        :return: True

        :Example: start_arp_on_ports()
        '''

        return self.start_arp()

    def start_arp_on_devices(self, ports=None):
        '''
        Send arp based on port list

        :param ports: list of port name or port handle or interface name from Json file.
                      Default is None for all ports
        :return: True

        :Example: start_arp_on_devices()
        '''

        return self.start_arp()

    def start_arp_on_objects(self,  objects=None, type='all'):
        '''
        Send arp based on port list

        :param objects: NA for IXIA
        :param type: NA for IXIA
        :return: True

        :Example: start_arp_on_objects()
        '''

        return self.start_arp()

    def set_stream_dhcp_client_mac(self, stream_name, mac_addr):
        """
        change the mac_ddr of dhcpclientmsg of specific stream

        :param stream_name: stream on which dhcpclientmsg is configured
        :param mac_addr: mac_addr that needs to replace mac_addr in dhcpclientmsg
        :return: True if successful else Raise Exception

        :Example: set_stream_dhcp_client_mac('Traffic Item 4','0xaa0a0a0a0a0a')
        """

        self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(
            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue = mac_addr

        return True

    def set_device_vlan_count(self,device_name,vlan_count):
        """
        Set device VLAN parameters
        :param device_name: device Group name
        :param vlan_count: vlan number,  Default is 1

        :return: True if successful
        :Example: set_device_vlan_count(device_name='Device Group 1', vlan_count=2)
        """
        self.log.info(f'Setting vlan count {vlan_count} for device name {device_name}')
        if vlan_count > 6:
            self.log.warning('Maximum supported vlan count is 6')
        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$'):
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find().VlanCount = vlan_count
            except:
                self.log.error("Error in setting vlan count")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def set_device_vlan(self, router_id, vlan_number=1, vlan_id=None, vlan_priority=None, vlan_type=None, **kwargs):
        """
        Set device VLAN parameters

        :param router_id: NA for IXIA
        :param vlan_number: vlan number,  Default is 1
        :param vlan_id: VLAN ID to be set
        :param vlan_priority: Priority to be set, Type is Integer. Range [0-7]. Default is 7
        :param vlan_type: Type to be set,  '8100', '88a8', '9100', '9200', '9300'
        :param kwargs: device_name, Mandatory for IXIA

        :return: True if successful

        :Example: set_device_vlan(router_id=None, device_name='Device Group 13' , vlan_number=8 , vlan_priority=0, vlan_id = 3, vlan_type = '0x9200')
        """
        device_name = kwargs.get('device_name',None)
        if device_name is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Changing VLAN Parameters for Vlan {0} in {1}".format(vlan_number, device_name))
        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',
                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}
        try:
            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values

        except:
            raise IxiaOperationException("Device Group not Found")
        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().Priority.Values
        tpidList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().Tpid.Values
        vlanIdList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().VlanId.Values
        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
        if indexList:
            for index in indexList:
                priorityList.pop(index)
                priorityList.insert(index, str(vlan_priority))
                vlanIdList.pop(index)
                vlanIdList.insert(index, str(vlan_id))

            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():
                vlan.Priority.ValueList(values=priorityList)
                vlan.Tpid.Single(vlanTpid[vlan_type])
                vlan.VlanId.ValueList(values=vlanIdList)
            self.log.info("VLAN Parameters Changed for Vlan {0} in {1}".format(vlan_number, device_name))
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("VLAN Number not Found")
        return True

    def set_vlan(self,device_name,vlan_id,**kwargs):
        """
        Set device VLAN id and enable/disable vlan
        :param device_name: device name to set vlan id
        :param vlan_id: VLAN ID to be set
        :param kwargs:
                vlan_number: vlan ID need to be modified
                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111
                vlan_count : vlan number which need to be changes, defalut is 1
                            Ex : vlan_count = 1, vlan ID 1 will be changed
                                 vlan_count = 2, vlan ID 2 will be changed
                vlan_step : Step to increment vlan_id, default 1
                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'
                enable_vlan : enable/disable vlan based on device_name
                              Ex : enable_vlan = True, vlan is enabled on device_name
                                   enable_vlan = False, vlan is disabled on device_name

        :return: None
        :Example: set_vlan(device_name='IPv4 Device Group 1' , vlan_id = 101)
                  set_vlan(device_name='IPv4 Device Group 1'  ,vlan_id = 300,enable_vlan =True )
        """
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        enable_vlan = kwargs.get('enable_vlan', None)
        vlan_index = kwargs.get('vlan_index', None)
        try:
            enable_vlan_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().EnableVlans
            enable_vlan_obj.ClearOverlays()
            if vlan_index:
                for index in vlan_index:
                    enable_vlan_obj.Overlay(index, enable_vlan)
            else:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)
        except:
            pass
        vlan_count = kwargs.get('vlan_count', 1)
        vlan_number = kwargs.get('vlan_number', None)
        if vlan_count:
            vlanObj = deviceObj.Vlan.find()[vlan_count-1]
        else:
            vlanObj = deviceObj.Vlan.find()[0]
        vlanIdList = vlanObj.VlanId.Values
        vlanList = vlanObj.VlanId.Values
        if vlan_number:
            indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
            if indexList:
                for index in indexList:
                    try:
                        vlanObj.VlanId.Overlay(index+1, str(vlan_id))
                    except:
                        pass
        else:
            vlan_direction = kwargs.get('vlan_direction', 'increment')
            vlanObj.VlanId.ClearOverlays()
            if vlan_direction.lower() == 'decrement':
                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def set_device_vlan_parameters(self, device_name,**kwargs):
        """
        Set device VLAN parameters
        :param device_name: device name to set vlan and vlan parameters
        :param kwargs:
            vlan1: (list) if vlan id 1 parameters has to be set
            priority1: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0
            tpid1: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'
            vlan2: (list) if vlan id 1 parameters has to be set
            priority2: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0
            tpid2: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'
        :return: True if successful

        :Example: set_device_vlan_parameters(device_name='IPv4 Device Group 1',vlan1=['703-705'],priority1=['4','5','6'],tpid1=['0x88a8','0x88a8','0x88a8'])
        """
        self.log.info("Changing VLAN Parameters for device ".format(device_name))
        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',
                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        vlan1 = kwargs.get('vlan1', None)
        vlan2 = kwargs.get('vlan2', None)
        if vlan1:
            priority1 = kwargs.get('priority1', None)
            tpid1 = kwargs.get('tpid1', None)
            vlan1Obj = deviceObj.Vlan.find()[0]
            for id in vlan1:
                if '-' in id:
                    vlanList = id.split('-')
                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]
                else:
                    vlanIdList = vlan1
            vlanList1 = vlan1Obj.VlanId.Values
            tpidList1 = vlan1Obj.Tpid.Values
            priorityList1 = vlan1Obj.Priority.Values
            indexList = [index for index in range(len(vlanList1)) if vlanList1[index] in vlanIdList]
            for index in indexList:
                if type(priority1) == list:
                    for value in range(len(priorityList1)):
                        try:
                            priorityList1.pop(indexList[value])
                            priorityList1.insert(indexList[value], priority1[value])
                        except:
                            pass
                if  type(tpid1) == list:
                    for value in range(len(tpidList1)):
                        try:
                            vlan1Obj.Tpid.Overlay(indexList[value]+1, vlanTpid[tpid1[value]])
                        except:
                            pass
                if type(priority1)== str:
                    priorityList1.pop(index)
                    priorityList1.insert(index, str(priority1))
                if type(tpid1) == str:
                    try:
                        vlan1Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid1]))
                    except:
                        pass
            vlan1Obj.Priority.ValueList(values=priorityList1)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if vlan2:
            priority2 = kwargs.get('priority2', None)
            tpid2 = kwargs.get('tpid2', None)
            vlan2Obj = deviceObj.Vlan.find()[1]
            for id in vlan2:
                if '-' in id:
                    vlanList = id.split('-')
                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]
                else:
                    vlanIdList = vlan2
            vlanList2 = vlan2Obj.VlanId.Values
            tpidList2 = vlan2Obj.Tpid.Values
            priorityList2 = vlan2Obj.Priority.Values
            indexList = [index for index in range(len(vlanList2)) if vlanList2[index] in vlanIdList]
            for index in indexList:
                if type(priority2) == list:
                    for value in range(len(priorityList2)):
                        try:
                            priorityList2.pop(indexList[value])
                            priorityList2.insert(indexList[value], priority2[value])
                        except:
                            pass
                if  type(tpid2) == list:
                    for value in range(len(tpidList2)):
                        try:
                            vlan2Obj.Tpid.Overlay(indexList[value] + 1, vlanTpid[tpid2[value]])
                        except:
                            pass
                if type(priority2)== str:
                    priorityList2.pop(index)
                    priorityList2.insert(index, str(priority2))
                if type(tpid2) == str:
                    try:
                        vlan2Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid2]))
                    except:
                        pass
            vlan2Obj.Priority.ValueList(values=priorityList2)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _setup_stc_connection(self, server_ip, timeout=300, api_version=1):
        """
        Function NA for IXIA, added just to avoid AP error

        :param server_ip: Server IP of IXIA
        :param timeout: Timout for the IXIA connection
        :param api_version: IXIA API version
        """
        pass

    def _initiate_stream_results(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _apply(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _enable_data_mining(self, datamining_list):
        """
        Function NA for IXIA, added just to avoid AP error

        :param datamining_list: N/A
        """
        pass

    def _bll_version(self,**kwargs):
        """
        Function NA for IXIA, returns version to bypass the check
        """
        return "1.79"

    def set_auto_negotiate(self, port_list=None, auto_negotiate=True):
        """
        Function to set auto-negotiation of port speeds.

        :param port_list: List of port names
        :param auto_negotiate: True or False

        :Example: set_auto_negotiate(port_list=['port1'], auto_negotiate=False)
        """
        if port_list == None:
            self.log.info("Setting Auto Negotiation of all available ports in the config")
            for vport in self.ixNetwork.Vport.find():
                port_type = vport.Type
                capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)
                try:
                    port_obj = getattr(vport.L1Config, capitalized_card_type)
                    port_obj.update(AutoNegotiate=auto_negotiate)
                    self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {vport.Name}")
                except TypeError:
                    port_obj = getattr(vport.L1Config, capitalized_card_type)
                    port_obj.update(EnableAutoNegotiation=auto_negotiate)
                    self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {vport.Name}")
                except:
                    self.log.info(f"card type {capitalized_card_type} might not supported auto negotiation for port: {vport.Name}")
                    return False
        else:
            self.log.info(f"Setting Auto Negotiation of ports - {port_list} in the config")
            for port in port_list:
                if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', port)):
                    port = port.replace("/", ":")
                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + port + '$')
                else:
                    vport = self.ixNetwork.Vport.find(Name='^' + port + '$')
                if vport:
                    if port in [vport.Name, vport.AssignedTo]:
                        port_type = vport.Type
                        capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)
                        try:
                            port_obj = getattr(vport.L1Config, capitalized_card_type)
                            port_obj.update(AutoNegotiate=auto_negotiate)
                            self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {port}")
                        except TypeError:
                            port_obj = getattr(vport.L1Config, capitalized_card_type)
                            port_obj.update(EnableAutoNegotiation=auto_negotiate)
                            self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {port}")
                        except:
                            self.log.info(f"card type {capitalized_card_type} might not supported auto negotiation for port: {port}")
                            return False
                else:
                    self.log.info(f"port {port} not available in the config")
                    return False
        return True

    def _end_session(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        return self.tgn_disconnect()

    def _delete(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _connect(self, chassis_list):
        """
        Establish connection to one or more chassis.

        :param chassis_list: List of chassis (IP addresses or DNS names)
        """
        self.connect_to_chassis(chassis_list)

    def _stop_devices(self):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _get_dict_emulated_devices(self):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def get_ospf_router_status(self, router_ids):
        """
        The API returns the ospf status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding ospf status

        :Example: get_ospf_router_status(['192.0.0.1','193.0.0.1'])
        """
        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Ospfv2.find():
                    if routerId in ospf.LocalRouterID:
                        routerIdIndex = ospf.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def get_bgp_router_status(self, router_ids):
        """
        The API returns the bgp status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding bgp status

        :Example: get_bgp_router_status(['200.0.0.1','200.0.0.2','200.0.0.3','200.0.0.4'])
        """
        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for bgp in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    if routerId in bgp.LocalRouterID:
                        routerIdIndex = bgp.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = bgp.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def get_ospfv3_router_status(self, router_ids):
        """
        The API returns the ospfv3 status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding ospfv3 status

        :Example: get_ospfv3_router_status(['194.0.0.1','195.0.0.1'])
        """

        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ospfv3.find():
                    if routerId in ospf.LocalRouterID:
                        routerIdIndex = ospf.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def set_device_count(self, device_count, router_id=None, device_name=None, **kwargs):
        """
        Set device count
        :param device_count: new device count. Should be >=1
        :param router_id: router ID of Emulated device
        :param device_name: Device Group Name
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA Device name if device count of nested DG to be set
                                And for nested device device_name param in mandatory
        :return: True if successful
                raise exception if router id not found in Ixia

        :Example: set_device_count(device_count = 5, router_id = '200.0.0.1')
                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1')
                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')
       """
        nested_device = kwargs.get('nested_device')
        if device_count >= 1:
            if router_id and device_name == None:
                routerIdList = [routerObj.RouterId for routerObj in
                                self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
                for routerId in routerIdList:
                    if re.search(router_id, str(routerId)):
                        deviceList = [deviceGroupName.Name for deviceGroupName in
                                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
                        for device in deviceList:
                            try:
                                deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).RouterData.find().RouterId
                            except:
                                pass
                            if re.search(router_id, str(deviceRouterId)):
                                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Multiplier = device_count
            if device_name and nested_device is None:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + device_name + '$').Multiplier = device_count
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            if device_name and nested_device:
                try:
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(
                        Name='^' + nested_device + '$').Multiplier = device_count
                except:
                    pass
                try:
                    self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').DeviceGroup.find(
                        Name='^' + nested_device + '$').Multiplier = device_count
                except:
                    pass
        else:
            raise CafyException.InvalidValueError(
                'Device count (%s) has to be greater than or equal to 1' % device_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def get_link_status(self, print_info=False):
        """
        Get Link status information(Port, portStatus) for each port

        :param print_info: log link status info if this True
        :return: List of LinkStatusInfo objects

        :Example: get_link_status()
        """
        linkStatus = []
        for vport in self.ixNetwork.Vport.find():
            vport_name = vport.Name
            if re.search(r'\d+\/\d+', vport_name):
                vport_name = re.findall(r'\d+\/\d+', vport.Name)[0]

            linkStatus.append(["Name:" + vport_name, "State:" + vport.State])
            if print_info:
                log.info(f'Link Status Info for Port: {vport_name}, {vport.State}')
        return linkStatus

    def set_stream_frame(self, stream_name, frame_config,**kwargs):
        """
        Set the header field value of specific stream frame

        :param stream_name: stream on which specific header configured
        :param frame_config: dict with header name and field name with values to be configured \n
            Example: frame_config - single field: {'ipv4':{'sourceAddr':'10.1.1.1'}} \n
            Example: frame_config - list: {'ipv4':{'sourceAddr':['10.1.1.1','10.1.2.1','10.1.3.1']}} \n
            Example: frame_config - modifier: {'ipv4':{'destAddr':{'start': '10.1.1.10','step': '0.0.0.1', 'count': '3',
            'valueType': 'decrement','mask':'255.255.255.255'}}}
        :return: True if successful else Raise Exception

        :Example:
            set_stream_frame('Traffic Item 4', {'ipv4':{'destAddr':{'value': '10.1.1.12',
                'step': '0.0.0.1', 'count': '3','valueType': 'increment','mask':'255.255.255.255'}}})

            set_stream_frame(stream_name='Traffic Item 9', frame_config={
                'ipv6': {'destAddr': {'start': '2000:1:1::2', 'valueType': 'increment', 'step': '0::1', 'count': 100}}})

            set_stream_frame(stream_name='Traffic Item 11', frame_config={
                'udp': {'sourcePort': {'start': 68, 'valueType': 'increment', 'step': 1, 'count': 10}}})

            set_stream_frame(stream_name='Traffic Item 13', frame_config={'udp': {'sourcePort': 68}})
        """
        field_dict = {}
        self.log.info(f'Setting Stream Frame for Traffic Stream - {stream_name}')
        ipv4_map_dict = {'checksum': 'checksum', 'destAddr': 'dest_ip', 'fragOffset': 'fragment_offset',
                        'totalLength': 'total_len', 'protocol': 'protocol', 'sourceAddr': 'source_ip',
                        'identification': 'identification', 'ttl': 'ttl', 'version': 'version'}
        ipv6_map_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit', 'flowLabel': 'flowLabel',
                        'sourceAddr': 'source_ip', 'trafficClass': 'trafficClass', 'version': 'version',
                        'destAddr': 'dest_ip', 'nextHeader': 'nextHeader'}
        udp_map_dict = {'sourcePort': 'udp_src_prt', 'destPort': 'udp_dst_prt'}
        tcp_map_dict = {'urgBit': 'u_bit', 'protocolType': 'protocol', 'synBit': 's_bit', 'rstBit': 'r_bit',
                        'cwrBit': 'c_bit', 'pshBit': 'p_bit', 'ackBit': 'a_bit', 'finBit': 'f_bit', 'ecnBit': 'e_bit',
                        'ackNum': 'ack_num', 'reserved': 'reserved', 'seq_num': 'seqNum', 'offset': 'data_offset',
                        'sourcePort': 'tcp_src_prt', 'destPort': 'tcp_dst_prt', 'window': 'tcp_window',
                        'checksum': 'tcp_checksum', 'urgentPtr': 'urgent_ptr'}
        ethernet_map_dict = {'dstMac': 'destinationAddress', 'etherType': 'ether_type', 'srcMac': 'sourceAddress'}
        vlan_map_dict = {'vlan_user_priority': 'vlan_user_priority', 'vlan_cfi': 'vlan_cfi', 'id': 'vlan_id',
                         'vlan_tag_type': 'vlan_tag_type'}

        regex_dict = {'ipv4': ipv4_map_dict,'ipv6':ipv6_map_dict,'udp':udp_map_dict,'tcp':tcp_map_dict,'ethernet':ethernet_map_dict,
                      'vlan': vlan_map_dict}

        enable_stream = kwargs.get('enable_stream', False)

        stream_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream_name+'$')
        if not stream_obj:
            raise IxiaConfigException(f"{stream_name} stream not found")
        for header_name, header_config in frame_config.items():
            if header_name in regex_dict.keys():
                field_dict = regex_dict[header_name]
            else:
                raise IxiaConfigException(f'Invalid header name {header_name}')

            for header_field, header_field_value in header_config.items():
                header_field = field_dict[header_field]
                field = stream_obj.ConfigElement.find().Stack.find(StackTypeId='^'+header_name.lower()+'$').Field.find(Name='^'+header_field+'$')
                if not field:
                    err_msg = f"Invalid inputs for stack type {header_name} and field name {header_field}"
                    raise IxiaConfigException(err_msg)
                if isinstance(header_field_value, dict) and header_field_value.get('value'):
                    header_field_value['start'] = header_field_value['value']
                self._update_field_values(field, header_field_value)
            if enable_stream:
                self.enable_traffic_item([stream_name])
        return True

    def set_port_transmit_deviation(self, port_list=None, deviation='enabled', deviation_value=0, **kwargs):
        """
        Sets the transmit deviation type and value for a given set of ports

        :param port_list: (list) The port(s) to configure
            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']
            Note - for IXIA all ports in the same group will be enabled/disabled regardless of port_list
        :param deviation: (str) Selects whether transmit deviation is enabled or disabled
            e.g. 'enabled', 'disabled'
        :param deviation_value: (int/str): The desired PPM deviation value
            e.g. 10, "10"
        :param kwargs:
                    wait_interval : (int) sleep time default 0
                    repetition : (int) Number of time opertaion to be repeated Ex : 5
                    operation : "increment"/"decrement" if "decrement" then negative deviation_value will be set EX : -10
        :return: True on success, exception otherwise

        :Example: set_port_transmit_deviation(deviation_value=10)
                  set_port_transmit_deviation(deviation_value=10,operation="increment",wait_interval=5, repetition=2)
        """
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)
        operation = kwargs.get("operation", "increment")
        if operation == "decrement":
            deviation_value = - deviation_value

        cardTypeList = ['atlasFourHundredGigLan',
                        'atm',
                        'ethernet',
                        'ethernetImpairment',
                        'ethernetvm',
                        'fc',
                        'fortyGigLan',
                        'hundredGigLan',
                        'krakenFourHundredGigLan',
                        'novusHundredGigLan',
                        'novusTenGigLan',
                        'pos',
                        'tenFortyHundredGigLan',
                        'tenGigLan',
                        'tenGigWan',
                        'aresOneFourHundredGigLan',
                        'starFourHundredGigLan',
                        'aresOneM']

        while repetition != 0:
            if port_list:
                vports = self.ixNetwork.Vport.find()
                vports.ReleasePort()
                for port in port_list:
                    if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', port)):
                        port = port.replace("/", ":")
                        card_type = self.ixNetwork.Vport.find(AssignedTo=port).Type
                        port_type = "IP"
                    else:
                        card_type = self.ixNetwork.Vport.find(Name=port).Type
                        port_type = "NAME"

                    if card_type in cardTypeList:
                        card_type = card_type[0].upper() + card_type[1:]
                    else:
                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found. Code may need to be updated to support it')
                    if deviation.lower() == 'enabled':
                        if port_type == "NAME":
                            card_obj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + card_type)
                        if port_type == "IP":
                            card_obj = eval('self.ixNetwork.Vport.find(AssignedTo=port).L1Config.' + card_type)
                        card_obj.EnablePPM = True
                        card_obj.Ppm = deviation_value
                        self.log.info(f"On Port: {port} Enabled deviation and value set to: {deviation_value}")
                    elif deviation.lower() == 'disabled':
                        if port_type == "NAME":
                            card_obj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + card_type)
                        if port_type == "IP":
                            card_obj = eval('self.ixNetwork.Vport.find(AssignedTo=port).L1Config.' + card_type)
                        card_obj.EnablePPM = False
                        card_obj.Ppm = deviation_value
                        self.log.info(f"On Port: {port} Disabled deviation and value set to: {deviation_value}")
                vports.ConnectPorts()
            else:
                vports = self.ixNetwork.Vport.find()
                vports.ReleasePort()
                for vport in self.ixNetwork.Vport.find():
                    cardType = vport.Type
                    if cardType in cardTypeList:
                        cardType = cardType[0].upper() + cardType[1:]
                    else:
                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found. Code may need to be updated to support it')
                    if deviation.lower() == 'enabled':
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.EnablePPM = True
                        cardObj.Ppm = deviation_value
                        self.log.info(f"On Port: {vport.Name} Enabled deviation and value set to: {deviation_value}")
                    elif deviation.lower() == 'disabled':
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.EnablePPM = False
                        cardObj.Ppm = deviation_value
                        self.log.info(f"On Port: {vport.Name} Disabled deviation and value set to: {deviation_value}")
                vports.ConnectPorts()
            time.sleep(wait_interval)
            repetition -= 1
        return True

    def new_session(self, user_name=None, session_name=None, kill_existing=False, **kwargs):
        """
        Creates a new test session. Applicable only for Linux or Windows Connection Manager

        :param user_name: User name part of session ID.
        :param session_name: Session name part of session ID.
        :param kill_existing: If there is an existing session, with the same session name
                              and user name, then terminate it before creating a new session
        :return: True is session started, False if session was already started.

        :Example: new_session(()
        """
        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)
        if session_name:
            self.log.info(f"Creating New session - '{session_name}'")
        else:
            self.log.info("Creating new Session")
        self._new_session(user_name=user_name, session_name=session_name, kill_existing=kill_existing)
        self.log.info("Created new session - '%s'"%self.session_name)

        return True

    def isListEmpty(self, inList):
        """
        Check if the list is empty for each port,This API is not applicable to ixia

        :param inList: list of streams per port

        :Example: isListEmpty([])
        """
        pass

    def get_router_ids(self, device_list=None):
        """
        Retrieves router IDs for a given set of devices

        :param device_list: (str/list) A single device or a list of devices
                to retrieve the router id for. If None get for all devices
                e.g. 'device1' or ['device1', 'device2']
        :returns: a dict of device names/router IDs on pass, exception on failure

        :Example: get_router_ids(device_list=['Device Group 4','Device Group 3'])
        """
        devices_to_check = []
        router_ids = {}
        if device_list:
            if isinstance(device_list, str):
                devices_to_check = device_list.split(',')
            elif isinstance(device_list, list):
                devices_to_check = device_list
            else:
                raise CafyException.InvalidValueError('Invalid input type for device_list. Please use a str or a list')
        else:
            devices_to_check = self.get_device_names()
        for device in devices_to_check:
            deviceName = device
            dName = '^' + deviceName.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dName + '$'):
                try:
                    routerId = deviceGroupObj.RouterData.find().RouterId.Values
                    router_ids[device] = [str(id) for id in routerId]
                except:
                    pass
        return router_ids

    def enable_ping(self, router_id='all'):
        """
        Enable the ping on a device or on all devices, ping enabled by default in IXIA

        :param router_id: Router ID of the device
        :return: True on success else raises exception

        :Example: enable_ping()
        """

        return True

    def disable_ping(self, router_id='all'):
        """
        Disable the ping on a device or on all devices

        :param router_id: Router ID of the device
        :return: True on success else raises exception

        :Example: disable_ping()
        """

        return True

    def get_device_ip_info(self, router_id, ip_version='ipv4', key=None):
        """
        Get emulated device IP info

        :param router_id: Router ID of the device
        :param ip_version: IP Version
        :param key: Get specific key value
        :return: Device key info

        :Example: get_device_ip_info("192.0.0.1", ip_version='ipv4', key='Address')
        """
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")

        if type(router_id) is str:
            router_id = router_id.split(",")

        routerIdList = self.get_device_names()
        flag = False
        ipFieldsList = []
        for routerId in router_id:
            if '.' in routerId:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                            routerId = deviceGroupObj.Name
                            break
            else:
                routerId = routerId
            if routerId in routerIdList:
                flag = True
                if ip_version == 'ipv4':
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find()
                else:
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find()

                ipFieldsList = re.findall('([a-zA-z]+): (.*)', str(ipData))
                ipFieldsList.pop(0)
                ipFieldsList = dict(ipFieldsList)
                if ip_version == 'ipv4':
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find().Address.Values
                else:
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find().Address.Values
                ipFieldsList['address'] = ipData

        if not flag:
            raise IxiaOperationException("Router id not found")
        if not key:
            return ipFieldsList
        if key not in ipFieldsList:
            raise IxiaConfigException("key not available in ip info")
        return ipFieldsList[key]

    def set_bgp_route_count_all(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs. For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional
        :return: True if the operation is successful, False otherwise

        :Example: set_bgp_route_count_all(route_count=20, ip_type="ipv4")
        """
        protocolStatus = False
        self.log.info("Setting Bgp Route Count for all devices with bgp configured")
        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for deviceName in deviceNameList:
            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():
                        if ipv4PoolObj.BgpIPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                        if ipv4PoolObj.BgpV6IPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                else:
                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name=networkGroupObj.Name).Ipv6PrefixPools.find():
                        if ipv6PoolObj.BgpV6IPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
                        if ipv6PoolObj.BgpIPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("BGP protocol not configured or Configuration issue.")

    def set_isis_route_count_all(self, route_count, ip_type="ipv4", **kwargs):
        """
        Configures the route count for all isis devices. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
        :return: True if the operation is successful, False otherwise

        :Example: set_isis_route_count_all(route_count=20, ip_type="ipv4")
        """
        protocolStatus = False
        self.log.info("Setting ISIS Route Count for all devices with ISIS configured")
        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for deviceName in deviceNameList:
            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():
                        if ipv4PoolObj.IsisL3RouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                else:
                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv6PrefixPools.find():
                        if ipv6PoolObj.IsisL3RouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("ISIS protocol not configured or Configuration issue.")

    def get_device_names(self):
        """
        Retrieves a list of device names

        :returns: device_names (list) on pass, exception on failure

        :Example: get_device_names()
        """
        deviceList = []
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        return deviceList

    def enable_gateway_mac_address(self, ip_type, router_ids=None):
        """
        The API sets the gateway mac status to True

        :param ip_type: ipv4/ipv6
        :param router_ids: List of router_ids
        :return: return True if gateway mac address is enabled else raises exception

        :Example: enable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])
        """
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        routerIdList = [routerObj.RouterId for routerObj in
                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
        if router_ids is not None:
            for routerId in router_ids:
                routerId = ' ' + routerId
                if re.search(routerId, str(routerIdList)):
                    for device in deviceList:
                        try:
                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).RouterData.find().RouterId
                        except:
                            pass
                        if re.search(routerId, str(deviceRouterId)):
                            if ip_type == 'ipv4':
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)
                            else:
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)
                else:
                    raise IxiaConfigException('router id %s not found ', routerId)
        else:
            for device in deviceList:
                deviceRouterId = None
                try:
                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=device).RouterData.find().RouterId
                except:
                    pass
                if re.search(r'\d+.\d+.\d+.\d+', str(deviceRouterId)):
                    if ip_type == 'ipv4':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)
                        except:
                            pass
                    elif ip_type == 'ipv6':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)
                        except:
                            pass
        return True

    def disable_gateway_mac_address(self, ip_type, router_ids=None):
        """
        The API sets the gateway mac status to True

        :param ip_type: ipv4/ipv6
        :param router_ids: List of router_ids
        :return: return True if gateway mac address is enabled else raises exception

        :Example: disable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])
        """
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        routerIdList = [routerObj.RouterId for routerObj in
                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
        if router_ids is not None:
            for routerId in router_ids:
                routerId = ' ' + routerId
                if re.search(routerId, str(routerIdList)):
                    for device in deviceList:
                        try:
                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).RouterData.find().RouterId
                        except:
                            pass
                        if re.search(routerId, str(deviceRouterId)):
                            if ip_type == 'ipv4':
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)
                            else:
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)
                else:
                    raise IxiaConfigException('router id %s not found ', routerId)
        else:
            for device in deviceList:
                deviceRouterId = None
                try:
                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=device).RouterData.find().RouterId
                except:
                    pass
                if re.search(r'\d+.\d+.\d+.\d+', str(deviceRouterId)):
                    if ip_type == 'ipv4':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)
                        except:
                            pass
                    elif ip_type == 'ipv6':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)
                        except:
                            pass
        return True

    def change_ipv4_ipv6_src_address(self, cfg_dict, traffic_item_list=None):
        """
        Changes the IPv4/Ipv6 source address configuration for a given set
        of traffic streams

        :param cfg_dict: Dict including the data need to be modified
        :param traffic_item_list: List of traffic Items name. All Items if it is None.

        :Example: tgnObj.change_ipv4_ipv6_src_address(traffic_item_list=["Traffic Item 4"],
                                            cfg_dict={'fieldValue':"3.3.53.3",'startValue':"3.3.53.3",'valueType':"increment",'countValue':100})
        """
        self.log.info("Change IPv4/IPv6 Source Address %s")
        if traffic_item_list:
            for trafficItemName in traffic_item_list:
                traffic_item_name = re.escape(trafficItemName)
                for config_element in self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_name}$').ConfigElement.find():
                    if config_element.Stack.find(DisplayName="IPv4"):
                        stack_obj = config_element.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stack_obj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stack_obj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif config_element.Stack.find(DisplayName="IPv6"):
                        stackObj = config_element.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")

                    else:
                        raise IxiaConfigException("Ipv4/Ipv6 stack not configured on %s" % trafficItemName)
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")
                except:pass
        self.log.info("IPv4/Ipv6 Source Address Updated in Traffic Items")
        return True

    def change_ipv4_ipv6_dst_address(self, cfg_dict, traffic_item_list=None):
        """
        Changes the IPv4/Ipv6 source address configuration for a given set
        of traffic streams

        :param cfg_dict: Dict including the data need to be modified
        :param traffic_item_list: List of traffic Items name. All Items if it is None.

        :Example: tgnObj.change_ipv4_ipv6_dst_address(traffic_item_list=["Traffic Item 4"],
                    cfg_dict={'fieldValue':"3.3.53.3",'startValue':"3.3.53.3",'valueType':"increment",'countValue':100})
        """

        self.log.info("Change IPv4/IPv6 Source Address")
        if 'singleValue' in cfg_dict.keys():
            cfg_dict['fieldValue'] = cfg_dict['singleValue']

        if cfg_dict['valueType'] == 'increment' or cfg_dict['valueType'] == 'decrement':
            cfg_dict['fieldValue'] = cfg_dict['startValue']

        if traffic_item_list:
            for traffic_item_name in traffic_item_list:
                traffic_item = re.escape(traffic_item_name)
                for config_element in self.ixNetwork.Traffic.TrafficItem.find(
                        Name='^' + traffic_item + '$').ConfigElement.find():
                    if config_element.Stack.find(DisplayName="IPv4"):
                        stack_obj = config_element.Stack.find(DisplayName="IPv4")
                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]
                        for field_name in field_names:
                            if field_name.lower() == 'Destination Address'.lower():
                                field = stack_obj.Field.find(DisplayName=field_name)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \
                                    cfg_dict.get('valueType', 'singleValue'),cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \
                                    cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1"), cfg_dict.get('valueList',['0.0.0.0'])
                    elif config_element.Stack.find(DisplayName="IPv6"):
                        stack_obj = config_element.Stack.find(DisplayName="IPv6")
                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]
                        for field_name in field_names:
                            if field_name.lower() == 'Destination Address'.lower():
                                field = stack_obj.Field.find(DisplayName=field_name)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \
                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \
                                    cfg_dict.get('startValue',None), cfg_dict.get('stepValue', "::1"), cfg_dict.get('valueList',['0::0'])
                    else:
                        raise IxiaConfigException(f"Ipv4/Ipv6 stack not configured on {traffic_item_name}")
        else:
            for config_element in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if config_element.Stack.find(DisplayName="IPv4"):
                        stack_obj = config_element.Stack.find(DisplayName="IPv4")
                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]
                        for field_name in field_names:
                            if field_name.lower() == 'Destination Address'.lower():
                                field = stack_obj.Field.find(DisplayName=field_name)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \
                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \
                                    cfg_dict.get('startValue',None), cfg_dict.get('stepValue', "0.0.0.1"), cfg_dict.get('valueList',['0.0.0.0'])
                    elif config_element.Stack.find(DisplayName="IPv6"):
                        stack_obj = config_element.Stack.find(DisplayName="IPv6")
                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]
                        for field_name in field_names:
                            if field_name.lower() == 'Destination Address'.lower():
                                field = stack_obj.Field.find(DisplayName=field_name)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \
                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get( 'countValue', None), \
                                    cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1"),cfg_dict.get('valueList', ['0::0'])
                except:
                    pass
        self.log.info("IPv4/Ipv6 Destination Address Updated in Traffic Items")
        return True

    def _addTimestampToFile(self,filename):
        """
        Function used internally by API rfc2544_quicktest

        :param filename: filename for which timestamp to be added
        """
        currentTimestamp = datetime.datetime.now().strftime('%H%M%S')
        if '\\' in filename:
            filename = filename.split('\\')[-1]

        if '/' in filename:
            filename = filename.split('/')[-1]

        newFilename = filename.split('.')[0]
        newFileExtension = filename.split('.')[1]
        newFileWithTimestamp = '{}_{}.{}'.format(newFilename, currentTimestamp, newFileExtension)
        return newFileWithTimestamp

    def _getQuickTestCurrentAction(self,quickTestHandle):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: QucikTestHandle to test current Action
        """
        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber
        match = re.match(r'([0-9]+)\.[^ ]+ *', ixNetworkVersion)
        ixNetworkVersion = int(match.group(1))

        if ixNetworkVersion >= 8:
            timer = 10
            for counter in range(1, timer + 1):
                currentActions = quickTestHandle.Results.CurrentActions

                self.log.info('\n\ngetQuickTestCurrentAction:\n')
                for eachCurrentAction in quickTestHandle.Results.CurrentActions:
                    self.log.info('\t{}'.format(eachCurrentAction['arg2']))

                self.log.info('\n')

                if counter < timer and currentActions == []:
                    self.log.info('\n\ngetQuickTestCurrentAction is empty. Waiting %s/%s\n\n' % (counter, timer))
                    time.sleep(1)
                    continue

                if counter < timer and currentActions != []:
                    break

                if counter == timer and currentActions == []:
                    raise Exception('\n\ngetQuickTestCurrentActions: Has no action')

            return currentActions[-1]['arg2']
        else:
            return quickTestHandle.Results.Progress

    def _verifyQuickTestInitialization(self,quickTestHandle):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: QucikTest handle to verify Quick Test Initilization
        """
        for timer in range(1, 30 + 1):
            currentAction = self._getQuickTestCurrentAction(quickTestHandle)
            self.log.info('\n\nverifyQuickTestInitialization currentAction: {}\n'.format(currentAction))
            if currentAction == 'TestEnded':
                raise Exception('VerifyQuickTestInitialization: QuickTest failed during initialization: {}'.format(quickTestHandle.Results.Status))

            if timer < 30 and currentAction == 'None':
                self.log.info('\n\nverifyQuickTestInitialization CurrentState = %s\n\tWaiting %s/30 seconds to change state\n' % (currentAction, timer))
                time.sleep(1)
                continue
            else:
                break

            if timer == 20 and currentAction == 'None':
                raise Exception('\n\nQuick Test is stuck.')

        successStatusList = ['TransmittingComplete', 'TransmittingFrames', 'WaitingForStats', 'CollectingStats', 'TestEnded']
        quickTestApplyStates = ['InitializingTest', 'ApplyFlowGroups', 'SetupStatisticsCollection']
        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber
        match = re.match(r'([0-9]+)\.[^ ]+ *', ixNetworkVersion)
        ixNetworkVersion = int(match.group(1))

        applyQuickTestCounter = 120
        for counter in range(1, applyQuickTestCounter + 1):
            currentAction = self._getQuickTestCurrentAction(quickTestHandle)
            self.log.info('\n\nverifyQuickTestInitialization: CurrentState: %s  Expecting: TransmittingFrames\n\tWaiting %s/%s seconds\n' % (currentAction, counter, applyQuickTestCounter))

            if currentAction == 'TestEnded':
                raise Exception('\n\nVerifyQuickTestInitialization: QuickTest failed!!: {}'.format(quickTestHandle.Results.Status))

            if currentAction == None:
                currentAction = 'ApplyingAndInitializing'

            if ixNetworkVersion >= 8:
                if counter < applyQuickTestCounter and currentAction not in successStatusList:
                    time.sleep(1)
                    continue

                if counter < applyQuickTestCounter and currentAction in successStatusList:
                    self.log.info('\n\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\n')
                    break

            if ixNetworkVersion < 8:
                if counter < applyQuickTestCounter and currentAction != 'ApplyingAndInitializing':
                    time.sleep(1)
                    continue

                if counter < applyQuickTestCounter and currentAction == 'ApplyingAndInitializing':
                    self.log.info('\n\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\n')
                    break

            if counter == applyQuickTestCounter:
                if ixNetworkVersion >= 8 and currentAction not in successStatusList:
                    if currentAction == 'ApplyFlowGroups':
                        self.log.info('\n\nVerifyQuickTestInitialization: IxNetwork is stuck on Applying Flow Groups. You need to go to the session to FORCE QUIT it.\n')

                    raise Exception('\n\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (
                        currentAction, counter, applyQuickTestCounter))

                if ixNetworkVersion < 8 and currentAction != 'Trial':
                    raise Exception('\n\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (
                        currentAction, counter, applyQuickTestCounter))

    def _monitorQuickTestRunningProgress(self,quickTestHandle, getProgressInterval=10):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: qucikTest Handle
        :param getProgressInterval: Progressinterval
        """
        isRunningBreakFlag = 0
        trafficStartedFlag = 0
        waitForRunningProgressCounter = 0
        counter = 1
        connectionFailureCounter = 0
        maxRetries = 10

        while True:
            # This while loop was implemented because sometimes there could be failure to connect to the
            # API server.  It could be caused by many various issues not related to IxNetwork.
            # Going to retry doing GETs up to 10 times.
            connectedToApiServerFlag = False

            while True:
                try:
                    isRunning = quickTestHandle.Results.IsRunning
                    currentRunningProgress = quickTestHandle.Results.Progress
                    self.log.info('\nmonitorQuickTestRunningProgress: isRuning: %s', isRunning)
                    break
                except:
                    self.log.info('\n\nmonitorQuickTestRunningProgress: Failed to connect to API server {}/{} times\n'.format(connectionFailureCounter, maxRetries))
                    if connectionFailureCounter == maxRetries:
                        raise Exception('\n\nmonitorQuickTestRunningProgress: Giving up trying to connecto the the API server after {} attempts\n'.format(maxRetries))

                    if connectionFailureCounter <= maxRetries:
                        connectionFailureCounter += 1
                        time.sleep(3)
                        continue

            self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning: {}  CurrentRunningProgress: {}\n'.format(isRunning, currentRunningProgress))

            if isRunning == True:
                if bool(re.match('^Trial.*', currentRunningProgress)) == False:
                    if waitForRunningProgressCounter < 40:
                        self.log.info('\n\nmonitorQuickTestRunningProgress: Waiting for trial runs {0}/30 seconds\n'.format(waitForRunningProgressCounter))
                        waitForRunningProgressCounter += 1
                        time.sleep(1)

                    if waitForRunningProgressCounter == 40:
                        raise Exception('\n\nmonitorQuickTestRunningProgress: isRunning=True. QT is running, but no quick test iteration stats showing after 40 seconds.')
                else:
                    # The test is running fine.  Keep running until isRunning == False.
                    trafficStartedFlag = 1
                    time.sleep(getProgressInterval)
                    continue
            else:
                if trafficStartedFlag == 1:
                    # We only care about traffic not running in the beginning.
                    # If traffic ran and stopped, then break out.
                    self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning=False. Quick Test ran and is complete\n\n')
                    return True

                if trafficStartedFlag == 0 and isRunningBreakFlag < 40:
                    self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning=False. QT did not run yet. Wait {0}/40 seconds\n\n'.format(isRunningBreakFlag))
                    isRunningBreakFlag += 1
                    time.sleep(1)
                    continue

                if trafficStartedFlag == 0 and isRunningBreakFlag == 40:
                    raise Exception('\n\nmonitorQuickTestRunningProgress: Quick Test failed to start:: {}'.format(quickTestHandle.Results.Status))

    def _copyFileWindowsToLocalWindows(self,windowsPathAndFileName, localPath, includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param windowsPathAndFileName: windowspathandfilename
        :param localPath: localpath
        :param includeTimestamp: boolean True or False
        """
        self.log.info('\n\ncopyFileWindowsToLocalWindows: From: %s to %s\n\n' % (windowsPathAndFileName, localPath))
        fileName = windowsPathAndFileName.split('\\')[-1]
        fileName = fileName.replace(' ', '_')
        if includeTimestamp:
            fileName = self._addTimestampToFile(fileName)

        destinationPath = localPath + '\\' + fileName
        self.log.info('\nCopying from {} -> {}'.format(windowsPathAndFileName, destinationPath))
        self.ixNetwork.CopyFile(windowsPathAndFileName, destinationPath)

    def _copyApiServerFileToLocalLinux(self,apiServerPathAndFileName, localPath, localPathOs='linux', includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param apiServerPathAndFileName: apiServerPathAndFileName
        :param localPath: localPath
        :param localPathOs: localPathOs
        :param includeTimestamp: boolean True or False
        """
        if '/' in apiServerPathAndFileName:
            fileName = apiServerPathAndFileName.split('/')[-1]

        if '\\' in apiServerPathAndFileName:
            fileName = apiServerPathAndFileName.split('\\')[-1]

        fileName = fileName.replace(' ', '_')

        if includeTimestamp:
            fileName = self._addTimestampToFile(fileName)

        if localPathOs == 'linux':
            destinationPath = localPath + '/' + fileName

        if localPathOs == 'windows':
            destinationPath = localPath + '//' + fileName

        self.log.info('\nCopying file from API server:{} -> {}'.format(apiServerPathAndFileName, destinationPath))
        self.session.DownloadFile(apiServerPathAndFileName, destinationPath)

    def _getQuickTestCsvFiles(self,quickTestHandle, copyToPath, csvFile='all', includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: quickTestHandle
        :param copyToPath: copyToPath
        :param csvFile: csvFile
        :param includeTimestamp: boolean True or False
        """
        resultsPath = quickTestHandle.Results.ResultPath
        self.log.info('\ngetQuickTestCsvFiles: %s' % resultsPath)

        if csvFile == 'all':
            getCsvFiles = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']
        else:
            if type(csvFile) is not list:
                getCsvFiles = [csvFile]
            else:
                getCsvFiles = csvFile

        for eachCsvFile in getCsvFiles:
            # Backslash indicates the results resides on a Windows OS.
            if '\\' in resultsPath:
                windowsSource = resultsPath + '\\{0}'.format(eachCsvFile)

                if bool(re.match('[a-z]:.*', copyToPath, re.I)):
                    self._copyFileWindowsToLocalWindows(windowsSource, copyToPath, includeTimestamp=includeTimestamp)
                else:
                    # Copy From Windows API server to local Linux client filesystem
                    self._copyApiServerFileToLocalLinux(windowsSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)

            else:
                linuxSource = resultsPath + '/{0}'.format(eachCsvFile)

                # Copy from Linux api server to Local Linux client filesystem.
                try:
                    self.log.info('\nCopying file from Linux API server:{} to local Linux:{}'.format(linuxSource, eachCsvFile))
                    self._copyApiServerFileToLocalLinux(linuxSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)

                except Exception as errMsg:
                    self.log.info('copyApiServerFileToLocalLinux ERROR: %s', errMsg)

    def rfc2544_quicktest(self,name,options_dict,result_type='csv',timeout=600):
        """
        Creates a new rfc2544 throughput quicktest and configs the desired parameters

        :param name: (str) The name given to the new quicktest e.g. 'RFC2544_QuickTest'
        :param options_dict: (dict) A dict of options to configure

        :Traffic Selection Options:
            traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\n
            flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']\n
            background_traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\n
            background_flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']

        :Protocol Options:
            protocol_state (str): e.g. default, restart, stop, start\n
            wait_after_start (int): e.g. 120\n
            wait_after_stop (int): e.g. 30\n

        :Traffic Options:
            regenerate_traffic (bool): e.g. True, False\n
            frame_size_mode (str): e.g. increment, random, custom, unchanged\n
            start_size (int): e.g. 64\n
            step_size (int): e.g. 1\n
            end_size (int): e.g. 1280\n
            custom_frame_size (list): e.g ['64', '128', '256', '512', '1024']\n
            use_4_byte_sig (bool): e.g. True, False

        :Learning Frame Options
            learning_Frequency (str): e.g. never,onBinaryIteration,oncePerFramesize,oncePerTest,onTrial\n

        :Stats Parameters Options:
            aggregate_per_iteration (bool): e.g. True, False\n
            show_flooded_frames (bool): e.g. True, False\n
            calculate_latency (bool): e.g. True, False\n
            latency_type (str): e.g. 'cutThrough, forwardingDelay, mef, storeForward'\n
            calculate_jitter (bool): e.g. True, False\n
            sequence_errors (bool): e.g. True, False\n
            data_integrity_checl (bool): e.g. True, False\n
            tx_rx_l1_rates (bool): e.g. True, False\n
            per_flow_stats (bool): e.g. True, False\n
            per_port_stats (bool): e.g. True, False

        :Test Parameters Options:
            duration (int): e.g. 300\n
            trials (int): e.g. 2\n
            initial_rate (double): e.g. 10\n
            min_rate (double): e.g. 10\n
            max_rate (double): e.g. 99.99\n
            resolution (double): e.g. 3\n
            backoff (double): e.g. 50
            acceptable_frame_loss (double): e.g 5

        :param result_type: (str) Choose whether you want to save results as a csv, pdf, or both
        :param timeout: The timeout value set before failing the quicktest

        :return: True if successful, else raise an exception

        :Example: rfc2544_quicktest("QuickTestRFC2544",options_dict={'regenerate_traffic':True,'traffic_items':['Traffic Item 1']},result_type='csv',timeout=600)
        """

        quickTestHandle = self.ixNetwork.QuickTest.Rfc2544throughput.add(Name=name,ForceApplyQTConfig=None, Mode='existingMode')
        # for quickTestHandle in self.ixNetwork.QuickTest.Rfc2544throughput.find():

        if self.tgn_server_type == "linux":
            api_key = self.test_platform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        quicktest_href = quickTestHandle.href
        #RestAPI
        protocols_args = {'protocol_state': 'protocolState', 'wait_after_start': 'waitAfterStart',
                          'wait_after_stop': 'waitAfterStop'}

        traffic_options_args = {'regenerate_traffic': 'forceRegenerate', 'frame_size_mode': 'frameSizeMode',
                                'start_size': 'minIncrementFrameSize', 'step_size': 'stepIncrementFrameSize',
                                'end_size': 'maxIncrementFrameSize', 'custom_frame_size': 'framesizeList',
                                'use_4_byte_sig': 'enableMinFrameSize'}

        learning_options_args = {'learning_Frequency': 'learnFrequency'}

        stats_parameters_args = {'aggregated_results_per_iteration': '', 'flooded_frames': 'floodedFramesEnabled',
                                 'calculate_latency': 'calculateLatency', 'latency_type': 'latencyType',
                                 'calculate_jitter': 'calculateJitter', 'sequence_errors': 'reportSequenceError',
                                 'data_integrity_check': 'enableDataIntegrity', 'tx_rx_l1_rates': 'enableLayer1Rate',
                                 'per_flow_stats': '', 'per_port_stats': ''}

        test_parameters_args = {'duration': 'duration', 'trials': 'numtrials', 'initial_rate': 'initialBinaryLoadRate',
                                'min_rate': 'minBinaryLoadRate', 'max_rate': 'maxBinaryLoadRate',
                                'resolution': 'binaryResolution', 'backoff': 'binaryBackoff',
                                'acceptable_frame_loss': 'binaryTolerance', 'load_type': 'loadType','custom_load_list':'loadRateList'}

        # Get traffic item hrefs
        traffic_item_hrefs = []
        background_traffic_item_hrefs = []
        flow_item_hrefs = []
        background_flow_item_hrefs = []
        streams = self.get_traffic_items()
        for stream in streams:
            if 'traffic_items' in options_dict:
                if stream in options_dict['traffic_items']:
                    traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)
            if 'background_traffic_items' in options_dict:
                if stream in options_dict['background_traffic_items']:
                    background_traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)

        url = server_url + quicktest_href + '/trafficSelection'
        for href in traffic_item_hrefs:
            traffic_item_type = self.ixNetwork.Traffic.TrafficItem.read(traffic_item_hrefs[0]).TrafficType
            if traffic_item_type == 'raw':
                traffic_item_type = 'mac'
            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'inTest','trafficItemType': traffic_item_type}
            requests.post(url, json=data, headers=headers, verify=False)
        for href in background_traffic_item_hrefs:
            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'background'}
            requests.post(url, json = data, headers=headers,verify=False)
        for href in flow_item_hrefs:
            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'inTest'}
            requests.post(url, json = data, headers=headers,verify=False)
        for href in background_flow_item_hrefs:
            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'background'}
            requests.post(url, json = data, headers=headers,verify=False)

        # Modify the protocol options
        url = server_url + quicktest_href + '/protocols'
        protocol_args_config = {}
        for key, value in protocols_args.items():
            if key in options_dict.keys():
                protocol_args_config[value] = options_dict[key]
        if protocol_args_config:
            log.info('Configuring the quicktest protocol options...')
            requests.patch(url, json = protocol_args_config, headers=headers,verify=False)

        # Modify the traffic options
        url = server_url + quicktest_href + '/testConfig'
        traffic_options_config = {}
        for key, value in traffic_options_args.items():
            if key in options_dict.keys():
                traffic_options_config[value] = options_dict[key]
        if traffic_options_config:
            log.info('Configuring the quicktest traffic options...')
            requests.patch(url, json = traffic_options_config, headers=headers,verify=False)

        # Modify Learning frames
        url = server_url + quicktest_href + '/learnFrames'
        learn_frames_config = {}
        for key, value in learning_options_args.items():
            if key in options_dict.keys():
                learn_frames_config[value] = options_dict[key]
        if learn_frames_config:
            log.info('Configuring the quicktest learning frame options...')
            requests.patch(url, json=learn_frames_config, headers=headers, verify=False)

        # Modify the stats parameters options
        url =server_url + quicktest_href + '/testConfig'
        stats_parameters_config = {}
        for key, value in stats_parameters_args.items():
            if key in options_dict.keys():
                stats_parameters_config[value] = options_dict[key]
        if stats_parameters_config:
            log.info('Configuring the quicktest stats parameters...')
            requests.patch(url, json = stats_parameters_config, headers=headers,verify=False)

        # Modify the test parameters options
        url = server_url + quicktest_href + '/testConfig'
        test_parameters_config = {}
        for key, value in test_parameters_args.items():
            if key in options_dict.keys():
                if key == 'custom_load_list':
                    options_dict['custom_load_list'] = ','.join(map(str, options_dict['custom_load_list']))
                test_parameters_config[value] = options_dict[key]
        if test_parameters_config:
            log.info('Configuring the quicktest test parameters...')
            requests.patch(url, json=test_parameters_config, headers=headers, verify=False)

        #Restpy
        quickTestHandle.Apply()
        quickTestHandle.Start()
        self._verifyQuickTestInitialization(quickTestHandle)
        self._monitorQuickTestRunningProgress(quickTestHandle)

        try:
            # Store the results in the working dir
            path = CafyLog.work_dir + '/quicktest_results/{}'.format(name)
            os.makedirs(path)
            self.log.info('Saving quick test results to the following dir: {}'.format(path))
        except:
            # Quicktest results dir already exists - skip this step
            self.log.info('Quick test results folder {} already exists - copy the new results over'.format(path))

        linuxDestinationFolder = path
        windowsDestinationFolder = path

        if options_dict.get("load_type", "").lower() == ["binary","quick","combo"]:
            csv_files = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']
        else:
            csv_files = ['AggregateResults.csv', 'results.csv', 'logFile.txt', 'portMap.csv']

        if result_type == 'csv' or result_type == 'both':
            self._getQuickTestCsvFiles(quickTestHandle, csvFile=csv_files, copyToPath=path, includeTimestamp=False)

        if 'test_type' in options_dict.keys() and options_dict['test_type'] == 'latency_test':
            result_path = path + '/results.csv'
            result_info = pd.read_csv(result_path)
            result_info['Min Latency (ns)'] = result_info['Min Latency (ns)'] / 1000
            result_info['Max Latency (ns)'] = result_info['Max Latency (ns)'] / 1000
            result_info['Avg Latency (ns)'] = result_info['Avg Latency (ns)'] / 1000

            result_info.rename(columns={'Min Latency (ns)': 'Min Latency (us)', 'Max Latency (ns)': 'Max Latency (us)',
                                        'Avg Latency (ns)': 'Avg Latency (us)'}, inplace=True)
            with open(result_path, 'w') as file:
                file.truncate(0)
            result_info.to_csv(result_path, index=False)
        
        else:
            result_path = path + '/results.csv'
            result_info = pd.read_csv(result_path)
            result_info.to_csv(result_path, index=False)

        if result_type == 'pdf' or result_type == 'both':
            if self.tgn_server_type != 'linux':
                pdfFile = quickTestHandle.GenerateReport()
                destPdfTestResult = self._addTimestampToFile(pdfFile)

                # Copying the PDF from Windows to local Windows.
                self._copyFileWindowsToLocalWindows(pdfFile, windowsDestinationFolder + '\\' + destPdfTestResult)

                # Copying PDF from either a Windows API server or from a Linux API server to local Linux filesystem.
                self.log.info('Copying test result PDF to: {}'.format(linuxDestinationFolder + destPdfTestResult))
                self.session.DownloadFile(pdfFile, linuxDestinationFolder + destPdfTestResult)

        # Check the result to see if the test passed
        result = quickTestHandle.Results.Result
        if result == 'pass':
            log.info('RFC2544 Throughput Quicktest {} has passed'.format(name))
            return True
        else:
            log.info('RFC2544 Throughput Quicktest {} did not pass'.format(name))
            return False

    def _get_igmp_mld_dict_info(self, igmpMldObj, vlanIndex):
        """
        Function used internally by APIs to get emulated devices and their multicast information.

        :param igmpMldObj: Igmp or Mld object handle
        :param vlanIndex: Vlan id index
        :return: Return emulated devices and thier multicast information
        """
        igmpMldDict = dict()
        if "igmp" in igmpMldObj.href:
            igmpMldDict["igmp"] = {}
            igmpVersion = "IGMP_V2"
            versionTypeValues = igmpMldObj.VersionType.Values
            startMcastAddr = igmpMldObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values
            groupAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.McastAddrCnt.Values
            sourceRange = igmpMldObj.IgmpMcastIPv4GroupList.NoOfSrcRanges
            sourceAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
            if versionTypeValues[vlanIndex] == "version3":
                igmpVersion = "IGMP_V3"
            igmpMldDict["igmp"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["igmp"]["source_list"] = sourceAddrCount[vlanIndex*sourceRange]
            igmpMldDict["igmp"]["start_group_address"] = startMcastAddr[vlanIndex]
            igmpMldDict["igmp"]["version"] = igmpVersion
        if "mld" in igmpMldObj.href:
            igmpMldDict["mld"] = {}
            mldVersion = "MLD_V1"
            versionTypeValues = igmpMldObj.VersionType.Values
            startMcastAddr = igmpMldObj.MldMcastIPv6GroupList.StartMcastAddr.Values
            groupAddrCount = igmpMldObj.MldMcastIPv6GroupList.McastAddrCnt.Values
            sourceRange = igmpMldObj.MldMcastIPv6GroupList.NoOfSrcRanges
            sourceAddrCount = igmpMldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
            if versionTypeValues[vlanIndex] == "version2":
                mldVersion = "MLD_V2"
            igmpMldDict["mld"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["mld"]["source_list"] = sourceAddrCount[vlanIndex*sourceRange]
            igmpMldDict["mld"]["start_group_address"] = startMcastAddr[vlanIndex]
            igmpMldDict["mld"]["version"] = mldVersion
        if "pimV4" in igmpMldObj.href:
            igmpMldDict["pimV4"] = {}
            pimVersion = "PIMv4"
            groupaddr = igmpMldObj.PimV4JoinPruneList.GroupV4Address.Values
            groupAddrCount = igmpMldObj.PimV4JoinPruneList.GroupAddressCount.Values
            sourceAddr = igmpMldObj.PimV4JoinPruneList.SourceV4Address.Values
            sourceCount = igmpMldObj.PimV4JoinPruneList.SourceAddressCount.Values
            igmpMldDict["pimV4"]["start_group_address"] = groupaddr[vlanIndex]
            igmpMldDict["pimV4"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["pimV4"]["source_list"] = sourceAddr[vlanIndex]
            igmpMldDict["pimV4"]["version"] = pimVersion
        if "pimV6" in igmpMldObj.href:
            igmpMldDict["pimV6"] = {}
            pimVersion = "PIMv6"
            groupaddr = igmpMldObj.PimV6JoinPruneList.GroupV6Address.Values
            groupAddrCount = igmpMldObj.PimV6JoinPruneList.GroupAddressCount.Values
            sourceAddr = igmpMldObj.PimV6JoinPruneList.SourceV6Address.Values
            sourceCount = igmpMldObj.PimV6JoinPruneList.SourceAddressCount.Values
            igmpMldDict["pimV6"]["start_group_address"] = groupaddr[vlanIndex]
            igmpMldDict["pimV6"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["pimV6"]["source_list"] = sourceAddr[vlanIndex]
            igmpMldDict["pimV6"]["version"] = pimVersion
        return igmpMldDict

    def get_emulator_info(self, port_name=None, vlan_id=None):
        """
        Creates dictionary of emulated devices(handler) and its multicast configuration information and returns the same
        This Function gets the portname and vlanid and returns the emulated devices and only thier multicast config info like
        start group address, group count and source IP list created in specified portname and having specified vlan ID.

        :param port_name: Name of the port
        :param vlan_id: vlanid of emulated device.
        :return Returns nested dictionary of emulated devices and thier multicast information

        Usage Example:
        tgn.get_emulator_info(port_name="1/15", vlan_id="6")
        Return Output:
        {'P22_SM_v4_Auto_VRF6': {'igmp': {'group_count': '1',
                                          'source_list': '192.0.1.0',
                                          'start_group_address': '226.0.0.1',
                                          'version': 'IGMP_V2'}},
         'P22_SM_v4_BSR_VRF6': {'igmp': {'group_count': '1',
                                         'source_list': '192.0.1.0',
                                         'start_group_address': '227.0.0.1',
                                         'version': 'IGMP_V2'}},
         'P22_SM_v4_Static_VRF6': {'igmp': {'group_count': '1',
                                            'source_list': '192.0.1.0',
                                            'start_group_address': '225.0.0.1',
                                            'version': 'IGMP_V2'}}}
        """
        emulatedInfo = dict()
        dG = None
        if port_name:
            for topology in self.ixNetwork.Topology.find():
                if self.ixNetwork.Vport.find(Name=port_name).href in topology.Vports:
                    igmpMldObjDict = {}
                    for deviceGroupObj in topology.DeviceGroup.find():
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                for igmpObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                    if deviceGroupObj.href in igmpObj.href:
                                        igmpMldObjDict[igmpObj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                for mldObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                    if deviceGroupObj.href in mldObj.href:
                                        igmpMldObjDict[mldObj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():
                                for pimV4Obj in deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():
                                    if deviceGroupObj.href in pimV4Obj.href:
                                        igmpMldObjDict[pimV4Obj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():
                                for pimV6Obj in deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():
                                    if deviceGroupObj.href in pimV6Obj.href:
                                        igmpMldObjDict[pimV6Obj] = deviceGroupObj
                        except:
                            pass

                    for igmpMldOBj, deviceGroupObj in igmpMldObjDict.items():
                        for vlanObj in deviceGroupObj.Ethernet.find().Vlan.find():
                            if vlan_id and vlan_id in vlanObj.VlanId.Values:
                                dG = deviceGroupObj.Name
                                vlanIndex = (vlanObj.VlanId.Values).index(vlan_id)
                                igmpDictInfo = self._get_igmp_mld_dict_info(igmpMldOBj, vlanIndex)
                                if dG in emulatedInfo:
                                    emulatedInfo[dG].update(igmpDictInfo)
                                else:
                                    emulatedInfo[dG] = igmpDictInfo
                                break
                    break
        if dG is None:
            log.info('No Emulated devices are configured on port %s with vlan %s' % (port_name, str(vlan_id)))
            return None
        else:
            return emulatedInfo

    def _process_stream_block(self, high_level_stream_entry, endpointset_entry, traffic_item_obj, vlan_index, mcast_addr_dict, mcast_device):
        """
        Internal Method to process stream block
        :param high_level_stream_entry: Details related to frame rate,type,fixed size etc in high level stream
        :param endpointset_entry: Details of Endpoint set to traffic item
        :param traffic_item_obj:Traffic Item Object on which mcast details are captured
        :param vlan_index: Vlan index of Vlan
        :param mcast_addr_dict:Multicast address dictionary
        :param mcast_device: Multicast device details in topology
        """
        streamblock_info = dict()
        stream_source_ip = ''
        stream_destination_ip = ''

        frame_rate = high_level_stream_entry['frameRate']['rate']
        frame_type = high_level_stream_entry['frameRate']['type']
        frame_rate_type = str(frame_rate) + ' ' + frame_type
        frame_size = str(high_level_stream_entry['frameSize']['fixedSize'])
        flow_index = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 0))['arg3']
        source_ip_index = flow_index.index('Source Address')
        destination_ip_index = flow_index.index('Destination Address')

        flow_data = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 1))['arg4']
        if endpointset_entry['multicastDestinations']!= []:
            mcast_receivers = endpointset_entry['multicastReceivers']

            list(map(lambda x:x.update({'ethHandle': re.search(r'(\S+ethernet\[\d+\])', x['arg1']).group(0)}),mcast_receivers))

            eth_to_mcast_df = pd.DataFrame(map(lambda x: [x['ethHandle'], x['arg1']],
                                            mcast_receivers))
            eth_to_mcast_df.columns = ['ethHandle', 'mcastProto']
            eth_to_mcast_df.drop_duplicates(inplace=True)
            mcast_href_str = ' '.join(eth_to_mcast_df['mcastProto'])

            mcast_ip_list = list(
                map(lambda x: x['arg3'], endpointset_entry['multicastDestinations']))

            if mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index] in mcast_ip_list:
                mcast_ip = mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index]
                ip_type = ipaddress.ip_address(mcast_ip).version
                if (ip_type == 4 and mcast_device in ['igmp', 'pimv4']) or \
                    (ip_type == 6 and mcast_device in ['mld', 'pimv6']):
                    for value in flow_data:
                        stream_source_ip = value[source_ip_index]
                        stream_destination_ip = value[destination_ip_index]
                        if mcast_device in mcast_href_str:
                            mcast_source_ip = mcast_addr_dict[mcast_device][mcast_device + '_source_addr_list'][vlan_index]
                            streamblock_info[traffic_item_obj.Name] = {
                                'packet_rate': frame_rate_type,
                                'packet_size': frame_size,
                                'source_list': mcast_source_ip,
                                'start_group_address': mcast_ip,
                                'source_address': stream_source_ip,
                                'destination_address': stream_destination_ip}

        if streamblock_info:
            return streamblock_info
        else:
            return None

    def get_streamblock_info(self, port_name=None, vlan_id=None, **kwargs):
        """
        Creates dictionary of streamblocks and its multicast configuration information and returns the same
        This Function gets the portname and vlanid and returns the streamblocks and only thier multicast config info like
        start group address, group count and source IP list created in specified portname and having specified vlan ID.

        :param port_name: Name of the port. Make sure portname doesnt have "//". Ex: 172.27.152.15/7/12 instead of 172.27.152.15//7/12. This is as per Cisco request.
        :param vlan_id: vlanid of emulated device.
        :return Returns nested dictionary of Streamblocks and thier multicast information

        Usage Example:
        tgn.get_streamblock_info(port_name="172.27.152.15/7/12", vlan_id="6")
        Return Output:
        {'P22_Static_v4_1_7_12': {'packet_rate': '10 % Line Rate',
                                  'packet_size': '128',
                                  'source_list': '192.0.1.0',
                                  'start_group_address': '225.0.0.1'}}
        """
        streamblock_info = dict()
        port_index = kwargs.get('port_index')
        vlan_index = kwargs.get('vlan_index')

        mcast_device = kwargs.get('mcast_device')
        mcast_addr_dict = kwargs.get('mcast_addr_dict')
        if vlan_id != None:
            vlan_id = re.sub(r"\D", "", vlan_id)
        else:
            return None

        for index, traffic_item_obj in enumerate(self.ixNetwork.Traffic.TrafficItem.find()):
            traffic_item_json = self._get_json_trafficitem(index)
            high_level_stream_list = traffic_item_json['highLevelStream']
            endpointset_list = traffic_item_json['endpointSet']

            for _, high_level_stream_obj in enumerate(high_level_stream_list):
                if 'txPortId' in high_level_stream_obj:
                    streamblock_info = self._process_stream_block(high_level_stream_obj, endpointset_list[0],
                                                                     traffic_item_obj, vlan_index, mcast_addr_dict,
                                                                                 mcast_device)
                    if streamblock_info:
                        return streamblock_info

    def _update_version(self, version, prepend):
        """
        Internal Method to update the Multicast protocols (IGMP , MLD) version
        :param version: Version of the Multicast protocols
        :param prepend: Version type to be added
        """
        if version == 'version2':
            return prepend+ "_V2"
        elif version == "version1":
            return prepend + "_V1"
        else:
            return prepend + "_V3"

    def _retrieve_mcast_device_details(self, device_group_obj, mcast_type):
        """
        Internal Method to retrieve multicast device details
        :param device_group_obj: Device Group Object in topology
        :param mcast_type: given multicast type
        """
        if mcast_type == 'igmp':
            return self._retrieve_igmp_device_details(device_group_obj)
        elif mcast_type == 'mld':
            return self._retrieve_mld_device_details(device_group_obj)
        elif mcast_type == 'pimv4':
            return self._retrieve_pim4_device_details(device_group_obj)
        else:
            return self._retrieve_pim6_device_details(device_group_obj)

    def _retrieve_igmp_device_details(self, deviceGroupObj):
        """
        Internal Method to get the IGMP protocol device details
        :param deviceGroupObj: Device Group Object of IGMP
        return IGMP protocol related details
        """
        igmp_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr.Values
        igmp_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Values
        igmp_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
        igmp_versions = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().VersionType.Values
        igmp_version_list = [self._update_version(version, "IGMP") for version in igmp_versions]
        return [igmp_group_addr_values, igmp_group_addr_count, igmp_source_addr_list, igmp_version_list]

    def _retrieve_mld_device_details(self, deviceGroupObj):
        """
        Internal Method to get the MLD protocol device details
        :param deviceGroupObj: Device Group Object of MLD
        return MLD protocol related details
        """
        mld_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr.Values
        mld_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Values
        mld_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
        mld_versions = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().VersionType.Values
        mld_version_list = [self._update_version(version, "MLD") for version in mld_versions]
        return [mld_group_addr_values, mld_group_addr_count, mld_source_addr_list, mld_version_list]

    def _retrieve_pim4_device_details(self, deviceGroupObj):
        """
        Internal Method to get the PIMv4 protocol device details
        :param deviceGroupObj: Device Group Object of PIMv4
        return PIMv4 protocol related details
        """
        pimv4_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupV4Address.Values
        pimv4_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupAddressCount.Values
        pimv4_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.SourceV4Address.Values
        pimv4_versions = ["PIMv4"] * len(pimv4_group_addr_count)
        return [pimv4_group_addr_values, pimv4_group_addr_count, pimv4_source_addr_list, pimv4_versions]

    def _retrieve_pim6_device_details(self, deviceGroupObj):
        """
        Internal Method to get the PIMv6 protocol device details
        :param deviceGroupObj: Device Group Object of PIMv6
        return PIMv6 protocol related details
        """
        pimv6_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupV6Address.Values
        pimv6_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupAddressCount.Values
        pimv6_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.SourceV6Address.Values
        pimv6_versions = ["PIMv6"] * len(pimv6_group_addr_count)
        return [pimv6_group_addr_values, pimv6_group_addr_count, pimv6_source_addr_list, pimv6_versions]

    def _create_json_trafficitem(self):
        """
        Internal Method to create Traffic Item Json
        """
        traffic_xpath = '/traffic/trafficItem'
        json_str = self.ixNetwork.ResourceManager.ExportConfig([traffic_xpath+"/descendant-or-self::*"], True, "json")
        self.trafficitem_json = json.loads(json_str)

    def _get_json_trafficitem(self, index):
        """
        Internal Method to get Traffic Item Json
        :param index: Represents traffic item index
        """
        return self.trafficitem_json['traffic']['trafficItem'][index]

    def get_mcast_tgn_info(self, **kwargs):
        """
        Get the emulated device, streamblock info for a given port and vlan combination

        eg of the output:- {'172.27.152.15/7/1': {'vlan1': {'P14_SM_V4_Static_VRF1_7_1': {'igmp': {'group_count': '2500',
                                                                        'source_list': '192.0.1.0',
                                                                        'start_group_address': '225.0.0.1',
                                                                        'version': 'version2'}},
                                 'streamblock': {'P14_SM_V4_VRF1_STATIC_7_1': {'group_count': '2500',
                                                                               'packet_rate': '1004.0 framesPerSecond',
                                                                               'packet_size': '128',
                                                                               'source_list': '192.0.1.0',
                                                                               'start_group_address': '225.0.0.1'}}}}}
        return: Dictionary of emulated devices and stream block info
        """
        port_names_list = self.get_list_port_name()
        topology_dict = {}
        vports_dict = {}

        for port_name, topology_obj in product(port_names_list, self.ixNetwork.Topology.find()):
            vport_href = self.ixNetwork.Vport.find(Name=port_name).href
            if vport_href in topology_obj.Vports:
                topology_dict[port_name] = topology_obj
                vports_dict[port_name] = vport_href


        self._create_json_trafficitem()
        igmp_mld_obj_dict = {}
        mapping_dict = dict()

        for port_name, topology_obj in topology_dict.items():
            if port_name not in mapping_dict:
                mapping_dict.update({port_name: {}})
            if port_name not in igmp_mld_obj_dict:
                igmp_mld_obj_dict.update({port_name: {}})

            for device_group_obj in topology_obj.DeviceGroup.find():
                if device_group_obj.Name not in mapping_dict[port_name]:
                    mapping_dict[port_name].update({device_group_obj.Name: {}})
                vport_count = topology_obj.PortCount
                vports_obj_list = topology_obj.Ports

                vlan_list = device_group_obj.Ethernet.find().Vlan.find().VlanId.Values
                vlan_split_count = len(vlan_list) // vport_count
                port_index = (vports_obj_list.index(vports_dict[port_name]))
                length_to_split = [vlan_split_count] * vport_count
                vlan_id_list = iter(vlan_list)
                vlan_id_split_list = [list(islice(vlan_id_list, elem)) for elem in length_to_split]
                vlan_list = vlan_id_split_list[port_index]
                vlan_list = list(set(vlan_list))  ## TODO
                mapping_dict[port_name][device_group_obj.Name].update(
                    {'vlan': dict(zip(range(len(vlan_list)), (vlan_list)))})

                mcast_deviceobj_dict = {}
                if device_group_obj.Ethernet.find().Ipv4.find():
                    if len(device_group_obj.Ethernet.find().Ipv4.find().IgmpHost.find()) > 0:
                        mcast_deviceobj_dict.update({'igmp': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'igmp': {}})

                    if len(device_group_obj.Ethernet.find().Ipv4.find().PimV4Interface.find()) > 0:
                        mcast_deviceobj_dict.update({'pimv4': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'pimv4': {}})

                if device_group_obj.Ethernet.find().Ipv6.find():
                    if len(device_group_obj.Ethernet.find().Ipv6.find().MldHost.find()) > 0:
                        mcast_deviceobj_dict.update({'mld': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'mld': {}})

                    if len(device_group_obj.Ethernet.find().Ipv6.find().PimV6Interface.find()) > 0:
                        mcast_deviceobj_dict.update({'pimv6': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'pimv6': {}})

                group_addr_values = []
                group_addr_count = []
                source_addr_list = []
                version_list = []


                for key, device_group_obj in mcast_deviceobj_dict.items():
                    group_addr_values, group_addr_count, source_addr_list, version_list = \
                        self._retrieve_mcast_device_details(device_group_obj, key)
                    if len(vlan_list) < len(group_addr_values):
                        vlan_list = vlan_list * int(len(group_addr_values) / len(vlan_list))
                        port_index = 0
                    vlan_len = len(vlan_list)
                    start_index = port_index * vlan_len
                    end_index = (port_index + 1) * vlan_len

                    group_addr_count = group_addr_count[start_index:end_index]
                    source_addr_list = source_addr_list[start_index:end_index]
                    group_addr_values = group_addr_values[start_index:end_index]
                    version_list = version_list[start_index:end_index]

                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_group_addr_count': dict(zip(range(len(group_addr_count)), group_addr_count))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_source_addr_list': dict(zip(range(len(source_addr_list)), source_addr_list))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_group_addr_values': dict(zip(range(len(group_addr_values)), group_addr_values))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_version_list': dict(zip(range(len(version_list)), version_list))})


        for port_name in mapping_dict.keys():
            for device_name in mapping_dict[port_name].keys():
                for mcast_device in mapping_dict[port_name][device_name].keys():
                    group_count = mcast_device + '_group_addr_count'
                    source_addr = mcast_device + '_source_addr_list'
                    group_addr = mcast_device + '_group_addr_values'
                    version = mcast_device + '_version_list'

                    for vlan_index, vlan_id in mapping_dict[port_name][device_name]['vlan'].items():
                        if 'vlan' + vlan_id not in igmp_mld_obj_dict[port_name]:
                            igmp_mld_obj_dict[port_name].update({'vlan' + vlan_id: {}})

                        if device_name not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({device_name: {}})

                        if mcast_device != 'vlan' and mcast_device not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id][
                            device_name].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name].update({mcast_device: {}})

                        port_index = port_names_list.index(port_name)

                        if mcast_device != 'vlan' and len(mapping_dict[port_name][device_name][mcast_device]) > 0:
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name][mcast_device] = \
                                {'group_count': mapping_dict[port_name][device_name][mcast_device][group_count][
                                    vlan_index],
                                 'source_list': mapping_dict[port_name][device_name][mcast_device][source_addr][
                                     vlan_index],
                                 'start_group_address': mapping_dict[port_name][device_name][mcast_device][group_addr][
                                     vlan_index],
                                 'version': mapping_dict[port_name][device_name][mcast_device][version][vlan_index],
                                 }
                        if 'streamblock' not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({'streamblock': {}})
                        if mcast_device != 'vlan':
                            streamblock = self.get_streamblock_info(port_name=port_name, vlan_id=vlan_id, vlan_index=vlan_index,
                                                          port_index=port_index,
                                                          mcast_device=mcast_device,
                                                          mcast_addr_dict=mapping_dict[port_name][device_name])
                            if streamblock:
                                if igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock']:
                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'].update(streamblock.items())
                                else:
                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'] = streamblock

        return igmp_mld_obj_dict

    def get_dhcp_session_info(self, device, protocol='ipv4'):
        """
        Retrieves the DHCP session info for a given device

        :param device: The name of the device as seen in the GUI
        :param protocol: retrieves either the v4 'ipv4' or v6 'ipv6' session info
        :return: The DHCP session info on success, exception on failure
        """
        dhcpSessionDict = {}
        if protocol == 'ipv4':
            try:
                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find()
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        else:
            try:
                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find()
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        sessionInfoList = dhcpserversessions.SessionInfo
        for sessionIndex in range(0, len(sessionInfoList)):
            sessionId = 'Session ' + str(sessionIndex + 1)
            dhcpSessionDict[sessionId] = sessionInfoList[sessionIndex]
        return dhcpSessionDict

    def set_dhcp_server(self, device, cfg_dict, protocol='ipv4'):
        """
        Configures a DHCP server based on a given dict of attributes

        :param device: The name of the DHCP server device as seen in the GUI
        :param protocol: Can be 'ipv4' or 'ipv6'
        :param cfg_dict: The dictionary of attributes to be used for configuration
            lease_time (int): The desired lease time
            pool_start_addr (str): Starting IP address for DHCP pools
            pool_incr_addr (str): Increment for pool_start_addr
            pool_host_count (int): The host count for address leasing
            pool_host_incr (int): Increment for pool_host_count

        :return: True on success, exception on failure
        """

        if protocol == 'ipv4':
            try:
                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find().Dhcp4ServerSessions
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        else:
            try:
                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find().Dhcp6ServerSessions
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        dhcpServersessions.DefaultLeaseTime.Single(cfg_dict.get('lease_time', None))
        dhcpServersessions.IpAddress.Increment(start_value=cfg_dict.get('pool_start_addr', None),
                                               step_value=cfg_dict.get('pool_start_step', None))
        dhcpServersessions.IpAddressIncrement.Increment(start_value=cfg_dict.get('pool_incr_addr', None),
                                                        step_value=cfg_dict.get('pool_incr_step', None))
        dhcpServersessions.PoolSize.Increment(start_value=cfg_dict.get('pool_host_count', None),
                                              step_value=cfg_dict.get('pool_host_incr', None))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def set_bgp_med(self, router_id, med, route_block_name=None, ip_type="ipv4"):
        """
        Modify MED for the eBGP route blocks

        :param med: Integer/string representing new MED value
        :param router_id: Router ID of the device
        :param route_block_name: route block name from config
        :param ip_type: "ipv4" or "ipv6"
        :return:
        """
        self.log.info("setting MED value")
        result = False
        device = None
        if route_block_name == None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        device = deviceGroup
                        indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                        break
                else:
                    self.log.info("Router Configuration doesn't found on this device group '%s'"%(deviceGroup.Name))
            if device and device.NetworkGroup.find():
                for networkGroup in device.NetworkGroup.find():
                    networkMultiplier = networkGroup.Multiplier
                    enableList = ['True'] * networkMultiplier
                    if ip_type.lower() == "ipv4":
                        try:
                            if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()
                            if networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()

                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values
                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)

                            medValueList = bgpIpRoute.MultiExitDiscriminator.Values
                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med] * networkMultiplier
                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)
                            result = True
                        except:
                            pass
                    else:
                        try:
                            if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()
                            if networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()

                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values
                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)

                            medValueList =bgpIpRoute.MultiExitDiscriminator.Values
                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med]*networkMultiplier
                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)
                            result = True
                        except:
                            pass
            else:
                self.log.error("Network Group Configuration doesn't found on this device group '%s'" % (deviceGroup.Name))
        if route_block_name:
            if ip_type.lower() == "ipv4":
                try:
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + route_block_name + '$').Ipv4PrefixPools.find().href
                except:
                    raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'"%(route_block_name,ip_type))
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.href in networkGroupObj:
                        for ipv4PoolObj in deviceGroupObj.NetworkGroup.find().Ipv4PrefixPools.find():
                            if ipv4PoolObj.BgpIPRouteProperty.find():
                                result = True
                                bgpV4Route = ipv4PoolObj.BgpIPRouteProperty.find()
                            if ipv4PoolObj.BgpV6IPRouteProperty.find():
                                result = True
                                bgpV4Route = ipv4PoolObj.BgpV6IPRouteProperty.find()
                            bgpV4Route.EnableMultiExitDiscriminator.Single(True)
                            bgpV4Route.MultiExitDiscriminator.Single(med)
            else:
                try:
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().href
                except:
                    raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'"%(route_block_name,ip_type))
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.href in networkGroupObj:
                        for ipv6PoolObj in deviceGroupObj.NetworkGroup.find().Ipv6PrefixPools.find():
                            if ipv6PoolObj.BgpV6IPRouteProperty.find():
                                result = True
                                bgpV6Route = ipv6PoolObj.BgpV6IPRouteProperty.find()
                            if ipv6PoolObj.BgpIPRouteProperty.find():
                                result = True
                                bgpV6Route = ipv6PoolObj.BgpIPRouteProperty.find()
                            bgpV6Route.EnableMultiExitDiscriminator.Single(True)
                            bgpV6Route.MultiExitDiscriminator.Single(med)

        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if result:
            return result
        else:
            self.log.error("Failed due to the config issue")
            return result

    def set_bgp_local_preference(self, router_id, local_preference, route_block_name=None, ip_type="ipv4"):
        """
        Modify local preference for the iBGP route blocks

        :param local_preference: Integer/string representing new local preference. Ex: 100
        :param router_id: Router ID of the device. Ex: 1.1.1.1
        :param route_block_name: route block name from config. Ex: ipv4routerblock101
        :param ip_type: "ipv4" or "ipv6"
        :return:
        """
        self.log.info("setting local_preference value")
        result = True
        if route_block_name == None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in deviceGroup.RouterData.find().RouterId.Values:
                    device = deviceGroup
                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                    break

            for networkGroup in device.NetworkGroup.find():
                networkMultiplier = networkGroup.Multiplier
                enableList = ['True'] * networkMultiplier
                if ip_type.lower() == "ipv4":
                    try:
                        if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                            bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()

                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values
                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)

                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values
                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier
                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)
                    except:
                        pass
                else:
                    try:
                        if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                            bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()

                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values
                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)

                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values
                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier
                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)
                    except:
                        pass
        if route_block_name:
            if ip_type.lower() == "ipv4":
                try:
                    bgpV4Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv4PrefixPools.find().BgpIPRouteProperty.find()
                    bgpV4Route.EnableLocalPreference.Single(True)
                    bgpV4Route.LocalPreference.Single(local_preference)
                except:
                    result = False
            else:
                try:
                    bgpV6Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().BgpIPRouteProperty.find()
                    bgpV6Route.EnableLocalPreference.Single(True)
                    bgpV6Route.LocalPreference.Single(local_preference)
                except:
                    result = False
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return result

    def _bgp_asn_type(self, bgpObj, asn, dutAsn, index_value):
        """
        Internal function used by set_bgp_asn API .Configure type of BGP based on asn and dut_asn value.

        :param bgpObj: BGP Object
        :param asn: Ex: 100
        :param dutAsn: Ex: 100
        :param index_value: Ex: 1
        :return:
        """
        if dutAsn and asn:
            bgpTypeList = bgpObj.Type.Values
            if int(asn) != int(dutAsn):
                bgpTypeList[index_value] = 'external'
            else:
                bgpTypeList[index_value] = 'internal'
            bgpObj.Type.ClearOverlays()
            bgpObj.Type.ValueList(bgpTypeList)
        if dutAsn and asn is None:
            for asn in bgpObj.LocalAs2Bytes.Values:
                if int(asn) != int(dutAsn):
                    bgpObj.Type.Single('external')
                else:
                    bgpObj.Type.Single('internal')

    def set_bgp_asn(self, router_id, asn=None, dut_asn=None):
        """
        Modify AS number on BGP devices.
        Note: First set ASPATH and then modify ASN if changing from IBGP to EBGP.

        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1
        :param asn: AS number of the device on TGN. Ex: 100
        :param dut_asn: NA for IXIA
        :return:

        :Example: set_bgp_asn(router_id="192.0.0.2", asn=1000)
        """
        self.log.info("setting asn value")
        deviceGroupObj = None
        for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
            if deviceGroup.RouterData.find():
                if router_id in deviceGroup.RouterData.find().RouterId.Values:
                    deviceGroupObj = deviceGroup
                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                    break
        if deviceGroupObj:
            try:
                if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                        asnValueList = bgpObj.LocalAs2Bytes.Values
                        asnValueList[indexValue] = asn
                        bgpObj.LocalAs2Bytes.ClearOverlays()
                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)
                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)
            except:
                pass

            try:
                if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                        asnValueList = bgpObj.LocalAs2Bytes.Values
                        asnValueList[indexValue] = asn
                        bgpObj.LocalAs2Bytes.ClearOverlays()
                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)
                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)
            except:
                pass
        else:
            raise IxiaConfigException("Router Id '%s' not found on this configuration." % router_id)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _config_bgp_aspath(self, ipPoolsObj, aspath, ipType):
        """
        Configure BGP Aspath
        :param ipPoolsObj: Ipv4/Ipv6 Prefix Pool Object
        :param aspath: asPath value
        :param ipType: v4/v6
        :return:
        """
        if ipType == "v4":
            if ipPoolsObj.BgpIPRouteProperty.find():
                for bgpIpRoute in ipPoolsObj.BgpIPRouteProperty.find():
                    bgpIpRoute.Stop()
                    bgpIpRoute.OverridePeerAsSetMode.Single("True")
                    bgpIpRoute.EnableAsPathSegments.Single("True")
                    bgpIpRoute.AsSetMode.Single("dontincludelocalas")
                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():
                        pathSegmentObj.SegmentType.Single("asseq")
                    if aspath:
                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(aspath)
                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),
                                                        aspath):
                            bgpAspath.AsNumber.Single(pathValue)
                    else:
                        self.log.info("Aspath passed as null, not configured Aspath")
                    bgpIpRoute.Start()
        else:
            if ipPoolsObj.BgpV6IPRouteProperty.find():
                for bgpIpRoute in ipPoolsObj.BgpV6IPRouteProperty.find():
                    bgpIpRoute.Stop()
                    bgpIpRoute.OverridePeerAsSetMode.Single("True")
                    bgpIpRoute.EnableAsPathSegments.Single("True")
                    bgpIpRoute.AsSetMode.Single("dontincludelocalas")
                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():
                        pathSegmentObj.SegmentType.Single("asseq")
                    if aspath:
                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(
                            aspath)
                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),
                                                        aspath):
                            bgpAspath.AsNumber.Single(pathValue)
                    else:
                        self.log.info("Aspath passed as null, not configured Aspath")
                    bgpIpRoute.Start()
        return True

    def set_bgp_aspath(self, router_id, aspath=[], route_block_name=None, ip_type="ipv4"):
        """
        Modify AS path on BGP route blocks

        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1
        :param aspath: AS path to be set on TGN for the route_block. Ex: [10,20,30]
        :param route_block_name: BGP route block name under the BGP device. Ex: "ipv4routeblock101"
        :param ip_type: "ipv4" or "ipv6"
        :return: True or raise exception
        """
        self.log.info("setting BGP AP path value")
        deviceGroupObj = None
        result = False
        if route_block_name is None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObj = deviceGroup
                        break
            if deviceGroupObj.NetworkGroup.find():
                for networkGroup in deviceGroupObj.NetworkGroup.find():
                    if ip_type.lower() == "ipv4":
                        if networkGroup.Ipv4PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                        if networkGroup.Ipv6PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                    if ip_type.lower() == 'ipv6':
                        if networkGroup.Ipv6PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
                        if networkGroup.Ipv4PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")

        if route_block_name and router_id:
            if type(route_block_name) is list:
                routeBlockNameList = route_block_name
            else:
                routeBlockNameList = [route_block_name]
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObj = deviceGroup
                        break
            if deviceGroupObj:
                for routeBlockName in routeBlockNameList:
                    if ip_type.lower() == "ipv4":
                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                                if networkGroupObj.Ipv4PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                                if networkGroupObj.Ipv6PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                    else:
                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                                if networkGroupObj.Ipv6PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
                                if networkGroupObj.Ipv4PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
        if result:
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return result
        else:
            raise IxiaConfigException(
                "Failed due to configuration issue, Please check RouterId/Route Block Name/IpType")

    def enable_ecn(self, traffic_item, reserved):
        """
        The API is to enable ECN bits on  ipv4 or ipv6 stream

        :param traffic_item: Name of the stream on which ECN bit is to be enabled
        :param reserved: Reserved bits
        :return: None

        """
        self.log.info("Changing ECN value for the traffic item")
        reserved = int(reserved, 2)
        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item+'$')
        if not trafficItemObj:
            raise IxiaConfigException("Traffic item not found")
        if trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv4"):
            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv4")
            if headerHandle.Field.find(Name='default_phb').ActiveFieldChoice == True:
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='class_selector_phb').ActiveFieldChoice == True:
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.classSelectorPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='assured_forwarding_phb').ActiveFieldChoice == True:
                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.assuredForwardingPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='expedited_forwarding_phb').ActiveFieldChoice == True:
                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.expeditedForwardingPHB.unused').FieldValue = reserved
            else:
                headerHandle.Field.find(Name='default_phb').ActiveFieldChoice = True
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved
        elif trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv6"):
            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv6")
            headerHandle.Field.find(Name='trafficClass').FieldValue = reserved
        else:
            raise IxiaConfigException("IPV4/V6 stack not configured on traffic item")

    def retrieve_per_prefix_frame_loss(self, ip_type="ipv4", show_all=False, traffic_item_list=None):
        """
        API to retrieve per prefix frame-loss (Provided by Spirent vendor).
        On Spirent, a stream can have max 4000 flows and a dynamic result view
        can show upto 2000 entries only.
        Once a user-defined view is created, pages of 2000 entries need to be
        scanned to get the least loss and most loss for the flows.

        :param ip_type: If prefix is ipv4 or ipv6.
        :param show_all: True/False
        :param traffic_item_list: list of traffic items on which stats to be retrieved
        :return: Dictionary containing loss prefixes with loss duration
        Examples:
                retrieve_per_prefix_frame_loss()
                retrieve_per_prefix_frame_loss("ipv6",show_all=False)
                retrieve_per_prefix_frame_loss("ipv4",show_all=True)
                retrieve_per_prefix_frame_loss("ipv4",show_all= True, traffic_item_list=['Traffic_item1'])
        """
        prefixesLossDict = {}
        drildownIndex = 0
        prefixBaseStats = None
        all_traffic_items = self.get_traffic_items()

        if not traffic_item_list:
            traffic_item_list = self.get_active_streams()

            if ip_type.lower() == "ipv4":
                for item in all_traffic_items:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "ipv6":
                        try:
                            traffic_item_list.remove(item)
                        except:
                            pass
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "raw":
                        if 'ipv4DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(
                                Name='^' + item + '$').Tracking.find().TrackBy:
                            try:
                                traffic_item_list.remove(item)
                            except:
                                pass

            if ip_type.lower() == "ipv6":
                for item in all_traffic_items:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "ipv4":
                        try:
                            traffic_item_list.remove(item)
                        except:
                            pass
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "raw":
                        if 'ipv6DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(
                                Name='^' + item + '$').Tracking.find().TrackBy:
                            try:
                                traffic_item_list.remove(item)
                            except:
                                pass

        log.info(f"processing traffic items :: {traffic_item_list}")
        trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')
        rowList = [rowNumber for rowNumber, stat in enumerate(trafficItemStats.Rows) if
                   stat['Traffic Item'] in traffic_item_list]
        for rowIndex in rowList:
            trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')
            if ip_type == "ipv4":
                destType = 'IPv4 :Destination Address'
            else:
                destType = 'IPv6 :Destination Address'

            for _ in range(3):
                try:
                    prefixBaseStats = trafficItemStats.Drilldown(rowIndex,
                                                                 trafficItemStats.DrillDownOptions(rowIndex)[
                                                                     drildownIndex],
                                                                 trafficItemStats.TargetRowFilters()[rowIndex])
                    break
                except Exception as e:
                    log.info(f"failed with error {e} \\n\\nretrying")
                    time.sleep(10)


            if prefixBaseStats:
                trafficHeadersList = prefixBaseStats.ColumnHeaders
                trafficPrefixStatsDict = []
                for rowNumber, stat in enumerate(prefixBaseStats.Rows):
                    headerDict = {}
                    for column in trafficHeadersList:
                        if destType == column or column == 'Packet Loss Duration (ms)':
                            headerDict[column] = stat[column]
                            trafficPrefixStatsDict.append(headerDict)

                for trafficdict in trafficPrefixStatsDict:
                    try:
                        prefixIp = trafficdict[destType]
                        lossDuration = trafficdict['Packet Loss Duration (ms)']
                        if show_all:
                            prefixesLossDict.update({prefixIp: lossDuration})
                        else:
                            if int(float(lossDuration)) != 0:
                                prefixesLossDict.update({prefixIp: lossDuration})
                    except Exception as e:
                        if drildownIndex == 0:
                            drildownIndex = drildownIndex + 1
                        log.info(f"failed with error {e}")
                        break
            else:
                raise IxiaConfigException("Failed at drill down")
        if prefixesLossDict:
            return prefixesLossDict
        else:
            raise IxiaConfigException("%s type Traffic stream not found" % ip_type)

    def get_arp_status(self, devices=None):
        """
        Get ARP/ND status for All/specific devices
        :param devices: list of devices' router IDs and/or names
        :return: arp status for each device. Ex: {'192.0.0.20': 'FAILED', 'TestDeviceLDP1': 'FAILED'}
        """
        arpStatus = {}
        if not devices:
            log.info("Devices arg not passed. Fetching all devices from config")
            devices = [device.Name for device in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for device in devices:
            try:
                if '.' in device:
                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                        routerIdIndex = None
                        for routerDataObj in deviceObj.RouterData.find():
                            if device in routerDataObj.RouterId.Values:
                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)
                                break
                        if routerIdIndex is not None:
                            resolveGatewayList = deviceObj.Ethernet.find().Ipv4.find().ResolvedGatewayMac
                            if "Unresolved" in resolveGatewayList[routerIdIndex]:
                                arpStatus[device] = 'Failed'
                            else:
                                arpStatus[device] = 'Resolved'
                else:
                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv4.find().ResolvedGatewayMac
                    if "Unresolved" in resolveGatewayList[0]:
                        arpStatus[device] = 'Failed'
                    else:
                        arpStatus[device] = 'Resolved'
            except:
                pass
            try:
                if '.' in device:
                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                        routerIdIndex = None
                        for routerDataObj in deviceObj.RouterData.find():
                            if device in routerDataObj.RouterId.Values:
                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)
                                break
                        if routerIdIndex is not None:
                            resolveGatewayList = deviceObj.Ethernet.find().Ipv6.find().ResolvedGatewayMac
                            if "Unresolved" in resolveGatewayList[routerIdIndex]:
                                arpStatus[device] = 'Failed'
                            else:
                                arpStatus[device] = 'Resolved'
                else:
                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv6.find().ResolvedGatewayMac
                    if "Unresolved" in resolveGatewayList[0]:
                        arpStatus[device] = 'Failed'
                    else:
                        arpStatus[device] = 'Resolved'
            except:
                pass
        return arpStatus

    def get_worst_flows(self, sort_by="Dropped Frame", traffic_items=None, size=10):
        """
        Creates a new DRV and grabs the 10 worst flows

        Code is a modified version that was initially provided by Spirent (Matt Jefferson)
        :param sort_by: which property to sort Dynamic Result View
            "Dropped Frame"
            "Dropped Frame Duration"
        :param traffic_items: List of traffic items that interested to view it. Default is None, which will view
                            all flows that meet the conditions limited by size
        :param size: number flows per item.
        :return: A list of dictionaries on success, exception on failure
        """
        worstFlows = []
        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
        flowHeadersList = flowStats.ColumnHeaders
        flowStatHeaderValues = []
        for rowNumber, stat in enumerate(flowStats.Rows):
            headerDict = {}
            for column in flowHeadersList:
                headerDict[column] = stat[column]
            flowStatHeaderValues.append(headerDict)
        if traffic_items:
            trafficItemList = []
            for trafficItemName in traffic_items:
                for trafficItemDict in flowStatHeaderValues:
                    for key,value in trafficItemDict.items():
                        if value == trafficItemName:
                            trafficItemList.append(trafficItemDict)
        else:
            trafficItemList = flowStatHeaderValues
        sortedTrafficItemsDict = dict()
        if sort_by == "Dropped Frame":
            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: int(trafficItem.get('Frames Delta')),reverse=True)
        if sort_by == "Dropped Frame Duration":
            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: float(trafficItem.get('Packet Loss Duration (ms)')),reverse=True)
        for trafficItemIndex in range(0,len(sortedTrafficItemsDict)):
            if trafficItemIndex < size:
                worstFlows.append(sortedTrafficItemsDict[trafficItemIndex])
        if worstFlows:
            return worstFlows
        else:
            raise CafyException.InvalidValueError('No results found')

    def enable_traffic_minimum_size(self):
        """
        API to enable to send minimum size traffic
        :return:
        """
        self.ixNetwork.Traffic.EnableMinFrameSize = True

    def change_port_speed(self,port_list, speed='1G', media='fiber'):
        """
        To change the speed of the port

        :param port_list: list of ports
        :param speed: type of speed 1G, 10G
        :param media: type of media - "fiber" , "copper"

        Ex: tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='1G', media='copper')
            tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='10G')
        """
        speedDictIxiaMapping = {'1G': 'speed1000','10G':'speed10g'}
        for port in port_list:
            for vport in self.ixNetwork.Vport.find():
                if port.replace("/",":") == vport.AssignedTo:
                    cardType = vport.Type
                    if cardType == 'novusTenGigLan':
                        cardType = cardType[0].upper() + cardType[1:]
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.Media = media
                        if media == 'fiber':
                            cardObj.AutoNegotiate = False
                        cardObj.Speed = speedDictIxiaMapping[speed]
                    else:
                        self.log.info("Skipping changing the port speed as card type is not novusTenGigLan")

    def get_frame_l3_information(self,stream_name, mode='ipv4'):
        """
        Returns L3 header info for the stream requested

        :param stream_name: stream name used in TGN GUI
        :param mode: ipv4 or ipv6
        :return: dictionary containing L3 header info

        Example of data returned:
        {'VLAN Priority': '7', 'VLAN-ID': '2', 'Precedence': '110 Internetwork Control', 'Source Address': '50.0.0.2',
        'Destination Address': '70.0.0.2', 'TCP-Source-Port': '1024', 'TCP-Dest-Port': '1024', 'Name': 'v4-stream-2-1'}
        """
        try:
            trafficitem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')
        except:
            raise IxiaConfigException("Stream Not available")

        highlevelstream = trafficitem.HighLevelStream.find()
        output = highlevelstream.PreviewFlowPackets(0,1)
        l3Info = dict(zip(output['arg3'], output['arg4'][0]))
        remove = ['Packet #', 'Destination MAC Address', 'Source MAC Address', 'Ethernet-Type', 'PFC Queue']
        l3Info = dict([(k, v) for k, v in l3Info.items() if k not in remove])
        l3Info['Name'] = stream_name
        return l3Info

    def add_multiple_devices(self, port_tuple=None, device_info=None, csv_file=None, new_config=True, **kwargs):
        """
        API to create multiple devices in single attempt

        :param port_tuple: list of ports
        :param device_info: list of dictionary as shown in example
        :param csv_file: csv file
        :param new_config: boolean, True if want to clear the config else False

        :Example: add_multiple_devices(port_tuple = ['10.39.64.137/1/3', '10.39.64.137/2/3', '10.39.64.137/1/5', '10.39.64.137/2/4'],
                                       device_info = [{'port_name':'hu2_39_np0_sl0',  'device_name':'hu2_39_np0_sl0_v4',  'ipv4_address':'120.0.0.2',  'ipv4_gateway':'120.0.0.1'},
                                                      {'port_name': 'hu2_21_np0_sl1', 'device_name': 'hu2_21_np0_sl1_v4', 'ipv4_address': '120.0.1.2', 'ipv4_gateway': '120.0.1.1'}],
                                                      csv_file=device.csv)
        """
        self.log.info("Adding Multiple devices")
        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)
        if self.update_license == False and new_config == True:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        devicesInfo = list()
        portTuple = list()
        if csv_file:
            devicesInfoTemp = list()
            portTupleTemp = list()
            with open(csv_file) as csvFile:
                reader = csv.DictReader(csvFile)
                for row in reader:
                    rowAsDict = {key: value for key, value in row.items()}
                    devicesInfoTemp.append(rowAsDict)

            for deviceInfo in devicesInfoTemp:
                portTupleTemp.append(deviceInfo['port'])

            for port in portTupleTemp:
                if port not in portTuple and port != '':
                    portTuple.append(port)

            for deviceInfo in devicesInfoTemp:
                del deviceInfo['port']
                devicesInfo.append(deviceInfo)
        else:
            devicesInfo = device_info
            portTuple = port_tuple

        if new_config:
            self.ixNetwork.NewConfig()
        self.ixNetwork.Traffic.UseRfc5952 = True
        for device in devicesInfo:
            if device['port_name'] == '':
                continue
            else:
                if self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$'):
                    topology = self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$')
                else:
                    topology = self.ixNetwork.Topology.add(Name=device['port_name'], Note=None, Ports=None, Vports=self.ixNetwork.Vport.add(Name=device['port_name']))

                if 'subinterfaces_count' in device and device['subinterfaces_count']!= '':
                    multiplier = device['subinterfaces_count']
                else:
                    multiplier = 1
                if topology.DeviceGroup.find(Name=device['device_name']):
                    devicegroupObj = topology.DeviceGroup.find(Name=device['device_name'])
                    ethernetObj = devicegroupObj.Ethernet.find()
                else:
                    devicegroupObj = topology.DeviceGroup.add(Multiplier=multiplier, Name=device['device_name'])
                    ethernetObj = devicegroupObj.Ethernet.add()

                if 'vlan' in device and device['vlan'] != '':
                    ethernetObj.EnableVlans.Single(True)
                    if 'vlan_valuetype' not in device:
                        device['vlan_valuetype'] = 'increment'
                    if device['vlan_valuetype'] == 'custom' :
                        ethernetObj.Vlan.find()[0].VlanId.Custom(start_value= device['vlan_start_value'],
                                                                 step_value=device['vlan_step_value'],
                                                                 increments=[(0, device['vlan_repeat_count'], [])])
                    else:
                        ethernetObj.Vlan.find()[0].VlanId.Increment(start_value=device['vlan'], step_value=1)

                if 'ipv4_address' in device and device['ipv4_address'] != '':
                    if ethernetObj.Ipv4.find():
                        ipv4Obj = ethernetObj.Ipv4.find()
                    else:
                        ipv4Obj = ethernetObj.Ipv4.add()
                    if 'ipv4_address_step' in device  and device['ipv4_address_step'] != '':
                        step = device['ipv4_address_step']
                    else:
                        step = "0.0.1.0"
                    ipv4Obj.Address.Increment(start_value=device['ipv4_address'], step_value=step)
                if 'ipv4_prefix' in device and device['ipv4_prefix'] != '':
                    ipv4Obj.Prefix.Single(device['ipv4_prefix'])
                if 'ipv4_gateway' in device and device['ipv4_gateway'] != '':
                    if 'ipv4_gateway_step' in device  and device['ipv4_gateway_step'] != '':
                        step = device['ipv4_gateway_step']
                    else:
                        step = "0.0.1.0"
                    ipv4Obj.GatewayIp.Increment(start_value=device['ipv4_gateway'], step_value=step)
                if 'ipv4_suppress_arp_gateway' in device and device['ipv4_suppress_arp_gateway'] != '':
                    if ethernetObj.Ipv4.find():
                        self.ixNetwork.Globals.Topology.Ipv4.SuppressArpForDuplicateGateway.Single(device['ipv4_suppress_arp_gateway'])
                if 'ipv6_address' in device and device['ipv6_address'] != '':
                    if ethernetObj.Ipv6.find():
                        ipv6Obj = ethernetObj.Ipv6.find()
                    else:
                        ipv6Obj = ethernetObj.Ipv6.add()
                    if 'ipv6_address_step' in device  and device['ipv6_address_step'] != '':
                        step = device['ipv6_address_step']
                    else:
                        step = "::1:0"
                    ipv6Obj.Address.Increment(start_value=device['ipv6_address'], step_value=step)
                if 'ipv6_prefix' in device and device['ipv6_prefix'] != '':
                    ipv6Obj.Prefix.Single(device['ipv6_prefix'])
                if 'ipv6_gateway' in device and device['ipv6_gateway'] != '':
                    if 'ipv6_gateway_step' in device  and device['ipv6_gateway_step'] != '':
                        step = device['ipv6_gateway_step']
                    else:
                        step = "::1:0"
                    ipv6Obj.GatewayIp.Increment(start_value=device['ipv6_gateway'], step_value=step)
                if 'ipv6_suppress_ns_gateway' in device and device['ipv6_suppress_ns_gateway'] != '':
                    if ethernetObj.Ipv6.find():
                        self.ixNetwork.Globals.Topology.Ipv6.SuppressNsForDuplicateGateway.Single(device['ipv6_suppress_ns_gateway'])

                igmpKwargs = {key: device[key] for key in device if "igmp" in key and device[key] != ""}
                mldKwargs = {key: device[key] for key in device if "mld" in key and device[key] != ""}
                ospfv2Kwargs = {key: device[key] for key in device if "ospf_v2" in key and device[key] != ""}
                ospfv3Kwargs = {key: device[key] for key in device if "ospf_v3" in key and device[key] != ""}
                ldpv4Kwargs = {key: device[key] for key in device if "ldp_v4" in key and device[key] != ""}
                ldpv6Kwargs = {key: device[key] for key in device if "ldp_v6" in key and device[key] != ""}
                bgpv4Kwargs = {key: device[key] for key in device if "bgp_v4" in key and device[key] != ""}
                bgpv6Kwargs = {key: device[key] for key in device if "bgp_v6" in key and device[key] != ""}
                isisKwargs = {key: device[key] for key in device if "isis" in key and device[key] != ""}

                # Create IGMP
                if igmpKwargs != {}:
                    igmpObj = IGMP(ixNetwork=self.ixNetwork,
                                   obj=ipv4Obj,
                                   **igmpKwargs)
                    igmpObj.config()
                    igmp_rate_interval = igmpKwargs.get('igmp_rate_interval', 0)
                    devicegroup_name = devicegroupObj.Name
                    if igmp_rate_interval:
                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name)

                # Create MLD
                if mldKwargs != {}:
                    mldObj = MLD(ixNetwork=self.ixNetwork,
                                 obj=ipv6Obj,
                                 **mldKwargs)
                    mldObj.config()
                    mld_rate_interval = mldKwargs.get('mld_rate_interval', 0)
                    devicegroup_name = devicegroupObj.Name
                    if mld_rate_interval:
                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name)

                # Create OSPFv2
                if ospfv2Kwargs != {}:
                    ospfv2Obj = OSPFv2(ixNetwork=self.ixNetwork,
                                       obj=ipv4Obj,
                                       **ospfv2Kwargs)
                    ospfv2Obj.config()

                # Create OSPFv3
                if ospfv3Kwargs != {}:
                    ospfv3Obj = OSPFv3(ixNetwork=self.ixNetwork,
                                       obj=ipv6Obj,
                                       **ospfv3Kwargs)
                    ospfv3Obj.config()

                #Create LDP on IPV4
                if ldpv4Kwargs != {}:
                    ldpv4Obj = LDPv4(ixNetwork=self.ixNetwork,
                                       obj=ipv4Obj,
                                       **ldpv4Kwargs)
                    ldpv4Obj.config()

                #Create LDP on IPV6
                if ldpv6Kwargs != {}:
                    ldpv6Obj = LDPv6(ixNetwork=self.ixNetwork,
                                       obj=ipv6Obj,
                                       **ldpv6Kwargs)
                    ldpv6Obj.config()

                # Create BGPv4
                if bgpv4Kwargs != {}:
                    bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork,
                                     obj=ipv4Obj,
                                     **bgpv4Kwargs)
                    bgpv4Obj.config()

                # Create BGPv6
                if bgpv6Kwargs != {}:
                    bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork,
                                     obj=ipv6Obj,
                                     **bgpv6Kwargs)
                    bgpv6Obj.config()

                # Create ISIS
                if isisKwargs != {}:
                    isisObj = ISIS(ixNetwork=self.ixNetwork,
                                   obj=ethernetObj,
                                   test_platform=self.test_platform,
                                   server_type=self.tgn_server_type,
                                   server_ip=self.server_ip,
                                   port=self.port,
                                   **isisKwargs)
                    isisObj.config()

        if portTuple:
            chassisList = list()
            portList = list()
            for port in portTuple:
                self.log.info(f"Device created for: {port}")
                chassisListTemp = port.split('/')
                portListTemp = port.split('/')
                if len(chassisListTemp) < 3:
                    chassisList.append(self.chassis_ip)
                    portListTemp.insert(0, self.chassis_ip)
                else:
                    chassisList.append(port.split('/')[0])
                portList.append(portListTemp)
            chassisList = list(set(chassisList))
            self.connect_to_chassis(chassisList)
            if self.primary:
                self.connect_to_chassis([self.primary])
                self.set_chassis_mode(primary=self.primary, secondary=chassisList)
            self._assign_ports(portList)

    def add_multiple_traffic_streams(self, traffic_info=None, csv_file=None, **kwargs):
        """
        API to create multiple traffic streams

        :param traffic_info: list of dictionary [{'stream_name': 'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc',
        'stream_type': 'Unicast', 'traffic_type': 'ipv4', 'stream_src': 'TenGigE0/2/0/0_v4',
        'stream_dest': 'TenGigE0/2/0/1_v4', 'frame_size': '1518', 'multicast_address': '', 'bi-directional': 'FALSE',
        'Groupname(multicast) (Eg: ipv4Group1)': '', 'Increment(Multicast)(Eg: 3:1)': '255.255.255.255', 'txLoad(%)': '100',
        'tolerance(%)': '', 'tcp_header': 'TRUE', 'tcp_src_port': '2000', 'tcp_dst_port': '3000', 'udp_header': '',
        'udp_src_port': '', 'udp_dst_port': '', 'throughput(%)': '', 'tos': 'Precedence'}]

        :param csv_file: csv file
        :param  stream_name'    Ex:  'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc'
        :param   'stream_type'  Ex:  'Unicast'
        :param   'traffic_type' Ex:  'ipv4'
        :param   'stream_src'   Mandatory parameter Ex:  'TenGigE0/2/0/0_v4'
        :param   'stream_dest'  Mandatory parameter Ex:  'TenGigE0/2/0/1_v4'
        :param   'frame_size'   Ex:  '1518'
        :param   'multicast_address'    Ex:  '255.255.255.255'
        :param   'bi-directional'   Ex:  'FALSE'
        :param   'Groupname(multicast)  Ex:  ipv4Group1)'
        :param   'Increment(Multicast)  Ex: 3
        :param   'txLoad(%)'    Ex:  '100'
        :param   'tolerance(%)' Ex:  ''
        :param   'tcp_header'   Ex:  'TRUE'
        :param   'tcp_src_port' Ex:  '2000'
        :param   'tcp_dst_port' Ex:  '3000'
        :param   'udp_header'   Ex:  'TRUE'
        :param   'udp_src_port' Ex:  '2000'
        :param   'udp_dst_port' Ex:  '3000'
        :param   'throughput(%)'Ex: '100'
        :param   'tos' if value is from '0'-'255'
                  IP Priority will be set to 'TOS' if 'tos' value is  from '0' to '7' or ""000 Routine","001 Priority","010 Immediate","011 Flash","100 Flash Override","101 CRITIC/ECP","110 Internetwork Control"
                  IP Priority will be set to 'Raw Priority' if value is from '8' to '255'
        :param   'enable' bool
        :param   'raw_stream_ip_stack' : ipv4 or ipv6
        :param   'eth_src_mac' Ex: '00:00:00:00:00:01'
        :param   'eth_dst_mac' Ex: '00:00:00:00:01:01'
        :param   'eth_dst_mac_mode' Ex: 'INCR'
        :param   'eth_src_mac_mode' Ex: 'INCR'
        :param   'eth_src_mac_count' Ex: 1
        :param   'eth_dst_mac_count' Ex: 1
        :param   'eth_dst_mac_step' Ex: '00:00:00:00:00:01'
        :param   'eth_src_mac_step' Ex: '00:00:00:00:00:01'
        :param   'src_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'
        :param   'src_count' Ex: 1
        :param   'dst_mode' Ex: 'INCR'
        :param   'dst_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'
        :param   'dst_count' Ex: 1
        :param   'dst_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'
        :param   'src_mode' Ex: 'INCR'
        :param   'src_count' Ex: 1
        :param   'src_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'
        :return:
        """
        self.log.info("Adding Multiple Traffic Items")
        tos_value_list = [0, 20, 40, 60, 80, 28, 30, 38, 48, 50, 58, 68, 70, 78, 88, 90, 98]
        trafficsItemInfo = list()

        def _is_ip(value):

            try:
                ipaddress.ip_address(value)
                return True
            except ValueError:
                return False

        if csv_file:
            with open(csv_file) as csvFile:
                reader = csv.DictReader(csvFile)
                for row in reader:
                    rowAsDict = {key: value for key, value in row.items()}
                    trafficsItemInfo.append(rowAsDict)
        else:
            trafficsItemInfo = traffic_info

        if traffic_info:
            try:
                save_dir = CafyLog.work_dir
                os.makedirs(save_dir, exist_ok=True)

                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                save_path = os.path.join(save_dir, f"traffic_info_{timestamp}.json")

                with open(save_path, "w", encoding="utf-8") as f:
                    f.write("# === Traffic Info Snapshot ===\n\n")
                    f.write(json.dumps(trafficsItemInfo, indent=4, ensure_ascii=False))

                self.log.info(f"Traffic info saved to: {save_path}")
            except Exception as e:
                self.log.warning(f"Failed to save traffic_info snapshot: {e}")

        for trafficItemInfo in trafficsItemInfo:

            src_ip = None
            dst_ip = None

            trafficItemInfo['stream_type'] = trafficItemInfo.get('stream_type', 'Unicast')
            if trafficItemInfo['stream_type'] == '':
                continue
            else:
                trafficItemInfo['stream_name'] = trafficItemInfo['stream_name'].replace('+', r'\+').replace('*', r'\*')
                if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemInfo['stream_name'] + '$'):
                    trafficItem = self.ixNetwork.Traffic.TrafficItem.find(
                        Name='^' + trafficItemInfo['stream_name'] + '$')
                else:
                    trafficItem = self.ixNetwork.Traffic.TrafficItem.add(Name=trafficItemInfo['stream_name'],
                                                                         TrafficType=trafficItemInfo['traffic_type'],
                                                                         BiDirectional=trafficItemInfo.get(
                                                                             'bi-directional', False))
                if 'enable' in trafficItemInfo:
                    if trafficItemInfo['enable'] != '':
                        trafficItem.Enabled = trafficItemInfo['enable']
                sources_ip = list()
                destinations_ip = list()
                sources = list()
                destinations = list()

                if trafficItemInfo['stream_type'] == 'Unicast':

                    if 'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] != '':
                        if trafficItemInfo['traffic_type'] == "raw":
                            if 'stream_src' not in trafficItemInfo or trafficItemInfo['stream_src'] == '':
                                raise IxiaConfigException(
                                    "Please send 'stream_src' parameter value to create Raw Traffic")
                            else:
                                if isinstance(trafficItemInfo['stream_src'], str):
                                    trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]
                                if isinstance(trafficItemInfo['stream_src'], list):
                                    for src in trafficItemInfo['stream_src']:
                                        vport_href = self.ixNetwork.Vport.find(
                                            Name='^' + src + '$').href
                                        sources.append(vport_href + '/protocols')

                        else:
                            sources_ip = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],
                                                                       topology=None)
                    else:
                        if trafficItemInfo['traffic_type'] == "raw":
                            if isinstance(trafficItemInfo['stream_src'], str):
                                trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]
                            if isinstance(trafficItemInfo['stream_src'], list):
                                for src in trafficItemInfo['stream_src']:
                                    vport_href = self.ixNetwork.Vport.find(
                                        Name='^' + src + '$').href
                                    sources.append(vport_href + '/protocols')
                            else:
                                raise IxiaConfigException("Port Name '%s' not found" % trafficItemInfo['stream_src'])
                        else:

                            if isinstance(trafficItemInfo['stream_src'], str):
                                trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]

                            sources = []
                            for src_stream in trafficItemInfo['stream_src']:
                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + src_stream + '$')
                                if dg and len(dg) > 0:
                                    sources.extend([dg_item.href for dg_item in dg])
                                else:
                                    self.log.warning(f"DeviceGroup '{src_stream}' not found in topology.")

                    if 'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] != '':
                        if trafficItemInfo['traffic_type'] == "raw":
                            if 'stream_dest' not in trafficItemInfo or trafficItemInfo['stream_dest'] == '':
                                raise IxiaConfigException(
                                    "Please send 'stream_dest' parameter value to create Raw Traffic")
                            else:
                                if isinstance(trafficItemInfo['stream_dest'], str):
                                    trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]
                                if isinstance(trafficItemInfo['stream_dest'], list):
                                    for dest in trafficItemInfo['stream_dest']:
                                        vport_href = self.ixNetwork.Vport.find(
                                            Name='^' + dest + '$').href
                                        destinations.append(vport_href + '/protocols')
                        else:
                            destinations_ip = self._endpoint_destination_handles(trafficItemInfo['dst_ip'],
                                                                                 destinationsList=[], topology=None)
                    else:
                        if trafficItemInfo['traffic_type'] == "raw":
                            if isinstance(trafficItemInfo['stream_dest'], str):
                                trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]
                            if isinstance(trafficItemInfo['stream_dest'], list):
                                for dest in trafficItemInfo['stream_dest']:
                                    vport_href = self.ixNetwork.Vport.find(
                                        Name='^' + dest + '$').href
                                    destinations.append(vport_href + '/protocols')
                            else:
                                raise IxiaConfigException("Port Name '%s' not found" % trafficItemInfo['stream_dest'])
                        else:

                            if isinstance(trafficItemInfo['stream_dest'], str):
                                trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]

                            destinations = []
                            for dest_stream in trafficItemInfo['stream_dest']:
                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dest_stream + '$')
                                if dg and len(dg) > 0:
                                    destinations.extend([dg_item.href for dg_item in dg])

                                else:
                                    self.log.warning(f"DeviceGroup '{dest_stream}' not found in topology.")

                    # pdb.set_trace()
                    if all(k in trafficItemInfo for k in ('stream_src', 'stream_dest', 'src_ip', 'dst_ip')) \
                            and trafficItemInfo['src_ip'] and trafficItemInfo['dst_ip']:
                        sources_ip = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],
                                                                   topology=None)
                        destinations_ip = self._endpoint_destination_handles(trafficItemInfo['dst_ip'],
                                                                             destinationsList=[], topology=None)

                    src_ip = trafficItemInfo.get('src_ip')
                    dst_ip = trafficItemInfo.get('dst_ip')
                    stream_src = trafficItemInfo.get('stream_src')
                    stream_dest = trafficItemInfo.get('stream_dest')

                    if isinstance(src_ip, str):
                        src_ip = [src_ip]
                    if isinstance(dst_ip, str):
                        dst_ip = [dst_ip]

                    if isinstance(stream_src, str):
                        stream_src = [stream_src]
                    if isinstance(stream_dest, str):
                        stream_dest = [stream_dest]

                    trafficItemInfo['src_ip'] = src_ip
                    trafficItemInfo['dst_ip'] = dst_ip
                    trafficItemInfo['stream_src'] = stream_src
                    trafficItemInfo['stream_dest'] = stream_dest

                    if (
                            'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] and
                            'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] and
                            'raw_stream_ip_stack' not in trafficItemInfo and
                            trafficItemInfo['traffic_type'] != 'raw' and
                            all(_is_ip(ip) for ip in trafficItemInfo.get('src_ip', [])) and
                            all(_is_ip(ip) for ip in trafficItemInfo.get('dst_ip', [])) and
                            all(k in trafficItemInfo for k in ('stream_src', 'stream_dest'))
                    ):
                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip,
                                                    ScalableDestinations=destinations_ip)

                    elif (
                            'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] and
                            'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] and
                            'raw_stream_ip_stack' not in trafficItemInfo and
                            trafficItemInfo['traffic_type'] != 'raw' and
                            all(_is_ip(ip) for ip in trafficItemInfo.get('src_ip', [])) and
                            all(_is_ip(ip) for ip in trafficItemInfo.get('dst_ip', [])) and
                            not all(k in trafficItemInfo for k in ('stream_src', 'stream_dest'))
                    ):
                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip,
                                                    ScalableDestinations=destinations_ip)

                    # Case 1: One-to-Many (single src_ip  all in stream_dest)
                    if (
                            "src_ip" in trafficItemInfo and trafficItemInfo["src_ip"] and
                            "stream_dest" in trafficItemInfo and trafficItemInfo["stream_dest"] and
                            ("dst_ip" not in trafficItemInfo or not trafficItemInfo["dst_ip"]) and
                            trafficItemInfo["traffic_type"] in ["ipv4", "ipv6"]
                    ):
                        sources_ip = self._endpoint_source_handles(trafficItemInfo["src_ip"], sourcesList=[],
                                                                   topology=None)

                        if isinstance(trafficItemInfo["stream_dest"], str):
                            dest_dgs = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=f"^{trafficItemInfo['stream_dest']}$"
                            )
                            destinations = list(dest_dgs)
                        elif isinstance(trafficItemInfo["stream_dest"], list):
                            destinations = []
                            for dest_name in trafficItemInfo["stream_dest"]:
                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f"^{dest_name}$")
                                if dg:
                                    destinations.extend(list(dg))

                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip, Destinations=destinations)

                    # Case 2: Many-to-One (all in stream_src -> single dst_ip)
                    elif (
                            "dst_ip" in trafficItemInfo and trafficItemInfo["dst_ip"] and
                            "stream_src" in trafficItemInfo and trafficItemInfo["stream_src"] and
                            ("src_ip" not in trafficItemInfo or not trafficItemInfo["src_ip"]) and
                            trafficItemInfo["traffic_type"] in ["ipv4", "ipv6"]
                    ):
                        # destinations_ip = self._endpoint_destination_handles(trafficItemInfo["dst_ip"], destinationsList=[], topology=None)

                        if isinstance(trafficItemInfo["stream_src"], str):
                            src_dgs = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=f"^{trafficItemInfo['stream_src']}$"
                            )
                            sources = list(src_dgs)
                        elif isinstance(trafficItemInfo["stream_src"], list):
                            sources = []
                            for src_name in trafficItemInfo["stream_src"]:
                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f"^{src_name}$")
                                if dg:
                                    sources.extend(list(dg))

                        destinations_ip = self._endpoint_destination_handles(trafficItemInfo["dst_ip"],
                                                                             destinationsList=[], topology=None)
                        trafficItem.EndpointSet.add(Name=None, Sources=sources, ScalableDestinations=destinations_ip)


                    elif (
                            trafficItemInfo.get('stream_src') == trafficItemInfo.get('src_ip') and
                            trafficItemInfo['traffic_type'] != 'raw' and
                            trafficItemInfo.get('stream_dest') == trafficItemInfo.get('dst_ip')
                    ):
                        trafficItem.EndpointSet.add(Name=None, Sources=sources_ip, Destinations=destinations_ip)

                    elif (
                            trafficItemInfo.get('stream_src') and
                            trafficItemInfo.get('stream_dest') and
                            trafficItemInfo['traffic_type'] != 'raw'
                    ):
                        trafficItem.EndpointSet.add(Name=None, Sources=sources, Destinations=destinations)


                    elif trafficItemInfo['traffic_type'] == 'raw':
                        trafficItem.EndpointSet.add(Name=None, Sources=sources, Destinations=destinations)

                    elif sources_ip and not destinations_ip:
                        raise IxiaConfigException("Raised exception due to destination Ip not passed")

                    elif not sources_ip and destinations_ip:
                        raise IxiaConfigException("Raised exception due to source Ip not passed")

                else:

                    if 'stream_dest' in trafficItemInfo:
                        trafficItemInfo.pop('stream_dest')

                    if 'dst_ip' in trafficItemInfo:
                        trafficItemInfo.pop('dst_ip')

                    stream_src = trafficItemInfo.get("stream_src", [])
                    if isinstance(stream_src, str):
                        stream_src = [stream_src]
                    trafficItemInfo["stream_src"] = stream_src

                    multicast_address = trafficItemInfo.get("multicast_address")
                    if not multicast_address:
                        raise IxiaConfigException("Missing 'multicast_address' for multicast stream")

                    is_ipv6 = ":" in multicast_address

                    sources = []
                    for src_name in stream_src:
                        dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f"^{src_name}$")
                        if dg:
                            sources.extend(list(dg))
                        else:
                            self.log.warning(f"[IXIA] DeviceGroup '{src_name}' not found for multicast source")

                    if not sources:
                        raise IxiaConfigException(f"No valid sources found for {trafficItemInfo['stream_src']}")

                    sources_ip = []
                    if "src_ip" in trafficItemInfo and trafficItemInfo["src_ip"]:
                        sources_ip = self._endpoint_source_handles(
                            trafficItemInfo["src_ip"], sourcesList=[], topology=None
                        )

                    multicast_list = multicast_address if isinstance(multicast_address, list) else [multicast_address]
                    mcastdestination = [
                        {
                            "arg1": False,
                            "arg2": "none",
                            "arg3": str(mcast_addr),
                            "arg4": "::" if is_ipv6 else "0.0.0.0",
                            "arg5": 1
                        }
                        for mcast_addr in multicast_list if mcast_addr
                    ]

                    if sources_ip:
                        trafficItem.EndpointSet.add(
                            Name=None, ScalableSources=sources_ip, MulticastDestinations=mcastdestination
                        )
                    else:
                        trafficItem.EndpointSet.add(
                            Name=None, Sources=sources, MulticastDestinations=mcastdestination
                        )

                if isinstance(src_ip, list):
                    trafficItemInfo['src_ip'] = src_ip[0]
                if isinstance(dst_ip, list):
                    trafficItemInfo['dst_ip'] = dst_ip[0]

                if 'frame_size' in trafficItemInfo and trafficItemInfo['frame_size'] != '':
                    stackObj = trafficItem.ConfigElement.find().FrameSize
                    setattr(stackObj, 'FixedSize', trafficItemInfo['frame_size'])

                if 'txLoad(%)' in trafficItemInfo and trafficItemInfo['txLoad(%)'] != '':
                    stackObj = trafficItem.ConfigElement.find().FrameRate
                    setattr(stackObj, 'Type', 'percentLineRate')
                    setattr(stackObj, 'Rate', trafficItemInfo['txLoad(%)'])

                frame_rate_dict = {'rate_type': 'Type', 'frame_rate': 'Rate', 'bit_rate_units': 'BitRateUnitsType',
                                   'enforce_min_inter_packet_gap': 'InterPacketGapUnitsType'}
                frame_rate_options = list(set(frame_rate_dict.keys()).intersection(trafficItemInfo.keys()))
                if frame_rate_options:
                    for key in trafficItemInfo:
                        if key in frame_rate_dict:
                            setattr(trafficItem.ConfigElement.find().FrameRate, frame_rate_dict[key],
                                    trafficItemInfo[key])

                frame_size_dict = {'frame_size_type': 'Type', 'frame_size_fixed_size': 'FixedSize',
                                   'frame_size_increment_start': 'IncrementFrom',
                                   'frame_size_increment_stop': 'IncrementTo',
                                   'frame_size_increment_step': 'IncrementStep',
                                   'frame_size_preset_distribution': 'PresetDistribution',
                                   'frame_size_quad_gaussian': 'QuadGaussian',
                                   'frame_size_random_min': 'RandomMin', 'frame_size_random_max': 'RandomMax',
                                   'frame_size_weighted_pairs': 'WeightedPairs',
                                   'frame_size_weighted_pairs_range': 'WeightedRangePairs'}
                frame_size_options = list(set(frame_size_dict.keys()).intersection(trafficItemInfo.keys()))
                if frame_size_options:
                    for key in trafficItemInfo:
                        if key in frame_size_dict:
                            setattr(trafficItem.ConfigElement.find().FrameSize, frame_size_dict[key],
                                    trafficItemInfo[key])

                if trafficItemInfo['traffic_type'] == "raw":
                    if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',
                                                                                                        None) is None or kwargs.get(
                        'eth_dst_mac', None) is None:
                        if kwargs.get('eth_dst_mac_mode', None) == "INCR" or kwargs.get('eth_dst_mac_mode',
                                                                                        None) is None:
                            kwargs['eth_dst_mac_mode'] = 'increment'
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(
                            DisplayName="Destination MAC Address")
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                            'eth_dst_mac_mode', None), \
                            kwargs.get(
                                'eth_dst_mac',
                                "00:00:00:00:01:01"), kwargs.get(
                            'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', "00:00:00:00:01:01"), kwargs.get(
                            'eth_dst_mac_step', "00:00:00:00:00:01")

                        if kwargs.get('eth_src_mac_mode', None) == "INCR" or kwargs.get('eth_src_mac_mode',
                                                                                        None) is None:
                            kwargs['eth_src_mac_mode'] = 'increment'
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(
                            DisplayName="Source MAC Address")
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                            'eth_src_mac_mode', None), \
                            kwargs.get(
                                'eth_src_mac',
                                "00:00:00:00:00:01"), kwargs.get(
                            'eth_src_mac_count', 1), kwargs.get('eth_src_mac', "00:00:00:00:00:01"), kwargs.get(
                            'eth_src_mac_step', "00:00:00:00:00:01")
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46'):
                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':
                            pass
                        else:
                            trafficItemInfo['tos'] = 0
                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')
                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')
                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                        if ipv4Stack:
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                            flag = False
                            try:
                                if int(trafficItemInfo['tos']) not in tos_value_list:
                                    flag = True
                            except:
                                pass
                            if flag:
                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                            else:
                                if isinstance(trafficItemInfo['tos'], list):
                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                         cfg_dict={'displayName': 'precedence',
                                                                   'valueType': 'valueList',
                                                                   'valueList': trafficItemInfo['tos']})
                                elif isinstance(trafficItemInfo['tos'], str):
                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                         cfg_dict={'displayName': 'precedence',
                                                                   'valueType': 'singleValue',
                                                                   'singleValue': trafficItemInfo['tos']})
                                else:
                                    setattr(stackObj.Field.find(Name='precedence'), 'FieldValue',
                                            trafficItemInfo['tos'])
                        else:
                            if ethernetStack and vlanStack and not ipv4Stack:
                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv4Template))
                            if ethernetStack and not vlanStack and not ipv4Stack:
                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv4Template))
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                            flag = False
                            try:
                                if int(trafficItemInfo['tos']) not in tos_value_list:
                                    flag = True
                            except:
                                pass
                            if flag:
                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                            else:
                                if isinstance(trafficItemInfo['tos'], list):
                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                         cfg_dict={'displayName': 'precedence',
                                                                   'valueType': 'valueList',
                                                                   'valueList': trafficItemInfo['tos']})
                                elif isinstance(trafficItemInfo['tos'], str):
                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                         cfg_dict={'displayName': 'precedence',
                                                                   'valueType': 'singleValue',
                                                                   'singleValue': trafficItemInfo['tos']})
                                else:
                                    setattr(stackObj.Field.find(Name='precedence'), 'FieldValue',
                                            trafficItemInfo['tos'])
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46'):
                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':
                            pass
                        else:
                            trafficItemInfo['tos'] = 0
                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')
                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')
                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                        ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                        if ipv6Stack:
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',
                                    trafficItemInfo['tos'])
                        else:
                            if ethernetStack and vlanStack and not ipv6Stack and not ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv6Template))
                            if ethernetStack and not vlanStack and not ipv6Stack and not ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv6Template))
                            if ethernetStack and not vlanStack and not ipv6Stack and ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))
                            if ethernetStack and vlanStack and not ipv6Stack and ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',
                                    trafficItemInfo['tos'])
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv6'):
                        if 'src_ip' in trafficItemInfo or 'dst_ip' in trafficItemInfo or 'src_count' in trafficItemInfo:
                            if 'dst_mode' in trafficItemInfo:
                                if trafficItemInfo['dst_mode'] == "INCR" or trafficItemInfo['dst_mode'] is None:
                                    trafficItemInfo['dst_mode'] = 'increment'
                            else:
                                trafficItemInfo['dst_mode'] = 'increment'
                            if 'dst_ip' in trafficItemInfo:
                                if trafficItemInfo['dst_ip'] == '':
                                    trafficItemInfo['dst_ip'] = None
                            else:
                                trafficItemInfo['dst_ip'] = None
                            if 'dst_count' not in trafficItemInfo or 'src_count' not in trafficItemInfo:
                                trafficItemInfo['dst_count'] = 1
                                trafficItemInfo['src_count'] = 1
                            if 'dst_step' not in trafficItemInfo or 'src_step' not in trafficItemInfo:
                                if ':' in trafficItemInfo['src_ip']:
                                    trafficItemInfo['dst_step'] = '::1'
                                    trafficItemInfo['src_step'] = '::1'
                                else:
                                    trafficItemInfo['dst_step'] = '0.0.0.1'
                                    trafficItemInfo['src_step'] = '0.0.0.1'
                            if ':' in trafficItemInfo['dst_ip']:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(
                                    DisplayName="Destination Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['dst_mode'], \
                                        trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo[
                                        'dst_ip'], \
                                        trafficItemInfo['dst_step']
                            else:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(
                                    DisplayName="Destination Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['dst_mode'], \
                                        trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo[
                                        'dst_ip'], \
                                        trafficItemInfo['dst_step']

                            if 'src_mode' in trafficItemInfo:
                                if trafficItemInfo['src_mode'] == "INCR" or trafficItemInfo['src_mode'] is None:
                                    trafficItemInfo['src_mode'] = 'increment'
                            else:
                                trafficItemInfo['src_mode'] = 'increment'
                            if 'src_ip' in trafficItemInfo:
                                if trafficItemInfo['src_ip'] == '':
                                    trafficItemInfo['src_ip'] = None
                            else:
                                trafficItemInfo['src_ip'] = None
                            if ':' in trafficItemInfo['src_ip']:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(
                                    DisplayName="Source Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['src_mode'], \
                                        trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo[
                                        'src_ip'], \
                                        trafficItemInfo['src_step']
                            else:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(
                                    DisplayName="Source Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['src_mode'], \
                                        trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo[
                                        'src_ip'], trafficItemInfo['src_step']

                if trafficItemInfo['traffic_type'] == "ipv4" or trafficItemInfo[
                    'traffic_type'] == "ipv6" or 'raw_stream_ip_stack' in trafficItemInfo and (
                        trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[
                    'raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv46'):
                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[
                        'traffic_type'] == "ipv4":
                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                        flag = False
                        try:
                            if int(trafficItemInfo['tos']) not in tos_value_list:
                                flag = True
                        except:
                            pass
                        if flag:
                            stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                            setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                        else:
                            if isinstance(trafficItemInfo['tos'], list):
                                self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                     cfg_dict={'displayName': 'precedence', 'valueType': 'valueList',
                                                               'valueList': trafficItemInfo['tos']})
                            elif isinstance(trafficItemInfo['tos'], str):
                                self.change_ipv4_tos(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                     cfg_dict={'displayName': 'precedence', 'valueType': 'singleValue',
                                                               'singleValue': trafficItemInfo['tos']})
                            else:
                                setattr(stackObj.Field.find(Name='precedence'), 'FieldValue', trafficItemInfo['tos'])
                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[
                        'traffic_type'] == "ipv6":
                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                        if isinstance(trafficItemInfo['tos'], list):
                            self.change_ipv6_traffic_class(traffic_item_list=[trafficItemInfo["stream_name"]],
                                                           cfg_dict={'valueType': 'valueList',
                                                                     'valueList': trafficItemInfo['tos']})
                        else:
                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',
                                    trafficItemInfo['tos'])

                    trafficItem.Tracking.find().TrackBy = ['trackingenabled0']

                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] == 'Precedence':
                        self.log.info("Configuring IP TOS")

                    if 'stats_track_by' in trafficItemInfo:
                        stats_track_by = trafficItemInfo['stats_track_by']

                        stats_track_by.append('trackingenabled0')
                    else:
                        stats_track_by = ['trackingenabled0']
                    if "ipv4_precedence_full_mesh" not in trafficItemInfo:
                        trafficItemInfo["ipv4_precedence_full_mesh"] = False
                    self.change_traffic_flow_tracking(traffic_item_list=[trafficItem.Name],
                                                      cfg_dict={'trackBy': stats_track_by},
                                                      ipv4_precedence_full_mesh=trafficItemInfo[
                                                          "ipv4_precedence_full_mesh"])

                    print(
                        f"Configuring traffic stack for stream: {trafficItemInfo.get('stream_name', 'Unnamed Stream')}")

                    # === ESP Header ===
                    if 'esp_header' in trafficItemInfo and trafficItemInfo['esp_header'] in [True, 'TRUE']:
                        try:
                            espTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(
                                StackTypeId="^ipEncapsulatingSecurityPayload$")
                            self.log.info("Appending ESP header.")
                            if trafficItemInfo['traffic_type'] == "raw":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv4Stack and not ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(espTemplate))
                                elif ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(espTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv4":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(espTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv6":
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(espTemplate))
                            else:
                                self.log.warning(f"Unknown traffic type for ESP: {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            self.log.error(f"Failed to append ESP header: {e}")

                    # === GRE Header ===
                    if 'gre_header' in trafficItemInfo and trafficItemInfo['gre_header'] in [True, 'TRUE']:
                        try:
                            greTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^gre$")
                            self.log.info("Appending GRE header.")
                            if trafficItemInfo['traffic_type'] == "raw":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv4Stack and not ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(greTemplate))
                                elif ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(greTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv4":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(greTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv6":
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(greTemplate))
                            else:
                                self.log.warning(f"Unknown traffic type for GRE: {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            print(f"[ERROR] Failed to append GRE header: {e}")

                    # === TCP Header ===
                    if 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [True, 'TRUE']:
                        if 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [True, 'TRUE']:
                            self.log.warning("Both TCP and UDP headers are enabled. Only TCP will be added.")
                        try:
                            tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^tcp$")
                            self.log.info("Appending TCP header.")
                            if trafficItemInfo['traffic_type'] == "raw":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv4Stack and not ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))
                                elif ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv4":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv6":
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))
                            else:
                                self.log.warning(f"Unknown traffic type for TCP: {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            self.log.error(f"Failed to append TCP header: {e}")

                    # === UDP Header ===
                    elif 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [True, 'TRUE']:
                        try:
                            udpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^udp$")
                            self.log.info("Appending UDP header.")
                            if trafficItemInfo['traffic_type'] == "raw":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv4Stack and not ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))
                                elif ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv4":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv6":
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))
                            else:
                                self.log.warning(f"Unknown traffic type for UDP: {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            self.log.error(f" Failed to append UDP header: {e}")

                    # === ICMPv6 Header ===
                    if 'icmpv6_header' in trafficItemInfo and trafficItemInfo['icmpv6_header'] in [True, 'TRUE']:
                        try:
                            icmpv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv6$")
                            if trafficItemInfo['traffic_type'] in ["raw", "ipv6"]:
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv6Stack:
                                    self.log.info("Appending ICMPv6 header.")
                                    trafficItem.ConfigElement.find().Stack.read(
                                        ipv6Stack.AppendProtocol(icmpv6Template))
                                else:
                                    self.log.warning("IPv6 stack not found for ICMPv6 header.")
                            else:
                                self.log.warning(
                                    f"ICMPv6 can only be added to IPv6 traffic. Type: {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            self.log.error(f"Failed to append ICMPv6 header: {e}")

                    # === VLAN Header ===
                    if 'vlan_header' in trafficItemInfo and trafficItemInfo['vlan_header'] in [True, 'TRUE']:
                        try:
                            vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                            ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')
                            if ethernetStack:
                                self.log.info("Appending VLAN header.")
                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                            else:
                                self.log.warning("Ethernet stack not found. VLAN header not applied.")
                        except Exception as e:
                            self.log.error(f"Failed to append VLAN header: {e}")

                    # === AHP (AH) Header ===
                    if 'ahp_header' in trafficItemInfo and trafficItemInfo['ahp_header'] in [True, 'TRUE']:
                        try:
                            ahpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(
                                StackTypeId="^ipAuthenticationHeader$")
                            self.log.info("Appending AH (AHP) header.")
                            if trafficItemInfo['traffic_type'] == "raw":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                if ipv4Stack and not ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ahpTemplate))
                                elif ipv6Stack:
                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(ahpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv4":
                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ahpTemplate))
                            elif trafficItemInfo['traffic_type'] == "ipv6":
                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(ahpTemplate))
                            else:
                                self.log.warning(
                                    f"Unknown traffic type for AH (AHP): {trafficItemInfo['traffic_type']}")
                        except Exception as e:
                            self.log.error(f"Failed to append AH (AHP) header: {e}")

                    if 'tcp_src_port' in trafficItemInfo and trafficItemInfo[
                        'tcp_src_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="TCP-Source-Port")
                        field.Auto = trafficItemInfo.get('tcp_src_auto', 'False')
                        field.ValueType = trafficItemInfo.get('tcp_src_mode', 'singleValue')
                        field.FieldValue = trafficItemInfo.get('tcp_src_port', 1024)
                        field.CountValue = trafficItemInfo.get('tcp_src_count', 1)
                        field.StartValue = trafficItemInfo.get('tcp_src_port', None)
                        field.StepValue = trafficItemInfo.get('tcp_src_step', 1)
                        field.FullMesh = trafficItemInfo.get('tcp_src_fullmesh', False)
                        field.TrackingEnabled = trafficItemInfo.get('tcp_src_trackby', False)

                    if 'tcp_dst_port' in trafficItemInfo and trafficItemInfo[
                        'tcp_dst_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                        field.Auto = trafficItemInfo.get('tcp_dst_auto', 'False')
                        field.ValueType = trafficItemInfo.get('tcp_dst_mode', 'singleValue')
                        field.FieldValue = trafficItemInfo.get('tcp_dst_port', 1024)
                        field.CountValue = trafficItemInfo.get('tcp_dst_count', 1)
                        # field.StartValue = trafficItemInfo.get('tcp_dst_port', None)
                        field.StepValue = trafficItemInfo.get('tcp_dst_step', 1)
                        field.FullMesh = trafficItemInfo.get('tcp_dst_fullmesh', False)
                        field.TrackingEnabled = trafficItemInfo.get('tcp_dst_trackby', False)


                    if 'udp_src_port' in trafficItemInfo and trafficItemInfo[
                        'udp_src_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="UDP-Source-Port")
                        field.Auto = trafficItemInfo.get('udp_src_auto', 'False')
                        field.ValueType = trafficItemInfo.get('udp_src_mode', 'singleValue')
                        field.FieldValue = trafficItemInfo.get('udp_src_port', 1024)
                        field.CountValue = trafficItemInfo.get('udp_src_count', 1)
                        field.StartValue = trafficItemInfo.get('udp_src_port', None)
                        field.StepValue = trafficItemInfo.get('udp_src_step', 1)
                        field.FullMesh = trafficItemInfo.get('udp_src_fullmesh', False)
                        field.TrackingEnabled = trafficItemInfo.get('udp_src_trackby', False)


                    if 'udp_dst_port' in trafficItemInfo and trafficItemInfo[
                        'udp_dst_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="UDP-Dest-Port")
                        field.Auto = trafficItemInfo.get('udp_dst_auto', 'False')
                        field.ValueType = trafficItemInfo.get('udp_dst_mode', 'singleValue')
                        field.FieldValue = trafficItemInfo.get('udp_dst_port', 1024)
                        field.CountValue = trafficItemInfo.get('udp_dst_count', 1)
                        field.StartValue = trafficItemInfo.get('udp_dst_port', None)
                        field.StepValue = trafficItemInfo.get('udp_dst_step', 1)
                        field.FullMesh = trafficItemInfo.get('udp_dst_fullmesh', False)
                        field.TrackingEnabled = trafficItemInfo.get('udp_dst_trackby', False)


    def add_device_traffic_configuration(self, csv_file=None):
        """
        API to add devices and traffic configuration using csv file format

        :param csv_file: csv file
        :return:
        """
        rows = list()
        devicesInfo = list()
        portTuple = list()

        with open(csv_file, 'r') as csvfile:
            csvreader = csv.reader(csvfile)

            for row in csvreader:
                rows.append(row)

        for rowIndex in range(len(rows)):
            if 'stream_name' in rows[rowIndex]:
                trafficConfigRow = rowIndex

        deviceConfigRows = rows[:trafficConfigRow]
        trafficConfigRows = rows[trafficConfigRow:]

        deviceHeaders = deviceConfigRows[0]
        devicesInfoList = deviceConfigRows[1:]

        devicesInfoTemp = [dict(zip(deviceHeaders, deviceInfo)) for deviceInfo in devicesInfoList]
        portTupleTemp = [deviceInfo['port'] for deviceInfo in devicesInfoTemp]

        for port in portTupleTemp:
            if port not in portTuple and port != '':
                portTuple.append(port)

        for deviceInfo in devicesInfoTemp:
            del deviceInfo['port']
            devicesInfo.append(deviceInfo)

        trafficHeaders = trafficConfigRows[0]
        trafficInfoList = trafficConfigRows[1:]

        trafficsItemInfo = [dict(zip(trafficHeaders, trafficInfo)) for trafficInfo in trafficInfoList]
        self.add_multiple_devices(port_tuple=portTuple, device_info=devicesInfo)
        self.add_multiple_traffic_streams(traffic_info=trafficsItemInfo)

    def get_twamp_test_sessions(self):
        """
        Get TWAMP Test Sessoin handler with respect to its Name

        :return: List of Name and handler of TWAMP Test Sessions
        :Example: get_twamp_test_sessions()
        """
        ControlRangeName_list = []
        for ControlRange in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampTestRange.find():
            ControlRangeName_list.append(ControlRange.ControlRangeName)
        return ControlRangeName_list

    def start_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):
        """
        Start TWAMP Sessions

        :param delay_time: Delay Time (by default 30)
        :param twamp_test_sessions: List of TWAMP Test session Name
        :return: Raises exception on failure
        :Example: start_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')
        """

        if delay_time:
            time.sleep(delay_time)
        if twamp_test_sessions:
            ControlRangeName_list = twamp_test_sessions
        else:
            ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name=ControlRange).Start()
            except:
                pass

    def stop_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):
        """
        Stop TWAMP Sessions

        :param delay_time: Delay Time (by default 30)
        :param twamp_test_sessions: List of TWAMP Test session Name
        :return: Raises exception on failure
        :Example: stop_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')
        """
        if delay_time:
            time.sleep(delay_time)
        if twamp_test_sessions:
            ControlRangeName_list = twamp_test_sessions
        else:
            ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name=ControlRange).Stop()
            except:
                pass

    def request_twamp_sessions(self, router_ids):
        """
        Start Requesting TWAMP session by client from server

        :param router_ids: device list by default it request on all TWAMP client configured devices
        :return: Raises exception on failure
        :Example: request_twamp_sessions(router_ids='192.0.0.2')
        """
        ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name='^' + ControlRange + '$').Enabled = False
            except:
                pass
        if router_ids:
            self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                Name='^' + router_ids + '$').Enabled = True
            try:

                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name='^' + router_ids + '$').Start()
            except:
                pass

    def create_custom_stats_view(self, custom_view_name=None):
        """
        Create custome stats view for each traffic stream.
        :param custom_view_name: Custom view name
        :param tree_view_node_name: Tree view node name
        :return:
        """

        self.ixNetwork.Statistics.View.add(Caption=custom_view_name, Type='layer23ProtocolStack', Visible=True)
        afil = self.ixNetwork.Statistics.View.find(
            Caption='^' + custom_view_name + '$').AvailableProtocolStackFilter.find()

        fil = \
        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Layer23ProtocolStackFilter.find()[0]
        fil.update(DrilldownType='perSession', ProtocolStackFilterId=afil[-1], SortAscending=True)
        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Statistic.find():
            stats.Enabled = True
        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Enabled = True

        TrafficItemStats = StatViewAssistant(self.ixNetwork, custom_view_name, LocalCsvStorage=CafyLog.work_dir)
        trafficItemStatsDict = {}
        columnCaptions1 = TrafficItemStats.ColumnHeaders
        columnCaptions = []

        for ele in columnCaptions1:
            if ele == ' Max Latency [us]':
                columnCaptions.append('" Max Latency [us]"')
            else:
                columnCaptions.append(ele)

        for rowNumber, stat in enumerate(TrafficItemStats.Rows):
            statsDict = {}
            for column in columnCaptions:
                statsDict[column] = stat[column]
            trafficItemStatsDict[rowNumber + 1] = statsDict
        dict = {'avg_jitter': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Jitter Max [us]'],
                'avg_latency': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Max Latency [us]']}
        for key, value in trafficItemStatsDict.items():
            value.update(dict)
        return trafficItemStatsDict

    def get_twamp_test_session_results(self, router_id):
        """
        Get TWAMP Test Sessions Results of TWMP client device

        :param router_id: TWAMP Client ID on which TWAMP result should be obtained
        :return: TWAMP Test session result in dictionary
        :Example: get_twamp_test_session_results(router_id = '192.0.0.4')
        """
        view_name = self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
            Name='^' + router_id + '$').Name
        return self.create_custom_stats_view(custom_view_name=view_name)

    def start_twamp(self, router_ids):
        """
        Start TWAMP on mentioned hosts or on all
        :param router_ids: List of router_id by default it starts on all TWAMP configured devices
        :return: Raises exception on failure
        :Example: start_twamp(router_ids = '192.0.0.4')
        """
        if router_ids:
            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                try:
                    if range.TwampControlRange.find():
                        range.TwampControlRange.find(Name='^' + router_ids + '$').Start()
                except:
                    pass
        else:
            for port in self.ixNetwork.Vport.find():
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStart()
                except:
                    pass
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStart()
                except:
                    pass

    def stop_twamp(self, router_ids):
        """
        Stop TWAMP on mentioned hosts or on all
        :param router_ids: List of router_id by default it stops on all TWAMP configured devices
        :return: Raises exception on failure
        :Example: stop_twamp(router_ids = '192.0.0.4')
        """
        if router_ids:
            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                try:
                    if range.TwampControlRange.find():
                        range.TwampControlRange.find(Name='^' + router_ids + '$').Stop()
                except:
                    pass
        else:
            for port in self.ixNetwork.Vport.find():
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStop()
                except:
                    pass
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStop()
                except:
                    pass

    def get_twamp_test(self, router_id, delay=10):
        """
        Start TWAMP hosts, establish & start sessions and obtain their test results
        :param router_id: TWAMP Client device id from which TWAMP results to be obtained
        :param delay: Delay duration between Start and Stop
        :return: Results of TWAMP Test
        :Example: get_twamp_test(router_id = '192.0.0.4', delay = 10)
        """
        self.start_twamp()
        Helper.sleep(5, msg='Starting TWAMP on all Hosts')
        self.request_twamp_sessions()
        Helper.sleep(5, msg='Starting all TWAMP sessions')
        self.start_twamp_sessions()
        Helper.sleep(delay, msg='TWAMP Test delay')
        self.stop_twamp_sessions()
        results = self.get_twamp_test_session_results(router_id)
        self.stop_twamp()
        Helper.sleep(3, msg='Collecting TWAMP Results')
        return results

    def set_stream_only_generation(self, stream_block_name, enable=True):
        """
        This API is not applicable for IXIA and adding a dummy API to make it TGN vendor agnostic

        Set or unset stream only generation option for stream block(s)
        :param stream_block_name: string representing a stream block or 'all' representing all the streamblocks
        :param enable: boolean, false if you want to disable the stream only generation option
        :example: set_stream_only_generation(stream_block_name='StreamBlock 1',enable=False)
        :return:
        """
        pass

    def connect_to_lab_server(self,server_ip, timeout=300, api_version=1):
        """
        To connect to given TGN Lab server or API Server
        :param server_ip: IP address of TGN LabServer/APISerer
        :param timeout: Spirent Only Argument. Time to wait to receive response from server
        :param api_version: Spirent Only Argument. API version to use. Default is 1
        :return:
        """
        self.server_ip = server_ip
        self.log.info("Connecting to Ixia Lab Server - '%s'" %server_ip)

        if self.tgn_server_type == 'linux':
            self.test_platform = TestPlatform(ip_address=server_ip, rest_port=self.port, platform='linux',
                                             log_file_name=CafyLog.work_dir + '/restpy.log')
            self.test_platform.Authenticate(self.tgn_server_user, self.tgn_server_pw)

        if self.tgn_server_type == 'windows':
            self.log.warning("Connect Lab Server is Not Supported for Ixia Windows Lab Server")

    def _download_debug_files(self, type='ixncfg'):
        """
        To download debug files  and config files from Labserver to Cafy working directory.
        :param type: Format to save the Ixia config. Supports 'ixncfg' & 'json'. Default is 'ixncfg' format.
        :return: None
        :Example: _download_debug_files(type='ixncfg')
                  _download_debug_files(type='json')
        """
        filesToZip = []
        path = self.ixNetwork.Globals.PersistencePath
        if type == 'ixncfg':
            if self.tgn_server_type == 'windows':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')
                self._copyApiServerFileToLocalLinux(path + '\\' + 'IxiaConfig.ixncfg', CafyLog.work_dir,
                                                    localPathOs='windows',
                                                    includeTimestamp=False)
                timestamp = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')
                diag_file = 'diags_' + timestamp + '.zip'
                if not self.disable_diag_log and not self.disable_trace_log:
                    self.ixNetwork.CollectLogs(Arg1=(path + '\\' + diag_file), Arg2='currentInstance')
                    self._copyApiServerFileToLocalLinux(path + '\\' + diag_file, CafyLog.work_dir,
                                                    localPathOs='windows',
                                                    includeTimestamp=False)
                    self.session.RemoveFile(path + "\\" + diag_file)
            if self.tgn_server_type == 'linux':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')
                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.ixncfg', CafyLog.work_dir,
                                                    localPathOs='linux',
                                                    includeTimestamp=False)
                path = path.replace('IxNetwork', '')
                path_linux = path + 'sdmStreamManager/common/diagnostics/'
                timestamp = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')
                diag_file = 'diags_' + timestamp + '.zip'
                if not self.disable_diag_log:
                    self.ixNetwork.CollectLogs(Arg1=(path_linux + diag_file), Arg2='currentInstance')
                    self._copyApiServerFileToLocalLinux(path_linux + '/' + diag_file, CafyLog.work_dir,
                                                    localPathOs='linux',
                                                    includeTimestamp=False)
                    self.session.RemoveFile(path_linux + diag_file)
            filesToZip.append('IxiaConfig.ixncfg')
            filesToZip.append(diag_file)
        elif type == 'json':
            if self.tgn_server_type == 'windows':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')
                self._copyApiServerFileToLocalLinux(path + '\\' + 'IxiaConfig.json', CafyLog.work_dir,
                                                    localPathOs='windows',
                                                    includeTimestamp=False)
            if self.tgn_server_type == 'linux':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')
                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.json', CafyLog.work_dir,
                                                    localPathOs='linux',
                                                    includeTimestamp=False)
            filesToZip.append('IxiaConfig.json')
        error_files = 'ixiaerror.log'
        error_log_path = os.path.join(CafyLog.work_dir, error_files)
        globals = self.ixNetwork.Globals
        with open(error_log_path, 'w') as error_file:
            for apperrors in globals.AppErrors.find():
                for error in apperrors.Error.find():
                    if hasattr(error, 'Description') :
                        if error.ErrorLevel == 'kMessage':
                            continue
                        error_file.write(error.Description + '\n')
                        self.log.info(error.Description)
                        error_file.write(error.Name + '\n')
                        self.log.info(error.Name)
        filesToZip.append(error_files)
        filesToZip.append('all.log')
        debug_logs = 'IxiaDebugLogs_' + timestamp + '.zip'
        zip_file = os.path.join(CafyLog.work_dir, debug_logs)
        lenDirPath = len(CafyLog.work_dir)
        with ZipFile(zip_file, 'w') as zip:
            # writing each file one by one
            for file in filesToZip:
                log.info("Downloading %s from LabServer to %s" % (file, CafyLog.work_dir))
                file = CafyLog.work_dir + '/' + file
                zip.write(file, file[lenDirPath:])
                if file[lenDirPath:] != '/all.log':
                    os.remove(file)

    def traffic_options(self, **kwargs):
        """
        This API is used for the traffic options stats related changes
        :param kwargs:
                Argument:"frames_ordering" --> "No Ordering" , "peakLoading", "flowGroupSetup", "RFC2889"
        :return:
        """
        frames_order = kwargs.get("frames_ordering", None)
        if frames_order:
            if frames_order == 'RFC2889':
                self.ixNetwork.Traffic.EnableStreamOrdering = True
                self.ixNetwork.Traffic.FrameOrderingMode = frames_order
            else:
                self.ixNetwork.Traffic.EnableStreamOrdering = False
                self.ixNetwork.Traffic.FrameOrderingMode = frames_order

    def set_device_ip(self, device_name, ip_address_start, **kwargs):
        """
        Sets Device Ip addresses based on the device group name
        :param device_name: device name to which Ipv4/Ipv6 address need be set
        :param ip_address_start: Start Ip address to be set
        :param kwargs:
            :type: Ipv4/IPv6, Default value is ipv4
            :ip_address_step: Default Ipv4 ip address step is "0.0.0.1",
                              Default Ipv6 ip address step is "::0.1.0.0"

            :direction: increment|decrement, Default value is increment
            :gateway_address_start: Gateway Start Address
            :gateway_address_step: Default Ipv4 gateway address step is "0.0.0.0"
                                   Default Ipv6 gateway address step is "::0.0.0.0"
        :return: True if successful
        :Example: set_device_ip(device_name= 'TenGigE0/2/0/0_v4', ip_address_start = '6.5.5.5', gateway_address_start = '6.5.5.1')
        """
        # Setting Default values
        kwargs['type'] = kwargs.get('type', 'ipv4')
        kwargs['direction'] = kwargs.get('direction', 'increment')
        if kwargs['type'].lower() == 'ipv6':
            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '::0.1.0.0')
            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '::0.0.0.0')
            try:
                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
            except:
                raise IxiaOperationException("Device Group not Found")
        elif kwargs['type'].lower() == 'ipv4':
            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '0.0.0.1')
            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '0.0.0.0')
            try:
                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().Ipv4.find()
            except:
                raise IxiaOperationException("Device Group not Found")

        if type(ip_address_start) == list:
            ipObj.Address.ValueList(values= ip_address_start)
        else:
            if kwargs['direction'].lower() == "decrement":
                ipObj.Address.Decrement(start_value= ip_address_start, step_value= kwargs['ip_address_step'])
                if kwargs['gateway_address_start']:
                    ipObj.GatewayIp.Decrement(start_value=kwargs['gateway_address_start'], step_value=kwargs['gateway_address_step'])
                else:
                    pass
            elif kwargs['direction'].lower() == "increment":
                ipObj.Address.Increment(start_value=ip_address_start, step_value= kwargs['ip_address_step'])
                if kwargs['gateway_address_start']:
                    ipObj.GatewayIp.Increment(start_value=kwargs['gateway_address_start'],
                                                  step_value=kwargs['gateway_address_step'])
                else:
                    pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Device IP Address configured successfully")
        return True

    def capture_start_or_stop(self, port_name_list=None, action='Start', **kwargs):
        """
        API used to Collect Data or control plane packets

        :param port_name_list: port name list on whc packet need to be captured. E.g. '1/10'
        :param action: To start capture or stop capture. Default is "start". options are "start" and "stop"
        :kwargs :
                :param enable_data : to enable DATA capture (True/False) default False
                :param enable_control : to enable control capture (True/False) default True
                :param enable_slice : to enable data/control slicing on capture (True/False)

        :return: filename with path

        :Example: capture_start_or_stop(port_name_list=['1/9' ,'1/10'], action='stop',enable_data = True)
                  capture_start_or_stop(port_name_list=['10.39.65.156/2/7'], action='start',enable_data = True,enable_control = False)
                  capture_start_or_stop(port_name_list=['10.39.65.156/2/15'], action='start',enable_control= True,enable_slice = False)
                  capture_start_or_stop(port_name_list=['10.39.65.156/2/15'], action='start',enable_data= True,enable_slice = True)
        """
        port_list = []
        filenames = []
        self.log.info(f'Capturing port details {port_name_list} with action - {action}')
        if not port_name_list:
            self.log.info(f'Capture on all available ports with action - {action}')
            for port in self.ixNetwork.Vport.find():
                port_list.append(port.AssignedTo)
        else:
            if type(port_name_list) == str:
                port_name_list = port_name_list.split(",")
            for port in port_name_list:
                port_info = port.split('/')
                if len(port_info) < 3:
                    vport_list = [vport.AssignedTo for vport in self.ixNetwork.Vport.find()]
                    if isinstance(self.chassis_ip,str):
                        if ',' in self.chassis_ip:
                            self.chassis_ip = self.chassis_ip.split(',')
                        else:
                            self.chassis_ip = [self.chassis_ip]
                    for chassis in self.chassis_ip:
                        port_location = f'{chassis}:{port_info[0]}:{port_info[1]}'
                        if port_location in vport_list:
                            port_list.append(port_location)
                else:
                    port_list.append(':'.join(port_info))
        self.log.info(f'Capturing Ports are - {port_list}')
        if action.lower() == 'stop':
            path = self.ixNetwork.Globals.PersistencePath
            captured_files = self.ixNetwork.SaveCaptureFiles(path)
            for port_name in port_list:
                vport = self.ixNetwork.Vport.find(AssignedTo='^' + port_name + '$')
                vport_name = re.sub('/', '-', (vport.Name))
                for eachfile in captured_files:
                    if vport_name in eachfile:
                        timestamp = time.strftime("%Y%m%d-%H%M%S")
                        filename = "capture_" + re.sub(' |/', '_',(vport.Name).replace("(offline)", "")) + "_" + timestamp + ".cap"
                        try:
                            if self.tgn_server_type == 'windows':
                                api_filename = eachfile.split('\\')[-1]
                                api_filename = api_filename.replace(' ', '_')
                                src_file = CafyLog.work_dir + "/" + api_filename
                                dst_file = CafyLog.work_dir + "/" + 'capture_' + timestamp + '_' + api_filename
                                self._copyApiServerFileToLocalLinux(eachfile, CafyLog.work_dir, localPathOs='windows')
                            elif self.tgn_server_type == 'linux':
                                api_filename = eachfile.split("/")[-1]
                                api_filename = api_filename.replace(' ', '_')
                                src_file = CafyLog.work_dir + "/" + api_filename
                                dst_file = CafyLog.work_dir + "/" + 'capture_' + timestamp + '_' + api_filename
                                self._copyApiServerFileToLocalLinux(eachfile, CafyLog.work_dir, localPathOs='linux')
                            os.rename(src_file, dst_file)
                            filenames.append(dst_file)
                            log.info(f"Capture file successfully created: {dst_file}")
                        except:
                            pass
        elif action.lower() == 'start':
            self.ixNetwork.CloseAllTabs()
            for vport in self.ixNetwork.Vport.find():
                vport.Capture.HardwareEnabled = False
                vport.Capture.SoftwareEnabled = False
            for each_port in port_list:
                vport = self.ixNetwork.Vport.find(AssignedTo='^' + each_port + '$')
                enable_data = kwargs.get('enable_data', True)
                enable_control = kwargs.get('enable_control', True)
                enable_slice = kwargs.get('enable_slice', '0')
                self.ixNetwork.Vport.find().Capture.find().SliceSize = enable_slice
                self.ixNetwork.Vport.find().Capture.find().ControlSliceSize = enable_slice
                if enable_data:
                    vport.Capture.HardwareEnabled = enable_data
                if enable_control:
                    vport.Capture.SoftwareEnabled = enable_control
                vport.Capture.CaptureMode = "captureContinuousMode"
                vport.RxMode = 'captureAndMeasure'
                self.log.info(f"Starting Packet Capture on Port - {each_port}")
                vport.Capture.Start()
        return filenames

    def set_bgp_ttl(self, ttl, router_id=None):
        """
        Modify ttl value on BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100
        :return True on pass, Exception on failure.

        :Example: set_bgp_ttl(ttl=255, router_id='192.0.0.1')
        """
        if router_id:
            self.log.info("setting BGP ttl value {} on BGP Router ID {}".format(ttl, router_id))
        else:
            self.log.info("setting BGP ttl value {} on all BGP instances".format(ttl))
        self._set_get_bgp_ttl(action='set', ttl=ttl, router_id=router_id)
        return True

    def get_bgp_ttl(self, router_id=None):
        """
        To fetch ttl value of BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :return ttl_dict: Dictionary of router_id's and ttl value on pass, Exception on failure.

        :Example: get_bgp_ttl(router_id='192.0.0.1')
        """
        if router_id:
            self.log.info("getting BGP ttl value for BGP Router ID {}".format(router_id))
            dicttmp = self._set_get_bgp_ttl(action='get', router_id=router_id)
            if router_id in dicttmp.keys():
                ttl_dict = {router_id: dicttmp[router_id]}
        else:
            self.log.info("getting BGP ttl value for all BGP instances")
            ttl_dict = self._set_get_bgp_ttl(action='get', router_id=router_id)
        return ttl_dict

    def _set_get_bgp_ttl(self, action, ttl=None, router_id=None):
        """
        To Modify or to get ttl value on/of BGP devices.
        :param action: 'set' to set the ttl value on BGP devices, 'get' to get the ttl value of BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100
        :return True - If action is 'set'. ttl_dict - If action is 'get'.
        """
        deviceGroupObjects = []
        ttlDict = {}
        if router_id:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObjects.append(deviceGroup)
                        break
            else:
                raise IxiaConfigException("Router Id '%s' not found on this configuration." % router_id)
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    deviceGroupObjects.append(deviceGroup)
        if deviceGroupObjects:
            for deviceGroupObj in deviceGroupObjects:
                try:
                    if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                            if action.lower() == 'set':
                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))
                                if (len(listVal) > 1):
                                    if router_id:
                                        index = bgpObj.LocalRouterID.index(router_id)
                                        ttlValueList = bgpObj.Ttl.Values
                                        ttlValueList[index] = ttl
                                    else:
                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]
                                    bgpObj.Ttl.ValueList(ttlValueList)
                                else:
                                    bgpObj.Ttl.Single(ttl)
                            else:
                                rIdValueList = bgpObj.LocalRouterID
                                ttlValueList = bgpObj.Ttl.Values
                                dictTmp = zip(rIdValueList, ttlValueList)
                                ttlDict.update(dictTmp)
                except:
                    pass
                try:
                    if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                            if action.lower() == 'set':
                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))
                                if (len(listVal) > 1):
                                    if router_id:
                                        index = bgpObj.LocalRouterID.index(router_id)
                                        ttlValueList = bgpObj.Ttl.Values
                                        ttlValueList[index] = ttl
                                    else:
                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]
                                    bgpObj.Ttl.ValueList(ttlValueList)
                                else:
                                    bgpObj.Ttl.Single(ttl)
                            else:
                                rIdValueList = bgpObj.LocalRouterID
                                ttlValueList = bgpObj.Ttl.Values
                                dictTmp = zip(rIdValueList, ttlValueList)
                                ttlDict.update(dictTmp)
                except:
                    pass
        else:
            raise IxiaConfigException("No BGP found on this configuration.")
        if action.lower() == 'set':
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            return ttlDict

    def get_port_dict_streams(self, port='all'):
        '''
        Get dictionary of streams with port
        :param port: Port under which streams to returned, by default it is all ports
        :return: Dictionary of port and stream list

        :Example: get_port_dict_streams(port = ['Ethernet - 001'])
        '''
        portDict = dict()
        streamsList = []
        if port != 'all':
            ports = self._get_port_name_list(ports= port)
            if ports == []:
               raise CafyException.InvalidValueError('%s Port not available in config' % port)
        else:
            ports = [port.Name for port in self.ixNetwork.Vport.find()]
        for port_name in ports:
            for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find():
                for highLevelStreamObj in trafficItemObj.HighLevelStream.find():
                    if highLevelStreamObj.TxPortName == port_name:
                        if port_name not in portDict:
                            portDict[port_name] = []
                        portDict[port_name].append(trafficItemObj)
                    else:
                        streamsList.append(trafficItemObj)
        return portDict

    def activate_devices(self, device_list=None):
        """
        API to activate a given set of devices
        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'
        :return: True on success, else exception

        :Example: activate_devices(device_list=["Group Device 1"])
        """
        result = False
        if device_list:
            for deviceName in device_list:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(True)
            result = True
        else:
            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                deviceObj.Enabled.Single(True)
            result = True
        if result:
            return True
        else:
            raise IxiaConfigException("Failed due to configuration issue")

    def deactivate_devices(self, device_list=None):
        """
        API to deactivate a given set of devices
        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'
        :return: True on success, else exception

        :Example: deactivate_devices(device_list=["Group Device 1"])
        """
        result = False
        if device_list:
            for deviceName in device_list:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(False)
            result = True
        else:
            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                deviceObj.Enabled.Single(False)
            result = True
        if result:
            return True
        else:
            raise IxiaConfigException("Failed due to configuration issue")

    def get_module_port_status(self, chassis_to_check=None, port_list=None, check_ports=False):
        """
        Checks the module and port group status of the current chassis
        :param chassis_to_check: (str) Optional IP of the chassis to check (default is current)
            e.g. '172.16.20.5'
        :param port_list: (list) An optional list of ports to check (default is check all)
            e.g. ['5/7', '5/8', '7/10']
        :param check_ports: (bool) Toggles checking at the port level
        :return: 172.16.20.5,

        :Example: get_module_port_status(chassis_to_check = '10.1.1.1')
        """
        result = False
        if chassis_to_check is None:
            chassis_final = self.ixNetwork.AvailableHardware.Chassis.find().Hostname
        else:
            chassis_final = [chassisObj.Hostname for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find() if
                             chassisObj.Hostname == chassis_to_check]
        if chassis_final:
            statusDict = {}
            chassisIP = str(chassis_final)
            statusDict[chassisIP] = {}
            result = True
            try:
                if check_ports:
                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():
                        chassisState = chassisObj.State
                        statusDict[chassisIP][chassisState] = {}
                        if chassisObj.Hostname == chassis_to_check:
                            for cport in port_list:
                                cslot, cinterface = cport.split('/')[0], cport.split('/')[1]
                                for cardObj in chassisObj.Card.find():
                                    slot = cardObj.CardId
                                    if slot == int(cslot):
                                        if slot not in statusDict[chassisIP][chassisState].keys():
                                            statusDict[chassisIP][chassisState][slot] = {}
                                        for portObj in cardObj.Port.find():
                                            portId = portObj.PortId
                                            if portId == int(cinterface):
                                                portId = portObj.PortId
                                                statusDict[chassisIP][chassisState][slot][portId] = {}
                                                statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable
                else:
                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():
                        chassisState = chassisObj.State
                        statusDict[chassisIP][chassisState] = {}
                        if chassisObj.Hostname == chassis_to_check:
                            for cardObj in chassisObj.Card.find():
                                slot = cardObj.CardId
                                statusDict[chassisIP][chassisState][slot] = {}
                                for portObj in cardObj.Port.find():
                                    portId = portObj.PortId
                                    statusDict[chassisIP][chassisState][slot][portId] = {}
                                    statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable
            except Exception as err:
                raise CafyException.TgenClientError('Failed to retrieve module/port status: {}'.format(err))
        if result:
            return statusDict
        else:
            raise CafyException.InvalidValueError('No matching chassis found in {}'.format(chassis_to_check))

    def create_ipv4_interface(self, router_id=None, ipv4_address=None, ipv4_gateway=None, ipv4_gateway_mac=None,
                              ipv4_prefix_length=None):
        """
        Creates Ipv4If object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param ipv4_address: Mapping Ipv4If attribute - Address. Example: 105.1.0.2
        :param ipv4_gateway: Mapping Ipv4If attribute - Gateway. IPv4 gateway address. Example: 104.1.0.1
        :param ipv4_gateway_mac: Mapping Ipv4If attribute - GatewayMac. Gateway MAC address. Example: 00:00:00:00:00:01
        :param ipv4_prefix_length: Mapping Ipv4If attribute - PrefixLength. IPv4 address prefix length. Range: 0 - 32
        :return: Ipv4If object.
        :Example: create_ipv6_interface(router_id='10.10.10.1',ipv4_address='10.10.1.1',
                              ipv4_gateway='10.10.1.2', ipv4_gateway_mac='00:00:01:00:00:01',
                              ipv4_prefix_length='24')
        """
        result = False
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    Ipv4Obj = deviceGroup.Ethernet.add().Ipv4.add()
                    Ipv4Obj.Address.Increment(start_value=ipv4_address)
                    Ipv4Obj.GatewayIp.Increment(start_value=ipv4_gateway)
                    Ipv4Obj.ManualGatewayMac.Increment(start_value=ipv4_gateway_mac)
                    Ipv4Obj.Prefix.Increment(start_value=ipv4_prefix_length)
                    break
        if result:
            return Ipv4Obj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_ipv6_interface(self, router_id, ipv6_address=None, ipv6_gateway=None, ipv6_gateway_mac=None,
                              ipv6_prefix_length=None,ipv6_gateway_learning=None):
        """
        Creates Ipv6If object.
        :param router_id: Router ID of Device
        :param ipv6_address: ipv6 address
        :param ipv6_gateway: ipv6 gateway address
        :param ipv6_gateway_mac: ipv6 gateway mac address
        :param ipv6_prefix_length: ipv6 prefix length
        :param ipv6_gateway_learning: ipv6 gateway learning mode
                                    : for ixia Resolve gateway True|False, default is True.
        :return: Ipv6If object.
        :Example: create_ipv6_interface(router_id='10.10.10.1', ipv6_address='1000:0:0:1::1',
                              ipv6_gateway='1000:0:0:1::2',ipv6_gateway_mac='00:00:10:00:00:10',
                              ipv6_prefix_length='112',ipv6_gateway_learning=True)))
        """
        result = False
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    Ipv6Obj = deviceGroup.Ethernet.add().Ipv6.add()
                    Ipv6Obj.Address.Increment(start_value=ipv6_address)
                    Ipv6Obj.GatewayIp.Increment(start_value=ipv6_gateway)
                    Ipv6Obj.ManualGatewayMac.Increment(start_value=ipv6_gateway_mac)
                    Ipv6Obj.Prefix.Increment(start_value=ipv6_prefix_length)
                    Ipv6Obj.ResolveGateway.Single(ipv6_gateway_learning)
                    break
        if result:
            return Ipv6Obj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def delete_network_groups(self, devices, network_groups, nested_device=None):
        """
        Deletes network groups
        :param devices: List of device names
        :param network_groups: List of network group names
        :param nested_device: Nested device name
        :return: True on success
        """

        for each_device in devices:
            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)
            if nested_device:
                device_obj = device_obj.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')

            for network_group in network_groups:
                log.info(f"remove network group: {network_group}")
                try:
                    if device_obj.NetworkGroup.find(Name=network_group):
                        device_obj.NetworkGroup.find(Name=network_group).remove()
                except Exception as err:
                    log.error(f"Failed to remove network group: {network_group} with error:\n {err}")
                    raise err

    def _delete_protocol(self, device_obj, protocol_name):
        """
        Deletes protocol
        :param device_obj: Device object
        :param protocol_name: Protocol name
        :return: True on success
        """
        loopback_protocol_dict = {'BgpIPv4EvpnEvi': 'BgpIpv4Peer', 'BgpIPv6EvpnEvi': 'BgpIpv6Peer'}
        log.info(f"remove protocol: {protocol_name}")
        try:
            eval('device_obj' + '.Ethernet.find().' + protocol_name + '.find().' + 'remove()')
        except:
            pass

        try:
            eval('device_obj' + '.' + protocol_name + '.find().' + 'remove()')
        except:
            pass

        try:
            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().' + 'remove()')
        except:
            pass

        try:
            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().' + 'remove()')
        except:
            pass

        try:
            if protocol_name in loopback_protocol_dict.keys():
                eval('device_obj' + '.Ipv4Loopback.find().' +
                    loopback_protocol_dict[protocol_name] + '.find().' +
                    protocol_name + '.find().' + 'remove()')
            else:
                eval('device_obj' + '.Ipv4Loopback.find().' + protocol_name + '.find().' + 'remove()')
        except:
            pass

        try:
            if protocol_name in loopback_protocol_dict.keys():
                eval('device_obj' + '.Ipv6Loopback.find().' + loopback_protocol_dict[protocol_name] + '.find().' +
                    protocol_name + '.find().' + 'remove()')
            else:
                eval('device_obj' + '.Ipv6Loopback.find().' + protocol_name + '.find().' + 'remove()')
        except:
            pass
        return True

    def delete_protocols(self, devices, protocols, nested_device=None):
        """
        Deletes protocol
        :param devices: List of device names
        :param protocols: List of protocol names
        :param nested_device: Nested device name
        :return: True on success
        """
        protocolsList = {'isis': 'IsisL3', 'dhcpv4client': 'Dhcpv4client', 'dhcpv6client': 'Dhcpv6client',
                        'pppoxclient': 'Pppoxclient', 'pppoxserver': 'Pppoxserver', 'mpls': 'Mpls',
                        'dotonex': 'DotOneX', 'bfdv4interface': 'Bfdv4Interface', 'bgp': 'BgpIpv4Peer',
                        'dhcpv4server': 'Dhcpv4server', 'igmp': 'IgmpHost', 'rsvp': 'RsvpteLsps',
                        'rsvpteif': 'Rsvpteif', 'bgpevpn': 'BgpIPv4EvpnEvi', 'bgpv6evpn': 'BgpIPv6EvpnEvi',
                        'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',
                        'ldptargetedrouter': "LdpTargetedRouter",
                        'ldpconnectedinterface': 'LdpConnectedInterface', 'ospfv2': 'Ospfv2',
                        'bfdv6interface': 'Bfdv6Interface', 'bgpv6': 'BgpIpv6Peer', 'dhcpv6server': 'Dhcpv6server',
                        'ldpbasicrouterv6': 'LdpBasicRouterV6', 'ldpv6connectedinterface': 'Ldpv6ConnectedInterface',
                        'mld': 'MldHost', 'mldquerier': 'MldQuerier', 'pimv6interface': 'PimV6Interface',
                        'ospfv3': 'Ospfv3','ipv4':'Ipv4','ipv6':'Ipv6'}

        for protocol in protocols:
            for each_device in devices:
                device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)
                if nested_device:
                    device_obj = device_obj.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                self._delete_protocol(device_obj, protocolsList[protocol.lower()])

        return True


    def delete_emulated_device(self, router_id=None, **kwargs):
        """
        Deletes emulated device Objects.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
        configured.
        :return: True on success
        :Example: delete_emulated_device(router_id='10.10.10.1')
        """
        result = False
        device_name = kwargs.get("device_name", None)
        if isinstance(router_id, str):
            router_id = [router_id]
        if isinstance(device_name, str):
            device_name = [device_name]
        if router_id == None and device_name == None:
            raise CafyException.TgenInvalidInputError('router_id or device name is a mandatory parameter.')
        if device_name:
            for dev in device_name:
                for device in self.ixNetwork.Topology.find():
                    try:
                        if dev == device.DeviceGroup.find().Name:
                            device.DeviceGroup.find().remove()
                            result = True
                            break
                    except:
                        pass

        if router_id:
            for each_id in router_id:
                for device in self.ixNetwork.Topology.find():
                    try:
                        if each_id in device.DeviceGroup.find().RouterData.find().RouterId.Values:
                            device.DeviceGroup.find().remove()
                            result = True
                            break
                    except:
                        pass
        if result:
            return True
        else:
            raise IxiaOperationException(f"Given Router ID : {router_id} or device {device_name} is not found in the existing config")

    def create_dhcp_option(self,router_id,option_type,address_family,
                           msg_type=['kDiscover', 'kRequest'],
                           msg_type_list=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'],
                           remove=False, **kwargs):
        """
        Configures dhcpv4 or dhcpv6 options (TLV).
        :param router_id: Name of Device group in which DHCP client is configured.
        :param option_type: Option value (code).
        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6.
        :param msg_type: only applicable to dhcpv4. Includes the message option in 'kDiscover', 'kRequest', 'kDecline', 'kRelease'.
            Default value for v4 client is ['kDiscover', 'kRequest']
        :param msg_type_list: only applicable to dhcpv6. Possible values are 'kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'
            Default value for v4 client is ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'']
        :param remove: Enable or disable removal of option (TLV). Default is False.
        :return: True on success.
        :Example: create_dhcp_option(router_id="dhcp-v6-client", option_type=['SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',
                 'Identity Association for Prefix Delegation'], address_family="IPV6", msg_type=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'], remove=True)
        """

        v4Msg = ['kDiscover', 'kRequest', 'kDecline', 'kRelease', 'kInform']
        v4Tlv = ['Subnet Mask', 'Time Offset', 'Router Address', 'Time Server', 'Name Server', 'Domain Name Server',
                 'Log Server', 'Cookie Server', 'LPR Server', 'Impress Server', 'Resource Location Server', 'Host Name',
                 'Boot File Size', 'Merit Dump File', 'Domain Name', 'Swap Server', 'Root Path', 'Extension Path',
                 'IP Forwarding Enable/Disable', 'Non-Local Source Routing Enable/Disable', 'Policy Filter',
                 'Maximum Datagram Reassembly Size', 'Default IP Time-to-live', 'Path MTU Aging Timeout',
                 'Path MTU Plateau Table', 'Interface MTU Size', 'All Subnets are Local', 'Broadcast Address',
                 'Perform Mask Discovery', 'Mask Supplier', 'Perform Router Discovery', 'Router Solicitation Address',
                 'Static Route', 'Trailer Encapsulation', 'ARP Cache Timeout', 'Ethernet Encapsulation',
                 'TCP Default TTL', 'TCP Keepalive Interval', 'TCP Keepalive Garbage',
                 'Network Information Service Domain', 'Network Information Servers', 'Network Time Protocol Servers',
                 'Vendor Specific Information', 'NetBIOS over TCP/IP Name Server',
                 'NetBIOS over TCP/IP Datagram Distribution Server', 'NetBIOS over TCP/IP Node Type',
                 'NetBIOS over TCP/IP Scope', 'X Window System Font Server', 'X Window System Display Manager',
                 'Requested IP Address', 'IP Address Lease Time', 'Option Overload', 'DHCP Message Type',
                 'Server Identifier', 'Parameter Request List', 'Message', 'Maximum DHCP Message Size',
                 'Renewal (T1) Time Value', 'Renewal (T2) Time Value', 'Vendor Class Identifier', 'Client Identifier',
                 'NetWare/IP Domain Name', 'NetWare/IP Information', 'Network Information Service+ Domain',
                 'Network Information Service+ Servers', 'TFTP Server Name', 'Bootfile Name', 'Mobile IP Home Agent',
                 'Simple Mail Transport Protocol (SMTP) Server', 'Post Office Protocol (POP3) Server',
                 'Network News Transport Protocol (NNTP) Server', 'Default World Wide Web (WWW) Server',
                 'Default Finger Server', 'Default Internet Relay Chat (IRC) Server', 'StreetTalk Server',
                 'StreetTalk Directory Assistance (STDA) Server', 'User Class Information', 'SLP Directory Agent',
                 'SLP Service Scope', 'Rapid Commit', 'DHCP Client FQDN', 'DHCP Relay Agent Information',
                 'Authentication (RFC3118)']
        v6Msg = ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind']
        v6Tlv = ['Client Identifier', 'Client Identifier', 'Server Identifier',
                 'Identity Association for Non-temporary Addresses', 'Identity Association for Temporary Addresses',
                 'IA Address', 'Option Request', 'Preference', 'Elapsed Time', 'Relay Message', 'Authentication',
                 'Server Unicast', 'Status Code', 'Rapid Commit', 'User Class', 'Vendor Class',
                 'Vendor-specific Information', 'Interface-ID', 'Reconfigure Message', 'Reconfigure Accept',
                 'SIP Servers Domain Name', 'SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',
                 'Identity Association for Prefix Delegation', 'IA_PD Prefix',
                 'Network Information Service (NIS) Servers', 'Network Information Service V2 (NIS+) Servers',
                 'Network Information Service (NIS) Domain Name',
                 'Network Information Service V2 (NIS+) Domain Name Option',
                 'Simple Network Time Protocol (SNTP) Servers', 'Information Refresh Time',
                 'Broadcast and Multicast Service Controller Domain Name',
                 'Broadcast and Multicast Service Controller IPv6 Address', 'DHCP Civic Location',
                 'Relay Agent Remote-ID', 'Relay Agent Subscriber-ID', 'Client FQDN', 'PANA Authentication Agent',
                 'POSIX Timezone', 'Timezone Database', 'Relay Agent Echo Request', 'Query', 'Client Data',
                 'Client Last Transaction Time', 'Relay Data', 'Client Link', 'MIPv6 Home Network ID FQDN',
                 'MIPv6 Visited Home Network Information', 'LoST Server', 'CAPWAP AC', 'Relay-ID', 'MoS IPv6 Address',
                 'MoS Domain Name List', 'NTP Server', 'Access Network Domain Name',
                 'SIP User Agent Configuration Service Domains', 'Boot File Uniform Resource Locator',
                 'Boot File Parameters', 'Client System Architecture Type', 'Client Network Interface Identifier',
                 'Geographical Location', 'AFTR-Name', 'ERP Local Domain Name', 'Relay-Supplied DHCP Options',
                 'Prefix Exclude', 'Virtual Subnet Selection', 'MIPv6 Identified Home Network Information',
                 'MIPv6 Unrestricted Home Network Information', 'MIPv6 Home Network Prefix', 'MIPv6 Home Agent Address',
                 'MIPv6 Home Agent FQDN', 'RDNSS Selection DHCPv6', 'Kerberos Principal Name', 'Kerberos Realm Name',
                 'Kerberos Default Realm Name', 'Kerberos KDC']

        if re.match(r'\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif any(type(var) is not list for var in (option_type, msg_type_list, msg_type)):
            raise IxiaOperationException('All these msg_type/msg_type_list/option_type arguments has to be in'
                                         ' list format')
        else:
            if self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id):
                if re.fullmatch('ipv4|v4', address_family, re.IGNORECASE):
                    if set(option_type) - set(v4Tlv) or set(msg_type) - set(v4Msg):
                        raise IxiaOperationException('DHCP v4 client supports the following message {0} and the '
                                                     'following TLV {1}'.format(v4Msg, v4Tlv))
                    else:
                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find()\
                            .Dhcpv4client.find()
                        tlvMessage = msg_type
                elif re.fullmatch('ipv6|v6', address_family, re.IGNORECASE):
                    if set(option_type) - set(v6Tlv) or set(msg_type_list) - set(v6Msg):
                        raise IxiaOperationException('DHCP v6 client supports the following message {0} and the '
                                                     'following TLV {1}'.format(v6Msg, v6Tlv))
                    else:
                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find().\
                            Dhcpv6client.find()
                        tlvMessage = msg_type_list
                else:
                    raise IxiaOperationException('Given "{}" format is not supported for "address_family" argument. '
                                                 'It accepts any one from the following ipv4/v4/ipv6/v6'.
                                                 format(address_family))

                if not dhcpObj:
                    raise IxiaConfigException(
                        'DHCP {} client is not configured in the "{}" devicegroup'.format(address_family, router_id))

                if not remove:
                    for tlv in option_type:
                        dhcpObj.TlvProfile.find().Tlv.add(Name=tlv, IncludeInMessages=tlvMessage)
                    return True
                else:
                    tlvnotconfigured = []
                    for tlv in option_type:
                        if dhcpObj.TlvProfile.find().Tlv.find(Name=tlv):
                            dhcpObj.TlvProfile.find().Tlv.find(Name=tlv).remove()
                        else:
                            tlvnotconfigured.append(tlv)

                    if tlvnotconfigured:
                        self.log.info('The following TLV"s {0} are not configured in the DHCP {1} Client'
                                      .format(tlvnotconfigured, address_family))
                    return True
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))

    def _get(self, handle, *args):
        """
        Returns the value(s) of one or more object attributes.

        If multiple arguments, this method returns a dictionary of argument
        names mapped to the value returned by each argument.
        Ex :{attrib_name:attrib_val, attrib_name:attrib_val, ..}

        If a single argument is given, then the response is a list of values/string value
        for that argument.

        NOTE: If the string contains multiple substrings, then the
        client will need to parse these.
        :param handle: Handle that identifies object to get info for.
        :param args: Zero or more attributes or relationships.
        :return: Dictionary/list/string mapped to object attributes else raises exception.
        """
        data = {}
        try:
            if args:
                for arg in args:
                    if self.bgp_devices != {} and handle in self.bgp_devices:
                        bgpHandle = self.bgp_devices[handle]
                        data[arg] = eval('bgpHandle.' + arg)
                    if self.isis_devices != {} and handle in self.isis_devices:
                        isisHandle = self.isis_devices[handle]
                        data[arg] = eval('isisHandle.' + arg)
                    if self.ldp_devices != {} and handle in self.ldp_devices:
                        ldpHandle = self.ldp_devices[handle]
                        data[arg] = eval('ldpHandle.' + arg)
                    if self.ospf_devices != {} and handle in self.ospf_devices:
                        ospfHandle = self.ospf_devices[handle]
                        data[arg] = eval('ospfHandle.' + arg)
        except:
            raise IxiaOperationException(
                'Invalid handle "%s". Please obtain the handle using create or get' % str(handle))
        return data

    def _get_emulated_devices(self):
        """
        Get the list of Emulated Devices in configuration.

        :return: list of emulated devices.
        """
        log.debug('Fetch emulated devices from config')
        try:
            if self.ixNetwork.Topology.find().DeviceGroup.find():
                self.emulated_devices = self.ixNetwork.Topology.find().DeviceGroup.find()
            return self.emulated_devices
        except:
            raise IxiaOperationException("Device Config Not Found")

    def _get_bgp_config_for_emulated_devices(self):
        """
        Get BGP routers in the configuration.

        :return: Dictionary of BGP routers.
        """
        log.info('Fetch BGP devices from config')
        for device in self.emulated_devices:
            try:
                if device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    self.bgp_devices[
                        device.Ethernet.find().Ipv4.find()] = device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()
                    self._get_bgp_routes_for_emulated_device(device)
            except:
                pass
            try:
                if device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                    self.bgp_devices[
                        device.Ethernet.find().Ipv6.find()] = device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()
                    self._get_bgp_routes_for_emulated_device(device)
            except:
                pass
        return self.bgp_devices

    def _get_bgp_routes_for_emulated_device(self, device, bgp_router_config=None):
        """
        Get the BGP routes for a given device.

        :param device: Emulated device name
        :param bgp_router_config: BGP router config handle
        :return:
        """
        device_name = device.Name
        try:
            if device.NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find() or device.NetworkGroup.find().Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():
                for ipv4PrefixPool in device.NetworkGroup.find().Ipv4PrefixPools.find():
                    start_ip = ipv4PrefixPool.NetworkAddress.Values
                    router_id = device.RouterData.find().RouterId.Values
                    self.bgp_routes_startip_rid_v4[str(start_ip), str(router_id)] = ipv4PrefixPool
                    self.bgp_routes_startip_device_name_v4[str(start_ip), device_name] = ipv4PrefixPool
                    for topology in self.ixNetwork.Topology.find():
                        if topology.href in device.href:
                            for vportObj in self.ixNetwork.Vport.find():
                                if vportObj.href in topology.Vports:
                                    port_name = vportObj.Name
                                    self.bgp_routes_startip_port_name_v4[port_name, str(start_ip)] = ipv4PrefixPool
        except:
            pass
        try:
            if device.NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find() or device.NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                for ipv6PrefixPool in device.NetworkGroup.find().Ipv6PrefixPools.find():
                    start_ip = ipv6PrefixPool.NetworkAddress.Values
                    router_id = device.RouterData.find().RouterId.Values
                    self.bgp_routes_startip_rid_v6[str(start_ip), str(router_id)] = ipv6PrefixPool
                    self.bgp_routes_startip_device_name_v6[str(start_ip), device_name] = ipv6PrefixPool
                    for topology in self.ixNetwork.Topology.find():
                        if topology.href in device.href:
                            for vportObj in self.ixNetwork.Vport.find():
                                if vportObj.href in topology.Vports:
                                    port_name = vportObj.Name
                                    self.bgp_routes_startip_port_name_v6[port_name, str(start_ip)] = ipv6PrefixPool
        except:
            pass

    def set_ipv4_traffic_ttl(self, traffic_item, ttl):
        """
        setting the value of the TTL Value for the specified traffic items

        :param traffic_item: (list/str) of Traffic items to set the TTL value from.
        :param ttl: (list/str/int) of ttl values to be set
        :return: return True on success else raises exception

        :Example: set_ipv4_traffic_ttl(traffic_item= ["Traffic Item 1","Traffic Item 2"],ttl = ['255','220'])
                  set_ipv4_traffic_ttl(traffic_item= ["Traffic Item 1","Traffic Item 2"],ttl = '255')
                  set_ipv4_traffic_ttl(traffic_item= "Traffic Item 1",ttl = '255')
                  set_ipv4_traffic_ttl(traffic_item= "Traffic Item 1",ttl = 255)
        """
        self.log.info("Setting TTL for Traffic item")
        if type(traffic_item) != list:
            traffic_item = [traffic_item]
        for item in traffic_item:
            item = item.replace('+', r'\+').replace('*', r'\*').replace('(',r'\(').replace(')',r'\)')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():
                try:
                    configElement.Stack.find(DisplayName="IPv4")
                    fieldValue = configElement.Stack.find(StackTypeId='ipv4').Field.find(Name='ttl')
                    fieldValue.ValueType = 'singleValue'
                    if type(ttl) == int:
                        ttl = str(ttl)
                        fieldValue.SingleValue = ''.join(ttl)
                    if type(ttl) == list:
                        fieldValue.SingleValue = ttl[traffic_item.index(item)]
                    if type(ttl) == str:
                        fieldValue.SingleValue = ''.join(ttl)
                except:
                    self.log.info("IPV4 stack Not Available in %s" % item)
                    raise IxiaOperationException("IPV4 Stack Not Available in %s" % item)
        return True

    def set_ipv6_traffic_hop_limit(self, traffic_item, hop_limit):
        """
        setting the value of the Hop Limit Value for the specified traffic items

        :param traffic_item: (list/str) of Traffic items to set the TTL value from.
        :param hop_limit: (list/str/int) of hop_limit values to be set
        :return: return True on success else raises exception

        :Example: set_ipv6_traffic_hop_limit(traffic_item= ["Traffic Item 1","Traffic Item 2"],hop_limit = ['255','220'])
                  set_ipv6_traffic_hop_limit(traffic_item= ["Traffic Item 1","Traffic Item 2"],hop_limit = '225')
                  set_ipv6_traffic_hop_limit(traffic_item= "Traffic Item 1",hop_limit = '225')
                  set_ipv6_traffic_hop_limit(traffic_item= "Traffic Item 1",hop_limit = 225)
        """
        self.log.info("Setting Hop Limit for Traffic item")
        if type(traffic_item) != list:
            traffic_item = [traffic_item]
        for item in traffic_item:
            item = item.replace('+', r'\+').replace('*', r'\*').replace('(',r'\(').replace(')',r'\)')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():
                try:
                    configElement.Stack.find(DisplayName="IPv6")
                    fieldValue = configElement.Stack.find(StackTypeId='ipv6').Field.find(Name='hopLimit')
                    fieldValue.ValueType = 'singleValue'
                    if type(hop_limit) == int:
                        hop_limit = str(hop_limit)
                        fieldValue.SingleValue = ''.join(hop_limit)
                    if type(hop_limit) == list:
                        fieldValue.SingleValue = hop_limit[traffic_item.index(item)]
                    if type(hop_limit) == str:
                        fieldValue.SingleValue = ''.join(hop_limit)
                except:
                    self.log.info("IPV6 stack Not Available in %s" % item)
                    raise IxiaOperationException("IPV6 Stack Not Available in %s" % item)
        return True

    def get_traffic_ethernet_vlan_priority(self, traffic_list):
        """
        Gets the value of the Ethernet VLAN priority for the specified traffic items

        :param traffic_list: A list of traffic items to get the VLAN priority values from.
        :return: A dict of results containing the VLAN ID and VLAN priority value for the specified traffic items

        :Example: get_traffic_ethernet_vlan_priority(traffic_list=["Traffic Item 1"])
        """
        self.log.info("Getting VLAN Priority For Traffic Items")
        results = {}
        for trafficName in traffic_list:
            vlanPriority = list()
            try:
                for vlanStack in self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').ConfigElement.find().Stack.find(StackTypeId='vlan'):
                    vlanPriority.append({'vlan':vlanStack.Field.find(Name='vlan_id').SingleValue,'priority': vlanStack.Field.find(Name='vlan_user_priority').SingleValue})
                results[trafficName] = vlanPriority
            except:
                self.log.info("Not able to find the %s in config" % trafficName)
                raise IxiaOperationException("Not able to find the %s in config" % trafficName)
        return results

    def set_network_group_count(self, network_count, network_group, **kwargs):
        """
        Set network group count of MAC Pools.

        :param int network_count: Network count. Should be >=1.
        :param str network_group: Network Group Name.
        :param kwargs: Additional keyword arguments.
            - nested_network_group (str): Network Group name at nested level, default is None.
            - network_group_mac (str): MAC address to be set on NG, default is '10:00:00:00:00:00'.
            - network_group_mac_step (str): MAC address to be incremented, default is '00:00:00:00:00:01'.
            - mac1 (str): Custom type MAC address 1, default is '00:00:00:00:00:01'.
            - mstep1 (int): Custom type MAC address step 1, default is 1.
            - mac2 (str): Custom type MAC address 2, default is '00:00:00:00:00:01'.
            - mstep2 (int): Custom type MAC address step 2, default is 1.
            - network_group_vlan (int): VLAN start value, default is 1001.
            - network_group_vlan_step (int): VLAN step value, default is 1.
            - vlan1 (int): Custom VLAN1 increment value, default is 1.
            - vstep1 (int): Custom VLAN1 step1, default is 1.
            - vlan2 (int): Custom VLAN2 increment value, default is 1.
            - vstep2 (int): Custom VLAN2 step2, default is 1.
            - first_level_spoke_count (int): Custom first level spoke count, default is 1.

        Example:
            set_network_group_count(network_count = 5,network_group='Network Group 1')
            set_network_group_count(network_count = 3,network_group='Network Group 1',network_group_mac = "00:13:00:01:10:01",
            network_group_mac_step = "00:00:00:00:00:00",mac1 = '00:00:00:01:00:00',mstep1 = 4, mac2 = '00:00:00:00:00:01',
            mstep2 = 5, network_group_vlan = 200, network_group_vlan_step = 3, vlan1 = 2,vstep1 = 1,vlan2 = 2,vstep2 = 2)
        """

        self.log.info("Setting Network Group count and MAC and VLAN")
        nested_network_group = kwargs.get('nested_network_group', None)
        network_group_mac = kwargs.get('network_group_mac', '10:00:00:00:00:00')
        network_group_mac_step = kwargs.get('network_group_mac_step', '00:00:00:00:00:01')
        mac1 = kwargs.get('mac1', '00:00:00:00:00:01')
        mstep1 = kwargs.get('mstep1', 1)
        mac2 = kwargs.get('mac2', '00:00:00:00:00:01')
        mstep2 = kwargs.get('mstep2', 1)
        network_group_vlan = kwargs.get('network_group_vlan', '1001')
        network_group_vlan_step = kwargs.get('network_group_vlan_step', '0')
        vlan1 = kwargs.get('vlan1', '0')
        vstep1 = kwargs.get('vstep1', 1)
        vlan2 = kwargs.get('vlan2', '1')
        vstep2 = kwargs.get('vstep2', 1)
        network_obj = None
        first_level_spoke_count = kwargs.get('first_level_spoke_count',1)
        try:
            if network_group and nested_network_group is None:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$')
            elif network_group and nested_network_group:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$').DeviceGroup.find().NetworkGroup.find(
                    Name='^' + nested_network_group + '$')
            if network_obj:
                network_obj.Multiplier = network_count
            else:
                self.log.error(f'Network Group Not Found - {network_group}')
            if network_obj.MacPools.find():
                network_obj.MacPools.find().Mac.Custom(start_value=network_group_mac, step_value=network_group_mac_step,
                                                    increments=[(mac1, mstep1, [(mac2, mstep2, [])])])

                network_obj.MacPools.find().Vlan.find().VlanId.Custom(start_value=network_group_vlan,
                                                                    step_value=network_group_vlan_step,
                                                                    increments=[(vlan1, vstep1, [(vlan2, vstep2, [])])])
            if network_obj.NetworkTopology.find():
                if network_obj.NetworkTopology.find().NetTopologyHubNSpoke.find():
                    network_obj.NetworkTopology.find().NetTopologyHubNSpoke.find().NumberOfFirstLevelSpokes = first_level_spoke_count
        except:
            self.log.info("%s Not in config " % network_group)
            raise IxiaOperationException("%s Not in config " % network_group)
        return True

    def create_ethernetII_interface(self, router_id=None, source_mac=None):

        """
        Creates VlanIf object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param source_mac: Mapping EthIIIf attribute - SourceMac. Example: 00:10:94:00:00:02
        :return: EthIIIf object.

        Example: create_ethernetII_interface(router_id="192.0.0.1", source_mac="00:10:94:00:00:ff")
        """
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    EthObj = deviceGroup.Ethernet.find()
                    if not EthObj:
                        EthObj = deviceGroup.Ethernet.add()
                    else:
                        EthObj.Mac.Increment(start_value=source_mac)
                    break

        if result:
            return EthObj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_vlan_interface(self, router_id, vlan_id=None, id_step=None, vlan_priority=None):

        """
        Creates VlanIf object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param vlan_id: Mapping VlanIf attribute - VlanId. Range: 0 - 4095
        :param id_step: Mapping VlanIf attribute - IdStep.
        :param vlan_priority: Mapping VlanIf attribute - Priority. Range: 0 - 7
        :return: VlanIf object.
        Example: create_vlan_interface(router_id="192.0.0.1", vlan_id=5, id_step=1, vlan_priority=2)
        """

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    deviceGroup.Ethernet.find().UseVlans = True
                    VlanObj = deviceGroup.Ethernet.find().Vlan.find()
                    VlanObj.VlanId.Increment(start_value=vlan_id, step_value=id_step)
                    VlanObj.Priority.Increment(start_value=vlan_priority)
                    break

        if result:
            return VlanObj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def set_emulated_device_basic_attributes(self,
                                             router_id=None,
                                             device_count=None,
                                             enable_ping_response=None,
                                             router_id_step=None,
                                             ipv6_router_id=None,
                                             ipv6_router_id_step=None,
                                             emulated_device_name=None):

        """
        Sets emulated device attributes.

        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be configured.
        :param device_count: Mapping emulated device attribute - DeviceCount.
            Description: Number of devices in the device block.
            Type: u32
            Range: 1 - 0xFFFFFFFF
        :param enable_ping_response: Mapping emulated device attribute - EnablePingResponse.
            Description: Whether the emulated device will respond to ping.
            Type: bool
            Possible Values: TRUE - Respond to ping. FALSE - Do not respond to ping.
        :param router_id_step: Mapping emulated device attribute - RouterIdStep.
            Type: ip (Example: 0.0.0.1)
        :param ipv6_router_id: Mapping emulated device attribute - Ipv6RouterId.
            Type: ipv6 (Example: 2000::1)
        :param ipv6_router_id_step: Mapping emulated device attribute - Ipv6RouterIdStep.
            Type: ipv6 (Example: 0000::1)
        :param emulated_device_name: Mapping emulated device attribute - Name.
            Description: Emulated device name, Example: "Device 1"
        :return: True on success

        Example: set_emulated_device_basic_attributes(router_id="193.0.0.1",
                                             device_count=30,
                                             enable_ping_response=True,
                                             router_id_step="0.0.0.5",
                                             ipv6_router_id='150::0',
                                             ipv6_router_id_step=2,
                                             emulated_device_name="DG2")
        """

        result = False

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                try:
                    if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                        devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroup.Name)
                        if devicegroupObj:
                            if emulated_device_name is not None:
                                devicegroupObj.Name = emulated_device_name
                            if device_count is not None:
                                devicegroupObj.Multiplier = device_count
                            if devicegroupObj.RouterData.find():
                                devicegroupObj.RouterData.find().RouterId.Increment(step_value=router_id_step)
                            else:
                                raise IxiaConfigException(
                                    "No router data found on the given Router-ID '{}'".format(router_id))
                            result = True
                except:
                    pass
        if result:
            return True
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_dhcp_client(self, router_id, address_family, vlan1_id=None, vlan1_step=1, vlan2_id=None, vlan2_step=1,
                           source_mac=None, dhcpv6_client_mode='iana', dhcpv6_duid_type='duid_llt'):

        """
        Creates dhcp client (IPv4, IPv6).

        :param router_id: Mandatory parameter. IXIA doesn't support IPv4 / IPv6 address format. Please input Device Group Name to which DHCP client has to be configured.
        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6|.\
            IXIA doesn't support dual stack (IPv4v6)
        :param vlan1_id: vlan ID in case of single tagged and SVLAN (Outer VLAN), in case of QinQ.
            Parent Object: VlanIf
            Range: 0 - 4095
        :param vlan1_step: VLAN ID step value.
            Parent Object: VlanIf
        :param vlan2_id: CVLAN (Inner VLAN), in case of QinQ.
            Parent Object: VlanIf
            Range: 0 - 4095
        :param vlan2_step: VLAN ID step value.
            Parent Object: VlanIf
        :param source_mac: Mapping EthiiIf attribute - SourceMac. Source MAC address. Example: 00:10:94:00:00:02
        :param dhcpv6_client_mode: The type of client to emulate. Applicable to dhcpv6 only. possible values:
            IANA - The client emulates DHCPv6. (default)
            IATA - The client emulates DHCP PD.
            IAPD - The client emulates DHCP PD.
            IANA_IAPD - The client emulates DHCPv6 and DHCP PD.
        :param dhcpv6_duid_type: DHCPv6 unique identifier type. possible values:
            DUID_LLT    - Link-layer address plus time. (default)
            DUID_EN     - Vendor-assigned unique ID based on enterprise number.
            DUID_LL     - Link-layer address.
        :return: True on success
        Example: create_dhcp_client(router_id='DG1',
                                    address_family='ipv4',
                                    vlan1_id=2,
                                    vlan1_step=1,
                                    vlan2_id=3,
                                    vlan2_step=1,
                                    source_mac="00:10:94:00:00:02",
                                    dhcpv6_client_mode='iana',
                                    dhcpv6_duid_type='duid_llt')
        """
        result = False

        if re.match(r'\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format for DHCP. Please provide Device'
                                      ' Group Name')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                result = True
                if vlan1_id is None and vlan2_id or vlan1_id and vlan2_id:
                    enableVlan = True
                    TotalVlan = 2
                elif vlan1_id and vlan2_id is None:
                    enableVlan = True
                    TotalVlan = 1
                elif vlan1_id is None and vlan2_id is None:
                    enableVlan = None
                    TotalVlan = None
                vlanId = [vlan1_id, vlan2_id]
                vlanId = [0 if vId is None else vId for vId in vlanId]
                vlanStep = [vlan1_step, vlan2_step]
                EthObj = devicegroupObj.Ethernet.add(UseVlans=enableVlan, VlanCount=TotalVlan)
                EthObj.Mac.Increment(start_value=source_mac)
                if enableVlan:
                    for vlanObj, id, step in zip(EthObj.Vlan.find(), vlanId, vlanStep):
                        vlanObj.VlanId.Increment(start_value=id, step_value=step)
                if re.search('ipv4|v4', address_family.lower()):
                    dhcpObj = EthObj.Dhcpv4client.add()
                elif re.search('ipv6|v6', address_family.lower()):
                    dhcpObj = EthObj.Dhcpv6client.add()
                    dhcpObj.Dhcp6IaType.Single(dhcpv6_client_mode.lower())
                    dhcpObj.Dhcp6DuidType.Single(dhcpv6_duid_type.lower())

        if result:
            return result
        else:
            raise IxiaConfigException('No matching Device Group is found for the given name "{}"'.format(router_id))

    def set_stream_ip_count(self, stream_name, src_or_dest, ip_count, version='ipv4', **kwargs):
        """
        API to modify traffic items source and destination step count
        :param stream_name: Traffic item name Ex : "Traffic Item 1"
        :param src_or_dest: set IP count on src/dest/both EX: src
        :param ip_count: IP count to set EX: 50
        :param version: ipv4/6 EX: "ipv4"
        :param kwargs: Supported step_value parameters as optional in kwargs.
        :return: True on Success

        :Example: tgnObj.set_stream_ip_count(stream_name="Traffic Item 1",src_or_dest="src",ip_count=50,version="ipv4")
        """
        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')
        if not trafficItemObj:
            raise IxiaConfigException("Traffic item not found")
        if trafficItemObj.TrafficType != 'raw':
            raise IxiaConfigException("Traffic type should be raw")
        if version.lower() == 'ipv4':
            version = "IPv4"
        if version.lower() == 'ipv6':
            version = "IPv6"
        if src_or_dest.lower() in ["src", "both"]:
            try:
                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(
                    DisplayName="Source Address")
                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[
                    0] if field.ValueType == 'valueList' else field.StartValue]
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \
                    , str(start_address[0]), ip_count, str(start_address[0])
                if kwargs['step_value']:
                    field.StepValue = kwargs['step_value']
            except:
                pass
        if src_or_dest.lower() in ["dest", "both"]:
            try:
                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(
                    DisplayName="Destination Address")
                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[
                    0] if field.ValueType == 'valueList' else field.StartValue]
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \
                    , str(start_address[0]), ip_count, str(start_address[0])
                if kwargs['step_value']:
                    field.StepValue = kwargs['step_value']
            except:
                pass
        return True

    def get_dynamic_ip_list_device(self, router_id, protocol='ipv4'):

        """
        Returns a list of IP Address configured for a specific device

        :param router_id: Mandatory parameter. Router ID of emulated device.
        :param protocol: IP Protocol (ipv4|ipv6)

        :return: A list of ip addresses for the emulated device.
                e.g: ['10.0.0.1', '10.0.0.2', '10.0.0.3']

        :Example: get_dynamic_ip_list_device("DG1", 'ipv4')
        """
        self.log.info("Getting Dynamic IP list of the devices")
        if re.match(r'\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif protocol.lower() != 'ipv4' and protocol.lower() != 'ipv6':
            raise IxiaConfigException("Unsupported IP type. Please use ipv4 or ipv6")
        else:
            protocol = protocol[0].capitalize() + protocol[1:]
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                try:
                    ipObj = getattr(devicegroupObj.Ethernet.find(), protocol).find()
                    deviceIp = ipObj.Address.Values
                except:
                    raise IxiaConfigException("{0} stack doesn't exist on given device group {1}.".format(protocol, router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return deviceIp

    def set_invalid_ipv4(self, traffic_items, cfg_dict):
        """
        API used to configure invalid IPv4 headers for a given list of streams

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            src_addr (sourceAddr)
            dst_addr (destAddr)
            checksum (checksum)
            header_length (ihl)
            ttl (ttl)
            version (version)
            total_length (totalLength)
            frag_offset (fragOffset)
            options (options)
            source_routing (loosesrcroute)
            record_route (recordroute)
            timestamp (timestamp)
        :return: True on success, exception on failure
        :Example: set_invalid_ipv4(['Traffic item'], {'src_addr':'100.1.1.1', 'dst_addr':'100.1.1.2', 'checksum':64, 'header_length':10, 'ttl':64, 'total_length':8,'frag_offset':10})
        """
        self.log.info("Configuring invalid Ipv4 headers")
        for trafficItemName in traffic_items:
            trafficItemName = trafficItemName.replace('+', r'\+').replace('*', r'\*')
            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):
                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType
            else:
                trafficType = None
                raise IxiaConfigException("Traffic stream '%s' not found on the config"%(trafficItemName))
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():
                if trafficType.lower() == 'ipv4' or trafficType.lower() == 'raw':
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        if "header_length" in cfg_dict:
                            field = stackObj.Field.find(DisplayName='Header Length')
                            field.Auto, field.FieldValue, field.SingleValue = 'False', cfg_dict['header_length'], cfg_dict['header_length']
                        if "checksum" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'SingleValue', cfg_dict['checksum'])
                        if "ttl" in cfg_dict:
                            setattr(stackObj.Field.find(Name='ttl'), 'SingleValue', cfg_dict['ttl'])
                        if "version" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Version'), 'SingleValue', cfg_dict['version'])
                        if "total_length" in cfg_dict:
                            setattr(stackObj.Field.find(Name='total_len'), 'Auto', 'False')
                            setattr(stackObj.Field.find(Name='total_len'), 'SingleValue', cfg_dict['total_length'])
                        if "frag_offset" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Fragment offset'), 'SingleValue', cfg_dict['frag_offset'])
                        if "timestamp" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Timestamp'), 'SingleValue', cfg_dict['timestamp'])
                    if trafficType.lower() == 'raw':
                        if "src_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue', cfg_dict['src_addr'])
                        if "dst_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue', cfg_dict['dst_addr'])

    def set_invalid_ipv6(self, traffic_items, cfg_dict):
        """
        API used to configure invalid IPv6 headers for a given list of streams

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            src_addr (sourceAddr)
            dst_addr (destAddr)
            checksum (checksum)
            ttl (hopLimit)
            total_length (payloadLength)
        :return: True on success, exception on failure
        :Example: set_invalid_ipv6(['Traffic item 1'], {'checksum':74, 'ttl':84, 'total_length':8})
        """
        self.log.info("Configuring invalid Ipv6 headers")
        for trafficItemName in traffic_items:
            trafficItemName = trafficItemName.replace('+', r'\+').replace('*', r'\*')
            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):
                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType
            else:
                trafficType = None
                raise IxiaConfigException("Traffic stream '%s' not found on the config" % (trafficItemName))
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(
                    Name='^' + trafficItemName + '$').ConfigElement.find():
                if trafficType.lower() == 'ipv6' or trafficType.lower() == 'raw':
                    if configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        if "checksum" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'SingleValue',
                                    cfg_dict['checksum'])
                        if "ttl" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Hop Limit'), 'SingleValue', cfg_dict['ttl'])
                        if "total_length" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'SingleValue', cfg_dict['total_length'])
                    if trafficType.lower() == 'raw':
                        if "src_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue',
                                    cfg_dict['src_addr'])
                        if "dst_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue',
                                    cfg_dict['dst_addr'])

    def change_mld_source_list(self, device_list=None, mld_source_list=None, port_list=None,**kwargs):
        """
        Modify MLD source Address
        :param device_list: Device group name
        :param mld_source_list: Mld source address
        :param port_list: Ports
        :return: True else raise exception
        :Example: change_mld_source_list(device_list=["DG1"],mld_source_list=["100::101:1","200::200:2","300::300:3"], port_list=["Port1","Port2"])
        """
        result = False
        value_type = kwargs.get('value_type',None)
        if mld_source_list:
            sourceRange = len(mld_source_list)
        else:
            sourceRange = 1
        if port_list:
            for portName in port_list:
                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):
                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')
                    for topoObj in self.ixNetwork.Topology.find():
                        if vportObj.href in topoObj.Ports:
                            portIndex = (topoObj.Ports).index(vportObj.href)
                            if device_list and mld_source_list:
                                for deviceGroupName in device_list:
                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')
                                        if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                            for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                                mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                                                sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
                                                indexList = []
                                                for srcRange in range(0, sourceRange):
                                                    indexList.append(portIndex)
                                                    portIndex += 1
                                                for ipIndex,sourceIp in zip(indexList,mld_source_list):
                                                    sourceListValues[ipIndex] = sourceIp
                                                    mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                    else:
                                        log.info("The deviceGroup '%s' not configured under this port '%s'"%(deviceGroupName,portName))
                                result = True
                            elif device_list is None and mld_source_list:
                                for deviceGroupObj in topoObj.DeviceGroup.find():
                                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                                            sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
                                            indexList = []
                                            for srcRange in range(0, sourceRange):
                                                indexList.append(portIndex)
                                                portIndex += 1
                                            for ipIndex, sourceIp in zip(indexList, mld_source_list):
                                                sourceListValues[ipIndex] = sourceIp
                                            mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                        result = True
                            else:
                                raise IxiaConfigException("Failed due to device_list/mld_source_list parameter not passed")
        if device_list and port_list is None:
            for deviceGroupName in device_list:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')
                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                            if value_type == 'custom':
                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ClearOverlays()
                                increment_value = [(kwargs.get('step_value', '0:0:0:1::'), 3,[('0::0', kwargs.get('repeat_value', 1), [])])]
                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Custom\
                                    (start_value=kwargs.get('start_value','0::0'),
                                     step_value=kwargs.get('step_value','0:0:0:1::'),
                                     increments=increment_value)
                            else:
                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=mld_source_list)
                        result = True
                else:
                    log.info("The deviceGroup '%s' not configured" %deviceGroupName)
        if result:
            return result
        else:
            raise IxiaConfigException("Failed to update MLD source Ip, Check Port List %s and Device Group %s configured on Ixia config"%(port_list,device_list))

    def change_igmp_source_list(self, device_list=None, igmp_source_list=None, port_list=None,**kwargs):
        """
        Modify IGMP source Address
        :param device_list: Device group name
        :param igmp_source_list: Igmp source address
        :param port_list: Ports
        :return: True else raise exception
        :Example: change_igmp_source_list(device_list=["DG1"],igmp_source_list=["1.1.1.1","2.2.2.2","3.3.3.3"], port_list=["Port1","Port2"])
        """
        result = False
        value_type = kwargs.get('value_type',None)
        if igmp_source_list:
            sourceRange = len(igmp_source_list)
        else:
            sourceRange = 1
        if port_list:
            for portName in port_list:
                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):
                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')
                    for topoObj in self.ixNetwork.Topology.find():
                        if vportObj.href in topoObj.Ports:
                            portIndex = (topoObj.Ports).index(vportObj.href)
                            if device_list and igmp_source_list:
                                for deviceGroupName in device_list:
                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')
                                        if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                            for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                                igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                                                sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
                                                indexList = []
                                                for srcRange in range(0, sourceRange):
                                                    indexList.append(portIndex)
                                                    portIndex += 1
                                                for ipIndex,sourceIp in zip(indexList,igmp_source_list):
                                                    sourceListValues[ipIndex] = sourceIp
                                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                    else:
                                        log.info("The deviceGroup '%s' not configured under this port '%s'"%(deviceGroupName,portName))
                                result = True
                            elif device_list is None and igmp_source_list:
                                for deviceGroupObj in topoObj.DeviceGroup.find():
                                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                                            sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
                                            indexList = []
                                            for srcRange in range(0, sourceRange):
                                                indexList.append(portIndex)
                                                portIndex += 1
                                            for ipIndex, sourceIp in zip(indexList, igmp_source_list):
                                                sourceListValues[ipIndex] = sourceIp
                                            igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                        result = True
                            else:
                                raise IxiaConfigException("Failed due to device_list/igmp_source_list parameter not passed")
        if device_list and port_list is None:
            for deviceGroupName in device_list:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')
                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                            if value_type == 'custom':
                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ClearOverlays()
                                increment_value = [(kwargs.get('step_value', '0.0.0.1'), 3,[('0.0.0.0', kwargs.get('repeat_value', 1), [])])]
                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Custom\
                                    (start_value=kwargs.get('start_value', '0.0.0.0'),
                                    step_value=kwargs.get('step_value', '0.0.0.1'),
                                     increments=increment_value)
                            else:
                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=igmp_source_list)
                        result = True
                else:
                    log.info("The deviceGroup '%s' not configured" %deviceGroupName)
        if result:
            return result
        else:
            raise IxiaConfigException("Failed to update Igmp source Ip, Check Port List %s and Device Group %s configured on Ixia config"%(port_list,device_list))


    def get_ipv4_tos(self, traffic_item_list=None):
        """
        Get IP priority set on traffic items
        :param traffic_item_list: List of traffic items to fetch IP priority

        :return: Dict of IP Priority configured in traffic item
                 Raise exception if traffic item not found

        :Example: get_ipv4_tos(traffic_item_list = ['Traffic Item 1','Traffic Item 2'])
        """
        self.log.info("Checking Ipv4 TOS information is available in TrafficItem")
        result = dict()
        tosDict = {'000 Routine': '00', '001 Priority': '20', '010 Immediate': '40', '011 Flash': '60', '100 Flash Override': '80', '101 CRITIC/ECP': 'A0', '110 Internetwork Control': 'C0', '111 Network Control': 'E0'}
        classPHB = {'Precedence 1':'20', 'Precedence 2':'40', 'Precedence 3':'60', 'Precedence 4':'80', 'Precedence 5':'A0', 'Precedence 6':'C0', 'Precedence 7':'E0'}
        if traffic_item_list == None:
            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]
        for trafficItemName in traffic_item_list:
            trafficItemName = trafficItemName.replace('+', r'\+').replace('*', r'\*')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():
                for count, stackObj in enumerate(configElement.Stack.find(DisplayName="IPv4"),start=1):
                    if count == 1:
                        key = 'Outer'
                    if count == 2:
                        key = 'Inner'
                    if stackObj.Field.find(DisplayName="Precedence").ActiveFieldChoice == True:
                        key = key+'TOS'
                        try:
                            result.setdefault(trafficItemName, [] ).append({key:tosDict[stackObj.Field.find(DisplayName="Precedence").FieldValue]})
                        except:
                            pass
                    if stackObj.Field.find(DisplayName="Class selector PHB").ActiveFieldChoice == True:
                        key = key + 'Diff-serv'
                        try:
                            result.setdefault(trafficItemName, []).append({key: classPHB[stackObj.Field.find(DisplayName="Class selector PHB").FieldValue]})
                        except:
                            pass
                    if stackObj.Field.find(DisplayName="Raw priority").ActiveFieldChoice == True:
                        key = key + 'Raw Priority'
                        try:
                            result.setdefault(trafficItemName, []).append({key: stackObj.Field.find(DisplayName="Raw priority").FieldValue})
                        except:
                            pass
        return result

    def config_device_twamp_client(self, router_id, ip_version='ipv4', add_test_session=True, **kwargs):

        """
        Configure TWAMP Client on device

        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.
        :param ip_version: IPV4 or IPV6.
        :param add_test_session: Add TWAMP Test Session by default and if TwampControlRange has to be configured then the attribute 'Count' is mandatory.
        :param kwargs: Supported parameters as optional in kwargs with default values.
        :return: TWAMP Client handle if configured else raise an exception.
        Example:config_device_twamp_client(router_id= 'IP-4', ip_version='ipv4', add_test_session=True, ControlStartServerIp = '20.1.1.1', Count= 1)
        """

        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',
                      'ErrorEstimateMultiplier']
        controlArg = ['ControlServerIpIncrement', 'ControlServerPort', 'ControlStartServerIp', 'Count', 'Enabled',
                      'KeyId', 'Mode', 'ControlServerName', 'Secret']
        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',
                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',
                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',
                          'TypepDescriptor']

        userArg = {key.lower(): value for key, value in kwargs.items()}
        configOptions = {}
        configControl = {}
        configTestSession = {}

        for ixnArg in optionsArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configOptions[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in controlArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'ControlServerName'.lower():
                    configControl['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configControl[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in testSessionArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'TestSessionName'.lower():
                    configTestSession['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).TwampClient.add()
                    self.ixNetwork.Vport.find().ProtocolStack.TwampOptions.add(**configOptions)
                    if add_test_session:
                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                            Name=router_id).Range.add().TwampControlRange.add(**configControl)
                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                            Name=router_id).Range.add().TwampTestRange.add(**configTestSession)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def config_device_twamp_server(self, router_id, ip_version='ipv4', **kwargs):

        """
        Configure TWAMP Client on device

        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.
        :param ip_version: IPV4 or IPV6.
        :param kwargs: Supported parameters as optional in kwargs with default values. 'Count & ReflectorPort' is mandatory.
        :return: TWAMP Client handle if configured else raise an exception.
        Example:config_device_twamp_server(router_id='IP-5', ip_version='ipv4', ControlPort = 2000, Count= 1, ReflectorPort = 13000)
        """

        serverArg = ['ControlPort', 'Count', 'EnableAccessControl', 'Enabled', 'IterationCount', 'KeyId',
                     'MaxTestSessions', 'Mode', 'Name', 'PermittedIp', 'PermittedIpIncrement', 'PermittedSenderPort',
                     'ReflectorPort', 'Secret']
        userArg = {key.lower(): value for key, value in kwargs.items()}
        configServer = {}

        for ixnArg in serverArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configServer[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).Range.add().TwampServerRange.add(**configServer)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def get_stream_name(self, stream_handle):
        """
        The function returns the Name of the traffic handle
        :param stream_handle: Traffic stream handle
        :return: Name of the traffic stream.
        Example: get_stream_name(stream_handle = 'TrafficItemObj')
        """
        return stream_handle.Name

    def get_twamp_peer_ip(self, router_id=None):
        """
        To fetch TWAMP peer IP and device IP of each TWAMP device in a dictonary.

        :param router_id: TWAMP Client Router ID of which Peer IP and device IP details are fetched.
        :return: Dictonary of TWAMP Client Router ID to device and peer IP of TWAMP Client.
        Example: get_twamp_peer_ip(router_id = 'TWAMPControl-R9')
        """
        twamp_peer_ip_dict = dict()
        if not router_id:
            device_list = []
            control_list = []
            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                controlObj = RangeObj.TwampControlRange.find()
                try:
                    device_list.append(RangeObj.IpRange)
                    control_list.append(controlObj)
                except:
                    pass
        else:
            device_list = []
            control_list = []
            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                controlObj = RangeObj.TwampControlRange.find()
                try:
                    if controlObj.Name == router_id:
                        device_list.append(RangeObj.IpRange)
                        control_list.append(controlObj)
                        break
                except:
                    pass
        if not device_list:
            if router_id:
                raise CafyException.InvalidValueError('%s no such device' % router_id)
            else:
                raise CafyException.InvalidValueError('No devices in configuration')
        for index in range(len(device_list)):
            try:
                twamp_peer_ip_dict[control_list[index].Name] = {}
                twamp_peer_ip_dict[control_list[index].Name]['Device IP'] = device_list[index].IpAddress
                twamp_peer_ip_dict[control_list[index].Name]['Peer IP'] = device_list[index].GatewayAddress
            except:
                pass
        return twamp_peer_ip_dict

    def get_mac_from_captured_packets(self, pcap_filename=None, pkt_mode="random", pkt_num=None,
                                      random_check_till_ip=5):
        """
        Used to fetch source and destination MAC from the captured packet file.
        :param pcap_filename: Pcap file name with location.
        :param pkt_mode: options are "random" and "fixed", default: "random" .
                         If set "random" - one randome packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,
                            if the packet is IP packet, returns source and destination MAC.
                            if the packet is ARP packet, another random packet is picked and process repeats for "random_check_till_ip" number of times.
                         If set "fixed" - packet with packet number="pkt_num" is used to fetch src and dst mac.
        :param pkt_num: packet with packet number="pkt_num" is used to fetch src and dst mac. Only when pkt_mode is "fixed"
        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.
        Example: get_mac_from_captured_packets(pcap_filename='sampledata1.pcap', pkt_mode="random", pkt_num=None, random_check_till_ip=5)
        """
        self.log.info('Getting MAC from Captured file')
        ret_mac = {}
        packets = []
        if pcap_filename:
            self.log.info(f'Fetching MAC addresses of the file {pcap_filename}')
            try:
                with open(dpkt.pcap.Reader(open(pcap_filename, 'rb'))) as pkt:
                    packets.append(pkt)
            except ValueError:
                # Load packets from the .cap file
                packets = rdpcap(pcap_filename)

            if pkt_mode.lower() == "random":
                for count in range(random_check_till_ip):
                    log.info("try: %d" % count)
                    pkt_num = random.randrange(1, len(packets))
                    try:
                        # pylint: disable=no-member
                        eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                        if isinstance(eth.data, dpkt.ip.IP):
                            ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)
                            ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)
                            break
                    except IndexError:
                        eth = packets[pkt_num]
                        if Ether in eth:
                            ret_mac['src_mac'] = eth[Ether].src
                            ret_mac['dst_mac'] = eth[Ether].dst
                            break
                else:
                    raise CafyException.TgenInvalidInputError(
                        'No IP packet found after %s tries' % random_check_till_ip)
            elif pkt_mode.lower() == "fixed":
                if pkt_num:
                    try:
                        # pylint: disable=no-member
                        eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                        if not isinstance(eth.data, dpkt.ip.IP):
                            raise CafyException.TgenInvalidInputError(f"'\'pkt_num\' {pkt_num} is not an IP packet")
                        else:
                            ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)
                            ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)
                    except IndexError:
                        eth = packets[pkt_num]
                        if Ether in eth:
                            ret_mac['src_mac'] = eth[Ether].src
                            ret_mac['dst_mac'] = eth[Ether].dst
                else:
                    raise CafyException.TgenInvalidInputError('\'pkt_num\' is must for pkt_mode = fixed')
        else:
            raise CafyException.TgenInvalidInputError('\'pcap_filename\' is a mandatory parameter.')
        return ret_mac

    def get_card_type(self, port):
        """
        To fetch card type using port name.

        :param port: Name/location of the port, whose card type is required.
        :return: Card type. Ex: "FX2-40G-Q2"

        :Example: get_card_type("7/5")
                  get_card_type("10.10.1.1/5/1")
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        port = port.split("/")
        port[0] = port[1] if len(port) > 2 else port[0]
        if self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$'):
            cardObj = self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$')
            if cardObj.Port.find(PortId='^' + port[1] + '$'):
                card_type = cardObj.Description
            else:
                self.log.error('%s not a valid port name or location' % port[1])
                card_type = None
        return card_type

    def set_invalid_mpls(self, traffic_items, cfg_dict):
        """
        API used to configure invalid mpls headers for a given list of streams
        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            All values below should be strings:
                label (label) - Label identifier to be used [0 - 1048575]
                sbit (sBit) - Last label for a given stack [0/1]
                exp (exp) - Experimental bits value [0 - 7]
                ttl (ttl) - Time to live value  [0 - 255]
                active (Active) - Sets the mpls status to active (true/false)
        :return: True on success, exception on failure
        :Example: set_invalid_mpls(['Traffic ipv4'], {'label':'111', 'sbit':'1', 'exp':7, 'ttl':84, 'active':True})
        """
        result = False
        self.log.info("Setting INVALID MPLS Headers in Traffic Item/Items")
        if type(traffic_items) is list and type(cfg_dict) is dict:
            for trafficName in traffic_items:
                try:
                    for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                        for mplsObj in configElement.Stack.find(StackTypeId='mpls'):
                            labelObj, expObj, sbitObj, ttlObj = mplsObj.Field.find(
                                Name='mpls_label_value'), mplsObj.Field.find(Name='mpls_exp'), mplsObj.Field.find(
                                Name='mpls_bos'), mplsObj.Field.find(Name='mpls_ttl')
                            labelObj.SingleValue = cfg_dict['label'] if 'label' in cfg_dict.keys() else None
                            expObj.SingleValue = cfg_dict['exp'] if 'exp' in cfg_dict.keys() else None
                            sbitObj.SingleValue = cfg_dict['sbit'] if 'sbit' in cfg_dict.keys() else None
                            ttlObj.SingleValue = cfg_dict['ttl'] if 'ttl' in cfg_dict.keys() else None
                            result = True
                except:
                    pass
        else:
            raise IxiaOperationException(
                'Given object types of traffic_items {}, cfg_dict {} is not supported. Supported object types are traffic_items should be list and cfg_dict should be dict'.format(
                    type(traffic_items), type(cfg_dict)))
        if result:
            return result
        else:
            raise IxiaConfigException('Either Streams or MPLS headers is not present')

    def set_rsvp_tunnel(self, tunnel_type, router_id=None, **kwargs):
        """
        Set RSVP tunnel attributes
        :param router_id: Router ID of the device
        :param tunnel_type: Ingress/Egress
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                tunnel_name: tunnel name from config
                source_ip_address: IP address of the RSVP PATH message sender
                source_ip_address_step: Source IP address step
                destination_ip_address: Destination IP address of the RSVP PATH message
                destination_ip_address_step: Destination IP address step
                tunnel_count: Integer/String representing the new tunnel count
                tunnel_id: tunnel identifier
                tunnel_id_step: Tunnel ID step for incrementing Tunnel ID when TunnelCount is greater than one
                lsp_count: Number of LSPs established within the tunnel. Lsp Count should be between 1 and 20
                lsp_id: LSP ID
                lsp_id_step: LSP ID step
                ERO (Explicit Route Object) Configuration:
                - enable_ero (bool): Optional. Set to True to enable ERO configuration.
                - ero_count (int): Optional. Specifies the number of ERO hops.
                 **ERO configuration will be applied only if at least one of `enable_ero=True` or `ero_count` is specified.**
                 If neither is given, ERO IPs (ero<n>_ip) will be ignored.But if the configuration already has ERO enabled,
                if its TRUE then IP's will be updated.
                - ero<n>_ip (str): IP address for the nth ERO hop (e.g., ero1_ip, ero2_ip, etc.).
                
        :return: True if successfull else raises exception
        :Example: set_rsvp_tunnel(router_id="192.0.0.1",tunnel_type="Ingress",tunnel_name="RSVP Tunnel",source_ip_address="10.10.10.1",source_ip_address_step="0.0.0.1",destination_ip_address="11.11.11.1",
                    destination_ip_address_step="0.0.0.1",tunnel_count=2,tunnel_id=11,tunnel_id_step=2,lsp_count=2,lsp_id=1,lsp_id_step=2)
                set_rsvp_tunnel(router_id="192.0.0.1",tunnel_type="Ingress",tunnel_name="RSVP1",enable_ero=True,ero_count=1,ero1_ip="192.168.1.1")
        """
        self.log.info('Setting RSVP Tunnel parameters')
        tunnelName = kwargs.get('tunnel_name')
        device_name = kwargs.get('device_name',None)
        nested_device = kwargs.get('nested_device',None)
        deviceObjDict = {}
        result = False
        if router_id:
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroupObj.RouterData.find():
                    if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceObjDict[router_id] = deviceGroupObj
                    break
        elif device_name and not nested_device:
            for device_group_obj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name):
                if device_group_obj.Ethernet.find():
                    if device_group_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        deviceObjDict[device_group_obj.Name] = device_group_obj
                elif device_group_obj.Ipv4Loopback.find():
                    if device_group_obj.Ipv4Loopback.find().RsvpteLsps.find():
                        deviceObjDict[device_group_obj.Name] = device_group_obj
        elif device_name and nested_device:
            for device_group_obj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).NetworkGroup.find().\
                    DeviceGroup.find(Name=nested_device):
                if device_group_obj.Ethernet.find():
                    if device_group_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        deviceObjDict[device_group_obj.Name] = device_group_obj
                elif device_group_obj.Ipv4Loopback.find():
                    if device_group_obj.Ipv4Loopback.find().RsvpteLsps.find():
                        deviceObjDict[device_group_obj.Name] = device_group_obj
        else:
            try:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    for ipv4Obj in deviceGroupObj.Ethernet.find().Ipv4.find():
                        if ipv4Obj.RsvpteLsps.find():
                            deviceObjDict[deviceGroupObj.Name] = deviceGroupObj
            except:
                pass
        if deviceObjDict:
            if tunnel_type.lower() == "ingress":
                for key, deviceObj in deviceObjDict.items():
                    if deviceObj.Ethernet.find():
                        for rsvp_if_Obj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():
                            rsvp_if_Obj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),
                                                    step_value=kwargs.get('destination_ip_address_step', None))
                    rsvpte_obj = []
                    if deviceObj.Ethernet.find():
                        rsvpte_obj.extend(deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find())
                    elif deviceObj.Ipv4Loopback.find():
                        rsvpte_obj.extend(deviceObj.Ipv4Loopback.find().RsvpteLsps.find())

                    for rsvp_te_obj in rsvpte_obj:
                        rsvp_te_obj.Name = tunnelName
                        if rsvp_te_obj.RsvpP2mpIngressLsps and rsvp_te_obj.RsvpP2mpEgressLsps:
                            if kwargs.get('tunnel_count'):
                                rsvp_te_obj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', 1)
                            if kwargs.get('lsp_count'):
                                rsvp_te_obj.P2mpIngressLspCount = kwargs.get('lsp_count', 1)
                            if kwargs.get('source_ip_address'):
                                rsvp_te_obj.RsvpP2mpIngressLsps.SourceIpv4.Increment(
                                    start_value=kwargs.get('source_ip_address', None),
                                    step_value=kwargs.get('source_ip_address_step', None))
                            if kwargs.get('tunnel_id') and not kwargs.get('tunnel_id_step'):
                                rsvp_te_obj.RsvpP2mpIngressLsps.TunnelId.Single(kwargs.get('tunnel_id'))
                            if kwargs.get('tunnel_id') and kwargs.get('tunnel_id_step'):
                                rsvp_te_obj.RsvpP2mpIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', 1),
                                                                            step_value=kwargs.get('tunnel_id_step', 1))
                            if kwargs.get('lsp_id') and not kwargs.get('lsp_id_step'):
                                rsvp_te_obj.RsvpP2mpIngressLsps.LspId.Single(kwargs.get('lsp_id'))
                            if kwargs.get('lsp_id') and kwargs.get('lsp_id_step'):
                                rsvp_te_obj.RsvpP2mpIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', 1),
                                                                        step_value=kwargs.get('lsp_id_step', 1))
                            if 'local_protection' in kwargs:
                                local_protection = kwargs.get('local_protection', False)
                                rsvp_te_obj.RsvpP2mpIngressLsps.LocalProtectionDesired.Single(local_protection)
                            if 'label_recording' in kwargs:
                                label_recording = kwargs.get('label_recording', False)
                                rsvp_te_obj.RsvpP2mpIngressLsps.LabelRecordingDesired.Single(label_recording)
                            if 'fast_reroute' in kwargs:
                                fast_reroute = kwargs.get('fast_reroute', False)
                                rsvp_te_obj.RsvpP2mpIngressLsps.EnableFastReroute.Single(fast_reroute)
                            # Step 1: Detect if user passed any eroX_ip / eroX_as values
                            ero_ip_keys = sorted([k for k in kwargs if k.startswith('ero') and k.endswith('_ip')])
                            ero_as_keys = sorted([k for k in kwargs if k.startswith('ero') and k.endswith('_as')])
                            ero_keys_present = bool(ero_ip_keys or ero_as_keys)

                            # Step 2: Check if ERO is enabled in loaded config
                            try:
                                ero_enabled = rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Values[0]
                            except Exception as err:
                                ero_enabled = False
                                self.log.warning(f'RSVP Ingress ERO Enable Failed with Error - {err}')

                            # Step 3: Optional override if user passed 'enable_ero'
                            if 'enable_ero' in kwargs:
                                rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Single(kwargs['enable_ero'])
                                ero_enabled = kwargs['enable_ero']  # update status based on override

                            # Step 4: Handle ERO config logic
                            if ero_keys_present:
                                if not ero_enabled:
                                    self.log.warning(
                                        f"[ERO WARNING] ERO sub-object values were provided, "
                                        f"but ERO is disabled in the loaded config for tunnel '{rsvp_te_obj.Name}'. "
                                        f"ERO configuration will be skipped."
                                    )
                                else:
                                    # Auto-calculate how many ERO sub-objects were passed
                                    ero_count_from_args = max(
                                        [int(k[3:].split('_')[0]) for k in ero_ip_keys + ero_as_keys],
                                        default=0
                                    )
                                    # Set ero_count (either from kwargs or auto)
                                    if 'ero_count' in kwargs:
                                        rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = kwargs.get('ero_count',
                                                                                                          0)
                                    else:
                                        rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = ero_count_from_args
                                # Apply ERO sub-objects
                                ero_sub_objs = rsvp_te_obj.RsvpP2PIngressLsps.RsvpEROSubObjectsList.find()
                                if not ero_sub_objs:
                                    self.log.warning(f"ERO is enabled and count is set,but no ERO sub-object exist for tunnel-'{rsvp_te_obj.Name}'")
                                else:
                                    ero_dict = {
                                        'ero' + str(index): ero_obj
                                        for index, ero_obj in enumerate(ero_sub_objs, start=1)
                                    }
                                    for ero_name, ero_object in ero_dict.items():
                                        if ero_name + '_ip' in kwargs:
                                            ero_object.Type.Single('ip')
                                            ero_object.Ip.Single(kwargs.get(ero_name + '_ip'))
                                        if ero_name + '_as' in kwargs:
                                            ero_object.Type.Single('as')
                                            ero_object.AsNumber.Single(kwargs.get(ero_name + '_as'))
                            result = True
                        if rsvp_te_obj.RsvpP2PIngressLsps and rsvp_te_obj.RsvpP2PEgressLsps:
                            if kwargs.get('lsp_count'):
                                rsvp_te_obj.IngressP2PLsps = kwargs.get('lsp_count', 1)
                            if kwargs.get('source_ip_address'):
                                rsvp_te_obj.RsvpP2PIngressLsps.SourceIp.Increment(
                                    start_value=kwargs.get('source_ip_address', None),
                                    step_value=kwargs.get('source_ip_address_step', None))
                            if kwargs.get('tunnel_id') and not kwargs.get('tunnel_id_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.TunnelId.Single(kwargs.get('tunnel_id'))
                            if kwargs.get('tunnel_id') and kwargs.get('tunnel_id_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', 1),
                                                                        step_value=kwargs.get('tunnel_id_step', 1))
                            if kwargs.get('lsp_id') and not kwargs.get('lsp_id_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.LspId.Single(kwargs.get('lsp_id'))
                            if kwargs.get('lsp_id') and kwargs.get('lsp_id_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', 1),
                                                                        step_value=kwargs.get('lsp_id_step', 1))
                            if kwargs.get('remote_ip') and not kwargs.get('remote_ip_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Single(kwargs.get('remote_ip'))
                            if kwargs.get('remote_ip') and kwargs.get('remote_ip_step'):
                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Increment(start_value=kwargs.get('remote_ip', None),
                                                                                  step_value=kwargs.get('remote_ip_step','0.0.0.1'))
                            if kwargs.get('remote_ip') and kwargs.get('remote_ip_step') and kwargs.get('remote_ip_incr_count'):
                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Custom(start_value=kwargs.get('remote_ip', None),
                                                                               step_value=kwargs.get('remote_ip_step','0.0.0.1'),
                                                                               increments=[(kwargs.get('remote_ip_step','0.0.0.1'),
                                                                                            kwargs.get('remote_ip_incr_count',1), [])])
                            if kwargs.get('tag_id_type', None) == 'singleValue':
                                rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Single(kwargs.get('tag_id_start', 1))
                            elif kwargs.get('tag_id_type', None) == 'increment':
                                rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Increment(
                                    start_value=kwargs.get('tag_id_start', 1), step_value=kwargs.get('tag_id_step', 1))
                            elif kwargs.get('tag_id_type', None) == 'custom':
                                if kwargs.get('tag_id_repeat') == 1:
                                    rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Custom(
                                        start_value=kwargs.get('tag_id_start', 1), step_value=0,
                                        increments=[(kwargs.get('tag_id_step', 1),
                                                     kwargs.get('tag_id_len', kwargs.get('lsp_count', 1)), [])])
                            if 'local_protection' in kwargs:
                                local_protection = kwargs.get('local_protection', False)
                                rsvp_te_obj.RsvpP2PIngressLsps.LocalProtectionDesired.Single(local_protection)
                            if 'label_recording' in kwargs:
                                label_recording = kwargs.get('label_recording', False)
                                rsvp_te_obj.RsvpP2PIngressLsps.LabelRecordingDesired.Single(label_recording)
                            if 'fast_reroute' in kwargs:
                                fast_reroute = kwargs.get('fast_reroute', False)
                                rsvp_te_obj.RsvpP2PIngressLsps.EnableFastReroute.Single(fast_reroute)
                            if 'enable_ero' in kwargs:
                                rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Single(kwargs.get('enable_ero'))
                            if 'ero_count' in kwargs:
                                rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = kwargs.get('ero_count', 0)
                            result = True
            elif tunnel_type.lower() == "egress":
                for key, deviceObj in deviceObjDict.items():
                    for rsvpIfObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():
                        rsvpIfObj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),
                                                step_value=kwargs.get('destination_ip_address_step', None))
                    for rsvpTeObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        rsvpTeObj.Name = tunnelName
                        if rsvpTeObj.RsvpP2mpEgressLsps:
                            rsvpTeObj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', None)
                        result = True
            else:
                raise IxiaConfigException("Passed '%s' invalid Tunnel Type" % tunnel_type)
        else:
            raise IxiaConfigException('Device with Router ID %s not available in the config' % router_id)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return result

    def config_twamp_test_session(self, router_id=None, twamp_client_handle=None, **kwargs):
        """
        Configure or Create a Test session either with TWAMP client device or its config handle
        One of the argument is mandatory
        :param router_id: TWAMP Client device's router id
        :param twamp_client_handle: TWAMP config handler in Client device
        :return: Raises exception on failure
        Example:config_twamp_test_session('IP-6', twamp_client_handle=None,
                                        TestSessionName = 'TWAMPTest-R15', ControlRangeName= 'TWAMPControl-R10',
                                        TestSessionsCount= 1, SessionSenderPort= 2000,
                                        SessionSenderPortIncrement= 1, SessionReflectorPort=4000,
                                        SessionReflectorPortIncrement= 1,
                                        NumberOfPackets=10, PacketsPerSecond=10, Timeout=30, PacketLength= 128,
                                        PaddingWithZero= False,
                                        TypepDescriptor= 0
                                        )
        """
        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',
                      'ErrorEstimateMultiplier']
        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',
                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',
                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',
                          'TypepDescriptor']

        userArg = {key.lower(): value for key, value in kwargs.items()}
        configOptions = {}
        configControl = {}
        configTestSession = {}

        for ixnArg in optionsArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configOptions[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in testSessionArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'TestSessionName'.lower():
                    configTestSession['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).Range.add().TwampTestRange.add(**configTestSession)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def set_protocol_stack_count(self, stack_count, device_name, ip_type="ipv4", **kwargs):
        """
        Modifying stack multiplier count for protocol stack.

        :param stack_count: Integer/String representing stack multiplier
        :param device_name: String devices name for whc stack multiplier need to be set
        :param ip_type: String demonstrating the IP version ipv4/ipv6
        :param kwargs:
                nested_device : if nested device, Need to pass nested_device = True
        :return: True if the operation is successful, False otherwise

        :Example: set_protocol_stack_count(stack_count=10, device_name='Device Group 1')
                  set_protocol_stack_count(stack_count=10, device_name='Device Group 1', nested_device=True)
        """
        self.log.info("Setting Stack Count for Device Group:%s" % (device_name))
        nested_device = kwargs.get('nested_device', False)
        if stack_count >= 1:
            if nested_device:
                if self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                        Name='^' + device_name + '$'):
                    if ip_type.lower() == "ipv4":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ipv4Loopback.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):
                    if ip_type.lower() == "ipv4":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
        else:
            raise CafyException.InvalidValueError('Stack count (%s) has to be greater than or equal to 1' % stack_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def _dhcp_action_control(self, router_id, command_action, type):
        """
        internal function to perform dhcpv4/v6 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4/v6 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :param type: Perform on DHCPv4 or DHCPv6 client
        :return: True on success.
        """
        if re.match(r'\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format for DHCP. Please provide Device Group Name')
        elif command_action not in ['start', 'stop', 'rebind', 'renew', 'abort', 'restartDown']:
            raise IxiaConfigException('Only the following commands "start/stop/restartDown/renew/rebind/abort" can be '' performed on DHCP client.')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                try:
                    command_action = command_action[0].capitalize() + command_action[1:]
                    dhcpv4Obj = getattr(devicegroupObj.Ethernet.find(), type).find()
                    getattr(dhcpv4Obj, command_action)()
                    result = True
                except:
                    raise IxiaConfigException('"{}" is not configured in the given device group "{}"'.format(type, router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return result

    def perform_dhcpv6_command(self, router_id, command_action):
        """
        Performs dhcpv6 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv6 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :return: True on success.

        :Example: perform_dhcpv6_command("DHCPv6 Client", "stop")
                  perform_dhcpv6_command("DHCPv6 Client", "start")
        """
        return self._dhcp_action_control(router_id, command_action, "Dhcpv6client")

    def perform_dhcpv4_command(self, router_id, command_action):
        """
        Performs dhcpv4 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :return: True on success.

        :Example: perform_dhcpv4_command("DHCPv4 Client", "stop")
                  perform_dhcpv4_command("DHCPv4 Client", "start")
        """
        return self._dhcp_action_control(router_id, command_action, "Dhcpv4client")

    def modify_isis_hello_padding(self, port_list, action='enable'):
        """
        To modify the hello padding settings of isis enabled devices.
        :param port_list: List of port names, whose isis devices needs modification.
        :param action: To enable or disable hello padding. Default: enable.
        :return True on success else raise exception.

        :Example: modify_isis_hello_padding(["Ethernet - 001"])
                  modify_isis_hello_padding(["Ethernet - 001"],'disable')
        """
        sup_dict = {'enable':True,'disable':False}
        if not isinstance(port_list, list):
            port_list = [port_list]
        portNameList = []
        for vport in self.ixNetwork.Vport.find():
            if vport.AssignedTo.replace(":", "/") in port_list or vport.Name in port_list:
                portNameList.append(vport.Name)
        for portName in portNameList:
            for topology in self.ixNetwork.Topology.find():
                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                    for device in topology.DeviceGroup.find():
                        if device.IsisL3Router.find():
                            device.IsisL3Router.find().EnableHelloPadding.Single(sup_dict[action])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def perform_pppoe_action(self, router_id, action, address_family="dual_stack"):

        """
        The API retries to connect to PPPoX sessions
        :param router_id: router id of emulated device
        :param action: action to perform options: start|stop|RestartDown|openipcp|CloseIpcp|OpenIpv6cp|CloseIpv6cp
        :param address_family: IpCp mode ipv4/ipv6/dual_stack
        :return: True on success.

        :Example: perform_pppoe_action("DG2", "start", 'dual_stack')
                 perform_pppoe_action("DG2", "stop", 'dual_stack')
        """

        result = False
        if re.match(r'\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif action.lower() not in ['start', 'stop', 'restartdown', 'connect', 'disconnect', 'retry', 'openipcp',
                                    'closeipcp', 'openipv6cp', 'closeipv6cp']:
            raise IxiaOperationException('IXIA supports only the following commands "Start|Stop|RestartDown|openipcp|'
                                         'CloseIpcp|OpenIpv6cp|CloseIpv6cp" on PPPoE client.')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                pppoxObj = devicegroupObj.Ethernet.find().Pppoxclient.find()
                if pppoxObj:
                    ncpType = pppoxObj.NcpType.Values
                    if re.fullmatch(ncpType[0], address_family, re.IGNORECASE):
                        if re.fullmatch('start|connect', action, re.IGNORECASE):
                            pppoxObj.Start()
                            result = True
                        if re.fullmatch('stop|disconnect', action, re.IGNORECASE):
                            pppoxObj.Stop()
                            result = True
                        if re.fullmatch('restartdown|retry', action, re.IGNORECASE):
                            pppoxObj.RestartDown()
                            result = True
                        if ncpType[0].lower() == 'dual_stack' and action.lower() in ['openipcp', 'closeipcp', 'openipv6cp', 'closeipv6cp']:
                            if re.fullmatch('openipcp', action, re.IGNORECASE):
                                pppoxObj.OpenIpcp()
                                result = True
                            if re.fullmatch('closeipcp', action, re.IGNORECASE):
                                pppoxObj.CloseIpcp()
                                result = True
                            if re.fullmatch('openipv6cp', action, re.IGNORECASE):
                                pppoxObj.OpenIpv6cp()
                                result = True
                            if re.fullmatch('closeipv6cp', action, re.IGNORECASE):
                                pppoxObj.CloseIpv6cp()
                                result = True
                    else:
                        raise IxiaConfigException('PPPoE client is configured with "{}" NCP Type. Please change '
                                                  'address_family value and call the API'.format(ncpType[0]))
                else:
                    raise IxiaConfigException('PppoxClient is not configured in the given device group "{}"'.format(router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return result

    def generate_license_details(self, chassis_ip, username='admin', password='admin', license_feature=None):
        """
        API used to retrieve license details based on Ixia chassis
        """
        USERNAME_PASSWORD = {'username': username, 'password': password}
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        JSON_USERNAME_PASS = json.dumps(USERNAME_PASSWORD)
        auth_key_call = f"https://{chassis_ip}/api/v1/auth/session"

        try:
            api_response = requests.post(auth_key_call, data=JSON_USERNAME_PASS,
                                         headers={'content-type': "application/json"}, verify=False, timeout=10)
            api_response.raise_for_status()
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Authentication failed: {err}")
            return None

        api_json = api_response.json()
        api_key = api_json.get("apiKey")
        if not api_key:
            self.log.error(f"[{chassis_ip}] No API key returned during authentication.")
            return None

        HEADERS = {
            'x-api-key': api_key,
            'content-type': "application/json"
        }

        for server_type in ['platform', 'ixnetworkweb']:
            license_server_url = f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/"
            try:
                license_server_response = requests.get(license_server_url, headers=HEADERS, verify=False, timeout=10)
                if license_server_response.status_code == 200:
                    break
            except Exception as err:
                self.log.debug(f"{chassis_ip}] Failed to connect to {license_server_url}: {err}")
                continue
        else:
            self.log.error(f"[{chassis_ip}] License Fetch failed for chassis/server.")
            return None

        try:
            server_id = license_server_response.json()[0]['id']
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Could not extract server ID: {err}")
            return None

        license_retrieval_url = f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/operations/retrievecountedfeaturestats"

        try:
            license_retrieval_response = requests.post(license_retrieval_url, headers=HEADERS, verify=False, timeout=10)
            license_retrieval_response.raise_for_status()
            id_json = license_retrieval_response.json()
            license_id = id_json.get("id")
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Failed to start license retrieval: {err}")
            return None

        if not license_id:
            self.log.error(f"[{chassis_ip}] No async operation ID received.")
            return None

        license_list_url = (
            f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/"
            f"operations/retrievecountedfeaturestats/{license_id}/result"
        )

        max_retries = 30
        wait_time = 1
        for attempt in range(max_retries):
            try:
                license_list_response = requests.get(license_list_url, headers=HEADERS, verify=False, timeout=10)
                status = license_list_response.status_code
                data = license_list_response.json()

                if status == 200 and isinstance(data, list):
                    break
                if isinstance(data, dict) and "no async operation" in str(data).lower():
                    time.sleep(wait_time)
                    wait_time = min(wait_time * 2, 5)
                    continue
                if status != 200 or "error" in str(data).lower():
                    time.sleep(wait_time)
                    continue

            except Exception as err:
                self.log.debug(f"[{chassis_ip}] Attempt {attempt + 1}/{max_retries} failed: {err}")
                time.sleep(wait_time)
                continue
        else:
            self.log.error(f"[{chassis_ip}] Timed out waiting for license result after {max_retries} retries.")
            return None

        license_data = license_list_response.json()
        if not isinstance(license_data, list):
            self.log.error(f"[{chassis_ip}] Unexpected license data format: {license_data}")
            return None

        if license_feature:
            for lic in license_data:
                if license_feature in lic.values():
                    self.log.info(f"Showing license count for {chassis_ip} and featureName {license_feature}.\n {lic}")
                    return lic
            self.log.warning(f"License Feature Name given: '{license_feature}' not available on {chassis_ip}.")
            return False

        self.log.info(f"Showing license count for {chassis_ip}.\n {json.dumps(license_data, indent=2)}")
        return license_data

    def set_filtered_stream_results(self, port, protocol):
        """
        This api created custom traffic view stats named "ECN" to capture eggress tracking of active traffic items
        :param port: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"
        :param protocol: ipv4 or ipv6, based on which filter to apply is selected

        Example: set_filtered_stream_results(port="10.10.10.1/1/5",protocol = 'ipv4')
                 set_filtered_stream_results(port="10.10.10.1/1/6",protocol = 'ipv6')
        """
        streamList = self.get_active_streams()
        trafficList = list()
        for stream in streamList:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream + '$').ConfigElement.find():
                if protocol.lower() == "ipv4":
                    if configElement.Stack.find(DisplayName="IPv4"):
                        trafficList.append(stream)
                else:
                    if configElement.Stack.find(DisplayName="IPv6"):
                        trafficList.append(stream)

        self.disable_traffic_item()
        self.enable_traffic_item(trafficList)

        if self.ixNetwork.Traffic.State in ['stopped','stoppedWaitingForStats','unapplied']:
            self.regenerate_traffic()
            self._apply_traffic()

        if self.ixNetwork.Statistics.View.find(Caption="ECN"):
            self.ixNetwork.Statistics.View.find(Caption="ECN").remove()
        self.ixNetwork.Statistics.View.add(Caption="ECN", Type='layer23TrafficFlow', Visible=True, TreeViewNodeName="Views\\Custom Views")
        afil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailableTrafficItemFilter.find()
        fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Layer23TrafficFlowFilter.find()
        port_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailablePortFilter.find()
        fil.update(AggregatedAcrossPorts=False, EgressLatencyBinDisplayOption="showEgressRows", PortFilterIds=port_fil,
                   TrafficItemFilterIds=afil)
        traffic_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Layer23TrafficFlowFilter.find()
        tracking_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailableTrackingFilter.find()
        tracking_fil_list = list()
        for i in range(0,2):
            tracking_fil_list.append(tracking_fil[i].href)
        enum = traffic_fil.EnumerationFilter
        for elem in tracking_fil_list:
            enum.add(SortDirection=None, TrackingFilterId=elem)
        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Statistic.find():
            stats.Enabled = True
        self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Enabled = True

    def disable_filter_stream(self, port):
        """
        This api removes the custom traffic view stats named "ECN"
        :param port: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"

        Example: disable_filter_stream(port="10.10.10.1/1/5")
                 disable_filter_stream(port="10.10.10.1/1/6")
        """
        self.log.info(" Disabling tracking on traffic items ")
        if self.ixNetwork.Statistics.View.find(Caption="ECN"):
            self.ixNetwork.Statistics.View.find(Caption="ECN").remove()

    def get_filtered_stream_results(self, port_number):
        """
        Returns the traffic stats from custom traffic stats view named "ECN" which has egress tracking and traffic class tracking
        :param port_number: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"
        :return: Dictionary of filtered stream data

        Example: get_filtered_stream_results(port_number="10.10.10.1/1/5")
                get_filtered_stream_results(port_number="10.10.10.1/1/5")
        """
        streamList = self.get_active_streams()
        rxPort = self.get_port_name_from_location(port_number)
        filteredResult = {}
        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
        flowHeadersList = flowStats.ColumnHeaders
        flowStatHeaderValues = []

        customStats = StatViewAssistant(self.ixNetwork, 'ECN', LocalCsvStorage=CafyLog.work_dir)
        customHeadersList = customStats.ColumnHeaders
        customStatHeaderValues = []

        # flowstats
        for rowNumber, stat in enumerate(flowStats.Rows):
            headerDict = {}
            for column in flowHeadersList:
                headerDict[column] = stat[column]
            flowStatHeaderValues.append(headerDict)

        #customstats
        for rowNumber, stat in enumerate(customStats.Rows):
            headerDict = {}
            for column in customHeadersList:
                headerDict[column] = stat[column]
            customStatHeaderValues.append(headerDict)

        # list to remove excess keys as per customer request
        rem_list = ['First TimeStamp', 'Frames Delta', 'Last TimeStamp','Loss %','Packet Loss Duration (ms)','Rx Bytes','Rx Frame Rate','Rx Rate (Kbps)','Rx Rate (Mbps)',
                    'Rx Rate (Bps)','Tx Frame Rate','Tx Frames','Tx L1 Rate (bps)','Tx Rate (Bps)','Tx Rate (Kbps)','Tx Rate (Mbps)']
        # appending mandatory keys into 2nd and 3rd row of flow stats
        add_list = ['IPv4 :Class selector PHB','IPv6 :Traffic Class','Traffic Item','Tx Port','Tx Rate (bps)','Rx Port']

        # ECN bit from custom stats into ECN_dict
        ECN_dict = dict()
        for item in streamList:
            for i in range(len(customStatHeaderValues) - 1):
                if customStatHeaderValues[i]['Traffic Item'] == item:
                    [customStatHeaderValues[i].pop(k) for k in rem_list if k in customStatHeaderValues[i].keys()]
                    ECN_dict.setdefault(item, []).append(customStatHeaderValues[i])
                    if (len(customStatHeaderValues)//len(streamList) )== 3:
                        if customStatHeaderValues[i + 2]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 2].pop(k) for k in rem_list if k in customStatHeaderValues[i + 2].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 2])
                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])
                    if (len(customStatHeaderValues)//len(streamList) )== 2:
                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])

        # filteredResult dict adding traffic item with flow statistics flow
        if streamList:
            for trafficItemName in streamList:
                for trafficItemDict in flowStatHeaderValues:
                    [trafficItemDict.pop(k) for k in rem_list if k in trafficItemDict.keys()]
                    for key, value in trafficItemDict.items():
                        if value == trafficItemName and trafficItemDict['Rx Port'] == rxPort:
                            filteredResult.setdefault(trafficItemName, []).append(trafficItemDict)

        # using add_list adding mandatory keys from 1st flow into 2nd n 3rd flow
        for trafficName, flow in ECN_dict.items():
            for key, value in filteredResult.items():
                if key == trafficName:
                    for (eachflow, eachvalue) in zip(flow, value):
                        value[0]['Egress Tracking'] = eachflow['Egress Tracking']
                    for count in range(1, len(flow)):
                        filteredResult[trafficName].append(flow[count])
                        for k in add_list:
                            try:
                                flow[count][k] = value[0][k]
                            except:
                                pass

        for key, value in filteredResult.items():
            #remove 1st dict as its not required wrt spirent
            value.pop(0)
            for flow in value:
                for field in list(flow):
                    if field == 'IPv6 :Traffic Class':
                        try:
                            flow['Traffic Class (int)'] = flow['Egress Tracking']
                        except:pass
                        del flow['IPv6 :Traffic Class']

                    if field == 'IPv4 :Class selector PHB':
                        flow['DSCP (int)'] = flow['IPv4 :Class selector PHB']
                        del flow['IPv4 :Class selector PHB']

                    if field == 'Egress Tracking':
                        try:
                            flow['ECN (bits)'] = bin(int(flow['Egress Tracking'], 16))[2:]
                        except:
                            flow['ECN (bits)'] = flow['Egress Tracking']
                        del flow['Egress Tracking']

                    if field == 'Rx L1 Rate (bps)':
                        flow['Rx L1 Rate'] = int(float(flow['Rx L1 Rate (bps)']))
                        del flow['Rx L1 Rate (bps)']
                    if field == 'Rx Frames':
                        flow['Rx Count'] = flow['Rx Frames']
                        del flow['Rx Frames']
                try:
                    if flow['ECN (bits)'] == '0':
                        flow.update({'ECN': 'Non-ECT'})
                    elif flow['ECN (bits)'] == '1':
                        flow.update({'ECN': 'ECT(1)'})
                    elif flow['ECN (bits)'] == '10':
                        flow.update({'ECN': 'ECT(0)'})
                    elif flow['ECN (bits)'] == '11':
                        flow.update({'ECN': 'CE'})
                except:pass

        for key, value in filteredResult.items():
            filteredResult[key] = [ele for ele in ({key: val for key, val in sub.items() if val != ''} for sub in value) if ele]
        return filteredResult

    def add_network_group(self, device_name, protocol, **kwargs):
        """
        API to add Network group for ISIS,OSPF and BGP protocols , Supports both ipv4 and ipv6 network groups

        :param device_name: Name of the Device group on which the network routes to be added
        :param protocol: protocol on which the network routes to be added. Ex: protocol='isis' or 'bgp' or 'ospf'
        :param kwargs:
                network_address_step: Network prefix step value
                network_address_incr_step: Network IP address increment step Ex  Integer value for step value
                network_group_multiplier: Network group multiplier Ex 1 or 2
                v4_network_address_start: Ipv4 network address start value Ex '2.2.2.2'/['2.2.2.2']
                v4_network_address_incr_step: ipv4 network address increment step Ex: '0.0.0.1'
                v4_network_address_prefix_list: ipv4 network address prefix length Ex : [24, 32]
                network_address_type: Network address type it can be List/Increment
                network_group_name : Str Network group name
                ip_type: String demonstrating the IP version
                route_type: String demonstrating the Network Group version type
        return True on success or raise exception

        Examples:
            1.tgnObj.add_network_group(device_name='Device1', protocol='ospf')

            2.tgnObj.add_network_group(device_name='Device_isis', number_of_address = [10,20],protocol='isis',
            network_group_multiplier= 2, prefix_type ='list',v4_network_address_start=['2.2.2.2', '3.3.3.3'],
            v4_network_address_prefix_list=[32, 24],v4_network_address_incr_step='0.0.0.2',
            network_address_step=[20, 30], network_address_type='list')
        """
        v4_network_address_incr_step = kwargs.get('v4_network_address_incr_step', '0.0.0.1')
        v4_network_address_start = kwargs.get('v4_network_address_start', None)
        v4_network_address_prefix_list = kwargs.get('v4_network_address_prefix_list', None)
        v6_network_address_start = kwargs.get('v6_network_address_start', None)
        v6_network_address_prefix_list = kwargs.get('v6_network_address_prefix_list', None)
        v6_network_address_incr_step = kwargs.get('v6_network_address_incr_step', '0:0:1::')
        network_group_name = kwargs.get('network_group_name', None)
        network_group_multiplier = kwargs.get('network_group_multiplier', 1)
        prefix_type = kwargs.get('prefix_type', 'SingleValue')
        number_of_address = kwargs.get('number_of_address', [1])
        network_address_step = kwargs.get('network_address_step', [1])
        ip_type = kwargs.get('ip_type', 'ipv4')
        if ip_type.lower() == "ipv4":
            route_type = kwargs.get('route_type', 'ipv4')
        if ip_type.lower() == "ipv6":
            route_type = kwargs.get('route_type', 'ipv6')

        if kwargs.get('v6_network_address_start', None):
            if type(kwargs['v6_network_address_start']) == str:
                network_address_type = kwargs.get('network_address_type', 'increment')
            elif type(kwargs['v6_network_address_start']) == list:
                network_address_type = kwargs.get('network_address_type', 'list')
        if kwargs.get('v4_network_address_start', None):
            if type(kwargs['v4_network_address_start']) == str:
                network_address_type = kwargs.get('network_address_type', 'increment')
            elif type(kwargs['v4_network_address_start']) == list:
                network_address_type = kwargs.get('network_address_type', 'list')
        if kwargs.get('v4_network_address_start') == None and kwargs.get('v6_network_address_start') == None:
            network_address_type = kwargs.get('network_address_type', 'increment')

        protocolStatus = False
        try:
            networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').NetworkGroup.add(Multiplier=network_group_multiplier,
                                                            Name=network_group_name)
        except:
            raise IxiaConfigException("'%s' Device group not found to add Network Group" % device_name)

        # The protocol to which network group need to be connected
        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        if protocol.lower() == 'isis':
            protocolObj = deviceObj.Ethernet.find().IsisL3.find()
        elif protocol.lower() == 'ospf' and ip_type.lower() == 'ipv4':
            protocolObj = deviceObj.Ethernet.find().Ipv4.find().Ospfv2.find()
        elif protocol.lower() == 'bgp' and ip_type.lower() == 'ipv4':
            protocolObj = deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()

        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        if protocol.lower() == 'ospf' and ip_type.lower() == 'ipv6':
            protocolObj = deviceObj.Ethernet.find().Ipv6.find().Ospfv3.find()
        if protocol.lower() == 'bgp' and ip_type.lower() == 'ipv6':
            protocolObj = deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()

        if route_type.lower() == "ipv4":
            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(
                Name=networkGroupObj.Name).Ipv4PrefixPools.add()
        if route_type.lower() == "ipv6":
            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(
                Name=networkGroupObj.Name).Ipv6PrefixPools.add()
        ipPool.Connector.find().ConnectedTo = protocolObj.href

        # Verifying is protocol is present in the given device group
        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').NetworkGroup.find(
            Name=networkGroupObj.Name):

            if route_type.lower() == "ipv4":
                ipPoolObj = networkObj.Ipv4PrefixPools.find()
            if route_type.lower() == "ipv6":
                ipPoolObj = networkObj.Ipv6PrefixPools.find()

            if protocol.lower() == 'isis':
                if ipPoolObj.IsisL3RouteProperty.find():
                    protocolStatus = True
            if protocol.lower() == 'ospf':
                if route_type.lower() == "ipv4":
                    if ipPoolObj.OspfRouteProperty.find():
                        protocolStatus = True
                if route_type.lower() == "ipv6":
                    if ipPoolObj.Ospfv3RouteProperty.find():
                        protocolStatus = True
            if protocol.lower() == 'bgp':
                if ipPoolObj.BgpIPRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpV6IPRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpL3VpnRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpV6L3VpnRouteProperty.find():
                    protocolStatus = True

        # only if protocol is found go ahead and set the passed args
        if protocolStatus:
            if network_address_type.lower() == 'increment':
                if route_type.lower() == "ipv4":
                    ipPoolObj.NetworkAddress.Increment(start_value=v4_network_address_start,
                                                    step_value=v4_network_address_incr_step)
                if route_type.lower() == "ipv6":
                    ipPoolObj.NetworkAddress.Increment(start_value=v6_network_address_start,
                                                    step_value=v6_network_address_incr_step)
            if network_address_type.lower() == 'list':
                if route_type.lower() == "ipv4":
                    ipPoolObj.NetworkAddress.ValueList(v4_network_address_start)
                if route_type.lower() == "ipv6":
                    ipPoolObj.NetworkAddress.ValueList(v6_network_address_start)
            if prefix_type.lower() == 'list':
                if route_type.lower() == "ipv4":
                    ipPoolObj.PrefixLength.ValueList(v4_network_address_prefix_list)
                if route_type.lower() == "ipv6":
                    ipPoolObj.PrefixLength.ValueList(v6_network_address_prefix_list)
            elif prefix_type.lower() == 'increment':
                if route_type.lower() == "ipv4":
                    ipPoolObj.PrefixLength.Increment(start_value=v4_network_address_prefix_list,step_value=1)
                if route_type.lower() == "ipv6":
                    ipPoolObj.PrefixLength.Increment(start_value=v6_network_address_prefix_list,step_value=1)
            else:
                if route_type.lower() == "ipv4":
                    ipPoolObj.PrefixLength.Single(v4_network_address_prefix_list)
                if route_type.lower() == "ipv6":
                    ipPoolObj.PrefixLength.Single(v6_network_address_prefix_list)

            if number_of_address is not None:
                if isinstance(number_of_address, (int, str)):
                    ipPoolObj.NumberOfAddressesAsy.Single(number_of_address)
                else:
                    ipPoolObj.NumberOfAddressesAsy.ValueList(number_of_address)

            if network_address_step is not None:
                if isinstance(network_address_step, (int, str)):
                    ipPoolObj.PrefixAddrStep.Single(network_address_step)
                else:
                    ipPoolObj.PrefixAddrStep.ValueList(network_address_step)
        else:
            pass

        self.log.info("Network Group added Successfully")
        return True

    def change_port_transmit_mode(self, port=None, transmit_mode='interleaved'):
        """
        API to change the port transmit mode
        :param port: name of the port on which transmit mode to be changed.
                    Ex: port = '1/1' or port = ['10.10.1.1/1/2']
        :param transmit_mode: supported mode values - 'interleaved' , 'sequential'
        return: True on successful

        Example: tgnObj.change_port_transmit_mode(transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port=['1/1'], transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port='10.36.75.242/2/5', transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port=['10.36.75.242/2/6'], transmit_mode='interleaved')
        """
        self.log.info('Changing the Port Transmit Mode')
        if port:
            if type(port) is str:
                port = port.split(",")
            portList = []
            for vport in self.ixNetwork.Vport.find():
                if vport.AssignedTo.replace(":", "/") in port or vport.Name in port:
                    portList.append(vport)
        else:
            portList = self.get_list_ports()
        for eachPort in portList:
            eachPort.TxMode = transmit_mode
        return True

    def set_advance_sequencing(self, enable=True):
        """
        Set or unset the Advance Sequencing to allow determination of re-order packets
        :param enable: boolean, true to enable. false if you want to disable feature
        :return: True if the operation is successful , False Otherwise
        """
        try:
            self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled = enable
        except:
            raise IxiaConfigException("Unable to change Advance Sequence Checking")
        return True

    def verify_inorder_reorder_traffic(self):
        """
        Verify no reordered packets on any traffic streams

        :return: Print out table showing in-order packets and re-ordered packets with Status
        """
        if not self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled:
            raise IxiaConfigException("Advance Sequence Checking is not enabled")
        else:
            try:
                stats = self.get_stats(view_name='Traffic Item Statistics')

            except:
                raise IxiaConfigException("Unable to get Traffic Item Statistics")
            headers = ["Traffic Item", "In Order Frames", "Reordered Frames", "Status"]
            data = []
            item_headers = headers.copy()
            stats_headers = set()
            for one_obj in stats.values():
                for head in one_obj.keys():
                    stats_headers.add(head)
            Inorder_flag = False
            TX_Frames_flag = False
            ReOrder_flag = False
            for one_obj in stats.values():
                for key, value in list(one_obj.items()):
                    if key == "Reordered Frames" and int(value) > 0 :
                        one_obj.update({'Status': 'Fail'})
                        ReOrder_flag = True
                        break
                    elif key == "Reordered Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Pass'})
                    if key =="Tx Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Fail'})
                        TX_Frames_flag = True
                        break
                    elif key =="In Order Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Fail'})
                        Inorder_flag = True
                        break
            for one_obj in stats.values():
                one_data = []
                for _head in item_headers:
                    if _head in one_obj.keys():
                        one_data.append(one_obj[_head])
                    else:
                        one_data.append('N/A')
                data.append(one_data)
            stats_tb = tabulate.tabulate(data,
                                         headers=item_headers,
                                         tablefmt='rst')

            self.log.info('Traffic Item:\n' + stats_tb)
            if TX_Frames_flag:
                raise IxiaConfigException("Tx Frames count is 0")
            elif Inorder_flag :
                raise IxiaConfigException("In-Order Frames count is 0")
            elif ReOrder_flag:
                raise IxiaConfigException("Re-Order Frames count is greater than 0")
            return stats_tb

    def _set_ldp_network_group_options(self, poolHandle, routeCount, prefixIp=None, prefixlen=None, routerID=None):
        """
        Set Route count and prefix based on Protocol handle.
        :param poolHandle: PrefixPool Handle
        :param routeCount: RouteCount to be updated
        :param prefixIp: prefixIp as reference
        :param prefixlen: prefixlen as reference
        :param routerID: routerID as reference
        :return:
        """
        if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:
            if prefixIp and routerID:
                if prefixIp in poolHandle.NetworkAddress.Values:
                    ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)
                    valueList = poolHandle.NumberOfAddressesAsy.Values
                    valueList[ipPrefixIndex] = routeCount
                    poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)
                    if prefixlen:
                        valueList = poolHandle.PrefixLength.Values
                        valueList[ipPrefixIndex] = prefixlen
                        poolHandle.PrefixLength.ValueList(values=valueList)
            elif routerID and prefixIp is None:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if routerID in deviceGroupObj.RouterData.find().RouterId.Values:
                            routerIDIndex = (deviceGroupObj.RouterData.find().RouterId.Values).index(routerID)
                            valueList = poolHandle.NumberOfAddressesAsy.Values
                            valueList[routerIDIndex] = routeCount
                            poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)
                            if prefixlen:
                                valueList = poolHandle.PrefixLength.Values
                                valueList[routerIDIndex] = prefixlen
                                poolHandle.PrefixLength.ValueList(values=valueList)
            else:
                poolHandle.NumberOfAddressesAsy.Single(routeCount)
                if prefixlen:
                    poolHandle.PrefixLength.Single(prefixlen)
        # This block for 8.50 version
        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
            poolHandle.NumberOfAddresses = routeCount
            if prefixlen:
                poolHandle.PrefixLength.Single(prefixlen)

    def _modify_ldp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix,
                                router_id, **kwargs):
        """
        Internal API to support setting route count and prefix length of BGP network group

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param prefix: prefix
        :param router_id: router ID
        :return: result
        """
        protocolStatus = False
        deviceGroupName = None
        nested_network_group = kwargs.get('nested_network_group')
        networkGroupNameList = []
        for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
            if deviceGroupObj.RouterData.find():
                for routerId in router_id:
                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceGroupName = deviceGroupObj.Name
                        break
        try:
            if deviceGroupName:
                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + deviceGroupName + '$').NetworkGroup.find():
                    if network_group:
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                            break
                    else:
                        networkGroupNameList.append(networkGroup.Name)
        except:
            pass
        if network_group:
            try:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if nested_network_group and network_group:
            try:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if networkGroupNameList:
            for networkGroupName in networkGroupNameList:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + networkGroupName + '$')
                if nested_network_group:
                    try:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                    except:
                        pass
                if ip_type.lower() == "ipv4":
                    for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                        if networkGroupObj.LdpFECProperty.find():
                            protocolStatus = True
                            networkObj.Enabled.Single(True)
                            for routerId in router_id:
                                self._set_ldp_network_group_options(networkGroupObj, route_count,
                                                                    prefixIp=start_ip_prefix,
                                                                    prefixlen=prefix, routerID=routerId)
                if ip_type.lower() == "ipv6":
                    for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                        if networkGroupObj.LdpIpv6FECProperty.find():
                            networkObj.Enabled.Single(True)
                            protocolStatus = True
                            for routerId in router_id:
                                self._set_ldp_network_group_options(networkGroupObj, route_count,
                                                                    prefixIp=start_ip_prefix,
                                                                    prefixlen=prefix, routerID=routerId)
        else:
            raise IxiaConfigException("Router Id or network_group not found ")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("LDP protocol not configured or Configuration issue.")

    def set_ldp_route_count(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                router_id: Router ID of the device
                route_block_name: route block name from config
                start_ip: represents the first IP of the route block
                prefix: Integer/String representing the new prefix
                nested_network_group : if nested network group, Need to pass nested_network_group = True
                                if nested_network_group is True 'route_block_name' is mandatory
        :return: True if the operation is successful, False otherwise

        :Example: set_ldp_route_count(route_count=10, ports=["Ethernet - 001"], network_group="Network Group 9")
        """
        network_group = kwargs.get('route_block_name')
        if 'network_group' in kwargs:
            network_group = kwargs.get('network_group')
        self.log.info("Setting Ldp Route Count for route_block_name:%s" % (network_group))
        startIp = kwargs.get('start_ip')
        prefixLength = kwargs.get('prefix')
        routerId = kwargs.get('router_id')
        if not isinstance(routerId, list):
            routerId = [routerId]
        nestedGroup = kwargs.get('nested_network_group', False)
        if not network_group and routerId is None:
            raise IxiaConfigException('Please pass either Network group/Router Id')
        return self._modify_ldp_route_count(network_group, route_count, ip_type, start_ip_prefix=startIp,
                                            prefix=prefixLength, router_id=routerId,
                                            nested_network_group=nestedGroup)

    def modify_vlan(self, device_name, port_list=None, vlan_id=1, **kwargs):
        """
        Modifies device VLAN id and enable/disable vlan based on Device name or port name
        :param device_name: device group name to set vlan id
        :param port_list: list of port names - Ex: ['R1_T1_1']
        :param vlan_id: VLAN ID to be set. Default value is 1
        :param kwargs:
                vlan_number: vlan ID need to be modified
                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111
                vlan_count : vlan number which need to be changes, defalut is 1
                            Ex : vlan_count = 1, vlan ID 1 will be changed
                                 vlan_count = 2, vlan ID 2 will be changed
                vlan_step : Step to increment vlan_id, default 1
                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'
                enable_vlan : enable/disable vlan based on device_name
                              Ex : enable_vlan = True, vlan is enabled on device_name
                                   enable_vlan = False, vlan is disabled on device_name
        :return: None
        :Example: modify_vlan(device_name='V4_V6_SSM',port_list=['PortConfig1/2/3 TenGigE0/0/0/2_R1'],enable_vlan=True)
                  modify_vlan(device_name='V4_V6_SM',port_list='PortConfig1/2/1 TenGigE0/0/0/0_R1', enable_vlan=True)
        """
        self.log.info("Modifying vlan id based on device group name / port name")
        ethObj = None
        try:
            ethObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        except:
            raise IxiaOperationException("Device Group not Found in the Ixia Configuration")

        port_index_list = []
        if port_list:
            if type(port_list) == list:
                for port in port_list:
                    for topology in self.ixNetwork.Topology.find():
                        if self.ixNetwork.Vport.find(Name=port).href in topology.Vports:
                            topologyObj = topology.href
                            port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port).href))
                            for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():
                                if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                    ethObj = ethernet
            elif type(port_list) == str:
                for topology in self.ixNetwork.Topology.find():
                    if self.ixNetwork.Vport.find(Name=port_list).href in topology.Vports:
                        topologyObj = topology.href
                        port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port_list).href))

                        for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():
                            if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                ethObj = ethernet

        vlan_count = kwargs.get('vlan_count', 1)
        vlan_number = kwargs.get('vlan_number', None)
        if vlan_count:
            vlanObj = ethObj.Vlan.find()[vlan_count - 1]
        else:
            vlanObj = ethObj.Vlan.find()[0]
        vlanList = vlanObj.VlanId.Values
        enableList = ethObj.EnableVlans.Values
        if 'enable_vlan' in kwargs:
            if 'device_id' in kwargs:
                enableList[kwargs['device_id'] - 1] = kwargs['enable_vlan']
                ethObj.EnableVlans.ValueList(enableList)
            elif 'vlan_number' in kwargs:
                vlan_index = vlanList.index(str(kwargs['vlan_number']))
                enableList[vlan_index] = kwargs['enable_vlan']
                ethObj.EnableVlans.ValueList(enableList)
            else:
                for port_index in port_index_list:
                    if deviceObj.Multiplier > 1:
                        count = 0
                        if port_index == 0:
                            count = port_index
                            while count < deviceObj.Multiplier:
                                enableList[count] = kwargs['enable_vlan']
                                count += 1
                            ethObj.EnableVlans.ValueList(enableList)
                        else:
                            index = port_index * deviceObj.Multiplier
                            while (index < deviceObj.Multiplier * (port_index + 1)):
                                enableList[index] = kwargs['enable_vlan']
                                index += 1
                            ethObj.EnableVlans.ValueList(enableList)
                    else:
                        enableList[port_index] = kwargs['enable_vlan']
                        ethObj.EnableVlans.ValueList(enableList)
        else:
            enable_vlan = kwargs.get('enable_vlan', None)
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)
            except:
                pass

        if 'vlan_number' in kwargs or 'device_id' in kwargs:
            if 'vlan_number' in kwargs:
                vlan_index = vlanList.index(str(vlan_number))
                vlanList[vlan_index] = str(vlan_id)
                vlanObj.VlanId.ValueList(vlanList)
            elif 'device_id' in kwargs:
                vlan_index = kwargs['device_id'] - 1
                vlanList[vlan_index] = str(vlan_id)
                vlanObj.VlanId.ValueList(vlanList)
        else:
            vlan_direction = kwargs.get('vlan_direction', 'increment')
            if vlan_direction.lower() == 'decrement':
                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def load_bgp_routes(self, file_name, network_group, overwrite=True):
        """
        Adding start address and prefix from given CSV file into the BGP network group
        :param file_name: csvFile with contains start address and prefix
        :param network_group: Network group name to which route and prefix need to be added
        :param overwrite: boolean flag, to overwrite or to concat to existing address pools, default value is True
        :return: returns True on success
        Example: load_bgp_routes(file_name = "ipv4_routes.csv",network_group = "Network Group BGP")
                load_bgp_routes(file_name = "ipv6_routes.csv",network_group = "Network Group BGP", overwrite=False)
        """
        log.info("Adding Route Prefix to %s",network_group)
        routeEntries = 0
        originValuesDict = {"igp":"i", "egp":"e"}

        networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                    Name='^' + network_group + '$')
        try:
            poolObj =  networkGroupObj.Ipv4PrefixPools.find()
            if poolObj.BgpIPRouteProperty.find():
                bgpRouteObj = poolObj.BgpIPRouteProperty.find()
            if poolObj.BgpV6IPRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()
            if poolObj.BgpL3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()
            if poolObj.BgpV6L3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()
            ip_type = "ipv4"
        except Exception as e:
            poolObj =  networkGroupObj.Ipv6PrefixPools.find()
            if poolObj.BgpIPRouteProperty.find():
                bgpRouteObj = poolObj.BgpIPRouteProperty.find()
            if poolObj.BgpV6IPRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()
            if poolObj.BgpL3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()
            if poolObj.BgpV6L3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()
            ip_type = "ipv6"

        networkPrefixValues = poolObj.PrefixLength.Values
        networkAddrValues = poolObj.NetworkAddress.Values
        aspath = bgpRouteObj.AsPathASString
        Med = bgpRouteObj.MultiExitDiscriminator.Values
        LocalPref = bgpRouteObj.LocalPreference.Values
        weight = bgpRouteObj.Weight.Values
        origin = bgpRouteObj.Origin.Values

        outputfile = CafyLog.work_dir + '/' + "output.csv"
        existingDetails = []

        if overwrite == False:
            routeEntries += bgpRouteObj.Count
            for addr, prefix, asstr, med, pref, weight, org in zip(networkAddrValues, networkPrefixValues, aspath, Med, LocalPref, weight, origin):
                entry = []
                entry.append(originValuesDict[org]) #first cell
                entry.append(addr +'/' + prefix) #add/prefix
                if ip_type == "ipv4":
                    entry.append("0.0.0.0") #next hop
                else:
                    entry.append("1.1.1.1")

                entry.append(med) #med
                entry.append(pref) #local  pref
                entry.append(weight) #wegith
                entry.append(asstr) #as path
                entry.append(originValuesDict[org])
                existingDetails.append(entry)

        with open(file_name, 'r') as csvinput:
            with open(outputfile, 'w') as csvoutput:
                writer = csv.writer(csvoutput, lineterminator='\n')
                reader = csv.reader(csvinput)
                row = next(reader)
                for row in reader:
                    rowEntry = []
                    rowEntry.append("i") # firs cell
                    rowEntry.append(row[0] + '/' + row[1]) #address/prefix
                    if len(row) <= 2:
                        if ip_type == "ipv4":
                            rowEntry.append("0.0.0.0") #next hop
                        else:
                            rowEntry.append("1.1.1.1")
                        rowEntry.extend(["0", "0", "0", "{1}"])
                    else:
                        try:
                            rowEntry.append(row[2]) # next hop
                            rowEntry.append(row[3]) #med
                            rowEntry.append(row[4]) #local pref
                            rowEntry.append(row[5]) #wegith
                            rowEntry.append(row[6]) #as path
                        except Exception as e:
                            pass
                    rowEntry.append("i") #as path
                    routeEntries +=1
                    existingDetails.extend([rowEntry])
                writer.writerows(existingDetails)

        try:
            # To mitigate UDF error repeating the last route entry
            prime_check = False
            if routeEntries > 1000000:
                for i in range(2, int(routeEntries ** 0.5) + 1):
                    if routeEntries % i == 0:
                        break
                else:
                    prime_check = True

            if prime_check and routeEntries > 1000000 or routeEntries == 1399997:
                routeEntries += 1
                with open(outputfile, 'a', newline='') as output:
                    writer_object = csv.writer(output)
                    writer_object.writerows([existingDetails[-1]])

            bgpRouteObj.ImportBgpRoutes(Arg2='roundRobin', Arg3=True, Arg4='overwriteTestersAddress',
                                                Arg5='csv',Arg6=(Files(outputfile, local_file=True)),Arg7=routeEntries)
            networkGroupObj.Multiplier = routeEntries
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        except Exception as e:
            raise IxiaConfigException("Network Group '%s' not found on the config" % (network_group))
        return True

    def get_device_protocol_status(self, protocols=None, devices=None):
        """
        This api returns the protocol status (up | down | Not started) based of protocol or devices
        :param protocols: List of protocols to fetch status
        :param devices: List of device names
        :return:True on success otherwise return False

        Example: get_device_protocol_status(protocols = ["isis","bgp"], devices = ['Device ISIS 1','BGP Router 3'])
                 get_device_protocol_status(protocols = ["isis","ospf"])
                 get_device_protocol_status()
        """
        self.log.info(" Getting protocol status info ")
        resultDict = dict()
        if devices is None:
            devices = self.get_device_names()
        protocolsList = {'isis': 'IsisL3', 'bgp': 'BgpIpv4Peer',
                         'igmp': 'IgmpHost', 'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',
                         'ospfv2': 'Ospfv2', 'bgpv6': 'BgpIpv6Peer', 'ldpbasicrouterv6': 'LdpBasicRouterV6',
                         'pimv4interface': 'PimV4Interface',
                         'mld': 'MldHost', 'mldquerier': 'MldQuerier',
                         'pimv6interface': 'PimV6Interface', 'ospfv3': 'Ospfv3'}
        if protocols:
            for protocol in protocols:
                for eachDevice in devices:
                    eachDevice = eachDevice.replace('+', r'\+').replace('*', r'\*')
                    if protocol.lower() in protocolsList:
                        if protocol.lower() in ["isis"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
                        if protocol.lower() in ["bgp", "igmp", "igmpquerier", "ldpbasicrouter", "pimv4interface",
                                                "ospfv2"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
                        if protocol.lower() in ["bgpv6", "ldpbasicrouterv6", "mld", "mldquerier", "pimv6interface",
                                                "ospfv3"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
        else:
            for key, protocol in protocolsList.items():
                for eachDevice in devices:
                    eachDevice = eachDevice.replace('+', r'\+').replace('*', r'\*')
                    if key in ["isis"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
                    if key in ["bgp", "igmp", "igmpquerier", "ldpbasicrouter", "pimv4interface", "ospfv2"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
                    if key in ["bgpv6", "ldpbasicrouterv6", "mld", "mldquerier", "pimv6interface", "ospfv3"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
        return resultDict

    def add_new_bgp_route_block(self, device, ip_type='ipv4', **kwargs):
        """
        Add a bgp route block/prefix to an existing device

        :param device: device on which route block to be added
        :param ip_type: 'ipv4' or 'ipv6'(default value is 'ipv4')
        :param route_start: starting IP of route block
        :param route_prefix: Route prefix
        :param route_count: Number of routes
        :param route_prefix_step: Route prefix step to increment
        :return: True on success, exception on failure
        ex: tgn.add_new_bgp_route_block(device='Router 1',route_start='150.0.0.1',route_count='5', route_prefix_step='2', route_prefix='24')
        """

        if ip_type.lower() == 'ipv6':
            network_address_start = kwargs.get('route_start', '2000::1')
            network_address_prefix_list = kwargs.get('route_prefix', '64')
            network_address_count = kwargs.get('route_count', '1')
            network_address_prefix_step = kwargs.get('route_prefix_step', '1')
            network_address_incr_step = kwargs.get('route_address_incr', '::1')
            route_prefix_type = kwargs.get('route_prefix_type','singleValue')
            network_group_name = kwargs.get('network_group_name', None)
            self.add_network_group(device_name=device, protocol='bgp',
                                ip_type='ipv6',
                                v6_network_address_start=network_address_start,
                                v6_network_address_prefix_list=network_address_prefix_list,
                                v6_network_address_incr_step=network_address_incr_step,
                                number_of_address=network_address_count,
                                network_address_step=network_address_prefix_step,
                                prefix_type=route_prefix_type,
                                network_group_name= network_group_name)
        else:
            network_address_start = kwargs.get('route_start', '192.0.1.0')
            network_address_prefix_list = kwargs.get('route_prefix', '24')
            network_address_count = kwargs.get('route_count', '1')
            network_address_prefix_step = kwargs.get('route_prefix_step', '1')
            network_address_incr_step = kwargs.get('route_address_incr', '0.0.0.1')
            route_prefix_type = kwargs.get('route_prefix_type', 'singleValue')
            network_group_name= kwargs.get('network_group_name', None)
            self.add_network_group(device_name=device, protocol='bgp',
                                ip_type='ipv4',
                                v4_network_address_start=network_address_start,
                                v4_network_address_prefix_list=network_address_prefix_list,
                                v4_network_address_incr_step=network_address_incr_step,
                                number_of_address=network_address_count,
                                network_address_step=network_address_prefix_step,
                                prefix_type=route_prefix_type,
                                network_group_name= network_group_name)
        return True

    def config_pim_group_member(self, device_name, ip_version, group_name=None, **kwargs):
        """
        Configures PIM group-membership
        :param device_name: Name of the Device
        :param ip_version: ipv4/ipv6
        :param group_name: Name of the IPv4/Ipv6 Multicast group
        :param kwargs: Optional arguments
        :param pim_rp_ipv4: Rendezvous Point Router (RPR) IPv4 address
        :param pim_rp_ipv6: Rendezvous Point Router (RPR) IPv6 address
        :param pim_group_type: STARG/SG/STARSTARRP
        :param pimv4_join_src: Start IPv6 address of Join source range
        :param pimv4_prefix_length: prefix length of Join source IPv4 address
        :param pimv6_join_src: Start IPv6 address of Join source range
        :param pimv6_prefix_length: prefix length of Join source IPv6 address
        :return: True on successful configuration
        Example: tgn.config_pim_group_member(device_name='Device 1', ip_version = 'ipv4',
                                             pim_group_type='STARG', enable_prune=True)
        """

        if ip_version.lower() == 'ipv4':
            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \
                Ipv4.find().PimV4Interface.find()
            self.config_multicast_group(ip_version='ipv4', device_name=device_name,
                                        protocol='pimv4',
                                        group_name=group_name,
                                        start_ip=kwargs.get('pimv4_join_src', '192.0.1.0'),
                                        step='0.0.0.1',
                                        prefix=kwargs.get('pimv4_prefix_length', 24))
        else:
            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \
                Ipv6.find().PimV6Interface.find()
            self.config_multicast_group(ip_version='ipv6', device_name=pimDevice.Name,
                                        protocol='pimv6',
                                        group_name=group_name,
                                        start_ip=kwargs.get('pimv6_join_src', '::2'),
                                        step='::1',
                                        prefix=kwargs.get('pimv6_prefix_length', 64))

        return True

    def modify_streamblock_params(self, cfg_dict, traffic_item_list=None):
        """
        Function NA for IXIA as these streamblock params are not applicable for IXIA

        Allows user to modify Streamblock parameters
        :param traffic_item_list: List of Traffic item for which modification is required
        :param cfg_dict: params that requires to be modified
            cfg_dict={'Allow_InvalidHeaders': False, 'enable_stream_generation': True, 'Enable_FcsErrorInsertion': False}
            Allow_InvalidHeaders (DefaultValue=False)
            Enable_FcsErrorInsertion (DefaultValue=False)
            Insert_Fcs (DefaultValue=True)
            enable_stream_generation (DefaultValue=True)
            enable_highSpeed_analysis (DefaultValue=True)
        :return: True if successful else raise Exception
        """
        pass

    def set_ipv4_traffic_destip(self, traffic_item, dest_ip):
        """
        Allows user to insert/change modifier for IPv4 Dest IP or its value alone at runtime
        :param traffic_item: List of stream names whose traffic class value to be changed
        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list
        :return: Returns True in case no exceptions
        """
        self.log.info("Modifying IPv4 Destination Address")
        if type(traffic_item) is str:
            traffic_item = [traffic_item]
        for eachTi in traffic_item:
            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
            if not trafficItem:
                raise IxiaConfigException("stream not found")
            configElement = trafficItem.ConfigElement.find()[0]
            ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
            try:
                if type(dest_ip) is str:
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = "singleValue"
                    ipv4Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip
                elif type(dest_ip) is list:
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = "valueList"
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip
                else:
                    self.log.error("Invalid Destination IP address %" % dest_ip)
            except:
                raise IxiaConfigException("IPv4 destination address modification failed")
        return True

    def set_ipv6_traffic_destip(self, traffic_item, dest_ip):
        """
        Allows user to insert/change modifier for IPv6 Dest IP or its value alone at runtime
        :param traffic_item: List of stream names whose traffic class value to be changed
        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list
        :return: Returns True in case no exceptions
        """
        self.log.info("Modifying IPv6 Destination Address")
        if type(traffic_item) is str:
            traffic_item = [traffic_item]
        for eachTi in traffic_item:
            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
            if not trafficItem:
                raise IxiaConfigException("stream not found")
            configElement = trafficItem.ConfigElement.find()[0]
            ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
            try:
                if type(dest_ip) is str:
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = "singleValue"
                    ipv6Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip
                elif type(dest_ip) is list:
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = "valueList"
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip
                else:
                    self.log.error("Invalid Destination IP address %" % dest_ip)
            except:
                raise IxiaConfigException("IPv6 destination address modification failed")
        return True

    def _update_field_values(self, field_entry, field_value):
        """
        This API takes the field_entry from traffic item stack and
        set values from field_value. This is a generic API to set/update protocol's stack field
        :param field_entry: Stack field object from traffic item
        :param field_value: value to be copied into stack field object.
                           This handles values of singlevalue/increment/valueList
        """
        try:
            if isinstance(field_value, dict):
                field_entry.Auto = False
                if 'start' in field_value:
                    field_entry.ValueType = 'increment'
                    field_entry.StartValue = field_value['start']
                if 'min' in field_value:
                    field_entry.ValueType = 'repeatableRandomRange'
                    field_entry.MinValue = field_value['min']
                if 'max' in field_value:
                    field_entry.MaxValue = field_value['max']
                if 'seed' in field_value:
                    field_entry.Seed = field_value['seed']
                if 'step' in field_value:
                    field_entry.StepValue = field_value['step']
                else:
                    field_entry.StepValue = 1
                if 'count' in field_value:
                    field_entry.CountValue = field_value['count']
                else:
                    field_entry.CountValue = 1
                if 'type' in field_value:
                    if field_value['type'] == 'random':
                        field_entry.ValueType = 'nonRepeatableRandom'
                        field_entry.RandomMask = 65535
                    if field_value['type'] == 'randomBitMask':
                        field_entry.ValueType = 'random'
                        field_entry.RandomMask = 65535
            elif isinstance(field_value, (str, int)):
                # process single value
                field_entry.Auto = False
                field_entry.ValueType = 'singleValue'
                field_entry.SingleValue = field_value
            elif isinstance(field_value, list):
                # process value list
                field_entry.Auto = False
                field_entry.ValueType = 'valueList'
                field_entry.ValueList = field_value
            result = True
        except:
            result = False
        return result

    def _config_udp_fields(self, cfg_dict, configElement):
        """
        API to set/update udp stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        if 'src_port_value' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Source-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_src_port = cfg_dict['src_port_value']
                    result = self._update_field_values(fieldValue[index - 1], udp_src_port)
        if "dest_port_value" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Dest-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_dest_port = cfg_dict['dest_port_value']
                    result = self._update_field_values(fieldValue[index - 1], udp_dest_port)
        if "udp_header_len" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Length")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_hdr_len = cfg_dict['udp_header_len']
                    result = self._update_field_values(fieldValue[index - 1], udp_hdr_len)
        if "udp_checksum" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Checksum")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_checksum = cfg_dict['udp_checksum']
                    result = self._update_field_values(fieldValue[index - 1], udp_checksum)
        return result

    def _config_tcp_fields(self, cfg_dict, config_element):
        """
        API to set/update tcp stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param config_element: is the config_element object obtained from traffic item object
        """
        tcp_ip_options = {'mss': 'maximumSegmentSize'}
        if 'src_port_value' in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="TCP-Source-Port")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_src_port = cfg_dict['src_port_value']
                    result = self._update_field_values(field_value[index - 1], tcp_src_port)
        if "dest_port_value" in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_dest_port = cfg_dict['dest_port_value']
                    result = self._update_field_values(field_value[index - 1], tcp_dest_port)
        if "tcp_data_offset" in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="Data Offset")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_dataoffset = cfg_dict['tcp_data_offset']
                    result = self._update_field_values(field_value[index - 1], tcp_dataoffset)
        if "tcp_options" in cfg_dict.keys():
            try:
                if cfg_dict['tcp_options']['option'] == 'mss':
                    field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[
                        cfg_dict['tcp_options']['option']] + '.kind'
                    field_value_obj = config_element.Stack.find().Field.find(FieldTypeId=field_type_id)[
                        cfg_dict['header_index'] - 1]
                    if cfg_dict['tcp_options']['action'] == 'enable':
                        field_value_obj.OptionalEnabled = True
                        result = True
                        if "tcp_mss_data" in cfg_dict.keys():
                            field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[
                                cfg_dict['tcp_options']['option']] + '.data'
                            field_value = config_element.Stack.find().Field.find(FieldTypeId=field_type_id)
                            for index in range(1, len(field_value) + 1):
                                if index == cfg_dict['header_index']:
                                    tcp_mss_value = cfg_dict['tcp_mss_data']
                                    result = self._update_field_values(field_value[index - 1], tcp_mss_value)
                    else:
                        field_value_obj.OptionalEnabled = False
                        result = True
                else:
                    self.log.warning('Please share proper TCP Option')
                    result = False
            except:
                result = False
                self.log.error('TCP option update failed')
        if "tcp_checksum" in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="TCP-Checksum")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_data_checksum = cfg_dict['tcp_checksum']
                    result = self._update_field_values(field_value[index - 1], tcp_data_checksum)
        if "tcp_control_bit" in cfg_dict.keys():
            for key, value in cfg_dict["tcp_control_bit"].items():
                if config_element.Stack.find().Field.find(DisplayName=key):
                    field_value = config_element.Stack.find().Field.find(DisplayName=key)
                    for index in range(1, len(field_value) + 1):
                        if index == cfg_dict['header_index']:
                            result = self._update_field_values(field_value[index - 1], value)
                else:
                    self.log.error(f'Invalid TCP Control Bit {key}')
                    result = False
        if "tcp_ecn" in cfg_dict.keys():
            for key, value in cfg_dict["tcp_ecn"].items():
                if config_element.Stack.find().Field.find(DisplayName=key):
                    field_value = config_element.Stack.find().Field.find(DisplayName=key)
                    for index in range(1, len(field_value) + 1):
                        if index == cfg_dict['header_index']:
                            result = self._update_field_values(field_value[index - 1], value)
                else:
                    self.log.error(f'Invalid TCP Control Bit {key}')
                    result = False
        if 'tcp_window' in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="Window")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_window = cfg_dict['tcp_window']
                    result = self._update_field_values(field_value[index - 1], tcp_window)
        if 'tcp_urgent_pointer' in cfg_dict.keys():
            field_value = config_element.Stack.find().Field.find(DisplayName="Urgent Pointer")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    tcp_urgent_pointer = cfg_dict['tcp_urgent_pointer']
                    result = self._update_field_values(field_value[index - 1], tcp_urgent_pointer)
        return result

    def _config_mpls_fields(self, cfg_dict, configElement):
        """
        Internal Method to Configure MPLS stack under traffic item
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement:  Traffic Item Config Element
         """
        if 'mpls_ttl' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Time To Live")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_ttl = cfg_dict['mpls_ttl']
                    result = self._update_field_values(fieldValue[index - 1], mpls_ttl)
        if 'mpls_label_value' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Label Value")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_label_value = cfg_dict['mpls_label_value']
                    result = self._update_field_values(fieldValue[index - 1], mpls_label_value)
        if 'mpls_exp' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_exp = cfg_dict['mpls_exp']
                    result = self._update_field_values(fieldValue[index - 1], mpls_exp)
        return result

    def _config_ipv4_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        ip_options_dict = {'nop': 'nop', 'security': 'security.type', 'lsrr': 'lsrr.type', 'pointer': 'pointer',
                           'route': 'routeData', 'ssrr': 'ssrr.type',
                           'record': 'recordRoute.type', 'streamId': 'streamId.type', 'timestamp': 'timestamp.type',
                           'endOptions': 'last', 'raValue': 'routerAlert.type'}
        header_index = cfg_dict['header_index']

        if 'ipv4_tot_len' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="total_len")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_tot_len = cfg_dict['ipv4_tot_len']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_tot_len)
        if 'ipv4_more_fragements' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="^fragment_flag$")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_mf = cfg_dict['ipv4_more_fragements']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_mf)
        if 'ipv4_fragement_offset' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="fragment_offset")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_fo = cfg_dict['ipv4_fragement_offset']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_fo)
        if 'ipv4_modify_version' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='version')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_ver = cfg_dict['ipv4_modify_version']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_ver)
        if 'ipv4_src_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='source_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_src_ip = cfg_dict['ipv4_src_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_src_ip)
        if 'ipv4_dst_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='dest_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_dst_ip = cfg_dict['ipv4_dst_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_dst_ip)
        if 'ipv4_header_checksum' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPv4")
            fieldValue = stack.find().Field.find(Name='^checksum$')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_checksum = cfg_dict['ipv4_header_checksum']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_checksum)
        if 'ttl' in cfg_dict.keys():
            stack = configElement.find().Stack.find(DisplayName="IPv4")
            field_value = stack.Field.find(Name='^ttl$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_ttl = cfg_dict['ttl']
                    result = self._update_field_values(field_value[index - 1], ipv4_ttl)
        if 'ipv4_protocol' in cfg_dict.keys():
            header_index = cfg_dict['header_index']
            stack = configElement.Stack.find(DisplayName="IPv4")
            field_value = stack.Field.find(Name='^protocol$')[header_index - 1]
            if cfg_dict['ipv4_protocol'].upper() == 'AUTO':
                field_value.Auto = True
            else:
                field_value.Auto = False
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = cfg_dict['ipv4_protocol']
            result = True
        if 'ipv4_ip_options' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPv4")
            ip_option = cfg_dict['ipv4_ip_options']
            try:
                field_type_id = 'ipv4.header.options.nextOption.option.' + ip_options_dict[ip_option['option']]
                ip_obj = stack.Field.find(FieldTypeId=field_type_id)[header_index - 1]
                if ip_option['action'] == 'enable':
                    ip_obj.OptionalEnabled = True
                else:
                    ip_obj.OptionalEnabled = False
                result = True
            except:
                result = False
                raise IxiaOperationException("IP options update failed")
        if 'ipv4_last_fragment' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='IPv4')
            field_value = stack.Field.find(Name='^last_fragment_flag$')[header_index - 1]
            try:
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = cfg_dict['ipv4_last_fragment']
                result = True
            except:
                result = False
                self.log.error("IPv4 Last Fragment update failed")

        return result

    def _config_ipv6_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        ipv6NextHeader_dict = {
            "HOPOPT": 0, "ICMP": 1, "IGMP": 2, "GGP": 3, "IP": 4, "ST": 5, "TCP": 6, "CBT": 7, "EGP": 8, "IGP": 9,
            "BBN-RCC-MON": 10, "NVP-II": 11, "PUP": 12, "ARGUS": 13, "EMCON": 14, "XNET": 15, "CHAOS": 16, "UDP": 17,
            "MUX": 18, "DCN-MEAS": 19, "HMP": 20, "PRM": 21, "XNS-IDP": 22, "TRUNK-1": 23, "TRUNK-2": 24, "LEAF-1": 25,
            "LEAF-2": 26, "RDP": 27, "IRTP": 28, "ISO-TP4": 29, "NETBLT": 30, "MFE-NSP": 31, "MERIT-INP": 32, "SEP": 33,
            "3PC": 34, "IDPR": 35, "XTP": 36, "DDP": 37, "IDPR-CMTP": 38, "TP++": 39, "IL": 40, "IPv6": 41, "SDRP": 42,
            "IPv6-Route": 43, "IPv6-Frag": 44, "IDRP": 45, "RSVP": 46, "GRE": 47, "MHRP": 48, "BNA": 49, "ESP": 50,
            "AH": 51, "I-NLSP": 52, "SWIPE": 53, "NARP": 54, "MOBILE": 55, "TLSP": 56, "SKIP": 57, "IPv6-ICMP": 58,
            "IPv6-NoNxt": 59, "IPv6-Opts": 60, "Any host internal protocol": 61, "CFTP": 62, "Any local network": 63,
            "SAT-EXPAK": 64, "KRYPTOLAN": 65, "RVD": 66, "IPPC": 67, "Any distributed file system": 68, "SAT-MON": 69,
            "VISA": 70, "IPCV": 71, "CPNX": 72, "CPHB": 73, "WSN": 74, "PVP": 75, "BR-SAT-MON": 76, "SUN-ND": 77,
            "WB-MON": 78, "WB-EXPAK": 79, "ISO-IP": 80, "VMTP": 81, "SECURE-VMTP": 82, "VINES": 83, "TTP": 84,
            "NSFNET-IGP": 85, "DGP": 86, "TCF": 87, "EIGRP": 88, "OSPFIGP": 89, "Sprite-RPC": 90, "LARP": 91, "MTP": 92,
            "AX.25": 93, "IPIP": 94, "MICP": 95, "SCC-SP": 96, "ETHERIP": 97, "ENCAP": 98, "Any private encryption": 99,
            "GMTP": 100, "IFMP": 101, "PNNI": 102, "PIM": 103, "ARIS": 104, "SCPS": 105, "QNX": 106, "A/N": 107,
            "IPComp": 108, "SNP": 109, "Compaq-Peer": 110, "IPX-in-IP": 111, "VRRP": 112, "PGM": 113,
            "Any 0-hop protocol": 114, "L2TP": 115, "DDX": 116, "IATP": 117, "STP": 118, "SRP": 119, "UTI": 120,
            "SMP": 121, "SM": 122, "PTP": 123, "ISIS over IPv4": 124, "FIRE": 125, "CRTP": 126, "CRUDP": 127,
            "SSCOPMCE": 128, "IPLT": 129, "SPS": 130, "PIPE": 131, "SCTP": 132, "FC": 133, "RSVP-E2E-IGNORE": 134,
            "Mobility Header": 135, "UDPLite": 136, "MPLS-in-IP": 137}
        if 'ipv6_version' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="version")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_version = cfg_dict['ipv6_version']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_version)
        if 'ipv6_traffic_class' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="trafficClass")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_traffic_class = cfg_dict['ipv6_traffic_class']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_traffic_class)
        if 'ipv6_flow_label' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="flowLabel")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_flow_label = cfg_dict['ipv6_flow_label']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_flow_label)
        if 'ipv6_payload_len' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="payloadLength")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_payload_len = cfg_dict['ipv6_payload_len']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_payload_len)
        if 'ipv6_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="nextHeader")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    if cfg_dict['ipv6_next_header'] in ipv6NextHeader_dict:
                        ipv6_next_header = ipv6NextHeader_dict[cfg_dict['ipv6_next_header']]
                        result = self._update_field_values(fieldValue[index - 1], ipv6_next_header)
        if 'ipv6_hop_limit' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="hopLimit")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_hop_limit = cfg_dict['ipv6_hop_limit']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_hop_limit)
        if 'ipv6_src_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name='source_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_src_ip = cfg_dict['ipv6_src_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_src_ip)
        if 'ipv6_dst_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name='dest_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_dst_ip = cfg_dict['ipv6_dst_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_dst_ip)
        return result

    def _config_ipv6_routing_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv6 routing header stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_routing_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Routing Header' + '$')
            field_value = stack.Field.find(Name='next_header')[header_index - 1]
            try:
                if cfg_dict['ipv6_routing_next_header'].upper() == 'AUTO':
                    field_value.Auto = True
                else:
                    field_value.Auto = False
                    field_value.ValueType = 'singleValue'
                    field_value.FieldValue = cfg_dict['ipv6_routing_next_header']
            except:
                self.log.info('IPv6 Routing Next header modification failed')

        return True

    def _config_ipv6_authentication_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv6 authentication header stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_auth_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Authentication Header' + '$')
            field_value = stack.Field.find(Name='next_header')[header_index - 1]
            try:
                if cfg_dict['ipv6_auth_next_header'].upper() == 'AUTO':
                    field_value.Auto = True
                else:
                    field_value.Auto = False
                    field_value.ValueType = 'singleValue'
                    field_value.FieldValue = cfg_dict['ipv6_auth_next_header']
            except:
                self.log.info('IPv6 Authentication Next header modification failed')
        return True

    def _config_ipv6_fragment_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_fragment_offset' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')
            fieldValue = stack.Field.find(Name='fragment_offset')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_fragment_offset = cfg_dict['ipv6_fragment_offset']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_fragment_offset)
        if 'ipv6_more_fragments' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')
            field_value = stack.Field.find(Name='More Fragments')[header_index - 1]
        try:
            field_value.ValueType = 'singleValue'
            field_value.FieldValue = cfg_dict['ipv6_more_fragments']
        except:
            self.log.error('IPv6 More Fragments field modification failed')
        return True

    def _config_igmp_fields(self, cfg_dict, configElement):
        """
        API to set/update igmp stack fields under traffic item.
        :param cfg_dict: The igmp params and their respective values that
                        needs to be set/updated.Ex : igmp_version ,igmp_type,igmp_unused,igmp_checksum,igmp_group_address
        :param configElement: It is the configElement object obtained from traffic item object
        """
        stack = configElement.Stack.find(DisplayName="IGMP")
        if cfg_dict['protocol_name'] == 'igmpv1':
            stack = configElement.Stack.find(DisplayName="IGMPv1")
        if cfg_dict['protocol_name'] == 'igmpv2':
            stack = configElement.Stack.find(DisplayName="IGMPv2")
        if cfg_dict['protocol_name'] == 'igmpv3q':
            stack = configElement.Stack.find(DisplayName="IGMPv3 Membership Query")
        if cfg_dict['protocol_name'] == 'igmpv3r':
            stack = configElement.Stack.find(DisplayName="IGMPv3 Membership Report")

        if 'igmp_version' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name="version1")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_version = cfg_dict['igmp_version']
                    result = self._update_field_values(fieldValue[index - 1], igmp_version)
        if 'igmp_type' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name="type1")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_type = cfg_dict['igmp_type']
                    result = self._update_field_values(fieldValue[index - 1], igmp_type)
        if 'igmp_unused' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='unused')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_unused = cfg_dict['igmp_unused']
                    result = self._update_field_values(fieldValue[index - 1], igmp_unused)
        if 'igmp_checksum' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='checksum')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_checksum = cfg_dict['igmp_checksum']
                    result = self._update_field_values(fieldValue[index - 1], igmp_checksum)
        if 'igmp_group_address' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='group_address')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_group_address = cfg_dict['igmp_group_address']
                    result = self._update_field_values(fieldValue[index - 1], igmp_group_address)
        return result

    def _config_icmp_fields(self, cfg_dict, configElement):
        """
        API to set/update icmp stack fields under traffic item.
        :param cfg_dict: The icmp params and their respective values that
                        needs to be set/updated.Ex : icmp_message_type ,icmp_code_option
                        protocol_name will be below icmp types
        :param configElement: It is the configElement object obtained from traffic item object
        """
        icmp_msg_dict = {3: 'Dest. Unreachable', 4: 'Src. Quench', 5: 'Redirect Message', 11: 'Time Exceeded',
                         12: 'Parameter Problem', 0: 'Echo reply', 8: 'Echo message', 13: 'TimeStamp message',
                         14: 'TimeStamp reply', 15: 'Information Request', 16: 'Information Reply'}
        icmp_code_dict = {'dest_unreachable': 'Dest. Unreachable code options', 'src_quench': 'Src. Quench option',
                          'info_request': 'Info Request option',
                          'info_response': 'Info Response option', 'time_exceeded': 'Time Exceeded option',
                          'redirect_msg': 'Redirect Message option'}
        icmp_code_sub_dict = {'net_unreach': 'Net unreachable', 'host_unreach': 'Host unreachable',
                              'protocol_unreach': 'Protocol unreachable',
                              'port_unreach': 'Port unreachable', 'fragment_needed': 'Fragmentation needed and DF set',
                              'source_fail': 'Source route failed',
                              'ttl_exceeded': 'TTL exceeded in transit',
                              'fragment_reassembly': 'Fragment reassembly time exceeded',
                              'redirect_nw': 'Redirect datagrams for network',
                              'redirect_host': 'Redirect datagrams for the Host',
                              'redirect_tos_nw': 'Redirect datagrams for the TOS and network',
                              'redirect_tos_host': 'Redirect datagrams for the TOS and host'}
        unused_type_dict = {'unused_type3': 'opt1', 'unused_type4': 'opt2', 'unused_type11': 'opt3',
                            'unused_next_field': 'unsd'}
        header_index = cfg_dict['header_index']
        if 'icmp_message_type' in cfg_dict.keys():
            if cfg_dict['icmp_message_type'] in icmp_msg_dict:
                icmp_msg = cfg_dict['icmp_message_type']
                if (icmp_msg == 3 or icmp_msg == 4 or icmp_msg == 5 or icmp_msg == 11 or icmp_msg == 12):
                    stack = configElement.Stack.find(StackTypeId="^icmpv1$")
                else:
                    stack = configElement.Stack.find(StackTypeId="^icmpv2$")
                field_value = stack.Field.find(Name="msg_type")[header_index - 1]
                field_value.FieldValue = icmp_msg_dict[icmp_msg]
                result = True
        if 'icmp_code_options' in cfg_dict.keys():
            if cfg_dict['icmp_code_options'] in icmp_code_dict:
                stack = configElement.Stack.find(StackTypeId="^icmpv1$")
                field_value = stack.Field.find(DisplayName=icmp_code_dict[cfg_dict['icmp_code_options']])[header_index - 1]
                field_value.ActiveFieldChoice = True
                result = True
        if 'icmp_code_sub_options' in cfg_dict.keys():
            icmpSubOption = cfg_dict['icmp_code_sub_options']
            stack = configElement.Stack.find(StackTypeId="^icmpv1$")
            if icmpSubOption == 'net_unreach' or icmpSubOption == 'host_unreach' or icmpSubOption == 'protocol_unreach' or icmpSubOption == 'port_unreach' or icmpSubOption == 'fragment_needed' or icmpSubOption == 'source_fail':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['dest_unreachable'])[header_index - 1]
            elif icmpSubOption == 'ttl_exceeded' or icmpSubOption == 'fragment_reassembly':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['time_exceeded'])[header_index - 1]
            elif icmpSubOption == 'redirect_nw' or icmpSubOption == 'redirect_host' or icmpSubOption == 'redirect_tos_nw' or icmpSubOption == 'redirect_tos_host':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['redirect_msg'])[header_index - 1]
            try:
                field_value.ActiveFieldChoice = True
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = icmp_code_sub_dict[icmpSubOption]
                result = True
            except Exception as err:
                raise IxiaConfigException('ICMP Code options updation failed with {}'.format(err))
        if 'icmp_code_value' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv2$")
            field_value = stack.Field.find(Name="Code")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmp_code = cfg_dict['icmp_code_value']
                    result = self._update_field_values(field_value[index - 1], icmp_code)
        if 'icmp_identifier' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv2$")
            field_value = stack.Field.find(Name="^id_fier$")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmp_identifier = cfg_dict['icmp_identifier']
                    result = self._update_field_values(field_value[index - 1], icmp_identifier)
        if 'icmp_unused_type' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv1$")
            field_value = stack.Field.find(Name='^' + unused_type_dict[cfg_dict['icmp_unused_type']] + '$')
            field_value[header_index - 1].ActiveFieldChoice = True
            if 'icmp_unused_code' in cfg_dict.keys():
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmp_unused_code = cfg_dict['icmp_unused_code']
                        result = self._update_field_values(field_value[index - 1], icmp_unused_code)
        return result

    def _config_icmpv6_fields(self, cfg_dict, configElement):
        """
        API to set/update icmpv6 stack fields under traffic item.
        :param cfg_dict: The icmp params and their respective values that
                        needs to be set/updated.Ex : icmpv6_message_type ,icmpv6_code_option
                        protocol_name will be below icmp types
        :param configElement: It is the configElement object obtained from traffic item object
        """
        icmpv6_msg_dict = {1: 'destinationUnreachableMessage.mesageType',2:'packetTooBigMessage.messageType',
                           3: 'timeExceededMessage.messageType',4:'parameterProblemMessage.messageType',
                           128: 'echoRequestMessage.messageType',129:'echoReplyMessage.messageType'}
        icmpv6_code_dict = {'hop_limit':'Hop limit exceeded in transit','fragment_reassembly':'Fragment reassembly time exceeded',
                            'erroneous_header':'Erroneous header field encountered',
                            'unrecognized_header':'Unrecognized Next Header type encountered',
                            'unrecognized_ipv6':'Unrecognized IPv6 option encountered','no_route':'No route to destination',
                            'commun_prohibited':'Communication with destination administratively prohibited',
                            'not_assigned':'Not assigned','add_unreachable':'Address unreachable',
                            'port_unreachable':'Port unreachable'}
        header_index = cfg_dict['header_index']

        if 'icmpv6_message_type' in cfg_dict.keys():
            if cfg_dict['icmpv6_message_type'] in icmpv6_msg_dict:
                stack = configElement.Stack.find(StackTypeId="^icmpv6$")
                fieldTypeId = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[
                    cfg_dict['icmpv6_message_type']]
                field_value = stack.Field.find(FieldTypeId=fieldTypeId)[header_index - 1]
                field_value.ActiveFieldChoice = True
                result = True
        if 'icmpv6_code_options' in cfg_dict.keys():
            if 'icmpv6_message_type' in cfg_dict.keys():
                stack = configElement.Stack.find(StackTypeId="^icmpv6$")
                if cfg_dict['icmpv6_code_options'] in icmpv6_code_dict:
                    field_value = None
                    if cfg_dict['icmpv6_message_type'] == 3:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.timeExceededMessage.code')[header_index - 1]
                    elif cfg_dict['icmpv6_message_type'] == 4:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.parameterProblemMessage.code')[header_index - 1]
                    elif cfg_dict['icmpv6_message_type'] == 1:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.destinationUnreachableMessage.code')[header_index - 1]
                    else:
                        self.log.error('Please select valid message type to update code option')
                    if field_value:
                        try:
                            field_value.FieldValue = icmpv6_code_dict[cfg_dict['icmpv6_code_options']]
                            result = True
                        except Exception as err:
                            raise IxiaConfigException(
                                'Invalid Code Type for given message type: exception raised {}'.format(err))
                else:
                    result = False
                    self.log.error('Please share valid ICMPv6 code option')
            else:
                result = False
                self.log.error('Please select message type to update code option')
        if 'icmpv6_code' in cfg_dict.keys():
            field_type_id = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[cfg_dict['icmpv6_message_type']]
            field_type_id = field_type_id.replace('messageType', 'code')
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            field_value = stack.Field.find(FieldTypeId=field_type_id)
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmpv6_code = cfg_dict['icmpv6_code']
                    result = self._update_field_values(field_value[index - 1], icmpv6_code)
        if 'icmpv6_mtu' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            if cfg_dict['icmpv6_message_type'] == 2:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.packetTooBigMessage.maximumTransmissionUnit')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_mtu = cfg_dict['icmpv6_mtu']
                        result = self._update_field_values(field_value[index - 1], icmpv6_mtu)
            else:
                self.log.error('MTU value is only supported for Packet Too Big Message Type')
        if 'icmpv6_identifier' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            if cfg_dict['icmpv6_message_type'] == 128:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoRequestMessage.identifier')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_identifier = cfg_dict['icmpv6_identifier']
                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)
            elif cfg_dict['icmpv6_message_type'] == 129:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoReplyMessage.identifier')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_identifier = cfg_dict['icmpv6_identifier']
                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)
            else:
                self.log.error('Identifier value is only supported for Echo Request(128) or Echo Response(129) Message Types')
        return result

    def _config_vlan_fields(self, cfg_dict, configElement):
        """
        API to set/update vlan stack fields under traffic item.
        :param cfg_dict: takes the vlan params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        stack = configElement.Stack.find(DisplayName="VLAN")
        if 'vlan_id' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_id")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_id = cfg_dict['vlan_id']
                    result = self._update_field_values(fieldValue[index - 1], vlan_id)
        if 'vlan_priority' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_user_priority")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_priority = cfg_dict['vlan_priority']
                    result = self._update_field_values(fieldValue[index - 1], vlan_priority)
        if 'vlan_cfi' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_cfi")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_cfi = cfg_dict['vlan_cfi']
                    result = self._update_field_values(fieldValue[index - 1], vlan_cfi)
        if 'vlan_protocol' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_tag_type")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_protocol_id = cfg_dict['vlan_protocol']
                    result = self._update_field_values(fieldValue[index - 1], vlan_protocol_id)
        return result

    def _config_custom_fields(self, cfg_dict, config_element):
        """
        API to set/update custom stack fields under traffic item.
        :param cfg_dict: takes the custom params and their respective values that needs to be set/updated
                         Ex:custom_length,custom_data
        :param config_element: is the config element object obtained from traffic item object
        """
        stack = config_element.Stack.find(DisplayName="Custom")
        if 'custom_length' in cfg_dict.keys():
            field_value = stack.Field.find(Name='^' + 'Length' + '$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    custom_len = cfg_dict['custom_length']
                    result = self._update_field_values(field_value[index - 1], custom_len)
        if 'custom_data' in cfg_dict.keys():
            field_value = stack.Field.find(Name='^' + 'Data' + '$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    custom_data_value = cfg_dict['custom_data']
                    result = self._update_field_values(field_value[index - 1], custom_data_value)
        return result

    def modify_packet_stream_header(self, cfg_dict, traffic_item_list=None):
        """
        API to modify Traffic item protocol headers like TCP,UDP,IGMPv1,IGMPv2
        :param cfg_dict: A dictionary containing header items whose value needs to modify
        :param traffic_item_list: List of traffic items
        :return True on success otherwise return False
        Ex : modify_packet_stream_header(traffic_item_list=['T1'], cfg_dict={'protocol_name': 'udp','header_index':1,'src_port_value': 30,
                                         'dest_port_value': 60}))
        """
        self.log.info('Modifying traffic item header')
        result = False
        if type(traffic_item_list) != list:
            log.info('Invalid traffic_items_list type. Please use list')
        # header_index by default need to consider it as 1.
        if 'header_index' not in cfg_dict:
            cfg_dict['header_index'] = 1
        else:
            cfg_dict['header_index'] = cfg_dict['header_index'] + 1
        for trafficItemName in traffic_item_list:
            trafficItemName = trafficItemName.replace('+', r'\+').replace('*', r'\*')
            trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$')
            if not trafficItemObj:
                raise IxiaConfigException("Traffic item not found")
            for configElement in trafficItemObj.ConfigElement.find():
                if cfg_dict["protocol_name"] == 'udp':
                    result = self._config_udp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'tcp':
                    result = self._config_tcp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'mpls':
                    result = self._config_mpls_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv4':
                    result = self._config_ipv4_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6':
                    result = self._config_ipv6_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'custom':
                    result = self._config_custom_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'igmp':
                    result = self._config_igmp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'vlan':
                    result = self._config_vlan_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'icmp':
                    result = self._config_icmp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'icmpv6':
                    result = self._config_icmpv6_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Routing':
                    result = self._config_ipv6_routing_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Auth':
                    result = self._config_ipv6_authentication_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Fragment':
                    result = self._config_ipv6_fragment_fields(cfg_dict, configElement)
        return result

    def inject_traffic_error(self,traffic_item=None, crc_error="goodCrc", disparity_error=False):
        """
        API to inject CRC, disparity errors for traffic items

        :param traffic_item: Name of traffic item on which to inject error
        :param crc_error: To inject CRC error, Supported values - "badCrc" , "goodCrc"
        :param disparity_error: To inject disparity error if True
        :return True: On success

        Examples: inject_traffic_error(traffic_item=["ipv4"], crc_error="badCrc")
                  inject_traffic_error(traffic_item=["ipv4"], crc_error="goodCrc")
                  inject_traffic_error(traffic_item=["ipv4","ipv6"], disparity_error=True)
        """
        if traffic_item:
            for eachTi in traffic_item:
                if self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi):
                    trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
                    trafficItemObj.ConfigElement.find().Crc = crc_error
                    trafficItemObj.ConfigElement.find().EnableDisparityError = disparity_error
                else:
                    self.log.error("Traffic Item not found")
        else:
            for eachTi in self.ixNetwork.Traffic.TrafficItem.find():
                eachTi.ConfigElement.find().Crc = crc_error
                eachTi.ConfigElement.find().EnableDisparityError = disparity_error
        return True

    def modify_ignore_link_status(self, status, port_list=None):
        """
        Enable or disable ignore link status for a given set of ports. Not applicable to Ixia

        :param port_list: (list) The port(s) to configure
            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']
        :param status: (str) enable or disable ignore link status
            e.g. 'enable', 'disable'
        :return: True on success, exception otherwise
        """
        if status == 'enable':
            status = True
        if status == 'disable':
            status = False
        if port_list:
            self.log.info(f'Modifying the ignore link status for the following ports: {port_list}')
            for vport in self.ixNetwork.Vport.find():
                if vport.AssignedTo.replace(":", "/") in port_list:
                    vport.TransmitIgnoreLinkStatus = status
        else:
            self.log.info('Port list not specified - modifying the ignore link status on all ports...')
            for port in self.ixNetwork.Vport.find():
                port.TransmitIgnoreLinkStatus = status
        return True

    def create_dhcpv6_pd_host(self, host_router_id=None, cpe_router_id=None, source_mac=None, hosts_per_cpe=1):
        """
        Configures dhcpv6 PD host and home gateway link between CPE and host.
        Host gets IPv6 address from prefix delegated to CPE.

        This API is	Not applicable to ixia.

        :param host_router_id: Mandatory parameter. Router ID of host emulated device on which command needs to be performed.
        :param cpe_router_id: Mandatory parameter. Router ID of CPE emulated device on which command needs to be performed.
        :param source_mac: source mac
        :param hosts_per_cpe: host count per CPE.
        :return: True on success
        """
        pass

    def add_device_wizard(self, port, protocols, new_config, **kwargs):
        """
        API to create number of devices via wizard. Not applicable to Ixia.
        :param port: port string
        :param protocols: Protocols to be enabled eg: IGMP/MLD/PIM
        :param new_config: True if you want to clear the config else False
        :param kwargs: Optional arguments
        :param l3_type: IPV4/IPV6/IPV4V6
        :param count: Number of routers to create per port/VLAN.
        :param count_block_per_port: Count block per port
        :param count_per_block: Count per block
        :param block_mode: Single device/Block of many devices
        :param router_id: Router Id.
        :param ipv6_router_id: IPv6 Router Id
        :param duplicate_name_resolution: How duplicate device names are handled.
        :param device_name: Template string for defining device names
        :param block_index: Starting device block index.
        :param Role: Role to assign to the devices (Host/Router)
        # VLAN
        :param vlan_count: VLANs per port
        :param vlan_id: VLAN ID
        :param vlan_id_step: VLAN ID step value
        :param vlan_repeat_mode: How VLAN IDs are repeated.
        :param vlan_priority: VLAN priority.
        :param vlan_tpid: Tag protocol identifier.
        # IPV4
        :param ipv4_addr: IPv4 address.
        :param ipv4_addr_step: IPv4 address step value.
        :param ipv4_gateway: IPv4 gateway address.
        :param ipv4_gateway_step: IPv4 gateway address step value.
        :param ipv4_prefix_length: IPv4 address prefix length.
        :param ipv4_tos: TOS value used in the IP header.
        :param ipv4_tos_type: Formatting of the TOS value.
        # IPV6
        :param ipv6_addr: IPv6 address value
        :param ipv6_addr_step: IPv6 address step value
        :param ipv6_addr_type: Type of IPv6 address
        :param ipv6_gateway: IPv6 gateway address
        :param ipv6_gateway_step: IPv6 gateway address step
        :param ipv6_prefix_length: IPv6 address prefix length
        :param ipv6_traffic_class: Traffic Class
        # IGMP
        :param igmp_version: IGMP_V1/IGMP_V2/IGMP_V3.
        :param delete_igmp_existing_group: YES/NO. Whether to delete the existing IGMP group in the system
        :param igmp_dev_grp_mapping: Mapp b/w device and subscribed multicast group
        :param igmp_start_group_addr: IPv4 multicast group address.
        :param igmp_step_per_port: IPv4 multicast group step.
        :param igmp_group_count: Number of multicast groups to subscribe to.
        :param igmp_filter_mode: Mode for specifying filtered sources.
        :param igmp_filter_sources: Explicit set of sources from which multicast group is interested
        :param igmp_src_addr: Multicast source IPv4 address
        :param igmp_src_step: Step for the multicast source address
        :param igmp_src_prefix: Multicast source IPv4 prefix length
        :param igmp_src_count: Number of multicast sources
        # MLD
        :param mld_version: MLD_V1/MLD_V2
        :param delete_mld_existing_group: YES/NO. Whether to delete the existing MLD group in the system
        :param mld_dev_grp_mapping: Mapp b/w device and subscribed multicast group
        :param mld_group_count: Number of multicast groups to subscribe to.
        :param mld_start_addr: IPv6 multicast group address.
        :param mld_addr_step: IPv4 multicast group step.
        :param mld_filter_mode: Mode for specifying filtered sources.
        :param mld_filter_sources: Explicit set of sources from which multicast group is interested
        :param mld_src_addr: Multicast source IPv6 address
        :param mld_src_step: Step for the multicast source address
        :param mld_src_prefix: Multicast source IPv6 prefix length
        :param mld_src_count: Number of multicast sources
        # PIM
        :param pim_version: IP version to be used for communication with the neighbor.
        :param pim_mode: Emulated router's PIM mode.
        :param pim_dr_priority: Designated Router priority of this router.

        Example:
              add_device_wizard(port_list=['10.66.236.41/1/1', '10.66.236.41/1/2'],
              protocols=['IGMP', 'MLD', 'PIM'], l3_type = 'IPV4V6', vlan_count = 250, vlan_id = 30,
              igmp_version='IGMP_V3', igmp_group_count=20, igmp_filter_mode='INCLUDE', igmp_filter_sources = 'CUSTOM',
              mld_version = 'MLD_V2', mld_group_count = 40, mld_filter_mode = 'INCLUDE', mld_filter_sources = 'CUSTOM',
              pim_mode = 'SSM', pim_version = 'IPV6')
        """
        pass

    def set_invalid_l2_eth(self, traffic_items, cfg_dict):
        """
        API used to configure invalid L2 ethernet headers for a given list of streams. Not applicable to Ixia.

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
        """
        pass

    def modify_network_group_address_count(self,network_group=None, ip_type=None, address_count=1,**kwargs):
        """
        This API is used for modifying the Network group address count
        :param network_group:Network Group name to modify group address Count
        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'
        :param address_count: Group Address Count for IPv4/IPv6
        :param kwargs: Optional arguments
                        nested_network_group: If nested network group to be modified
        :return: True on success otherwise raise exception
        """
        nested_network_group = kwargs.get('nested_network_group',None)
        if ip_type==None:
            ip_type='ipv4'
        self.log.info("Changing Group address count for Network Group")
        # Modify Group address count for Network Group
        if network_group and nested_network_group:
            if ip_type.lower()=='ipv4':
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
            else:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
            if isinstance(address_count, dict):
                cfg_dict = address_count
                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))
            elif isinstance(address_count, int):
                networkObj.NumberOfAddressesAsy.Single(address_count)
            elif isinstance(address_count, list):
                networkObj.NumberOfAddressesAsy.ValueList(address_count)
        elif network_group:
            if ip_type.lower()=='ipv4':
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                    Ipv4PrefixPools.find()
            else:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                    Ipv6PrefixPools.find()
            if isinstance(address_count, dict):
                cfg_dict = address_count
                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))
            elif isinstance(address_count, int):
                networkObj.NumberOfAddressesAsy.Single(address_count)
            elif isinstance(address_count, list):
                networkObj.NumberOfAddressesAsy.ValueList(address_count)
        elif network_group == None:
            for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower()=='ipv4':
                    try:
                        networkObj = networkGroup.Ipv4PrefixPools.find()
                    except:
                        self.log.warning("Network Group does not have IPv4 Block")
                else:
                    try:
                        networkObj = networkGroup.Ipv6PrefixPools.find()
                    except:
                        self.log.warning("Network Group does not have IPv6 Block")
                if networkObj:
                    if isinstance(address_count, dict):
                        cfg_dict = address_count
                        networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),
                                                                  step_value=cfg_dict.get('step', 1))
                    elif isinstance(address_count, int):
                        networkObj.NumberOfAddressesAsy.Single(address_count)
                    elif isinstance(address_count, list):
                        networkObj.NumberOfAddressesAsy.ValueList(address_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Network Group address count added Successfully")
        return True

    def modify_ldp_params(self, config_dict, device_name=None):
        """
        This API is responsible for updating LDP parameters
        :param config_dict: configuration details to get updated under LDP stack
        :param device_name: Optional, device_name under which LDP device is configured.
        :return: True on success otherwise raise exception
        """
        if device_name == None:
            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find().LdpBasicRouter.find()
        else:
            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').LdpBasicRouter.find()

        if len(ldpObjs) == 0:
            raise IxiaConfigException("No LDP devices found")
        if len(ldpObjs.LdpLeafRangeV4) > 0:
            for ldpObj in ldpObjs:
                try:
                    if 'lsp_count_per_root' in config_dict:
                        lspCountRootObj = ldpObj.LdpLeafRangeV4.LspCountPerRoot
                        if isinstance(config_dict['lsp_count_per_root'], dict):
                            cfg_dict = config_dict['lsp_count_per_root']
                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),
                                                      step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lsp_count_per_root'], int):
                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])
                        elif isinstance(config_dict['lsp_count_per_root'], list):
                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])
                    if 'lable_start' in config_dict:
                        lblStartValObj = ldpObj.LdpLeafRangeV4.LabelValueStart
                        if isinstance(config_dict['lable_start'], dict):
                            cfg_dict = config_dict['lable_start']
                            lblStartValObj.Increment(start_value=cfg_dict.get('start', 10001),
                                                     step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lable_start'], int):
                            lblStartValObj.Single(config_dict['lable_start'])
                        elif isinstance(config_dict['lable_start'], list):
                            lblStartValObj.ValueList(config_dict['lable_start'])
                    if 'lable_step' in config_dict:
                        lblStepValObj = ldpObj.LdpLeafRangeV4.LabelValueStep
                        if isinstance(config_dict['lable_step'], dict):
                            cfg_dict = config_dict['lable_step']
                            lblStepValObj.Increment(start_value=cfg_dict.get('start', 1),
                                                    step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lable_step'], int):
                            lblStepValObj.Single(config_dict['lable_step'])
                        elif isinstance(config_dict['lable_step'], list):
                            lblStepValObj.ValueList(config_dict['lable_step'])
                except:
                    pass
        if len(ldpObjs.LdpRootRangeV4) > 0:
            for ldpObj in ldpObjs:
                try:
                    if 'lsp_count_per_root' in config_dict:
                        lspCountRootObj = ldpObj.LdpRootRangeV4.LspCountPerRoot
                        if isinstance(config_dict['lsp_count_per_root'], dict):
                            cfg_dict = config_dict['lsp_count_per_root']
                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),
                                                      step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lsp_count_per_root'], int):
                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])
                        elif isinstance(config_dict['lsp_count_per_root'], list):
                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])
                except:
                    pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_bgpmVpn_sender(self, config_dict, device_name, ip_version="ipv4", nested=False):
        """
        This API is to update values from sender-side for given bgp mVPN device
        :param config_dict: configuration details to get updated under bgp mVPN sender-side
        :param device_name: Name of the device group
        :param ip_version: supported values "ipv4" or "ipv6"
        :param nested: True if device group is nested. Default False
        :return: True on success otherwise raise exception
        """
        if nested == True:
            if ip_version == "ipv4":
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                    BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                        BgpMVpnSenderSitesIpv6.find()
            else:
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv6 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                    BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                        BgpMVpnSenderSitesIpv6.find()
        else:
            if ip_version == "ipv4":
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv6.find()
            else:
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv6.find()

        if len(networkObjs) == 0:
            raise IxiaConfigException("No devices found to update BgpMVpnSenderSites")
        for senderSiteObj in networkObjs:
            if 'group_address_count' in config_dict:
                grpAddrCountObj = senderSiteObj.GroupAddressCount
                if isinstance(config_dict['group_address_count'], dict):
                    cfg_dict = config_dict['group_address_count']
                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),
                                              step_value=cfg_dict.get('step', 1))
                elif isinstance(config_dict['group_address_count'], int):
                    grpAddrCountObj.Single(config_dict['group_address_count'])
                elif isinstance(config_dict['group_address_count'], list):
                    grpAddrCountObj.ValueList(config_dict['group_address_count'])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_bgpmVpn_receiver(self, config_dict, device_name, ip_version="ipv4", nested=False):
        """
        This API is responsible to update values from receiver-side for given bgp mVPN device
        :param config_dict: configuration details to get updated under bgp mVPN sender-side
        :param device_name: Name of the device group
        :param ip_version: supported values "ipv4" or "ipv6"
        :param nested: True if device group is nested. Default False
        :return: True on success otherwise raise exception
        """
        if nested == True:
            if ip_version == "ipv4":
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                    BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                        BgpMVpnReceiverSitesIpv6.find()
            else:
                # Check if BgpMVpnReceiverSitesIpv6 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                    BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                        BgpMVpnReceiverSitesIpv6.find()
        else:
            if ip_version == "ipv4":
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()
            else:
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()
        if len(networkObjs) == 0:
            raise IxiaConfigException("No devices found to update BgpMVpnReceiverSites")
        for receiverSiteObj in networkObjs:
            if 'group_address_count' in config_dict:
                grpAddrCountObj = receiverSiteObj.GroupAddressCount
                if isinstance(config_dict['group_address_count'], dict):
                    cfg_dict = config_dict['group_address_count']
                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),
                                              step_value=cfg_dict.get('step', 1))
                elif isinstance(config_dict['group_address_count'], int):
                    grpAddrCountObj.Single(config_dict['group_address_count'])
                elif isinstance(config_dict['group_address_count'], list):
                    grpAddrCountObj.ValueList(config_dict['group_address_count'])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def add_igmp_mld_group_member(self, device_name, protocol, group_name, **kwargs):
        """
        API to configure igmp/mld group membership and source list on top of existing membership
        :param device_name: Device name for which extra IGMP/MLD membership needs to be added
        :param protocol: igmp or mld
        :param group_name: Multicast Group Name required to configure as mld group membership
        :param kwargs: Optional kwargs
        :param deviceGroupMapping: mapping between device and subscribed multicast group (MANY_TO_MANY/ONE_TO_ONE/ROUND_ROBIN)
        :param filterMode: mode for the associated multicast groups and sources (EXCLUE/INCLUDE)
        :param SourceList: sources are list or range of addresses (TRUE/FALSE)
        :param userDefinedSources: Controls the use of user-defined multicast sources (TRUE/FALSE)
        :param source_ipv6: Start IPv6address list
        :param valueType: 'range' or 'list'
        :param addrIncr: Network address increment
        :param networkCount: Number of networks
        :param prefixLength: IPv6address prefix length
        :return: True on successful configuration
        Ex: tgn.add_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1'),
        user_defined_sources=True, device_group_mapping='MANY_TO_MANY', filter_mode='INCLUDE', source_ip='1.0.0.11',
        addr_increment=1, network_count=10, prefix_length=24, source_list=False)
        """
        result = False
        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)) == 0:
            raise IxiaConfigException("No device found with give name", device_name)
        if protocol.lower() not in ['igmp', 'mld']:
            raise IxiaConfigException("Invalid protocol specified, only igmp and mld are allowed!")
        if 'filterMode' in kwargs:
            if kwargs.get('filterMode').lower() == "include":
                source_mode = 'include'
            elif kwargs.get('filterMode').lower() == 'exclude':
                source_mode = 'exclude'

        source_list = kwargs.get('source_list', False)
        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if protocol.lower() == 'igmp':
            self.log.info("Configuring IGMP Group Member '{}' on '{}'".format(group_name, device_name))
            sourceIP = kwargs.get('source_ip', '192.0.1.0')
            valueType = kwargs.get('value_type', 'range')
            addrIncr = kwargs.get('addr_increment', '0.0.0.1')
            networkCount = kwargs.get('network_count', 1)
            prefixLength = kwargs.get('prefix_length', 32)
            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
            if len(igmpObj) == 0:
                raise IxiaConfigException("Invalid igmp group name specified")
            if 'filterMode' in kwargs:
                srcModeObj = igmpObj.IgmpMcastIPv4GroupList.SourceMode
                srcModeObj.Single(source_mode)
            igmpObj.IgmpMcastIPv4GroupList.Active.Single(True)
            if source_list == True:
                result = self.change_igmp_source_list(device_list=[device_name], igmp_source_list=sourceIP)
            elif source_list == False:
                try:
                    igmpObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Increment(
                        start_value = sourceIP, step_value = addrIncr)
                except:
                    result = False
            if result == False:
                raise IxiaConfigException("IGMP source address updation failed")
        elif protocol.lower() == 'mld':
            sourceIP = kwargs.get('source_ipv6', '2000::1')
            valueType = kwargs.get('value_type', 'range')
            addrIncr = kwargs.get('addr_increment', '::1')
            networkCount = kwargs.get('network_count', 1)
            prefixLength = kwargs.get('prefix_length', 128)
            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)
            if len(mldObj) == 0:
                raise IxiaConfigException("Invalid mld group name specified")
            if 'filterMode' in kwargs:
                srcModeObj = mldObj.MldMcastIPv6GroupList.SourceMode
                srcModeObj.Single(source_mode)
            mldObj.MldMcastIPv6GroupList.Active.Single(True)
            if source_list == True:
                result = self.change_mld_source_list(device_list=[device_name], mld_source_list=sourceIP)
            elif source_list == False:
                try:
                    mldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Increment(
                        start_value = sourceIP, step_value = addrIncr)
                except:
                    result = False
            if result == False:
                raise IxiaConfigException("MLD source address updation failed")
        return True

    def delete_igmp_mld_group_member(self, device_name, protocol, group_name):
        """
        Allows user to Delete IGMP/MLD Group membership
        :param device_name: Device name for which IGMP/MLD membership needs to be deleted
        :param protocol: 'igmp' or 'mld'
        :param group_name: Mcast group name for which membership needs to be deleted
        :return: True on Success
        Example: tgn.delete_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1')
        """
        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')) == 0:
            raise IxiaConfigException("No device found with give name", device_name)
        if protocol.lower() not in ['igmp', 'mld']:
            raise IxiaConfigException("Invalid protocol specified, only igmp and mld are allowed!")

        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if protocol.lower() == 'igmp':
            self.log.info("Deleting IGMP Group Member '{}' on '{}'".format(group_name, device_name))
            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
            if len(igmpObj) == 0:
                raise IxiaConfigException("Invalid igmp group name specified")
            igmpObj.IgmpMcastIPv4GroupList.Active.Single(False)
        elif protocol.lower() == 'mld':
            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name='^' + group_name + '$')
            if len(mldObj) == 0:
                raise IxiaConfigException("Invalid mld group name specified")
            mldObj.MldMcastIPv6GroupList.Active.Single(False)

    def start_stop_link_fault(self, port, faultmode='LOCAL', action=True):
        """
        Insert(stop/start) LOCAL/REMOTE Link Fault.

        :param port: port name or port handle or
                     interface name from Json file.
        :param faultmode: CHOICES LOCAL/REMOTE link fault.
        :param action: CHOICES True(start link fault)/False(Stop link fault)
        :return True
        """
        cardTypeList = ['atlasFourHundredGigLan', 'atm', 'ethernet', 'ethernetImpairment', 'ethernetvm',
                        'fc', 'fortyGigLan', 'hundredGigLan', 'krakenFourHundredGigLan', 'novusHundredGigLan',
                        'novusTenGigLan', 'pos', 'tenFortyHundredGigLan', 'tenGigLan', 'tenGigWan',
                        'aresOneFourHundredGigLan']
        cardType = self.ixNetwork.Vport.find(Name=port).Type
        vport = self.ixNetwork.Vport.find(Name=port)
        if cardType in cardTypeList:
            cardType = cardType[0].upper() + cardType[1:]

        cardObj = eval('vport.L1Config.' + cardType)

        if 'TypeAOrderedSets' not in dir(cardObj) or 'TypeBOrderedSets' not in dir(cardObj) or 'StartErrorInsertion' in dir(cardObj):
            self.log.error('card is Not supported for error insertion')
            return False

        if faultmode == "LOCAL":
            if 'TypeAOrderedSets' in dir(cardObj):
                cardObj.TypeAOrderedSets = "localFault"
            if 'TypeBOrderedSets' in dir(cardObj):
                cardObj.TypeBOrderedSets = "localFault"
            if 'StartErrorInsertion' in dir(cardObj):
                if action == True:
                    cardObj.StartErrorInsertion = True
                else:
                    cardObj.StartErrorInsertion = False
            return True
        elif faultmode == "REMOTE":
            if 'TypeAOrderedSets' in dir(cardObj):
                cardObj.TypeAOrderedSets = "remoteFault"
            if 'TypeBOrderedSets' in dir(cardObj):
                cardObj.TypeBOrderedSets = "remoteFault"
            if 'StartErrorInsertion' in dir(cardObj):
                if action == True:
                    cardObj.StartErrorInsertion = True
                else:
                    cardObj.StartErrorInsertion = False
            return True
        return False

    def set_invalid_netio(self, traffic_items, cfg_dict):
        """
        API used to configure invalid NetIO headers for a given list of streams. This API is not applicable to ixia

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
        """
        pass

    def config_traffic_options(self, **kwargs):
        """
        API to configure Global options related to Traffic generation available in Settings. This API is not applicable to ixia
        :param kwargs: Spirent specific Traffic Option parameters
        delete_inactive_streams_from_mem: to manage inactive stream block memory usage on test modules (True/False)
        enable_global_analyzer_preload: Indicate if all streamblocks analyzer preload flag will be set to (True/False)
        enable_txqueue_full_retrymode: Determines if transmit is retried when the queue is full on Virtual ports (True/False)
        exclude_ethernet_fcs: Exclude the last 4 bytes of the packet from pcap file when generating stream block (True/False)
        smoothen_random_length: Indicate if smoothen random length distribution per port is generated (True/False)
        traffic_start_interval: Delay in units of 64 microseconds between start of port transmissions
        traffic_start_interval_unit: The traffic start interval unit (UNITOF64US/UNITOF500NS)
        traffic_start_mode: Controls how the ports start sending traffic (ASYNCHRONOUS/SYNCHRONOUS)
        traffic_streamid_startindex: The first StreamID start index to use (1-65535)
        unique_randomlength_seed_perport: Indicate if unique random seeds are created on all ports (True/False)
        :return: True if successful else raise Exception
        :Example: tgn.config_traffic_options(DeleteInactiveStreamsFromMemory = delete_inactive_streams_from_mem, TrafficStartInterval = traffic_start_interval)
        """
        pass

    def create_subs_dynamic_view(self, ip_type="ipv4"):
        """
        Create and subscribe to a dynamic view (Similar to creating user defined views on GUI). This API is not applicable to ixia
        :param ip_type: To select IPv4/IPv6 src/dest address while creating the view.

        :return: None
        """
        pass

    def unsubsribe_dynamic_view(self, drv):
        """
        Unsubscribe from previously created dynamic view. This API is not applicable to ixia
        (User-defined view on GUI).
        :param drv: Dynamic result view object created during subscribe.
        :return: None
        """
        pass

    def port_laser_on_off(self, ports=None, operation="on"):
        """
        API to Turn Laser On/Off of given port

        :param ports: List of name of ports
        :param operation: operation to be set on port "on"/"off"

        Examples: port_laser_on_off(ports=["Ethernet - 001"],operation="off")
                  port_laser_on_off(ports=["Ethernet - 001", "Ethernet - 002"],operation="on")
        """
        res = ""
        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                portObj = getattr(vport.L1Config, capitalizedCardType)
                res = res + f"{vport_name} Laser: {operation}\n"
                if operation.lower() == "off":
                    try:
                        portObj.LaserOn = False
                        self.log.info(res)
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
                elif operation.lower() == "on":
                    try:
                        portObj.LaserOn = True
                        self.log.info(res)
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_insert_local_fault(self, ports=None, source_value='localFault', dest_value='remoteFault', **kwargs):
        """
        API to Insert L1 local/remote fauls and then initiate their transmission

        :param ports: List of name of ports
        :param source_value: str 'localFault'/'remoteFault'
        :param dest_value: str 'localFault'/'remoteFault'
        :param kwargs:
                    send_sets_mode: str "typeAOnly"/"typeBOnly"
                    wait_interval : sleep time default 0
                    repetition : Number of time opertaion to be repeated Ex : 5


        Examples: port_insert_local_fault(ports=["Ethernet - 001"], source_value='localFault', dest_value='remoteFault',
                                           send_sets_mode="typeAOnly")
                   port_insert_local_fault(ports=["Ethernet - 001"], source_value='remoteFault', dest_value='localFault',
                                            send_sets_mode="typeBOnly")
                  port_insert_local_fault(ports=["Ethernet - 001"], source_value='remoteFault', dest_value='localFault',
                                            send_sets_mode="alternate", wait_interval = 5 ,  repetition = 3)
        """
        send_sets_mode = kwargs.get("send_sets_mode")
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)

        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                vp = getattr(vport.L1Config, capitalizedCardType)

                while repetition != 0:
                    try:
                        # localFault | remoteFault
                        vp.TypeAOrderedSets = source_value
                        vp.TypeBOrderedSets = dest_value

                        # alternate | typeAOnly | typeBOnly
                        vp.SendSetsMode = send_sets_mode

                        vp.StartErrorInsertion = True
                        self.log.info('Local Faults applied for port : {}'.format(vport_name))
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
                    time.sleep(wait_interval)
                    repetition -= 1
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_clock_source_faults(self, ports=None, loopback_mode="none", **kwargs):
        """
        Inserting clock faults bases on loopback modes

        :param ports: List of name of ports
        :param loopback_mode: Str loopback mode to be set Ex : "none"/"lineLoopback"/"internalLoopback"
        :param kwargs:
                    wait_interval : (int) sleep time default 0
                    repetition : (int) Number of time opertaion to be repeated Ex : 5

        Examples: port_clock_source_faults(ports=["Ethernet - 001"], loopback_mode= "internalLoopback", wait_interval=5, repetition=2)
                  port_clock_source_faults(ports=["Ethernet - 001"], loopback_mode="lineLoopback" )
        """

        wait_interval = kwargs.get("wait_interval", 1)
        repetition = kwargs.get("repetition", 1)

        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                portObj = getattr(vport.L1Config, capitalizedCardType)

                while repetition != 0:
                    portObj.LoopbackMode = loopback_mode
                    self.log.info(f"Loopback mode: {portObj.LoopbackMode}")
                    time.sleep(wait_interval)
                    repetition -= 1
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_send_undersize_packets(self, traffic_item_name=None, **kwargs):
        """
        Sending frames with modified attributes for frame size, crc
        :param traffic_item_name: str Name of the traffic item Ex: "Traffic_ipv4"
        :param kwargs:
                undersize: undersize frame to be set or not True/False
                desired_frame_size : Frame size to be set on traffic item
                runt: True/False
                crc : Treu/False
                wait_interval : (int) sleep time default 0
                repetition : (int) Number of times operation to be repeated Ex : 5

        Examples: port_send_undersize_packets(traffic_item_name=["Traffic_item_1"], crc=True, desired_frame_size=128)
                  port_send_undersize_packets(traffic_item_name=[Traffic_item_1], runt=True, desired_frame_size=45,wait_interval = 5, repetition = 2 )
        """
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)

        if traffic_item_name is None:
            traffic_item_name = self.get_traffic_items()

        undersize = kwargs.get("undersize", False)
        runt = kwargs.get("runt", False)
        crc = kwargs.get("crc", False)
        desired_frame_size = kwargs.get("desired_frame_size", "128")

        for traffic_item in traffic_item_name:
            # Get the config element:
            configElement = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$').ConfigElement.find()[
                0]
            while repetition != 0:
                if configElement:
                    if undersize:
                        configElement.FrameSize.FixedSize = desired_frame_size

                    if runt or crc:
                        configElement.FrameSize.FixedSize = desired_frame_size
                        configElement.Crc = 'goodCrc'

                    self.log.info('Attributes modified in traffic item {}'.format(traffic_item))
                    self.regenerate_traffic()
                else:
                    self.log.info('traffic item {} not available in the config / not supported'.format(traffic_item))
                time.sleep(wait_interval)
                repetition -= 1

    def enable_network_group(self, network_group_list, enable=True, **kwargs):
        """
        Enable/Disable NetworkGroup(s) or specific routes under a DeviceGroup/NetworkGroup.

        :param network_group_list:
            - If mode == 'group': list of NetworkGroup names to enable/disable
            - If mode == 'routes': list of route indexes (e.g. [1, 2, 3])
        :param enable: True or False
        :param kwargs:
            -  mode: 'group' or 'routes'
            - device_group_name: required if mode == 'routes'
            - network_group_name: alternative if mode == 'routes'
        Examples:
        enable_network_group(network_group_list=['Network Group 2','Network Group 12'])
        enable_network_group(network_group_list=[1, 3, 5], mode='routes', device_group_name='NG_PEER_1_IPv6')
        enable_network_group(network_group_list=[1, 3, 10], enable= False, mode='routes', network_group_name='Network Group 11')
        """
        self.log.debug("Enable/Disable NetworkGroups by names or route indexes")
        mode = kwargs.get('mode','group')
        device_group_name = kwargs.get('device_group_name')
        network_group_name = kwargs.get('network_group_name')

        if enable:
            enable = 'true'
        if not enable:
            enable = 'false'

        try:
            if mode == 'group':
                if not network_group_list:
                    raise Exception("No NetworkGroup names provided for mode='group'")
                for network_group in network_group_list:
                    if not isinstance(network_group, str):
                        raise Exception(f"Expected string name in network_group_list, got '{network_group}' of type {type(network_group)}")

                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$')
                    if not network_obj:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + network_group + '$')
                    if not network_obj:
                        raise Exception(f"NetworkGroup '{network_group}' not found.")
                    network_obj.Enabled.Single(enable)
                    self.log.info(f"{'Enabled' if enable == 'true' else 'Disabled'} NetworkGroup '{network_group}'")
                self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                return True

            elif mode == 'routes':
                if not network_group_list:
                    raise Exception("No route indexes provided for mode='routes'")
                if not device_group_name and not network_group_name:
                    raise Exception("Must provide either 'device_group_name' or 'network_group_name' for mode='routes'")

                if device_group_name:
                    target_device_group = None
                    for topology in self.ixNetwork.Topology.find():
                        device_groups = topology.DeviceGroup.find(Name='^' + device_group_name + '$')
                        if device_groups:
                            target_device_group = device_groups
                            break
                        nested_device_groups = topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                            Name='^' + device_group_name + '$')
                        if nested_device_groups:
                            target_device_group = nested_device_groups
                            break
                    if not target_device_group:
                        raise Exception(f"DeviceGroup '{device_group_name}' not found.")

                    for network_group_obj in target_device_group.NetworkGroup.find():
                        total = network_group_obj.Multiplier
                        values = list(network_group_obj.Enabled.Values or ['false'] * total)
                        for i in network_group_list:
                            if 1 <= i <= total:
                                values[i - 1] = enable
                            else:
                                raise Exception(f"Index {i} out of range for NetworkGroup '{network_group_obj.Name}' (1-{total})")
                        network_group_obj.Enabled.ValueList(values)
                        self.log.info(f"Set Enabled={enable} for indexes {network_group_list} in NetworkGroup '{network_group_obj.Name}' "
                                      f"under DeviceGroup '{device_group_name}'")
                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                    return True

                elif network_group_name:
                    network_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group_name + '$')
                    if not network_objs:
                        network_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + network_group_name + '$')
                    if not network_objs:
                        raise Exception(f"NetworkGroup '{network_group_name}' not found.")

                    for network_obj in network_objs:
                        total = network_obj.Multiplier
                        values = list(network_obj.Enabled.Values or ['false'] * total)
                        for i in network_group_list:
                            if 1 <= i <= total:
                                values[i - 1] = enable
                            else:
                                raise Exception(f"Index {i} out of range for NetworkGroup '{network_group_name}' (1-{total})")
                        network_obj.Enabled.ValueList(values)
                        self.log.info(f"Set Enabled={enable} for indexes {network_group_list} in NetworkGroup '{network_group_name}'")
                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                    return True
            else:
                raise Exception(f"Invalid mode: {mode}. Expected 'group' or 'routes'.")
        except Exception as err:
            raise Exception(f"Failed to enable/disable: {err}")

    def set_bgp_vrf_stack_multiplier(self, stack_count, device_name, ip_type = "ipv4", **kwargs):
        """
        Set device count
        :param stack_count: Stack Multiplier count Should be >=1
        :param device_name: List of Device Group Name
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA Device name if device count of nested DG to be set
                                And for nested device device_name param in mandatory
        :return: True if successful
                raise exception if router id not found in Ixia

        :Example:
                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1')
                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')
       """
        nested_device = kwargs.get('nested_device')
        if stack_count >= 1:
            if nested_device is None:
                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
                if deviceObj:
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            if nested_device:
                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                if deviceObj:
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % nested_device")
        else:
            raise CafyException.InvalidValueError('Device count (%s) has to be greater than or equal to 1' % stack_count)
        return True

    def set_isis_sr_mpls(self, device_list=None, active='True'):
        """
        Setting ISIS SR MPLS

        :param device_list: list of device e.g. ["Device_Group_1"]
        :param active: operation to be set for SR MPLS Ex : 'True'/'False'
        :return: True on success else raises exception

        :Example: set_isis_sr_mpls(device_list=["Device_Group_1"], operation='True')
        """
        if device_list is None:
            device_list = self.get_device_names()
        self.log.info('Setting SR MPLS')
        for device in device_list:
            device = device.replace('+', r'\+').replace('*', r'\*')
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
            if deviceObj.IsisL3Router.find():
                try:
                    deviceObj.IsisL3Router.find().EnableSR = active
                except:
                    self.log.info('Could not set SR MPLS operation on device : {}'.format(device))
            else:
                self.log.info('Device/Protocol not avalible : {} '.format(device))
        return True

    def set_isis_sid_label(self, network_group_list, ip_type="ipv4", active='True', **kwargs):
        """
        Enable/Disable the SID/Index/Label in ISIS Network Group

        :param network_group_list: list of device e.g. ["Network_Group_1"]
        :param ip_type: IP type  Ex : "ipv4"/"ipv6"
        :param active: operation to be set for SR MPLS Ex : 'True'/'False'
        :param kwargs :
                        devices: List of device group names
                        address_list: List of start Address of Network Group

        :return: True on success else raises exception

        :Example: set_isis_sid_label(network_group_list=["Network_Group_1"], active='True')
                  set_isis_sid_label(network_group_list=["Network_Group_v6"], ip_type = "ipv6", active='False')
                  set_isis_sid_label(network_group_list=["Network Group 1"], ip_type = "ipv4", active='True' ,devices=["R1-main"], address_list = ["131.0.1.1"])
        """
        self.log.info('Setting ISIS SID/Index/Label ')
        devices = kwargs.get("devices", None)
        address_list = kwargs.get("address_list", None)
        isis_prefix_sid_active = kwargs.get('isis_prefix_sid_active', True)

        if devices and address_list:
            for device in devices:
                for ngroup in network_group_list:
                    for startaddress in address_list:
                        if ip_type.lower() == "ipv4":
                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv4PrefixPools.find()
                            address = networkObj.NetworkAddress.Values

                        if ip_type.lower() == "ipv6":
                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv6PrefixPools.find()
                            address = networkObj.NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass

        if devices and address_list == None:
            for device in devices:
                for ngroup in network_group_list:
                    device = device.replace('+', r'\+').replace('*', r'\*')
                    deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv4PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(
                                active)
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv4PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().Active.Single(
                                isis_prefix_sid_active)
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv6PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(
                                active)
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv6PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().Active.Single(
                                isis_prefix_sid_active)
                        except:
                            pass

        if devices == None and address_list:
            for ngroup in network_group_list:
                for startaddress in address_list:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + ngroup + '$').Ipv4PrefixPools.find()
                        address = networkObj.NetworkAddress.Values

                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + ngroup + '$').Ipv6PrefixPools.find()
                        address = networkObj.NetworkAddress.Values
                    if startaddress in address:
                        ipIndex = address.index(startaddress)
                        try:
                            valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values
                            valuesList[ipIndex] = active.lower()
                            bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel
                            bgpIpObj.ClearOverlays()
                            bgpIpObj.ValueList(values=valuesList)
                        except:
                            pass

        # support for configureSIDIndexLabel not present in ixnetwork_restpy verion 1.0.45 so using REST API
        if self.tgn_server_type == "linux":
            api_key = self.test_platform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        if devices == None and address_list == None:
            for ngroup in network_group_list:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + ngroup + '$')
                if ip_type.lower() == "ipv4":
                    try:
                        isisL3Obj = networkObj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'
                    except:
                        pass
                if ip_type.lower() == "ipv6":
                    try:
                        isisL3Obj = networkObj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'
                    except:
                        pass

                if isisL3Obj:
                    body = requests.get(server_url + isisL3Obj, headers=headers, verify=False)
                    isisSid = server_url + body.json()['configureSIDIndexLabel'] + '/singleValue'
                    data = {'value': active}
                    requests.patch(isisSid, json=data, headers=headers, verify=False)
                    isis_prefix_sid_active_state = server_url + body.json()['active'] + '/singleValue'
                    data = {'value': isis_prefix_sid_active}
                    requests.patch(isis_prefix_sid_active_state, json=data, headers=headers, verify=False)
        return True

    def modify_traffic_tx_rx_port(self,trafficList,rxPort=None, txPort=None):
        """
        To modify Tx/Rx ports of traffic items
        :param rxPort:Port Name has to be changed for Traffic Item in receiving side. Default: None.
        :param txPort:Port Name has to be changed for Traffic Item in transmitting side. Default: None.
        :param trafficList: Traffic Item to be changed
        Examples:
            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5'],rxPort=['10.39.70.2/3/7'],trafficList=['Traffic Item 1'])
            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5','10.39.70.2/3/6'],rxPort=['10.39.70.2/3/7','10.39.70.2/3/8'],
                                        trafficList=['Traffic Item 1','Traffic Item 2'])
        """
        self.log.info("Modifying Tx and Rx ports of traffic item")
        if rxPort == None and txPort == None:
            self.log.error('rxPort or txPort should be passed')
        rxPortNamesList = []
        txPortNamesList = []
        if rxPort:
            self.log.info(f'Modifying the Rx Port: {rxPort}')
            for eachPort in rxPort:
                if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                    portUpdated = eachPort.replace("/", ":")
                    rx_port_name = self.ixNetwork.Vport.find(AssignedTo='^'+portUpdated+'$').Name
                    rxPortNamesList.append(rx_port_name)
                    rxPort = rxPortNamesList
        if txPort:
            self.log.info(f'Modifying the Tx Port: {txPort}')
            for eachPort in txPort:
                if (re.search(r'\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                    portUpdated = eachPort.replace("/", ":")
                    tx_port_name = self.ixNetwork.Vport.find(AssignedTo='^'+portUpdated+'$').Name
                    txPortNamesList.append(tx_port_name)
                    txPort = txPortNamesList
        if trafficList:
            traffic_list = trafficList
            self.log.info(f'Modifying the Traffic Items: {traffic_list}')
            for traffic_item in traffic_list:
                traffic_item = re.escape(traffic_item)
                traffic_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$')
                if rxPort:
                    try:
                        rxPortDest = []
                        for eachRxPort in rxPort:
                            rxPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href
                            rxPortDestStr = rxPortHref + '/protocols'
                            rxPortDest.append(rxPortDestStr)
                        endPointObj = traffic_obj.EndpointSet.find()
                        endPointObj.Destinations = rxPortDest
                    except:
                        self.log.error('RxPort modification failed')
                if txPort:
                    try:
                        txPortDest = []
                        for eachRxPort in txPort:
                            txPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href
                            txPortDestStr = txPortHref + '/protocols'
                            txPortDest.append(txPortDestStr)
                        endPointObj = traffic_obj.EndpointSet.find()
                        endPointObj.Sources = txPortDest
                    except:
                        self.log.error('TxPort modification failed')
        return True

    def duplicate_traffic_item(self, traffic_item=None, count=1, rename_traffic=None):
        """
        API to duplicate traffic items

        :param traffic_item: Name of traffic item which needs to be duplicated
        :param count: Number of duplicates to be created
        :param rename_traffic: Name of duplicated traffic item to be renamed
        :return True: On success
        Examples:
            duplicate_traffic_item(traffic_item=['traffic(1)','traffic[2]','Traffic Item$'],count=1)
-           duplicate_traffic_item(count=2)
            duplicate_traffic_item(traffic_item='traffic(1)')
            duplicate_traffic_item(rename_traffic='test_new', traffic_item=['test'])
        """
        if isinstance(traffic_item, str):
            traffic_item = [traffic_item]

        if not traffic_item:
            for trafficObj in self.ixNetwork.Traffic.TrafficItem.find():
                trafficObj.Duplicate(arg2=count)
            self.log.info('Duplicates are created for all traffic items {} times'.format(count))
        else:
            self.log.info(f'Duplicating Traffic Items - {traffic_item}')
            for each_traffic in traffic_item:
                trafficList = [trafficObj for trafficObj in self.ixNetwork.Traffic.TrafficItem.find() if
                               (trafficObj.Name == each_traffic)]
                if trafficList:
                    trafficList[0].Duplicate(arg2=count)
                    self.log.info(f'Duplicate item is created for {each_traffic} {count} times')
                if rename_traffic:
                    self.log.info(f'Renaming the Duplicated Traffic Item as - {rename_traffic}')
                    each_traffic = re.escape(each_traffic + ' Copy (1)')
                    new_name = self.ixNetwork.Traffic.TrafficItem.find(Name=f"^{each_traffic}$")
                    new_name.Name = rename_traffic
                else:
                    self.log.error(f'{each_traffic} is not found')
        self.regenerate_traffic()
        return True

    def set_igmp_mld_rate(self, device_type, rate, **kwargs):
        """
        update join rate for IGMP/MLD device
        :param device_type: igmp, mld
        :param rate: rate to be configured
        :param kwargs:
        device_name: name of IGMP/MLD hosts
        device_group_name : device group name
        :return: True on success else raises exception
        :Example: set_igmp_mld_rate(device_type='igmp', rate=4000)
                  set_igmp_mld_rate(device_type='igmp', rate=3000, device_name='IGMP2')
        """
        if device_type.lower() not in ['igmp', 'mld']:
            raise Exception("Invalid device type", device_type)
        vport_dict = {}
        device_name = kwargs.get('device_name', None)
        device_group_name = kwargs.get('device_group_name', None)

        if device_name is None and device_group_name is None:
            # Set IGMP/MLD global values
            rate_count = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Count
            if isinstance(rate, int) or isinstance(rate, float):
                rate = [rate] * rate_count
            elif isinstance(rate, list):
                if len(rate) != rate_count:
                    raise Exception(f"mismatch length between configured {rate_count} and provided {len(rate)}")
            if device_type.lower() == 'igmp':
                self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList(values=rate)
            else:
                self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList(values=rate)
        else:
            if device_type.lower() == 'igmp':
                host = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_group_name).Ethernet.find().Ipv4.find().\
                    IgmpHost.find(Name=device_name)
                rate_values = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Values
                row_names = self.ixNetwork.Globals.Topology.IgmpHost.RowNames
                value_list = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList
            elif device_type.lower() == 'mld':
                host = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_group_name).Ethernet.find().Ipv6.find().\
                    MldHost.find(Name=device_name)
                rate_values = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.Values
                row_names = self.ixNetwork.Globals.Topology.MldHost.RowNames
                value_list = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList
            if len(host) == 0:
                raise Exception("Host not found with device name", device_name)
            for row_name in row_names:
                for vport in self.ixNetwork.Vport.find():
                    if row_name == vport.Name:
                        vport_dict[vport.href] = vport.Name
            for topo_entry in self.ixNetwork.Topology.find():
                if topo_entry.href in host.href:
                    for port_name in topo_entry.Ports:
                        port_index = row_names.index(vport_dict[port_name])
                        rate_values[port_index] = rate
                        value_list(values=rate_values)
            return True

    def _get_stream_ipv4_details(self, config_element):
        """
        Gets the value of the IPv4 headers DF,MF,Protocol and IP options field for the specified traffic items
        :param config_element: Config Element of traffic item
        :return: A list of results containing IPv4 field values for the specified streams
        """
        self.log.info("Getting IPv4 Header details of Traffic Item")
        results = {}
        ipv4_stack = config_element.find().Stack.find(StackTypeId='ipv4')
        if ipv4_stack:
            field_value = ipv4_stack.Field.find(Name='^' + 'fragment_flag' + '$')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='last_fragment_flag')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='source_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='dest_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='protocol')
            results.update({field_value.DisplayName: field_value.FieldValue})
            for ip_option_obj in ipv4_stack.Field.find(FieldTypeId='ipv4.header.options.nextOption.option.'):
                if ip_option_obj and ip_option_obj.ActiveFieldChoice:
                    results.update({ip_option_obj.DisplayName: ip_option_obj.FieldValue})
        else:
            self.log.error('IPv4 Stack is not found in traffic item')
        return results

    def _get_stream_ipv6_details(self, config_element):
        """
        Gets the value of the IPv6 headers Source IP,Destination IP and Next Header
        :param config_element: Config Element of traffic item
        :return: A list of results containing IPv6 field values for the specified streams
        """
        self.log.info("Getting IPv6 Header details of Traffic Item")
        results = {}
        ipv6_stack = config_element.find().Stack.find(StackTypeId='ipv6')
        if ipv6_stack:
            field_value = ipv6_stack.Field.find(Name='source_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv6_stack.Field.find(Name='dest_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv6_stack.Field.find(Name='nextHeader')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.error('IPv6 Stack is not found in traffic item')
        return results

    def _get_stream_icmp_details(self, header_name, config_element):
        """
        Gets the value of the ICMP headers Message Type and Code Options
        :param header_name: header Name for which details to be fetched
        :param config_element: Config Element of traffic item
        :return: A list of results containing ICMP field values for the specified streams
        """
        self.log.info("Getting ICMP Header details of Traffic Item")
        results = {}
        icmp3_code_list = ['Dest. Unreachable code options', 'Src. Quench option', 'Info Request option',
                         'Info Response option', 'Time Exceeded option', 'Redirect Message option']
        if header_name.upper() == 'ICMP3':
            icmp_stack = config_element.find().Stack.find(StackTypeId="^icmpv1$")
            if icmp_stack:
                field_value = icmp_stack.Field.find(Name='msg_type')
                results.update({field_value.DisplayName: field_value.FieldValue})
                for icmp3code in icmp3_code_list:
                    icmp3_code_obj = icmp_stack.Field.find(DisplayName=icmp3code)
                    if icmp3_code_obj and icmp3_code_obj.ActiveFieldChoice:
                        results.update({icmp3_code_obj.DisplayName: icmp3_code_obj.FieldValue})
            else:
                self.log.info('ICMP Msg Type 3,4,5,11,12 Stack is not found in traffic item')
        if header_name.upper() == 'ICMP0':
            icmp_stack = config_element.find().Stack.find(StackTypeId="^icmpv2$")
            if icmp_stack:
                field_value = icmp_stack.Field.find(Name='msg_type')
                results.update({field_value.DisplayName: field_value.FieldValue})
                field_value = icmp_stack.Field.find(Name="Code")
                results.update({field_value.DisplayName: field_value.FieldValue})
                field_value = icmp_stack.Field.find(Name="^id_fier$")
                results.update({field_value.DisplayName: field_value.FieldValue})
            else:
                self.log.error('ICMP Msg Type 0,8,13,14,15,16 Stack is not found in traffic item')
        return results

    def _get_stream_icmpv6_details(self, config_element):
        """
        Gets the value of the ICMPv6 headers Message Type and Code Options
        :param config_element: Config Element of traffic item
        :return: A list of results containing ICMPv6 field value for the specified streams
        """
        self.log.info("Getting ICMPv6 Header details of Traffic Item")
        results = {}
        icmpv6_stack = config_element.find().Stack.find(StackTypeId="^icmpv6$")
        if icmpv6_stack:
            for icmpv6_msg_obj in icmpv6_stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.'):
                if icmpv6_msg_obj.ActiveFieldChoice:
                    results.update({icmpv6_msg_obj.DisplayName: icmpv6_msg_obj.FieldValue})
        else:
            self.log.error('ICMPv6 Stack is not found in traffic item')
        return results

    def _get_stream_tcp_details(self, config_element):
        """
        Gets the value of the TCP header values
        :param config_element: Config Element of traffic item
        :return: A list of results containing TCP field value for the specified streams
        """
        self.log.info("Getting TCP Header details of Traffic Item")
        results = {}
        tcp_stack = config_element.find().Stack.find(StackTypeId="^tcp$")
        if tcp_stack:
            field_value = tcp_stack.Field.find(Name='tcp_src_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
            field_value = tcp_stack.Field.find(Name='tcp_dst_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.info('TCP Stack is not found in traffic item')
        return results

    def _get_stream_udp_details(self, config_element):
        """
        Gets the value of the UDP header values
        :param config_element: Config Element of traffic item
        :return: A list of results containing UDP field value for the specified streams
        """
        self.log.info("Getting UDP Header details of Traffic Item")
        results = {}
        udp_stack = config_element.find().Stack.find(StackTypeId="^udp$")
        if udp_stack:
            field_value = udp_stack.Field.find(Name='udp_src_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
            field_value = udp_stack.Field.find(Name='udp_dst_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.info('UDP Stack is not found in traffic item')
        return results

    def _get_stream_header_list(self, config_element):
        """
        Gets the value of all the traffic item headers configured
        :param config_element: Config Element of traffic item
        :return: A list of Traffic stream headers configured on the specified stream
        """
        self.log.info("Getting Header details of Traffic Item")
        results = [header.DisplayName for header in config_element.Stack.find() if header]
        return results

    def get_traffic_stream_header(self, traffic_item, header_type_list, header_name_list):
        """
        API to get Traffic item header contents like IPv4,IPv6,ICMPv4,ICMPv6
        :param traffic_item: Traffic Item where header is present
        :param header_name_list: header Name for which details to be fetched
        :param header_type_list: header Type for which details to be fetched
        :return True on success otherwise return False
        Ex : get_traffic_stream_header(traffic_item='Traffic Item 1',header_name='ipv4','headerType'='ipv4'))
        """
        self.log.info('Getting traffic item header details')
        header_contents = {}
        traffic_item_name = traffic_item.replace('+', r'\+').replace('*', r'\*')
        traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item_name + '$')
        if not traffic_item_obj:
            raise IxiaConfigException("Traffic item not found")
        for config_element in traffic_item_obj.ConfigElement.find():
            for header_name in header_name_list:
                header_type = header_type_list[header_name_list.index(header_name)]
                if header_type == 'all':
                    result = self._get_stream_header_list(config_element)
                elif header_type == 'ipv4':
                    result = self._get_stream_ipv4_details(config_element)
                elif header_type == 'ipv6':
                    result = self._get_stream_ipv6_details(config_element)
                elif header_type == 'icmp':
                    result = self._get_stream_icmp_details(header_name, config_element)
                elif header_type == 'icmpv6':
                    result = self._get_stream_icmpv6_details(config_element)
                elif header_type == 'tcp':
                    result = self._get_stream_tcp_details(config_element)
                elif header_type == 'udp':
                    result = self._get_stream_udp_details(config_element)
                header_contents.update({header_name: result})
        return header_contents

    def add_rocev2_header(self, traffic_item, destination_qp=None):
        """
        API to add Rocev2 traffic header
        :param traffic_item: List of Traffic Items to add Rocev2 header
        :param destination_qp: Type of data to be passed in custom header like fixed,list,increment,random
        :return True on success otherwise return False
        Example:
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],
                                  destination_qp={'random':{'min':'0x32','max':'ffffff','seed':'111','step':1,'count':100}})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'increment':{'start':'0x16','step':2,'count':100}})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'list':['0x32','0x16']})
                add_rocev2_header(traffic_item=['Traffic Item 1'],destination_qp={'fixed':'0x64'})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'fixed':'0x64'})
        """
        if destination_qp is None:
            destination_qp = {'fixed': 1}
        self.log.info('Adding Rocev2 header')
        for traffic in traffic_item:
            self.add_stream_header(traffic, 'custom', 'custom')
            self.add_stream_header(traffic, 'custom', 'custom')
        self.modify_packet_stream_header(traffic_item_list=traffic_item, cfg_dict={'protocol_name': 'custom', 'custom_length': '40',
                                                                                   'custom_data': '0x640f28403', 'header_index': 0})
        if 'fixed' in destination_qp.keys():
            custom_data = destination_qp['fixed']
        elif 'increment' in destination_qp.keys():
            custom_data = destination_qp['increment']
        elif 'list' in destination_qp.keys():
            custom_data = destination_qp['list']
        elif 'random' in destination_qp.keys():
            custom_data = destination_qp['random']
        else:
            raise IxiaConfigException('Invalid Destination QP value')
        self.modify_packet_stream_header(traffic_item_list=traffic_item, cfg_dict={'protocol_name': 'custom', 'custom_length': '24',
                                                                                   'custom_data': custom_data, 'header_index': 1})
        self.log.info('Traffic Header Rocev2 added successfully with destination QP value')
        return True

    def set_bgp_high_scale_mode(self, bgp="v4", active=True):
        """
        Setting BGP High scale mode in Globals

        :param bgp: BGP v4 or v6 Ex : 'v4'/'v6'
        :param active: operation to be set for High Scale mode Ex : True/False
        :return: True on success else raises exception

        :Example: set_bgp_high_scale_mode(active=False)
                  set_bgp_high_scale_mode(bgp="v6", active=True)
        """
        self.log.info('Setting BGP High Scale Mode')
        if self.tgn_server_type == "linux":
            api_key = self.test_platform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        if bgp.lower() == "v4":
            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv4Peer.href
        if bgp.lower() == "v6":
            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv6Peer.href

        body = requests.get(server_url + bgp_obj, headers=headers, verify=False)
        bgp_scale = server_url + body.json()['highScaleRouteMode'] + '/singleValue'
        data = {'value': active}
        requests.patch(bgp_scale, json=data, headers=headers, verify=False)

    def change_ipv4_diff_serv(self, cfg_dict, traffic_item_list):
        """
        Changes the Diff serv values in ipv4 stacks for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified\n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','singleValue', 'valueList',header_index \n
                'displayName' : 'default','classSelector','assuredForwarding','expeditedForwarding'
                'valueType'   : 'singleValue','valueList'
                Example: cfg_dict={'displayName':'classSelector','valueType':'singleValue','singleValue':'10'}
        :param traffic_item_list: List of traffic Items name. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions
        :Example: change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],
                        cfg_dict={'displayName':'default','valueType':'singleValue','singleValue':'0'})
                  change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],
                  cfg_dict={'displayName':'classSelector','valueType':'valueList','valueList':[16,24],'header_index':2})
        """
        self.log.info("Changing Diff Serv values in IPv4")
        if 'header_index' not in cfg_dict:
            cfg_dict['header_index'] = 1
        header_index = cfg_dict['header_index'] - 1
        diff_serve_hop_dict = {'default': 'Default PHB', 'classSelector': 'Class selector PHB',
                            'assuredForwarding': 'Assured forwarding PHB',
                            'expeditedForwarding': 'Expedited forwarding PHB'}
        if 'displayName' not in cfg_dict.keys():
            class_list = [8,16,24,32,40,48,56]
            if 'singleValue' in cfg_dict.keys():
                diff_value = cfg_dict['singleValue']
            else:
                diff_value = cfg_dict['valueList'][0]

            if diff_value == 0:
                cfg_dict['displayName'] = 'default'
            elif diff_value in class_list:
                cfg_dict['displayName'] = 'classSelector'
            elif diff_value == 46:
                cfg_dict['displayName'] = 'expeditedForwarding'
            else:
                cfg_dict['displayName'] = 'assuredForwarding'
        if 'reserved' not in cfg_dict.keys():
            cfg_dict['reserved'] = '0'

        for traffic_item_name in traffic_item_list:
            traffic_item_modified = re.escape(traffic_item_name)
            for config_element in self.ixNetwork.Traffic.TrafficItem.find(
                    Name='^' + traffic_item_modified + '$').ConfigElement.find():
                if config_element.Stack.find(DisplayName="IPv4"):
                    if cfg_dict['displayName'] in diff_serve_hop_dict.keys():
                        try:
                            stack_obj = config_element.Stack.find(DisplayName="IPv4")[header_index]
                            field_value = stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']])
                            field_value.ActiveFieldChoice = True
                            field_value.ValueType = cfg_dict['valueType']
                            if 'valueList' in cfg_dict['valueType']:
                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),
                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                        cfg_dict['valueList'])
                            elif 'singleValue' in cfg_dict['valueType']:
                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),
                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                        cfg_dict['singleValue'])
                        except Exception as err:
                            raise IxiaConfigException(f"Diff serv value update failed {err}")
                    else:
                        self.log.error('Invalid Diff-Serv hop value')
                    try:
                        stack_obj = config_element.Stack.find(DisplayName="IPv4")[header_index]
                        field_value = stack_obj.Field.find(DisplayName='Reserved')
                        self._update_field_values(field_value, cfg_dict['reserved'])
                    except Exception as err:
                        raise IxiaConfigException(f"Reserved value update failed {err}")
                else:
                    raise IxiaConfigException(f"IPv4 stack is not configured in {traffic_item_name}")
        self.log.info('IPv4 Diff-Serv Values updated in Traffic Items')
        return True

    def get_traffic_frame_size(self, traffic_item_list=None):
        """
        get the frame size of traffic.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :return: True on success else raises exception.

        :Example:
            get_traffic_frame_size(traffic_item_list=['Traffic Item 1'])
        """
        self.log.info("Getting Traffic Frame Size")
        cfg_dict=dict()
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()

        for traffic_name in traffic_item_list:
            traffic_name =  traffic_name.replace('+', r'\+').replace('*', r'\*')
            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' +traffic_name+ '$'):
                streams = traffic.ConfigElement.find()
                for stream in streams:
                    if stream.FrameSize.Type == "fixed":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Frame Size":stream.FrameSize.FixedSize})
                    elif stream.FrameSize.Type == "increment":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Start":stream.FrameSize.IncrementFrom,
                                                                      "End":stream.FrameSize.IncrementTo,"Step":stream.FrameSize.IncrementStep})
                    elif stream.FrameSize.Type == "random":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Random Max":stream.FrameSize.RandomMax,
                                                                      "Random Min":stream.FrameSize.RandomMin})
                    elif stream.FrameSize.Type in ["presetDistribution", "weightedPairs"]:
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,
                                                                      "weighted Range Pairs":stream.FrameSize.WeightedRangePairs})
        return cfg_dict

    def get_traffic_rate(self, traffic_item_list=None):
        """
        get the rate of traffic.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :return: True on success else raises exception.

        :Example:
            get_traffic_rate(traffic_item_list=['Traffic Item 1'])
        """
        self.log.info("Getting Traffic Rate")
        rate_type_dict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',
                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',
                        'percentLineRate': 'lineRate'}
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        cfg_dict = dict()
        for traffic_name in traffic_item_list:
            traffic_name = traffic_name.replace('+', r'\+').replace('*', r'\*')
            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_name + '$'):
                streams = traffic.ConfigElement.find()
                for stream in streams:
                    for frame_rate in stream.FrameRate:
                        if frame_rate.Type == "percentLineRate":
                            cfg_dict.setdefault(traffic_name, []).append({"Rate Type": rate_type_dict[frame_rate.Type],
                                                                          "Rate": str(int(frame_rate.Rate))+"%"})
                        else:
                            cfg_dict.setdefault(traffic_name, []).append({"Rate Type":rate_type_dict[frame_rate.Type],"Rate":frame_rate.Rate})
        return cfg_dict

    def port_ownership(self):
        """
        Function used to clear port ownership and take port ownership
        Forcefully take port ownership of ports owned by other users and connect ports

        :Example:
            port_ownership()
        """
        ports = self.ixNetwork.Vport.find()
        if ports:
            ports.ConnectPorts(arg2=True)
        else:
            self.log.error('No Ports Found or invalid configuration')

    def set_bgp_next_hop(self, network_group, next_hop_type, **kwargs):
        """
        Modifying Next Hop options for BGP protocol.
        :param network_group: represents the network group
        :param next_hop_type: String representing the next hop type(manaul,local_ip)
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_network_group : if nested network group, Need to pass nested_network_group = True
                                if nested_network_group is True 'route_block_name' is mandatory
                ip_type:String representing ip type (ipv4 or ipv6)
                next_hop_ip_type: String representing the next hop ip type(ipv4 or ipv6)
                next_hop_ipv4_adr,String representing next hop ipv4 address
                next_hop_ipv6_adr,String representing next hop ipv6 address
        :return: True if the operation is successful, False otherwise
        :Example:
            set_bgp_next_hop(network_group='Network Group 1',ip_type='ipv6',next_hop_type='manually',
                            next_hop_ipv4_adr='12.24.56.79',next_hop_ipv6_adr='ef12::f23:3')
        """
        ip_type = kwargs.get('ip_type', 'ipv4')
        next_hop_ip_type = kwargs.get('next_hop_ip_type', 'ipv4')
        next_hop_ipv4_adr = kwargs.get('next_hop_ipv4_adr', '0.0.0.0')
        next_hop_ipv6_adr = kwargs.get('next_hop_ipv6_adr', '::')

        self.log.info(f"Setting Bgp Next hop  options for Network Group {network_group}")

        network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
            Name='^' + network_group + '$')

        if network_group_obj:
            return self._modify_bgp_next_hop_options(network_obj=network_group_obj, ip_option=ip_type,
                                                     next_hop_option=next_hop_type,
                                                     next_hop_ip_option=next_hop_ip_type,
                                                     next_hop_ipv4_address=next_hop_ipv4_adr,
                                                     next_hop_ipv6_address=next_hop_ipv6_adr)
        else:
            self.log.error(f"BGP Network Group {network_group} Not Found")

    def _modify_bgp_next_hop_options(self, network_obj, ip_option, next_hop_option, next_hop_ip_option,
                                     next_hop_ipv4_address,
                                     next_hop_ipv6_address):
        """
        This function is used internally
        :param network_obj: Network Group Object
        :param ip_option: IP type of Network group
        :param next_hop_option: String representing the next hop type(manual,local_ip)
        :param next_hop_ip_option: String representing the next hop ip type(ipv4 or ipv6)
        :param next_hop_ipv4_address:next_hop_ipv4_adr,String representing next hop ipv4 address
        :param next_hop_ipv6_address:next_hop_ipv6_adr,String representing next hop ipv6 address
        """
        self.log.info(f"Modifying Bgp Next hop options for Network Group {network_obj.Name}")
        next_hop_type_dict = {'manually': 'manual', 'local_ip': 'sameaslocalip'}
        if ip_option.lower() == 'ipv4':
            if network_obj.Ipv6PrefixPools.find():
                bgp_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find()
            elif network_obj.Ipv4PrefixPools.find():
                bgp_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find()
            else:
                bgp_route_property_obj = None
            if bgp_route_property_obj:
                try:
                    bgp_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])
                    bgp_route_property_obj.NextHopIPType.Single(next_hop_ip_option)
                    bgp_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)
                    bgp_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)
                except:
                    self.log.error('Modification of BGP Next Hop options failed')
            else:
                self.log.error('BGP Network Route is not found in Topology')
        else:
            if network_obj.Ipv6PrefixPools.find():
                bgp_v6_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()
            elif network_obj.Ipv4PrefixPools.find():
                bgp_v6_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()
            else:
                bgp_v6_route_property_obj = None
            if bgp_v6_route_property_obj:
                try:
                    bgp_v6_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])
                    bgp_v6_route_property_obj.NextHopIPType.Single(next_hop_ip_option)
                    bgp_v6_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)
                    bgp_v6_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)
                except:
                    self.log.error('Modification of BGP Next Hop options failed')
            else:
                self.log.error('BGP Network Route is not found in Topology')
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_route_start_address(self, start_address, network_group=None, ip_type='ipv4', **kwargs):
        """
        This API is used for modifying the Network group address count
        :param start_address:Start address of the route to be set
        :param network_group:Network Group name to modify group address Count
        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'
        :param kwargs: Optional arguments
                        nested_network_group: nested network group name If nested network group to be modified
                                              Ex : 'Network Group 1'
        :return: True on success otherwise raise exception

        :Example: modify_route_start_address(start_address = "100.1.1.1", nested_network_group = "Network Group 1")
                  modify_route_start_address(start_address ={'start':"100.1.1.1",'step':'0.0.0.2'}, nested_network_group = "Network Group 1")
                  modify_route_start_address(start_address =["10.1.1.1","20.1.1.1","30.1.1.1"], nested_network_group = "Network Group 1")
        """
        nested_network_group = kwargs.get('nested_network_group', None)
        self.log.info("setting start address for Network Group ")
        # Modify Group start address for Network Group
        if network_group and nested_network_group:
            if ip_type.lower() == 'ipv4':
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$'). \
                        DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
                except:
                    pass

            else:
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$'). \
                        DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
                except:
                    pass

            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start'),
                                                     step_value=cfg_dict.get('step', "0.0.0.1"))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)
        elif network_group is None and nested_network_group:
            if ip_type.lower() == 'ipv4':
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
                except:
                    pass
            else:
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
                except:
                    pass

            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),
                                                     step_value=cfg_dict.get('step', 1))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)
        elif network_group and nested_network_group is None:
            if ip_type.lower() == 'ipv4':
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$').Ipv4PrefixPools.find()
            else:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$').Ipv6PrefixPools.find()
            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),
                                                     step_value=cfg_dict.get('step', 1))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)

        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Network Group start address added Successfully")
        return True

    def get_all_frame_headers(self, stream_name:str):
        """
        This API returns Mac and Ethernet type of given traffic item
        :param stream_name: Stream name where stream header details to be fetched
        :return: Dict of headers frames with field values
        :Example: get_all_frame_headers(stream_name='Traffic_1')
        output: {'header_1_ethernetii': {'dstMac': '01:01:10:00:03:00', 'srcMac': '01:01:20:aa:00:cd', 'etherType': '800'},
        'header_2_ipv4': {'version': '4', 'totalLength': '1500', 'identification': '0', 'fragOffset': '0', 'ttl': '64',
        'protocol': 'IPv6', 'checksum': '0', 'sourceAddr': '10.10.33.60', 'destAddr': '25.66.82.31'},
        'header_3_ipv6': {'version': '6', 'trafficClass': '0', 'flowLabel': '0', 'payloadLength': '1440',
        'nextHeader': 'TCP', 'hopLimit': '64', 'sourceAddr': '120::2', 'destAddr': '140::4'},
        'header_4_tcp': {'sourcePort': 'MSDP', 'destPort': 'LDP', 'ackNum': '0', 'offset': '5', 'reserved': '0',
        'cwrBit': '0', 'ecnBit': '0', 'urgBit': '0', 'ackBit': '1', 'pshBit': '0', 'rstBit': '0', 'synBit': '1',
        'finBit': '0', 'window': '0', 'checksum': '0', 'urgentPtr': '0'},
        'header_5_udp': {'sourcePort': 'RIP', 'destPort': 'NTP'},
        'header_6_gre': {'keyPresent': '0:No Key field', 'seqNumPresent': '0:No sequence number field',
        'reserved0': '0', 'version': '0', 'protocolType': '8100'},
        'header_7_vlan': {'vlanPriority': '1', 'vlanCfi': '0', 'vlanId': '6', 'vlanProtocol': '8100'}}
        """
        self.log.info(f'Fetching headers from traffic stream: {stream_name}')

        ethernet_field_dict = {'destinationAddress': 'dstMac', 'ether_type': 'etherType', 'sourceAddress': 'srcMac'}

        ipv4_field_dict = {'checksum': 'checksum', 'dest_ip': 'destAddr', 'fragment_offset': 'fragOffset',
                           'total_len': 'totalLength',
                           'protocol': 'protocol', 'source_ip': 'sourceAddr', 'identification': 'identification',
                           'ttl': 'ttl', 'version': 'version'}

        gre_field_dict = {'sequence_present': 'seqNumPresent', 'key_present': 'keyPresent', 'reserved0': 'reserved0',
                          'protocol': 'protocolType', 'version': 'version'}

        tcp_field_dict = {'u_bit': 'urgBit', 'protocol': 'protocolType', 's_bit': 'synBit', 'r_bit': 'rstBit',
                          'c_bit': 'cwrBit', 'p_bit': 'pshBit', 'a_bit': 'ackBit', 'f_bit': 'finBit', 'e_bit': 'ecnBit',
                          'ack_num': 'ackNum', 'reserved': 'reserved', 'seqNum': 'seq_num', 'data_offset': 'offset',
                          'tcp_src_prt': 'sourcePort', 'tcp_dst_prt': 'destPort',
                          'tcp_window': 'window', 'tcp_checksum': 'checksum', 'urgent_ptr': 'urgentPtr'}

        udp_field_dict = {'udp_src_prt': 'sourcePort', 'udp_dst_prt': 'destPort'}

        ipv6_field_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit',
                           'flowLabel': 'flowLabel', 'source_ip': 'sourceAddr', 'trafficClass': 'trafficClass',
                           'version': 'version', 'dest_ip': 'destAddr',
                           'nextHeader': 'nextHeader'}
        vlan_field_dict = {'vlan_user_priority': 'vlanPriority', 'vlan_id': 'vlanId', 'vlan_cfi': 'vlanCfi',
                           'vlan_tag_type': 'vlanProtocol'}

        regex_dict = {'ethernet': ethernet_field_dict, 'ipv4$': ipv4_field_dict, 'ipv6$': ipv6_field_dict,
                      'gre': gre_field_dict,
                      'tcp': tcp_field_dict, 'udp': udp_field_dict, 'vlan$': vlan_field_dict}

        header_contents = {}
        field_dict = {}
        stream_name = re.escape(stream_name)
        stream_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{stream_name}$')
        if not stream_item_obj:
            raise IxiaConfigException("Traffic item not found")

        for index, stack in enumerate(stream_item_obj.ConfigElement.find().Stack.find(), start=1):
            stack_name = 'header_' + str(index) + '_' + stack.DisplayName.lower().replace(' ', '')
            header_contents.update({stack_name: {}})
            for pattern in regex_dict.keys():
                if re.search(pattern, stack_name):
                    field_dict = regex_dict[pattern]
                    break

            if field_dict:
                for field in stack.Field.find():
                    if field.Name in field_dict.keys():
                        header_contents[stack_name].update({field_dict[field.Name]: field.FieldValue})
        return header_contents

    def get_values_from_captured_packets(self, pcap_filename: AnyStr, header: str = 'ipv4', pkt_mode: str = "random",
                                         pkt_num: int = None, random_check_till_ip: int = 5):
        """
        Used to fetch source and destination IP and TCP MSS value from the captured packet file.
        :param pcap_filename: Packet capture file name with location
        :param header: IP header type Ex : "ipv4" or "ipv6"
        :param pkt_mode: options are "random" and "fixed", default: "random"
        If set "random" - one random packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,
        If the packet is IP packet, returns source and destination MAC.
        If the packet is ARP packet, another random packet is picked and process repeats for "random_check_till_ip" number of times
        If set "fixed" - packet with packet number="pkt_num" is used to fetch src and dst mac.
        :param pkt_num: packet with packet number="pkt_num" is used to fetch src and dst mac. Only when pkt_mode is "fixed"
        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.

        Example: output = get_values_from_captured_packets(pcap_filename='sampledata1.pcap')
                 output : { 'dst_ip': '2303:d01:148::c001:201:48',
                            'dst_mac': '00:12:01:00:00:01',
                            'src_ip': '3303:d01:1122:404:6:200::',
                            'src_mac': 'c4:b2:39:ec:35:34',
                            'tcp_mss': '05a6'}
        """
        ret_header_values = {}
        packets = []
        header = header.lower()
        if pcap_filename:
            with open(pcap_filename, 'rb') as pcap_file:
                for _, pkt in dpkt.pcap.Reader(pcap_file):
                    packets.append(pkt)
            if pkt_mode.lower() == "random":
                for count in range(random_check_till_ip):
                    self.log.info(f'Try: {count}')
                    pkt_num = random.randrange(1, len(packets))
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    ethernet = Ether(packets[int(pkt_num)])
                    if isinstance(eth.data, dpkt.ip.IP) and header == "ipv4" or isinstance(eth.data, dpkt.ip6.IP6) and header == "ipv6":
                        ret_header_values['src_mac'] = ethernet.src
                        ret_header_values['dst_mac'] = ethernet.dst
                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)
                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)

                        try:
                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)
                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)
                        except:
                            pass

                        try:
                            tcp_mss = '.'.join(f'{x: 02x}' for x in eth.data.data.opts).split(".")[-2::]
                            if tcp_mss:
                                ret_header_values['tcp_mss'] = "".join([str(item) for item in tcp_mss])
                        except:
                            pass
                        break
                    else:
                        raise IxiaConfigException(f'No IP packet found after tries: {random_check_till_ip}')
            elif pkt_mode.lower() == "fixed":
                if pkt_num:
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    ethernet = Ether(packets[int(pkt_num)])
                    if not isinstance(eth.data, dpkt.ip.IP) and header == "ipv4":
                        raise CafyException.TgenInvalidInputError(f'Packet is not an IP packet: {pkt_num}')
                    elif not isinstance(eth.data, dpkt.ip6.IP6) and header == "ipv6":
                        raise CafyException.TgenInvalidInputError(f'Packet is not an IPv6 packet: {pkt_num}')
                    else:
                        ret_header_values['src_mac'] = ethernet.src
                        ret_header_values['dst_mac'] = ethernet.dst
                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)
                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)
                        try:
                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)
                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)
                        except:
                            pass
                        try:
                            tcp_mss = '.'.join(f'{x:02x}' for x in eth.data.data.opts).split(".")[-2::]
                            if tcp_mss:
                                ret_header_values['tcp_mss'] = "".join([str(item) for item in tcp_mss])
                        except:
                            pass
                else:
                    raise CafyException.TgenInvalidInputError(f'pkt_mode fixed is must for: {pkt_num}')
        else:
            raise CafyException.TgenInvalidInputError(f'mandatory parameter: {pcap_filename}')
        return ret_header_values

    def get_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None):
        """
        The API returns the SRV6 OAM session status, My discriminator, Peer Discriminator,
        TX Interval, Timeout multiplier, Reply source address and Session ID  for the given router ids

        :param device_name: SRV6OAM device name
        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their corresponding SRV6OAM session status

        :Example: get_srv6_oam_parameters(device_name = "PE1",router_ids=['192.0.0.1','192.0.0.5'])
        """
        router_id_status_mapping = dict()
        self.log.info(f"Getting SRV6OAM session status for device {device_name}")

        try:
            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
        except:
            self.log.error("Device Group Not Found")

        try:
            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId
            session_status_list =  ipv6_obj.Srv6Oam.find().SessionStatus
            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values
            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values
            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values
            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values
            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values

            if router_ids:
                for router_id in router_ids:
                    if router_id in router_id_list:
                        router_id_index = router_id_list.index(router_id)
                        value_dict = dict()
                        value_dict.setdefault('session_status' , session_status_list[router_id_index])
                        value_dict.setdefault('my_discriminator' , my_discriminator_list[router_id_index])
                        value_dict.setdefault('peer_discriminator', peer_discriminator_list[router_id_index])
                        value_dict.setdefault('tx_interval', tx_interval_list[router_id_index])
                        value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[router_id_index])
                        value_dict.setdefault('reply_source_address', reply_source_address_list[router_id_index])
                        value_dict.setdefault('session_id', router_id_index + 1)
                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)
            else:
                for index, router_id in enumerate(router_id_list):
                    value_dict = dict()
                    value_dict.setdefault('session_status', session_status_list[index])
                    value_dict.setdefault('my_discriminator', my_discriminator_list[index])
                    value_dict.setdefault('peer_discriminator', peer_discriminator_list[index])
                    value_dict.setdefault('tx_interval', tx_interval_list[index])
                    value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[index])
                    value_dict.setdefault('reply_source_address', reply_source_address_list[index])
                    value_dict.setdefault('session_id', index + 1)
                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)
        except:
            self.log.error("Device Group or SRV6OAM config Not Found")
        return router_id_status_mapping

    def set_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None,
                                sbfd_initiator : Optional[List[str]] = None, my_discriminator: Optional[List[str]] = None,
                                peer_discriminator: Optional[List[str]] = None, tx_interval: Optional[List[str]] = None,
                                timeout_multiplier: Optional[List[str]] = None, reply_source_address: Optional[List[str]] = None,
                                reply_source_address_mode: Optional[str] = None, reply_source_address_step: Optional[str] = None):
        """
        The API sets the SRV6 OAM parameters like My discriminator, Peer Discriminator,
        TX Interval, Timeout multiplier, Reply source address for the given router ids

        :param device_name: SRV6OAM device name
        :param router_ids: List of router_ids
        :param sbfd_initiator: SRV6 OAM s-bfd_initiator to be enabled or disabled Ex : s-bfd_initiator = "True" or "False"
        :param my_discriminator: SRV6 OAM my discriminator to be set on the device Ex : my_discriminator = ["1000000"]
        :param peer_discriminator: SRV6 OAM peer discriminator to be set on the device Ex : peer_discriminator = ["1999999"]
        :param tx_interval: SRV6 OAM tx interval to be set on the device Ex : tx_interval = ["50"]
        :param timeout_multiplier: SRV6 OAM timeout multiplier to be set on the device Ex : timeout_multiplier = ["3"]
        :param reply_source_address: SRV6 OAM reply source address to be set on the device Ex : reply_source_address = ["5000:0:0:1:0:0:0:0"]
        :param reply_source_address_mode: SRV6 OAM reply source address mode type to be set Ex : reply_source_address = 'increment' or 'decrement'
        :param reply_source_address_step: SRV6 OAM reply source address step to be set on the device Ex : reply_source_address = "::0.0.0.1"
        :return: True on success else raises exception

        :Example: set_srv6_oam_parameters(device_name = "PE1",router_ids = ['192.0.0.1','192.0.0.4','192.0.0.5'],
                                           sbfd_initiator = ['True','False','True'],
                                           my_discriminator = ["100","200","300"], peer_discriminator = ["199","299","399"],
                                           tx_interval = ["10","20","30"], timeout_multiplier = ["3","6","9"],
                                           reply_source_address = ["1000:0:0:1:0:0:0:0","2000:0:0:1:0:0:0:0","3000:0:0:1:0:0:0:0"])
        """
        self.log.info(f"Setting SRV6OAM session status for device {device_name}")

        try:
            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
        except:
            self.log.error("Device Group Not Found")

        if ipv6_obj.Srv6Oam.find():
            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId
            sbfd_initiator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Values
            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values
            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values
            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values
            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values
            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values
        else:
            self.log.error("SRV6OAM config Not Found")

        if router_ids:
            for index,router_id in enumerate(router_ids):
                if router_id in router_id_list:
                    router_id_index = router_id_list.index(router_id)
                    if sbfd_initiator:
                        sbfd_initiator_list[router_id_index] = sbfd_initiator[index].lower()
                    if my_discriminator:
                        my_discriminator_list[router_id_index] = my_discriminator[index]
                    if peer_discriminator:
                        peer_discriminator_list[router_id_index] = peer_discriminator[index]
                    if tx_interval:
                        tx_interval_list[router_id_index] = tx_interval[index]
                    if timeout_multiplier:
                        timeout_multiplier_list[router_id_index] = timeout_multiplier[index]
                    if reply_source_address:
                        reply_source_address_list[router_id_index] = reply_source_address[index]

            if sbfd_initiator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.ValueList(
                    values=sbfd_initiator_list)
            if my_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.ValueList(
                    values=my_discriminator_list)
            if peer_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.ValueList(
                    values=peer_discriminator_list)
            if tx_interval:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.ValueList(values=tx_interval_list)
            if timeout_multiplier:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.ValueList(
                    values=timeout_multiplier_list)
            if reply_source_address:
                ipv6_obj.Srv6Oam.find().RxSrcAddr.ValueList(values=reply_source_address_list)
        else:
            if sbfd_initiator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Single(sbfd_initiator[0].lower())
            if my_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Single(my_discriminator[0])
            if peer_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Single(peer_discriminator[0])
            if tx_interval:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Single(tx_interval[0])
            if timeout_multiplier:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Single(timeout_multiplier[0])
            if reply_source_address and reply_source_address_mode:
                if reply_source_address_mode.lower() == 'increment':
                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Increment(reply_source_address[0], reply_source_address_step)
                elif reply_source_address_mode.lower() == 'decrement':
                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Decrement(reply_source_address[0], reply_source_address_step)
            if reply_source_address and not reply_source_address_mode:
                ipv6_obj.Srv6Oam.find().RxSrcAddr.Single(reply_source_address[0])

        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)
        return True

    def _update_traffic_stream_frame_size(self, traffic_item_info: Dict, traffic_item, rate_type_dict: Dict):
        """
        This is an internal API to update frame size for specific traffic item
        :param traffic_item_info: config sent from user
        :param traffic_item: traffic item restpy object
        :param rate_type_dict: mapping dict to map rate type values
        """
        try:
            if traffic_item_info.get('type', None) in ['BITS_PER_SECOND', 'KILOBITS_PER_SECOND', 'MEGABITS_PER_SECOND',
                                                       'BYTES_PER_SECOND', 'KILOBYTES_PER_SECOND',
                                                       'MEGABYTES_PER_SECOND']:
                traffic_item.ConfigElement.find().FrameRate.find().BitRateUnitsType = rate_type_dict[
                    traffic_item_info['type']]

                if traffic_item_info.get('rate', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')

                if traffic_item_info.get('type', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Type = 'bitsPerSecond'
            else:
                if traffic_item_info.get('rate', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')
                if traffic_item_info.get('type', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Type = rate_type_dict[
                        traffic_item_info.get('type')]
        except Exception as err_msg:
            raise IxiaConfigException(f"failed to set frame rate param. exited with error message {err_msg}")

    def modify_bulk_streams(self, cfg_dict: Dict):
        """
        The API modifies frame rate (currently supported)
        :param cfg_dict: dictionary of traffic streams along with its attributes and values to be modified

        Examples:
        cfg_dict = {'V4_SM_BSR_RP_R3_Src': {'rate': 100,'type':'FRAMES_PER_SECOND'}}
        tgnObj.modify_bulk_streams(cfg_dict)

        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'PERCENT_LINE_RATE'}}
        tgnObj.modify_bulk_streams(cfg_dict)

        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'BITS_PER_SECOND'}}
        tgnObj.modify_bulk_streams(cfg_dict)
        """
        if StubitUtil.is_stubit_playback():
            log.info(f"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}")
            return

        rate_type_dict = {'BITS_PER_SECOND': 'bitsPerSec', 'KILOBITS_PER_SECOND': 'kbitsPerSec',
                          'MEGABITS_PER_SECOND': 'mbitsPerSec', 'BYTES_PER_SECOND': 'bytesPerSec',
                          'KILOBYTES_PER_SECOND': 'kbytesPerSec', 'MEGABYTES_PER_SECOND': 'mbytesPerSec',
                          'FRAMES_PER_SECOND': 'framesPerSecond', 'PERCENT_LINE_RATE': 'percentLineRate'}

        cfg_list = [{key: value} for key, value in cfg_dict.items()]
        for _, traffic_item_info in enumerate(cfg_list):
            stream_name = list(traffic_item_info.keys())[0]
            traffic_items = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name)
            if len(traffic_items) == 0:
                raise IxiaConfigException("invalid traffic stream name specified or traffic stream not found. exiting")

            with BatchUpdate(self.ixNetwork):
                for _, traffic_item in enumerate(traffic_items):
                    if traffic_item.Name == stream_name:
                        config = list(traffic_item_info.values())[0]
                        self._update_traffic_stream_frame_size(config, traffic_item, rate_type_dict)
        return True

    def save_config(self, file:str = None) -> str:
        """
        This API exports the loaded config to specified JSON file
        :param file: path name of the JSON file to be saved locally
        :return: (str) filename with full path to which config is saved to
        exception if error occurs
        """

        if not file:
            timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            file = os.path.join(CafyLog.work_dir, f"tgnconfig-{timestamp}.json")

        if not file.endswith('.json'):
            raise IxiaConfigException("Need JSON file name as part of user input")

        tgn_file_path = self.ixNetwork.Globals.ConfigFileName
        if self.tgn_server_type == 'windows':
            if '/' in tgn_file_path:
                common_path = "sdmStreamManager\\common\\"
                json_file = os.path.split(file)[1]
                remote_file_path = os.path.split(tgn_file_path)[0].replace('IxNetwork', common_path) + json_file
            elif '\\' in tgn_file_path:
                tgn_file_path = tgn_file_path.replace("\\", "/")
                json_file = os.path.split(file)[1]
                remote_file_path = os.path.split(tgn_file_path)[0] + "/" + json_file
        elif self.tgn_server_type == 'linux':
            common_path = "sdmStreamManager/common/"
            json_file = os.path.split(file)[1]
            remote_file_path = os.path.split(tgn_file_path)[0] + "/" + json_file

        try:
            self.ixNetwork.ResourceManager.ExportConfigFile(["/descendant-or-self::*"], True, "json", Files(json_file))
            self.session.DownloadFile(remote_file_path, file)
        except Exception as err_msg:
            raise CafyException.TgenClientError(err_msg)

        log.info(f'Configuration file {file} saved successfully.')
        return file

    def get_modifiers_count(self, traffic_item):
        """
        Allows users to extract the Modifiers and its count in any field of Streamblock
        :param traffic_item: Traffic Item Name (String type) for which modifiers and count is required
        :return: Dictionary of Modifiers along with its respective count
        """
        modifier_dict = {}
        ethernet_field_dict = {'destinationAddress': 'dstMac', 'ether_type': 'etherType', 'sourceAddress': 'srcMac'}

        ipv4_field_dict = {'checksum': 'checksum', 'dest_ip': 'destAddr', 'fragment_offset': 'fragOffset',
                           'total_len': 'totalLength',
                           'protocol': 'protocol', 'source_ip': 'sourceAddr', 'identification': 'identification',
                           'ttl': 'ttl', 'version': 'version'}
        ipv6_field_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit',
                           'flowLabel': 'flowLabel', 'source_ip': 'sourceAddr', 'trafficClass': 'trafficClass',
                           'version': 'version', 'dest_ip': 'destAddr',
                           'nextHeader': 'nextHeader'}
        tcp_field_dict = {'u_bit': 'urgBit', 'protocol': 'protocolType', 's_bit': 'synBit', 'r_bit': 'rstBit',
                          'c_bit': 'cwrBit', 'p_bit': 'pshBit', 'a_bit': 'ackBit', 'f_bit': 'finBit', 'e_bit': 'ecnBit',
                          'ack_num': 'ackNum', 'reserved': 'reserved', 'seqNum': 'seq_num', 'data_offset': 'offset',
                          'tcp_src_prt': 'sourcePort', 'tcp_dst_prt': 'destPort',
                          'tcp_window': 'window', 'tcp_checksum': 'checksum', 'urgent_ptr': 'urgentPtr'}
        udp_field_dict = {'udp_src_prt': 'sourcePort', 'udp_dst_prt': 'destPort'}
        mpls_field_dict = {'mpls_label_value': 'label', 'mpls_exp': 'exp', 'mpls_bos': 'sBit', 'mpls_ttl': 'ttl'}
        gre_field_dict = {'sequence_present': 'seqNumPresent', 'key_present': 'keyPresent'}

        regex_dict = {'ethernetii': ethernet_field_dict, 'ipv4': ipv4_field_dict, 'ipv6': ipv6_field_dict,
                      'tcp': tcp_field_dict, 'udp': udp_field_dict, 'mpls': mpls_field_dict, 'gre': gre_field_dict}

        traffic_item_modified = re.escape(traffic_item)
        traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_modified}$')
        if not traffic_item_obj:
            raise IxiaConfigException("Traffic Item not found")

        for stack in traffic_item_obj.ConfigElement.find().Stack.find():
            stack_name = stack.DisplayName.lower().replace(' ', '')
            stack_index=1
            if stack_name in regex_dict.keys():
                field_dict = regex_dict[stack_name]
            else:
                field_dict = {}

            for stack_key in modifier_dict.keys():
                if re.search(stack_name, stack_key):
                    stack_index += 1

            stack_name = stack_name + '_' + str(stack_index)
            if field_dict:
                for field in stack.Field.find():
                    if field.ValueType in ('increment', 'decrement', 'random', 'repeatableRandomRange'):
                        if field.Name in field_dict:
                            modifier_dict.update({stack_name + '.' + field_dict[field.Name]: field.CountValue})
        self.log.info(f"Modified fields and its respective count for the Traffic Item: '{traffic_item}' is: {modifier_dict}")
        return modifier_dict

    def change_port_aggregation_mode(self, port_list, port_mode=None):
        """
        Allows users to modify Card mode of a chassis
        :param port_list: List of ports on which port mode to be modified
        :param port_mode:Mode to be set for port_list, if None port aggregate mode will set on HighStream of same speed
        :return True on success otherwise return False
        :Example:change_port_aggregation_mode(port_list=['10.39.65.236/2/3'], port_mode='1x100GE')
        """
        self.log.info(f"Changing port mode for ports: {port_list}")
        port_mode_dict = {'1x100GE': 'novusHundredGigNonFanOut', '4x25GE': 'novusFourByTwentyFiveGigNonFanOut',
                          '1x40GE': 'novusOneByFortyGigNonFanOut', '4x10GE': 'novusFourByTenGigNonFanOut',
                          '1x100GE_high': 'novusHundredGigNonFanOutHighStream',
                          '4x25GE_high': 'novusFourByTwentyFiveGigNonFanOutHighStream',
                          '1x40GE_high': 'novusOneByFortyGigNonFanOutHighStream',
                          '4x10GE_high': 'novusFourByTenGigNonFanOutHighStream'}

        port_aggregate_dict = {
                          'novusHundredGigNonFanOut': 'novusHundredGigNonFanOutHighStream',
                          'novusFourByTwentyFiveGigNonFanOut': 'novusFourByTwentyFiveGigNonFanOutHighStream',
                          'novusOneByFortyGigNonFanOut': 'novusOneByFortyGigNonFanOutHighStream',
                          'novusFourByTenGigNonFanOut': 'novusFourByTenGigNonFanOutHighStream'}

        assigned_chassis = port_list[0].split("/")[0]
        connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find()]
        if assigned_chassis not in connected_chassis_list:
            self.connect_to_chassis([assigned_chassis])

        for port in port_list:
            assigned_card = port.split("/")[1]
            assigned_port = port.split("/")[2]

            try:
                card_obj = self.ixNetwork.AvailableHardware.find().Chassis.find(Hostname=assigned_chassis).Card.find(CardId='^' + assigned_card + '$')
                if not re.search(r'FAN\D+\d+', card_obj.Description, re.IGNORECASE):
                    assigned_port = str(int(assigned_port) - 1)
                if port_mode in port_mode_dict.keys():
                    pattern = r"\b" + re.escape('FAN+') + r"\b"
                    if re.search(pattern, card_obj.Description, re.IGNORECASE):
                        port_url = card_obj.href + '/port/' + assigned_port
                        for res_grp in card_obj.Aggregation.find():
                            if port_url in res_grp.ResourcePorts:
                                port_obj = res_grp
                    else:
                        port_url = card_obj.href + '/aggregation/' + assigned_port
                        port_obj = card_obj.Aggregation.read(port_url)

                    if port_mode_dict[port_mode] in port_obj.AvailableModes:
                        port_obj.Mode = port_mode_dict[port_mode]
                        self.log.info(f'Port mode modified for {port} successfully')
                        result = True
                    else:
                        self.log.warning(f'{port_mode} is not supported for Port {port}')
                        result = False
                else:
                    pattern = r"\b" + re.escape('FAN+') + r"\b"
                    if re.search(pattern, card_obj.Description, re.IGNORECASE):
                        port_url = card_obj.href + '/port/' + assigned_port
                        for res_grp in card_obj.Aggregation.find():
                            if port_url in res_grp.ResourcePorts:
                                port_obj = res_grp
                    else:
                        port_url = card_obj.href + '/aggregation/' + assigned_port
                        port_obj = card_obj.Aggregation.read(port_url)

                    if port_obj.Mode in port_aggregate_dict.keys():
                        port_obj.Mode = port_aggregate_dict[port_obj.Mode]
                        result = True
                        self.log.info(f'Port mode modified for {port} successfully')
                    else:
                        self.log.info(f'Port {port} is already in high stream mode')
                        result = False

            except:
                self.log.error(f'Port mode is not supported {port}')
                result = False
        return result

    def set_bgp_evi_count(self, devices, evi_count, ip_type='ipv4', nested_devices=None):
        """
        API to set the BGP EVPN EVI Count
        :param devices: List of devices for which EVI multiplier to be set
        :param evi_count: EVI multiplier value
        :param ip_type: IPv4/IPv6 - default is IPv4
        :param nested_devices: List of nested devices where EVI multiplier to be set
        :return: True on success otherwise return False
        :Example: set_bgp_evi_count(devices=['SAP-VCP-EVPN','CSR-EVPN'],evi_count=400)
        set_bgp_evi_count(devices='SAP-BL-Term-RAN',evi_count=100,ip_type='ipv6')
        """
        self.log.info('Modifying BGP EVI Multiplier')
        if isinstance(devices, str):
            devices = [devices]
        if isinstance(nested_devices,str):
            nested_devices = [nested_devices]
        if devices and nested_devices is None:
            for device in devices:
                device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
                if device_obj:
                    try:
                        if ip_type == 'ipv4':
                            device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpEthernetSegmentV4.find().EvisCount = evi_count
                        else:
                            device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpEthernetSegmentV6.find().EvisCount = evi_count
                    except:
                        self.log.info(f'Multiplier Modification failed for {device_obj.Name}')
                        return False
                else:
                    self.log.info(f'Device Group {device} is not found')
                    return False
        elif devices and nested_devices:
            for device in devices:
                for nested_device in nested_devices:
                    device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + device + '$').NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                    if device_obj:
                        try:
                            if ip_type == 'ipv4':
                                device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpEthernetSegmentV4.find().EvisCount = evi_count
                            else:
                                device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpEthernetSegmentV6.find().EvisCount = evi_count
                        except:
                            self.log.info(f'Multiplier Modification failed for {device_obj.Name} ')
                            return False
                    else:
                        self.log.info(f'Device Group {nested_device} in {device} is not found')
                        return False
        return True

    def enable_bgp_evi(self, devices, enable=True, ip_type='ipv4'):
        """
        API to enable the BGP Evpn EVI
        :param devices: List of devices to be enabled
        :param enable: True to Enable and False to disable EVI,default is True
        :param ip_type: IPv4/IPv6,default value IPv4
        :return: True on success otherwise return False
        :Example: enable_bgp_evi(devices='SAP-VCP-EVPN')
        enable_bgp_evi(devices=['SAP-VCP-EVPN','CSR-EVPN'],enable=False)
        """
        self.log.info('Enable/Disable BGP EVI')
        if isinstance(devices, str):
            devices = [devices]
        for device in devices:
            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
            if device_obj:
                try:
                    if ip_type == 'ipv4':
                        device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find().Active.Single(enable)
                    else:
                        device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find().Active.Single(enable)
                except:
                    self.log.info(f'Enable/Disable EVI failed for {device_obj.Name}')
                    return False
            else:
                self.log.info(f'Device Group {device} not found')
                return False
        return True

    def modify_bgp_evi_rd(self, devices, ip_type='ipv4', **kwargs):
        """
        API to modify BGP EVPN RD
        :param devices:List of devices for which RD values to be modified
        :param ip_type:IPv4/IPv6,default value IPv4
        :param kwargs:
        rd_type :RD Types ip/as/as4,default is ip
        auto_config_rd:Auto-Configure RD IP Addresses True/False,default is False
        rd_ip: RD IP Addresses for RD device,default is 0.0.0.0
        rd_as: RD AS Number of device,default is 100
        rd_evi_start: RD EVI start value of device,default is 1
        rd_evi_step: RD EVI step value of device,default is 1
        :return:True on success otherwise return False
        :Example: modify_bgp_evi_rd(devices=['SAP-VCP'],rd_type='as4',rd_evi_step=2,rd_ip='12.20.10.21',rd_evi_start=5,auto_config_rd=True,rd_as=40)
        modify_bgp_evi_rd(devices='SAP-BL-Term-RAN',rd_type='as',rd_evi_step=2,ip_type='ipv6')
        """
        self.log.info('Modifying BGP EVI RD values')
        rd_type = kwargs.get('rd_type', 'ip')
        auto_config_rd = kwargs.get('auto_config_rd', False)
        rd_ip = kwargs.get('rd_ip', '0.0.0.0')
        rd_as = kwargs.get('rd_as', 100)
        rd_evi_start = kwargs.get('rd_evi_start', 1)
        rd_evi_step = kwargs.get('rd_evi_step', 1)

        if isinstance(devices, str):
            devices = [devices]
        for device in devices:
            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
            if device_obj:
                try:
                    if ip_type == 'ipv4':
                        rd_obj = device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find()
                    else:
                        rd_obj = device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find()

                    rd_obj.RdType.Single(rd_type)
                    rd_obj.RdIpAddress.Single(rd_ip)
                    rd_obj.RdASNumber.Single(rd_as)
                    rd_obj.AutoConfigureRdIpAddress.Single(auto_config_rd)
                    rd_obj.RdEvi.Increment(rd_evi_start, rd_evi_step)
                    self.log.info(f'BGP EVI RD values are modified successfully for {device_obj.Name}')
                except:
                    self.log.info(f'Modification of BGP EVI RD values failed for {device_obj.Name}')
                    return False
            else:
                self.log.info(f'Device Group {device} not found')
                return False
        return True

    def modify_bgp_evi_rt(self, devices, ip_type='ipv4', **kwargs):
        """
        API to modify BGP EVPN RT
        :param devices:List of devices for which RD values to be modified
        :param ip_type:IPv4/IPv6,default value IPv4
        :kwargs:
        rt_kind:RT kind for which to be modified like import,l3_import,export and l3_export,default is import
        rt_count:Number of RTs,default is 1
        rt_type: RT Type for EVI like as/as4/ip,default is as
        :Examples:modify_bgp_evi_rt(devices=['SAP-VCP-EVPN','CSR-EVPN'])
        modify_bgp_evi_rt(devices=['SAP-VCP-EVPN','CSR-EVPN'],rt_count=2,rt_type='as4')
        """
        self.log.info('Modifying BGP EVI RT values')
        rt_kind = kwargs.get('rt_kind', 'export')
        rt_count = kwargs.get('rt_count', 1)
        rt_type = kwargs.get('rt_type', 'as')
        rt_kind_dict = {'import': 'NumRtInImportRouteTargetList', 'export': 'NumRtInExportRouteTargetList',
                        'l3_import': 'NumRtInL3vniImportRouteTargetList',
                        'l3_export': 'NumRtInL3vniExportRouteTargetList'}
        if isinstance(devices, str):
            devices = [devices]
        for device in devices:
            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
            if device_obj:
                try:
                    if ip_type == 'ipv4':
                        rt_obj = device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find()
                    else:
                        rt_obj = device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find()

                    if rt_kind in rt_kind_dict.keys():
                        setattr(rt_obj, rt_kind_dict[rt_kind], rt_count)
                        for each_rt_type in rt_obj.BgpExportRouteTargetList.find():
                            each_rt_type.TargetType.Single(rt_type)
                    else:
                        self.log.info('Invalid RT Type')
                except:
                    self.log.info(f'Modification of BGP EVI RT attributes failed for {device_obj.Name}')
                    return False
            else:
                self.log.info(f'Device Group {device} not found')
                return False
        return True

    def get_stream_details(self, tgn_config_file: str) -> List[Dict[str, Any]]:
        """
        utility to parse ixia config in json format and get details about streams
        1. flow type : L2 unicast, L2 mcast, L2 bcast, L3 ucast, L3 mcast, L3 bcast
        2. encaps in the stream
        3. flow rate : rate, rate_unit
        4. packet size : imix/custom/fixed..

        :param tgn_config_file: json file containing ixia config
        :return : (dict) stream details
        """

        try:
            with open(tgn_config_file, "r") as inf:
                stream_data = json.load(inf)
        except Exception as error:
            msg = f"Could not parse file {tgn_config_file}. Error {str(error)}"
            log.error(msg)
            raise CafyException.TgenInvalidInputError(msg) from error

        stream_details = []
        for traffic_item in stream_data["traffic"]["trafficItem"]:
            encap_list = []
            temp_stream_details = {}
            temp_stream_details["name"] = traffic_item.get("name", "Unknown")
            for config_element in traffic_item["configElement"]:
                for encaps in config_element["stack"]:
                    xpath = encaps["xpath"]
                    encap_name = xpath.split(" = ")[1].strip("'").split("-")[0]
                    encap_list.append(encap_name)
                    dest_addr_ip_version = None
                    if encap_name.lower() == "ipv4":
                        dest_addr_ip_version = "ipv4"
                    elif encap_name.lower() == "ipv6":
                        dest_addr_ip_version = "ipv6"
                    elif encap_name.lower() == "ethernet":
                        for field in encaps["field"]:
                            if "ethernet.header.destinationaddress" in field["xpath"].lower():
                                if "valueType" in field:
                                    if field["valueType"] in ["increment", "decrement"]:
                                        temp_stream_details["l2_dest_addr"] = field["startValue"]
                                        temp_stream_details["l2_dest_type"] = Helper.get_addr_type_mac(field["startValue"])
                                    elif field["valueType"] == "valueList":
                                        temp_stream_details["l2_dest_addr"] = "mixed"
                                        temp_stream_details["l2_dest_type"] = "mixed"
                                    elif field["valueType"] == "repeatableRandomRange":
                                        temp_stream_details["l2_dest_addr"] = field["minValue"]
                                        temp_stream_details["l2_dest_type"] = Helper.get_addr_type_mac(field["minValue"])
                                else:
                                    temp_stream_details["l2_dest_addr"] = field["singleValue"]
                                    temp_stream_details["l2_dest_type"] = Helper.get_addr_type_mac(field["singleValue"])
                    if dest_addr_ip_version:
                        for field in encaps["field"]:
                            if "dstip" in field["xpath"].lower():
                                if field['singleValue'] not in ["0.0.0.0", "0::0"]:
                                    dest_addr = field['singleValue']
                                else:
                                    value_type = field.get('valueType',"fixed")
                                    if value_type.lower() in ["increment", "decrement"]:
                                        dest_addr = field['startValue']
                                    elif value_type.lower() == "repeatableRandomRange":
                                        dest_addr = field['minValue']
                                    elif value_type.lower() == "valuelist":
                                        dest_addr = "mixed"
                                temp_stream_details["l3_dst_addr"] = dest_addr
                                if dest_addr != "mixed":
                                    temp_stream_details["l3_dst_addr_type"] = Helper.get_addr_type_ipvx(dest_addr)
                                else:
                                    temp_stream_details["l3_dst_addr_type"] = "mixed"

                encap_list.remove("fcs")
                temp_stream_details["encap_list"] = deepcopy(encap_list)
                temp_stream_details["packet_size_info"] = {}
                psi = temp_stream_details["packet_size_info"]
                psi["mode"] = config_element["frameSize"].get("type", "fixed")
                temp_stream_details["traffic_rate_info"] = {
                    "load": config_element["frameRate"]["rate"],
                    "load_unit": config_element["frameRate"].get("type", "linerate")
                }
                psi["pkt_sizes"] = []
                psi["pkt_size_ratio"] = []
                if psi["mode"].lower() == "fixed":
                    psi["pkt_sizes"].append(config_element["frameSize"].get("fixedSize", 64))
                    psi["pkt_size_ratio"].append(100)
                elif psi["mode"] in ["increment", "random"]:
                    psi["pkt_sizes"] = [
                        config_element["frameSize"]["incrementFrom"],
                        config_element["frameSize"]["incrementTo"],
                        config_element["frameSize"].get("incrementStep", 1)
                    ]
                elif psi["mode"] in ["presetDistribution", "weightedPairs"]:
                    psi["mode"] = config_element["frameSize"]["presetDistribution"]
                    while config_element["frameSize"]["weightedPairs"]:
                        psi["pkt_sizes"].append(config_element["frameSize"]["weightedPairs"].pop(0))
                        psi["pkt_size_ratio"].append(config_element["frameSize"]["weightedPairs"].pop(0))
                elif psi["mode"].lower() == "auto":
                    pass

            stream_details.append(temp_stream_details)

        return stream_details

    def get_streamblock_preview(self, stream_name=None, count=None, startingindex=0):
        """
        Retrieve the StreamBlock preview information and return a dictionary.
        The preview data allows the user to know exactly what is being generated by a streamblock.

        :param stream_name: List of Streamblock names. Default is "all"
        :param count: Number of rows to preview
        :param startingindex: Starting index (zero-based) of rows in the traffic path to preview.
        :return: Dictionary of Streamblock of Flows containing IPv4/IPv6 Src/Dest address.
        example: tgnObj.get_streamblock_preview(count = 2)
                 tgnObj.get_streamblock_preview(stream_name = ['Traffic Item 2'],count = 2)
                 tgnObj.get_streamblock_preview(stream_name = ['Traffic Item 1','Traffic Item 2'])
        """
        if stream_name:
            for traffic in stream_name:
                trafficitems = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic + '$')
        else:
            trafficitems = self.ixNetwork.Traffic.TrafficItem.find()
        result = {}
        for trafficitem in trafficitems:
            highlevelstream = trafficitem.HighLevelStream.find()
            output = highlevelstream.PreviewFlowPackets(0, 0)
            item_name = trafficitem.Name
            traffic_result = {'numflows': 0}
            flow = output.get('arg1')
            traffic_result['numflows'] = flow
            flow_data = {}
            if flow >= 500:
                count = 500
            elif count is None:
                count = flow
            else:
                count = count
            for i in range(count):
                output = highlevelstream.PreviewFlowPackets(i, 1)
                packet_data = output['arg4'][0]
                header_fields = output['arg3']
                udp_source_port = None
                tcp_source_port = None
                tcp_dest_port = None
                udp_dest_port = None
                ipv4_source = None
                ipv6_source = None
                ipv4_dest = None
                ipv6_dest = None
                if 'UDP-Source-Port' in header_fields:
                    udp_source_port = packet_data[header_fields.index('UDP-Source-Port')]
                if 'UDP-Dest-Port' in header_fields:
                    udp_dest_port = packet_data[header_fields.index('UDP-Dest-Port')]
                if 'TCP-Source-Port' in header_fields:
                    tcp_source_port = packet_data[header_fields.index('TCP-Source-Port')]
                if 'TCP-Dest-Port' in header_fields:
                    tcp_dest_port = packet_data[header_fields.index('TCP-Dest-Port')]
                source = packet_data[output['arg3'].index('Source Address')]
                dest = packet_data[output['arg3'].index('Destination Address')]
                if source:
                    if ipaddress.ip_address(source).version == 4:
                        ipv4_source = source
                    elif ipaddress.ip_address(source).version == 6:
                        ipv6_source = source
                if dest:
                    if ipaddress.ip_address(dest).version == 4:
                        ipv4_dest = dest
                    elif ipaddress.ip_address(dest).version == 6:
                        ipv6_dest = dest
                packet_info = {}
                if udp_source_port:
                    packet_info['UdpSourceport'] = udp_source_port
                if udp_dest_port:
                    packet_info['UdpDestinationport'] = udp_dest_port
                if tcp_source_port:
                    packet_info['TcpSourceport'] = tcp_source_port
                if tcp_dest_port:
                    packet_info['TCPDestinationport'] = tcp_dest_port
                if ipv4_source:
                    packet_info['IPv4.Source'] = ipv4_source
                if ipv6_source:
                    packet_info['IPv6.Source'] = ipv6_source
                if ipv4_dest:
                    packet_info['IPv4.Destination'] = ipv4_dest
                if ipv6_dest:
                    packet_info['IPv6.Destination'] = ipv6_dest
                if packet_info:
                    flow_data[i + 1] = packet_info
            result[item_name] = {'numflows': count}
            result[item_name].update(flow_data)
        return result

    def start_topology(self, topo_name):
        """
        API to start the devices , nested devices under the topology

        :param topo_name: Name of the topology
        :return: True if successful
                raise exception if Topology not found in config
        :Example: start_topology(['Topology 1','Topology 2'])
                  start_topology('Topology 1')
        """
        self.log.info(f"Starting protocols on Topology {topo_name}")
        timeout = 180
        result = False
        if isinstance(topo_name, str):
            topo_name = [topo_name]
        for topo in topo_name:
            try:
                topo = re.escape(topo)
                if self.ixNetwork.Topology.find(Name=topo):
                    topo_obj = self.ixNetwork.Topology.find(Name=topo)
                    topo_obj.Start()
                    for _ in range(1, timeout):
                        topo_obj = self.ixNetwork.Topology.find(Name=topo)
                        if topo_obj.Status in ['started']:
                            self.log.info(f"All Devices Started Successfully under Topology: {topo}")
                            result = True
                            break
                        else:
                            time.sleep(1)
                    if not result:
                        if topo_obj.Status in ['mixed']:
                            self.log.info("Few Devices are not started Yet..")
                else:
                    self.log.error(f'Topology: {topo} Not found')
                    return False
            except Exception as err:
                raise IxiaConfigException(f'Start Topology failed due to Exception - {err}')
        return True

    def stop_topology(self, topo_name):
        """
        API to stop the devices , nested devices under the topology

        :param topo_name: Name of the topology
        :return: True if successful
                raise exception if Topology not found in config
        :Example: stop_topology(['Topology 1','Topology 2'])
                  stop_topology('Topology 3')
        """
        self.log.info(f"Stopping protocols on Topology {topo_name}")
        timeout = 180
        result= False
        if isinstance(topo_name, str):
            topo_name = [topo_name]
        for topo in topo_name:
            try:
                topo = re.escape(topo)
                if self.ixNetwork.Topology.find(Name= topo):
                    topo_obj = self.ixNetwork.Topology.find(Name=topo)
                    topo_obj.Stop()
                    for _ in range(1, timeout):
                        topo_obj = self.ixNetwork.Topology.find(Name= topo)
                        if topo_obj.Status in ['notStarted']:
                            self.log.info(f"All Devices Stopped Successfully under Topology: {topo}")
                            result = True
                            break
                        else:
                            time.sleep(1)
                    if not result:
                        if topo_obj.Status in ['mixed']:
                            self.log.info("Few Devices are not stopped Yet..")
                else:
                    self.log.error(f'Topology: {topo} Not found')
                    return False
            except Exception as err:
                raise IxiaConfigException(f'Stop Topology failed due to Exception - {err}')
        return True

    def modify_ip_arp_ns(self, arp_rate=200, arp_interval=200, arp_max=1000, ns_rate=200, ns_interval=1000, ns_max=400,
                         resend_ns=True, resend_arp=True, **kwargs):
        """
        Set ARP and Ns parameters

        :param arp_rate:(int/str) arp rate per interval
        :param arp_interval: arp interval (ms)
        :param arp_max: max outstanding value
        :param ns_rate: Ns rate per interval
        :param ns_interval: Ns interval(ms)
        :param ns_max: max outstanding value
        :param resend_ns: resend ns after linkup (True/False)
        :param resend_arp: resend arp after linkup (True/False)

        :return: True if successful

        :Example: tgnObj.modify_ip_arp_ns(arp_rate =100, arp_interval =300, arp_max= 500)
                  tgnObj.modify_ip_arp_ns(ns_rate =100, ns_interval =300, ns_max= 500)
        """
        self.log.info(f"Modifying ARP per port Values as arp_rate: {arp_rate}, arp_interval: {arp_interval}, arp_max: {arp_max}")
        self.log.info(f"Modifying NS per port Values as ns_rate: {ns_rate}, ns_interval: {ns_interval}, ns_max: {ns_max}")
        globals = self.ixNetwork.Globals.find().Topology.find()
        if resend_arp:
            globals.Ipv4.find().ReSendArpOnLinkUp.Single(resend_arp)
        if resend_ns:
            globals.Ipv6.find().ReSendNsOnLinkUp.Single(resend_ns)
        if arp_rate or arp_interval or arp_max:
            arp_obj = globals.Ipv4.find().ArpRate
            self.log.info("Enabling Arp rate at port level")
            arp_obj.Enabled.Single(True)
            if arp_rate:
                arp_obj.Rate.Single(arp_rate)
            if arp_interval:
                arp_obj.Interval.Single(arp_interval)
            if arp_max:
                arp_obj.MaxOutstanding.Single(arp_max)
        if ns_rate or ns_interval or ns_max:
            ns_obj = globals.Ipv6.NsRate
            self.log.info("Enabling NS rate at port level")
            ns_obj.Enabled.Single(True)
            if ns_rate:
                ns_obj.Rate.Single(ns_rate)
            if ns_interval:
                ns_obj.Interval.Single(ns_interval)
            if ns_max:
                ns_obj.MaxOutstanding.Single(ns_max)
        return True

    def enable_rsvp_tunnel(self, tunnel_type, device, **kwargs):
        """
        Enable RSVP tunnel Ingress/Egress

        :param device: Device Name
        :param tunnel_type: Ingress/Egress
        :param kwargs:
        nested_device:  Nested device name
        enable_rsvp: True/False to activate/deactivate rsvp

        :return: True if successfull else raises exception
        
        :Example: enable_rsvp_tunnel(device = 'R2_T1_2',tunnel_type="Ingress",nested_device = 'R2_T1_2_Tunnels',enable_rsvp = False)
                  enable_rsvp_tunnel(device = 'R2_T1_2',tunnel_type="egress")
        """
        nested_device = kwargs.get('nested_device')
        enable_rsvp = kwargs.get('enable_rsvp', True)
        dev_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
        if not dev_obj:
            raise IxiaConfigException (f"Given Device: {device} is not found in the existing config")
        if device and not nested_device:
            self.log.info(f"Enable RSVP tunnel on {device}")
            if dev_obj.Ethernet.find().Ipv4.find():
                if dev_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                    rsvp_if_obj = dev_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find()
            elif dev_obj.Ipv4Loopback.find():
                if dev_obj.Ipv4Loopback.find().RsvpteLsps.find():
                    rsvp_if_obj = dev_obj.Ipv4Loopback.find().RsvpteLsps.find()
            if tunnel_type.lower() == "ingress":
                tunnel_obj = rsvp_if_obj.RsvpP2PIngressLsps.find()
            else:
                tunnel_obj = rsvp_if_obj.RsvpP2PEgressLsps.find()
            tunnel_obj.Active.Single(enable_rsvp)

        elif device and nested_device:
            self.log.info(f"Enable RSVP tunnel on {device} and {nested_device}")
            if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$'):
                if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find():
                    if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        rsvp_if_obj = dev_obj.NetworkGroup.find().DeviceGroup.find(
                            Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find()
                elif dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ipv4Loopback.find():
                    if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ipv4Loopback.find().RsvpteLsps.find():
                        rsvp_if_obj = dev_obj.NetworkGroup.find().DeviceGroup.find(
                            Name= '^' + nested_device + '$').Ipv4Loopback.find().RsvpteLsps.find()
            elif dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$'):
                if dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find():
                    if dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        rsvp_if_obj = dev_obj.DeviceGroup.find(
                            Name=nested_device).Ethernet.find().Ipv4.find().RsvpteLsps.find()
                elif dev_obj.DeviceGroup.find(Name=nested_device).Ipv4Loopback.find():
                    if dev_obj.DeviceGroup.find(Name=nested_device).Ipv4Loopback.find().RsvpteLsps.find():
                        rsvp_if_obj = dev_obj.DeviceGroup.find(
                            Name=nested_device).Ipv4Loopback.find().RsvpteLsps.find()
            else:
                raise IxiaConfigException(f"Given Device: {nested_device} is not found in the existing config")
            if tunnel_type.lower() == "ingress":
                tunnel_obj = rsvp_if_obj.RsvpP2PIngressLsps.find()
            else:
                tunnel_obj = rsvp_if_obj.RsvpP2PEgressLsps.find()
            tunnel_obj.Active.Single(enable_rsvp)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def get_bgp_routeblock_names(self, device=None, **kwargs):
        """
        API to get BGP RouteBlock names along with StartIpList, PrefixLength, NetworkCount, Active for given device
        :param device: String/List of the devices for which Routeblock params required
        :return: Dictionary of Routeblock names along with corresponding values
        Ex:- tgn.get_bgp_routeblock_names() or tgn.get_bgp_routeblock_names(device='Device 1')
        """
        nested_ng = kwargs.get('nested_ng', None)
        device_display = kwargs.get('device_display', False)
        ipv4_route_block_handles = []
        ipv6_route_block_handles = []
        result_dict = {}
        if not device:
            for network_handle in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if network_handle.Ipv4PrefixPools.find():
                    if network_handle.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                        ipv4_route_block_handles.append(network_handle)
                elif network_handle.Ipv6PrefixPools.find():
                    if network_handle.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                        ipv6_route_block_handles.append(network_handle)

        else:
            if isinstance(device, str):
                device = [device]
            for each in device:
                device_handle = None
                device_name = re.escape(each)
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name):
                    device_handle = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
                else:
                    device_object = self.ixNetwork.Topology.find().DeviceGroup.find()
                    if device_object.NetworkGroup.find().DeviceGroup.find(Name=device_name):
                        device_handle = device_object.NetworkGroup.find().DeviceGroup.find(Name=device_name)
                if not device_handle:
                    raise CafyException.TgenConfigMissingError(f"Device {each} not present in configuration")
                for network_handle in device_handle.NetworkGroup.find():
                    if network_handle.Ipv4PrefixPools.find():
                        if network_handle.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                            ipv4_route_block_handles.append(network_handle)
                    if network_handle.Ipv6PrefixPools.find():
                        if network_handle.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                            ipv6_route_block_handles.append(network_handle)

        if not ipv4_route_block_handles and not ipv6_route_block_handles:
            raise CafyException.TgenConfigMissingError("No Routeblock exists in configuration")
        bgpipv4_dict = {}
        if ipv4_route_block_handles:
            for each in ipv4_route_block_handles:
                bgpipv4_dict.update({each.Name: {}})
                bgp_ipv4_route_obj = each.Ipv4PrefixPools.find()
                if bgp_ipv4_route_obj:
                    bgpipv4_dict[each.Name].update({'StartIpList': bgp_ipv4_route_obj.NetworkAddress.Values})
                    bgpipv4_dict[each.Name].update({'PrefixLength': bgp_ipv4_route_obj.PrefixLength})
                    bgpipv4_dict[each.Name].update(
                        {'Active': bgp_ipv4_route_obj.BgpIPRouteProperty.find().Active})
                    bgpipv4_dict[each.Name].update(
                        {'PrefixIncrementPerRoute': bgp_ipv4_route_obj.PrefixAddrStep})
                    bgpipv4_dict[each.Name].update({'RouteCount': bgp_ipv4_route_obj.NumberOfAddressesAsy.Values})

        bgpipv6_dict = {}
        if ipv6_route_block_handles:
            for each in ipv6_route_block_handles:
                bgpipv6_dict.update({each.Name: {}})
                bgp_ipv6_route_obj = each.Ipv6PrefixPools.find()
                if bgp_ipv6_route_obj:
                    bgpipv6_dict[each.Name].update({'StartIpList': bgp_ipv6_route_obj.NetworkAddress.Values})
                    bgpipv6_dict[each.Name].update({'PrefixLength': bgp_ipv6_route_obj.PrefixLength})
                    bgpipv6_dict[each.Name].update(
                        {'Active': bgp_ipv6_route_obj.BgpV6IPRouteProperty.find().Active})
                    bgpipv6_dict[each.Name].update(
                        {'PrefixIncrementPerRoute': bgp_ipv6_route_obj.PrefixAddrStep})
                    bgpipv6_dict[each.Name].update({'RouteCount': bgp_ipv6_route_obj.NumberOfAddressesAsy.Values})

        result_dict = {**bgpipv4_dict, **bgpipv6_dict}
        if device_display:
            if not nested_ng:
                nested_ng = list(result_dict.keys())[0]
            if nested_ng in result_dict:
                route_detail_dict = {}
                device_count = len(result_dict[nested_ng]['StartIpList'])
                # prefix_values = self._process_bgp_routeblock_values(result_dict[nested_ng], 'PrefixLength',device_count)

                prefix_values = (
                    list(result_dict[nested_ng]['PrefixLength'].Values)
                    if hasattr(result_dict[nested_ng]['PrefixLength'], "Values")
                    else [str(result_dict[nested_ng]['PrefixLength'])] * device_count
                                )

                active_values = (
                    list(result_dict[nested_ng]['Active'].Values)
                    if hasattr(result_dict[nested_ng]['Active'], "Values")
                    else [str(result_dict[nested_ng]['Active'])] * device_count
                                )

                increment_values = (
                    list(result_dict[nested_ng]['PrefixIncrementPerRoute'].Values)
                    if hasattr(result_dict[nested_ng]['PrefixIncrementPerRoute'], "Values")
                    else [str(result_dict[nested_ng]['PrefixIncrementPerRoute'])] * device_count
                                    )

                route_count_list = self._process_bgp_routeblock_values(result_dict[nested_ng], 'RouteCount',
                                                                       device_count)

                for device in range(device_count):
                    device_num = device+1
                    route_detail_dict.update({device_num:{}})
                    route_detail_dict[device_num].update({'StartIpList':[result_dict[nested_ng]['StartIpList'][device]]})
                    route_detail_dict[device_num].update({'PrefixLength':prefix_values[device]})
                    route_detail_dict[device_num].update({'Active':str(active_values[device])})
                    route_detail_dict[device_num].update({'PrefixIncrementPerRoute':increment_values[device]})
                    route_detail_dict[device_num].update({'RouteCount': route_count_list[device]})
                    # route_detail_dict[device_num].update({'RouteCount': str(route_count_list[device])})
                result_dict = route_detail_dict
        return result_dict

    def _process_bgp_routeblock_values(self, routeblock_info, key, device_count):
        """
        It helps to process routeblock values
        :param routeblock_info:routeblock info of Network Group
        :param key:Parameters of BGP Routeblock
        :param device_count:Device Count of Network Group
        :return:field_values_list in form list
        """
        routeblock_key_list = ['PrefixLength','Active','PrefixIncrementPerRoute']
        field_value = routeblock_info[key]
        if str(field_value).startswith('List'):
            field_values_list = re.findall(r'\d+|True|true|False|false', str(field_value))
            if key in routeblock_key_list:
                if not len(field_values_list) > 1:
                    field_values_list = field_values_list * device_count
            elif key == 'RouteCount':
                field_values_list = field_values_list[1:]
        elif str(field_value).startswith('Inc'):
            start_value, step_value = re.findall(r'\d+|True|False|true|false', str(field_value))
            field_values_list = [int(start_value) + int(step_value) * device for device in range(device_count)]
        else:
            if key == 'RouteCount':
                field_values_list = field_value
            else:
                field_values_list = [str(field_value)] * device_count
        return field_values_list

    def delete_routeblocks(self, protocol=None, routeblock_name=None):
        """
            This API allows user to delete BGP Routeblocks

            :param protocol: String of protocol bgp/isis/ospfv2/ospfv3/igmp/mld
            :param routeblock_name: String/List of Routeblock Names which needs to be deleted
            Ex:- tgn.delete_routeblocks(routeblock_name=['Routeblock1', 'Routeblock2', 'Routeblock3'])
        """

        if not routeblock_name:
            raise CafyException.InvalidValueError("No Routeblock name provided which is mandate")
        if isinstance(routeblock_name, str):
            routeblock_name = [routeblock_name]
        dev_obj = self.ixNetwork.Topology.find().DeviceGroup.find()
        network_objs = [each.Name for each in dev_obj.NetworkGroup.find() if each]
        for routeblock in routeblock_name:
            if routeblock not in network_objs:
                self.log.error(f'Network Group: {routeblock} Not found')
        for device in dev_obj:
            for routeblock in routeblock_name:
                routeblock_modified = re.escape(routeblock)
                network_obj = device.NetworkGroup.find(Name=routeblock_modified)
                if network_obj:
                    try:
                        network_obj.remove()
                        self.log.info(f"{routeblock} Deleted succesfully")
                    except Exception as err:
                        raise IxiaConfigException(f'Delete routeblock failed due to: {err}')

    def get_rsvp_lsp_stats(self, tunnel_type='egress'):
        """
        API to get RSVP-TE sessions UP count

        :param tunnel_type: egress/ingress default its egress
        :return: A dictionary of total egress/ingress lsp_up
        :Example : tgnObj.get_rsvp_lsp_stats(tunnel_type='ingress')
        """
        self.log.info("Getting stats values for rsvp")
        flow_stats = self.get_stats(view_name='RSVPTE-IF Per Port')
        if flow_stats:
            rsvpte_df = pd.DataFrame.from_dict(flow_stats, orient='index')
            rsvpte_df.index = range(1, len(rsvpte_df) + 1)
            rsvpte_df_columns = list(rsvpte_df.columns)
            rsvp_stat_table = tabulate.tabulate(rsvpte_df, headers=rsvpte_df_columns, tablefmt="grid")
            self.log.info(f"flow_stats: \n{rsvp_stat_table}")
            output = {}
            if tunnel_type.lower() == "egress":
                egress_field_dict = {'Egress LSPs Up': 'total_egress_lsp_up',
                                     'Egress SubLSPs Up': 'total_egress_sub_lsp_up',
                                     'Session Flap Count': 'total_engress_flap_count', 'Paths Tx': 'egress_path_tx',
                                     'Paths Rx': 'egress_path_rx',
                                     'Path Tears Tx': 'egress_tears_tx', 'Path Tears Rx': 'egress_tears_rx',
                                     'LSP Self Ping Received by Egress': 'egress_ping_received',
                                     'LSP Self Ping Forwarded by Egress': 'egress_ping_forwarded'}
                field_dict = egress_field_dict
            else:
                ingress_field_dict = {'Ingress LSPs Up': 'total_ingress_lsp_up',
                                      'Ingress LSPs Configured': 'total_ingress_lsp_configured',
                                      'Ingress SubLSPs Configured': 'total_ingress_sub_lsp_configured',
                                      'Ingress SubLSPs Up': 'total_ingress_sub_lsp_up',
                                      'Session Flap Count': 'total_ingress_flap_count', 'Paths Tx': 'ingress_path_tx',
                                      'Paths Rx': 'ingress_path_rx',
                                      'Path Tears Tx': 'ingress_tears_tx', 'Path Tears Rx': 'ingress_tears_rx',
                                      'LSP Self Ping Sent from Ingress': 'ingress_ping_sent',
                                      'LSP Self Ping Received by Ingress': 'ingress_ping_received'}
                field_dict = ingress_field_dict

            for field, value in field_dict.items():
                ingress_df = rsvpte_df.astype({field: 'int'})
                output[value] = int(ingress_df[field].sum())

        return output

    def get_port_status(self, port_list=None, reboot=False):
        """
        Get port status information(Port, portStatus) for each port

        :param port_list: list of ports (10.39.65.156/2/12)
        :param reboot: Default reboot will be False. If user wants to reboot the port input will be reboot=True
        :return: dict with port status

        :Example: tgnObj.get_port_status(port_list = ['10.39.65.156/2/12','10.39.65.156/2/13'],reboot= True)
        """
        link_status = {}
        if port_list:
            self.log.info(f"Checking port status for {port_list}")
            for name in port_list:
                assigned = name.replace('/', ':')
                vport = self.ixNetwork.Vport.find(AssignedTo=assigned)
                if vport:
                    vport_state = vport.State
                    vport_connectionstate = vport.ConnectionState
                    vport_name = vport.AssignedTo.replace(':', '/')
                    if vport.ConnectionState == 'unassigned':
                        vport_name = vport.Name
                    self.log.info(f"Port : {vport_name}, State: {vport_state}, ConnectionStatus : {vport_connectionstate}")
                    if reboot:
                        if vport.ConnectionState == 'connectedLinkDown':
                            self.log.info(f"Rebooting the port {vport_name}")
                            vport.ResetPortCpuAndFactoryDefault()
                            time.sleep(2)
                    link_status[vport_name] = vport_state
                else:
                    self.log.warning(f"Port: {name} not found.")
        else:
            self.log.info("Checking Port status for all available ports")
            for vport in self.ixNetwork.Vport.find():
                vport_state = vport.State
                vport_connectionstate = vport.ConnectionState
                vport_name = vport.AssignedTo.replace(':', '/')
                if vport.ConnectionState == 'unassigned':
                    vport_name = vport.Name
                self.log.info(f"Port : {vport_name}, State: {vport_state}, ConnectionStatus : {vport_connectionstate}")
                if reboot:
                    if vport.ConnectionState == 'connectedLinkDown':
                        self.log.info(f"Rebooting the port {vport_name}")
                        vport.ResetPortCpuAndFactoryDefault()
                        time.sleep(2)
                    link_status[vport_name] = vport_state
                link_status[vport_name] = vport_state
        return link_status
    def copy_cert_files(self, device_name,  **kwargs):
        """
            Copy and update files(.pem) for DotOneX

            :param device_name: Device Group name
            :return: True. raise exception if False/error

            :Example: copy_cert_files("Device group 3")
                    copy_cert_files("Device Group 3",private_key = 'client-key-private.pem')
        """
        private_key = kwargs.get('private_key', 'client-key.pem')
        certificate_file = kwargs.get('certificate_file', 'client.pem')
        ca_certificate_file = kwargs.get('ca_certificate_file', 'ca.pem')
        certificate_dir = kwargs.get('certificate_dir', self.ixNetwork.Globals.PersistencePath)
        local_path = kwargs.get('local_path', CafyLog.work_dir)
        server_type = kwargs.get('server_type', 'linux')
        local_file_path = ''
        device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().DotOneX.find()
        if device_obj:
            try:
                if certificate_dir:
                    path = self.ixNetwork.Globals.PersistencePath
                    device_obj.CertDir.String(path)
                if private_key:
                    if server_type == 'windows':
                        path = self.ixNetwork.Globals.PersistencePath + '\\' + private_key
                    elif server_type == 'linux':
                        path = self.ixNetwork.Globals.PersistencePath + '/' + private_key
                    local_file_path = local_path + '/' + private_key
                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)
                    if upload_file['files'][0]['name'] == private_key:
                        device_obj.PrivateKey.String(private_key)
                        self.log.info(f"{private_key} file copied successfully")
                    else:
                        self.log.warning(f"Failed to copy {private_key} file ")
                if certificate_file:
                    if server_type == 'windows':
                        path = self.ixNetwork.Globals.PersistencePath + '\\' + certificate_file
                    elif server_type == 'linux':
                        path = self.ixNetwork.Globals.PersistencePath + '/' + certificate_file
                    local_file_path = local_path + '/' + certificate_file
                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)
                    if upload_file['files'][0]['name'] == certificate_file:
                        device_obj.PeerCert.String(certificate_file)
                        self.log.info(f"{certificate_file} file copied successfully")
                    else:
                        self.log.warning(f"Failed to copy {certificate_file} file ")
                if ca_certificate_file:
                    if server_type == 'windows':
                        path = self.ixNetwork.Globals.PersistencePath + '\\' + ca_certificate_file
                    elif server_type == 'linux':
                        path = self.ixNetwork.Globals.PersistencePath + '/' + ca_certificate_file
                    local_file_path = local_path + '/' + ca_certificate_file
                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)
                    if upload_file['files'][0]['name'] == ca_certificate_file:
                        device_obj.CaCert.String(ca_certificate_file)
                        self.log.info(f"{ca_certificate_file} file copied successfully")
                    else:
                        self.log.warning(f"Failed to copy {ca_certificate_file} file ")

            except Exception as err_msg:
                self.log.error(f'copying files failed as: {err_msg}')
        else:
            self.log.error(f'Device Group {device_name} is not found')
            return False
        return True

    def _get_protocol_stats(self):
        """
        This is an internal API helps to get protocol stats info

        return: port level protocol status
        """
        self.log.info('Getting Protocol details during traffic failure')
        protocol_info_list = ['Index', 'Protocol Type', 'Sessions Up', 'Sessions Down',
                              'Sessions Not Started', 'Sessions Total']
        protocol_status_dict = dict()

        try:
            protocol_summary = self.get_stats(view_name="Protocols Summary")
        except Exception as err_msg:
            self.log.error(f'Protocols are not configured {err_msg}')
            return False

        if protocol_summary:
            for _, proto_summary in protocol_summary.items():
                protocol = proto_summary['Protocol Type']
                protocol_status_dict.update({protocol: {}})
                for protocol_info in protocol_info_list:
                    if protocol_info in proto_summary.keys():
                        protocol_status_dict[protocol].update({protocol_info: proto_summary[protocol_info]})
        temp_summary = [protocol_summary[key] for key in protocol_summary]
        extracted_summary = [{key: field[key] for key in field if key in protocol_info_list} for field in temp_summary]
        summary_dataframe = pd.DataFrame(extracted_summary)
        summary_dataframe.index = range(1, len(extracted_summary) + 1)
        protocol_stat_table = tabulate.tabulate(summary_dataframe, headers=protocol_info_list, tablefmt="grid")
        self.log.info(f'\n{protocol_stat_table}')
        return protocol_stat_table

    def _get_port_stats(self):
        """
        This is an internal API helps to get port stats information

            return: port status
        """
        self.log.info('Getting Port details during traffic failure')
        port_info_list = ['Index', 'Stat Name', 'Port Name', 'Line Speed', 'Link State']
        port_status_dict = dict()

        try:
            port_stats = self.get_stats(view_name="Port Statistics")
        except Exception as err_msg:
            self.log.error(f'Failed to fetch Port Statistics {err_msg}')
            return False
        if port_stats:
            for _, port_stat in port_stats.items():
                port_name = port_stat["Port Name"]
                port_status_dict.update({port_name: {}})
                for port_info in port_info_list:
                    if port_info in port_stat.keys():
                        port_status_dict[port_name].update({port_info: port_stat[port_info]})
            temp_stats = [port_stats[key] for key in port_stats]
            extracted_summary = [{key: field[key] for key in field if key in port_info_list} for field in temp_stats]
            summary_dataframe = pd.DataFrame(extracted_summary)
            summary_dataframe.index = range(1, len(extracted_summary) + 1)
            port_stat_table = tabulate.tabulate(summary_dataframe, headers=port_info_list, tablefmt="grid")
            self.log.info(f'\n{port_stat_table}')
        return port_status_dict

    def _get_traffic_rate(self, result_dataset=None):
        """
        Get tx/rx rate, l1rate, fps, count and rxduplicatecount for each streamblock

        :param result_dataset: streamblock results' dataset
        :return: tx/rx rate, l1rate, fps, count and rxduplicatecount streamblocks as a dict
        """
        stream_rate_dict = {}
        stats = self.get_stats(view_name="Traffic Item Statistics")

        for flow,value in stats.items():
            stream_rate_dict[value['Traffic Item']] = value

        for _, value in stream_rate_dict.items():
            value.update({"txrate" : value['Tx Rate (bps)']})
            value.update({"txl1rate": value['Tx L1 Rate (bps)']})
            value.update({"txfps": value['Tx Frame Rate']})
            value.update({"txcount": value['Tx Frames']})

            value.update({"rxrate" : value['Rx Rate (bps)']})
            value.update({"rxl1rate": value['Rx L1 Rate (bps)']})
            value.update({"rxfps": value['Rx Frame Rate']})
            value.update({"rxcount": value['Rx Frames']})

        # list to remove excess keys as per customer request
        rem_list = ['First TimeStamp', 'Frames Delta', 'Last TimeStamp', 'Loss %', 'Packet Loss Duration (ms)',
                    'Rx Bytes', 'Rx Frame Rate', 'Rx Rate (Kbps)', 'Rx Rate (Mbps)','Traffic Item','Tx Rate (bps)',
                    'Rx Rate (Bps)', 'Tx Frame Rate', 'Tx Frames', 'Tx L1 Rate (bps)', 'Tx Rate (Bps)',
                    'Tx Rate (Kbps)', 'Tx Rate (Mbps)','Store-Forward Avg Latency (ns)','Store-Forward Max Latency (ns)',
                    'Store-Forward Min Latency (ns)','Rx Frames','Rx Rate (bps)','Rx L1 Rate (bps)']
        for _, flow in stream_rate_dict.items():
            for key in rem_list:
                if key in flow.keys():
                    del flow[key]

        return stream_rate_dict

    def add_multiple_traffic_streams_scale(self, traffic_info=None, **kwargs):
        """
        API to create traffic streams based on input. User can either pass csv file or can pass a dictionary with config parameters

        :param traffic_info: dictionary with config details

        Example 1: Below example creates multicast destination from ipv6 device group
        traffic_info = [{'stream_name': 'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv6_mc',
        'stream_type': 'Multicast', 'traffic_type': 'ipv6', 'stream_src': 'IPv6 Device Group 1',
        'vlan': '', 'frame_size': '128',
        'multicast_address': 'ff03::2', 'bi-directional': 'FALSE',
        'Groupname(multicast) (Eg: ipv4Group1)': '', 'Increment(Multicast)(Eg: 3:1)': '255.255.255.255', 'txLoad(%)': '100',
        'tolerance(%)': '', 'tcp_header': '', 'tcp_src_port': '', 'tcp_dst_port': '', 'udp_header': 'TRUE',
        'udp_src_port': '2000', 'udp_dst_port': '3000', 'throughput(%)': '', 'tos': 220, 'raw_stream_ip_stack': ''}]
        add_multiple_traffic_streams(traffic_info=traffic_info)
        Return : True
        """
        trafficitem_number = 1
        cfg_dict = {}
        scale_traffic = ScaleTraffic(ixnetwork=self.ixNetwork)
        exists_traffic_item_count = scale_traffic.return_existing_trafficitem_count()
        trafficitem_number += exists_traffic_item_count
        factors = list(range(trafficitem_number, trafficitem_number + len(traffic_info)))
        with ThreadPoolExecutor() as executor:
            results = list(executor.map(scale_traffic.add_multiple_traffic_streams, traffic_info, factors))
        self.ixNetwork.ResourceManager.ImportConfig(json.dumps(results), False)
        for each_traffic in traffic_info:
            if each_traffic.get('tos'):
                traffic_item_list = [each_traffic["stream_name"]]
                if isinstance(each_traffic['tos'], list):
                    cfg_dict = {'displayName': 'precedence', 'valueType': 'valueList',
                                'valueList': each_traffic['tos']}
                elif isinstance(each_traffic['tos'], str):
                    cfg_dict = {'displayName': 'precedence', 'valueType': 'singleValue',
                                'singleValue': each_traffic['tos']}
                thread = threading.Thread(target=self.change_ipv4_tos, args=(cfg_dict, traffic_item_list,))
                thread.start()
                thread.join()
            if each_traffic.get('ipv4_precedence_full_mesh'):
                self.ixNetwork.Traffic.TrafficItem.find(
                    Name=each_traffic["stream_name"]).ConfigElement.find().Stack.find(DisplayName="IPv4"). \
                    Field.find(DisplayName='Precedence').FullMesh = each_traffic['ipv4_precedence_full_mesh']
        return True

    def get_ip_stack_status(self, device_group_name=None, ip_version='ipv4', display_table=True):
        """
        API to retrieve the IP stack status (Up/Down/Not Started) for devices in specified device group(s).

        :param device_group_name: (str or list) Device group name(s) to filter on. If None, fetches all.
        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.
        :param display_table: (bool) If True, prints a formatted table to the console. Default is False.

        :return: Table with device group, Total IPs, IP Version, Statuses

        :Example:
            tgnObj.get_ip_stack_status(device_group_name="@#Device Group 1$%")
            tgnObj.get_ip_stack_status(device_group_name=["Device Group 1", "Device Group 2"])
        """
        assert ip_version.lower() in ['ipv4', 'ipv6'], "Invalid IP version. Use 'ipv4' or 'ipv6'."
        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'

        if isinstance(device_group_name, list):
            pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'
        elif isinstance(device_group_name, str):
            pattern = re.escape(device_group_name)
        else:
            pattern = '.*'

        result_summary = {}
        try:
            for topology in self.ixNetwork.Topology.find():
                for device_grp in topology.DeviceGroup.find(Name=pattern):
                    eth_list = device_grp.Ethernet.find()
                    if not eth_list:
                        self.log.warning(f"No Ethernet found in device group '{device_grp.Name}'")
                        continue

                    ip_status_map = {}
                    status_counter = defaultdict(int)

                    for eth in eth_list:
                        ip_stacks = getattr(eth, stack_attr).find()
                        for ip_stack in ip_stacks:
                            for i, ip_addr in enumerate(ip_stack.Address.Values):
                                status = ip_stack.SessionStatus[i] if i < len(ip_stack.SessionStatus) else 'unknown'
                                norm = status.strip().lower()
                                ip_status_map[ip_addr] = status
                                status_counter[
                                    'notstarted' if 'notstarted' in norm or 'not started' in norm else
                                    'up' if 'up' in norm else
                                    'down' if 'down' in norm else
                                    'unknown'
                                ] += 1

                    result_summary[device_grp.Name] = {
                        'total_ips': len(ip_status_map),
                        'IP version': ip_version.lower(),
                        'up': status_counter['up'],
                        'down': status_counter['down'],
                        'not started': status_counter['notstarted'],
                        'unknown': status_counter['unknown'],
                        'ip_status_map': ip_status_map
                    }

            if display_table and result_summary:
                self.log.info(f"""\n{tabulate.tabulate(
                    [[device_grp, d['total_ips'], d['IP version'], d['up'], d['down'], d['not started']]
                     for device_grp, d in result_summary.items()],
                    headers=['Device Group', 'Total IPs', 'IP Version', 'Up', 'Down', 'Not Started'],tablefmt='grid')}""")

        except Exception as err:
            self.log.exception(f"Unexpected error: {err}")
        return result_summary

    def restart_ip_stack(self, device_group_name=None, ip_version='ipv4', max_retries=25):
        """
        API that RestartDown all IPs that are in 'Down' or 'Not Started' state within the given device group(s).

        :param device_group_name: str or list of device group names to "restartDown" the IPs
        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.
        :param max_retries: number of retries for the "restartDown"
        """
        interval_sec, max_threads, chunk_size = 5, 10, 500
        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'
        assert ip_version.lower() in ['ipv4', 'ipv6'], "Invalid IP version. Use 'ipv4' or 'ipv6'."

        def _chunked(seq, size):
            return (seq[i:i + size] for i in range(0, len(seq), size))

        def _build_summary(stats):
            return {
                device_grp: {
                    "Total IPs": d['total_ips'], "IP Version": ip_version,
                    "Up": d['up'], "Down": d['down'], "Not Started": d['not started']
                } for device_grp, d in stats.items()
            }

        stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)
        restartable_ips = {
            ip_addr: status for d in stats.values()
            for ip_addr, status in d['ip_status_map'].items()
            if status.strip().lower() in ['down', 'notstarted', 'not started']
        }

        if not restartable_ips:
            self.log.success(f"All {ip_version.upper()} IPs are already UP.")
            summary = _build_summary(stats)
            return summary

        count_down = sum(1 for s in restartable_ips.values() if s.strip().lower() == 'down')
        count_notstarted = len(restartable_ips) - count_down
        self.log.warning(f"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED")

        if isinstance(device_group_name, list):
            pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'
        elif isinstance(device_group_name, str):
            pattern = re.escape(device_group_name)
        else:
            pattern = '.*'

        dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)
        ip_stack_refs = {
            ip_addr: ip_stack
            for device_grp in dgs for eth in device_grp.Ethernet.find()
            for ip_stack in getattr(eth, stack_attr).find()
            for ip_addr in ip_stack.Address.Values
            if ip_addr in restartable_ips
        }

        unique_stacks = list(set(ip_stack_refs.values()))
        self.log.info("Checking for any ongoing protocol actions")
        restart_stack = lambda s: s.RestartDown()
        # self.ixNetwork.Topology().find().protocolActionInProgress
        

        for attempt in range(1, max_retries + 1):
            pdb.set_trace()
            self.log.debug(f"RETRY {attempt}/{max_retries}: Restarting {len(unique_stacks)} stacks...")
            for chunk in _chunked(unique_stacks, chunk_size):
                with ThreadPoolExecutor(max_workers=max_threads) as executor:
                    list(executor.map(restart_stack, chunk))
                time.sleep(interval_sec)

            updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)
            all_status = {
                ip_addr: status for d in updated.values() for ip_addr, status in d['ip_status_map'].items()
            }
            restartable_ips = {
                ip_addr: s for ip_addr, s in restartable_ips.items()
                if all_status.get(ip_addr, 'unknown').strip().lower() != 'up'
            }

            if not restartable_ips:
                self.log.success(f"All IPs are UP after '{attempt}' attempt(s).")
                break

        summary = _build_summary(self.get_ip_stack_status(device_group_name, ip_version, display_table=True))

        if restartable_ips:
            self.log.fail(f"{len(restartable_ips)} IPs remained DOWN or NOT STARTED after {max_retries} retries.")
        return summary

    def modify_receive_ports(self, traffic_list=None, ports=None):
        """
        This method allows you to modify receive ports under a streamblock.
        :param traffic_list: List of the traffic streams to be modified
        :param ports: list of Rx ports
        :example: tgn.modify_receive_ports(traffic_list=['Stream1'],ports=['1/2','1/1'])
        :return: True if successful
        """
        if not traffic_list or not ports:
            self.log.error("Both traffic_list and ports must be provided")
            return False

        try:
            vport_href_list = []
            for port_name in ports:
                vport_match = self.ixNetwork.Vport.find(Name=port_name)
                if not vport_match:
                    self.log.warning(f"Port '{port_name}' not found in config, skipping")
                    continue
                vport_href_list.append(vport_match.Protocols.find().href)

            if not vport_href_list:
                self.log.error("No valid RX ports found in config")
                return False

            for ti_name in traffic_list:
                ti_match = self.ixNetwork.Traffic.TrafficItem.find(Name=ti_name)
                if not ti_match:
                    self.log.warning(f"Traffic Item '{ti_name}' not found, skipping")
                    continue

                if ti_match[0].TrafficType != "raw":
                    self.log.debug(f"Traffic Item '{ti_name}' is not 'raw', skipping")
                    continue

                for endpoint in ti_match[0].EndpointSet.find():
                    self.log.info(f"Updating RX ports for '{ti_name}' to {ports}")
                    endpoint.update(Destinations=vport_href_list)
            self.ixNetwork.Traffic.Apply()
            self.log.info("RX ports updated successfully for given traffic items")
            return True
        except Exception as e:
            self.log.error(f"Failed to modify RX ports: {e}")
            return False

    def rocve2_flow_config(self, enable=True, flow_group_name='all', burst_mode="continuous", burst_count=1):
        """
        Enable/disable RoCEv2 streams by flow group name(s) using BulkUpdateStreams.

        :param enable: True/False to enable or disable
        :param flow_group_name: 'all', a single stream name (str), or a list of flow group names
        :param burst_mode: By default continuous, options - 'fixed'/'continuous'
        :param burst_count: To set burst count (int)

        Example: rocve2_flow_config(enable=True,flow_group_name=['RoCEv2 Flow Group 1','RoCEv2 Flow Group 2','RoCEv2 Flow3'],burst_mode='fixed')
        """
        self.log.info("Configuring RoCEv2 Flow Groups Parameters")

        if enable == True and flow_group_name:
            self.log.info("Globally Enabling RoCEv2")
            self.ixNetwork.Traffic.find().RoceV2Traffic.find().Enabled = enable

        elif enable == False and flow_group_name == 'all':
            self.log.info("Globally Disabling RoCEv2")
            self.ixNetwork.Traffic.find().RoceV2Traffic.find().Enabled = enable

        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()
        if flow_group_name == 'all':
            rocve2_find_streams = rocev2.RoceV2Stream.find()

        elif isinstance(flow_group_name, str):
            rocve2_find_streams = rocev2.RoceV2Stream.find(Name='^' + flow_group_name + '$')

        elif isinstance(flow_group_name, (list, tuple)):
            all_streams = rocev2.RoceV2Stream.find()
            rocve2_find_streams = [s for s in all_streams if s.Name in flow_group_name]

        else:
            raise ValueError("flow_group_name must be 'all', a string, or a list of strings")

        valid_modes = {"continuous", "fixed"}
        if burst_mode not in valid_modes:
            self.log.warning(f"[RoCEv2] Invalid burst_mode '{burst_mode}' - defaulting to 'continuous'. Valid options: {valid_modes}")
            burst_mode = "continuous"

        arg2_payload = []
        for stream in rocve2_find_streams:
            stream_id = int(stream.href.split('/')[-1])
            arg2_payload.append({"arg1": stream_id,"arg2": enable,"arg3": burst_mode,"arg4": burst_count})

        if arg2_payload:
            rocev2.BulkUpdateStreams(Arg2=arg2_payload)
            if flow_group_name == 'all':
                self.log.info(f"Successfully updated ALL flow groups count={len(rocve2_find_streams)}"
                              f"to enable={enable}, mode={burst_mode}, burst={burst_count}")

            elif isinstance(flow_group_name, (list, tuple)):
                self.log.info(f"Successfully updated flow group(s) {flow_group_name} "
                              f"to enable={enable}, mode={burst_mode}, burst={burst_count}")

            elif isinstance(flow_group_name, str):
                self.log.info(f"Successfully updated flow group [{flow_group_name}] "
                              f"to enable={enable}, mode={burst_mode}, burst={burst_count}")
        else:
            self.log.error("No streams matched the given flow_group_name")
        return True

    def rocve2_port_config(self, tx_port_name='all', **kwargs):
        """
        Configure RoCEv2 ports by tx port(s).

        :param tx_port_name: by default 'all', a single port name (str), or a list of port names
        :param kwargs: Optional arguments
                inter_batch_value: change values of Inter Batch Period Value (int)
                inter_batch_units: change values of Inter Batch Period Value | options: str(microseconds | milliseconds | nanoseconds | seconds)
                target_rate: change Target Line Rate In Percent (int)
                tx_ctrl: change Transmission Control mode | str(interBatchPeriod | targetLineRate)

        Example: rocve2_port_config(tx_port_name=['D12-R1-FH-0/8/0/7','D12-R1-FH-0/8/0/6'],tx_ctrl='interBatchPeriod',target_rate='50')
        """
        inter_batch_value = kwargs.get('inter_batch_value', None)
        inter_batch_units = kwargs.get('inter_batch_units', None)
        target_rate = kwargs.get('target_rate', None)
        tx_ctrl = kwargs.get('tx_ctrl', None)

        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()
        self.log.info("Configuring RoCEv2 Tx Port Parameters")

        if tx_port_name == 'all':
            rocve2_find_ports = rocev2.RoceV2PortConfig.find()

        elif isinstance(tx_port_name, str):
            rocve2_find_ports = rocev2.RoceV2PortConfig.find(TxPort='^' + tx_port_name + '$')

        elif isinstance(tx_port_name, (list, tuple)):
            all_ports = rocev2.RoceV2PortConfig.find()
            rocve2_find_ports = [s for s in all_ports if s.TxPort in tx_port_name]
        else:
            raise ValueError("Tx_name must be 'all', a string, or a list of strings")

        for port in rocve2_find_ports:
            if inter_batch_value is not None:
                port.InterBatchPeriodValue = inter_batch_value
            if inter_batch_units is not None:
                port.InterBatchPeriodUnits = inter_batch_units
            if target_rate is not None:
                port.TargetLineRateInPercent = target_rate
            if tx_ctrl is not None:
                port.TxCtrlParam = tx_ctrl

            self.log.info(f"Updated RoCEv2 Port Config for {port.TxPort}")
        return True

    def rocve2_start_traffic(self):
        """
        Start RoCEv2 traffic for the enabled streams

        Example: ApData.TGEN.rocve2_start_traffic()
        """
        state = self.ixNetwork.Traffic.find().State
        if state == 'unapplied':
            self.log.info("Applying RoCEv2 Traffic changes")
            self.ixNetwork.Traffic.find().Apply()

        self.ixNetwork.Traffic.find().Start()
        self.log.info("Traffic Started for all enabled RoCEv2 flow groups")
        return True

    def rocve2_stop_traffic(self):
        """
        Stop RoCEv2 traffic for the running flow groups.

        Example: ApData.TGEN.rocve2_start_traffic()
        """
        self.ixNetwork.Traffic.find().Stop()
        self.log.info("RoCEv2 Traffic has been stopped for all running flow groups")
        return True

    def delete_ports(self, port_list='all'):
        """
        Deletes list of ports if provided else all the ports in the session

        :param port_list: List of ports to be remove from the session,Defualt is all
        :return: True on success
        :Example: delete_ports(port_list=['Ethernet - 001'])
                  delete_ports(port_list=['2/7'])
                  delete_ports(port_list=['10.39.65.156/2/7'])
        """
        return self._delete_ports(port_list=port_list)

    def _delete_ports(self, port_list='all'):
        """
        Deletes list of ports if provided else all the ports in the session
        Along with the ports the topology associated to the ports will also be deleted

        :param port_list: List of ports to be remove from the session
        :return: True on success
        """
        port_to_topology_map = {}
        all_topologies = self.ixNetwork.Topology.find()
        for topology in all_topologies:
            for port in topology.Ports:
                port_to_topology_map[port] = topology
        self.log.success("Port - Topology Map built.")

        deleted_topologies = set()
        for vport_obj in self.ixNetwork.Vport.find():
            if vport_obj.Name in port_list:
                try:
                    vport_href = vport_obj.href
                    vport_name = vport_obj.Name
                    self.log.info(f"\nProcessing port: '{vport_name}' (handle: {vport_href})")

                    # Find and delete the associated topology first.
                    topology_to_delete = port_to_topology_map.get(vport_href)
                    if topology_to_delete and topology_to_delete.Name not in deleted_topologies:
                        topo_name = topology_to_delete.Name
                        self.log.info(f"Found associated topology: '{topo_name}'. Deleting it first...")
                        topology_to_delete.remove()
                        deleted_topologies.add(topo_name)
                        self.log.success(f"Topology '{topo_name}' deleted.")

                    # delete the vport.
                    self.log.info(f"Deleting vPort: '{vport_name}'...")
                    vport_obj.remove()
                    self.log.success(f"vPort '{vport_name}' deleted.")
                except Exception as e:
                    self.log.exception(f"Error occurred processing a port: {e}")
        return True

    def _is_connected(self,chassis_ip):
        """
        Internal function used by chassis_connection_status to get chassis state

        :param chassis_ip: Chassis information
        :return: True if chassis connected in the session else False
        """
        if self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + chassis_ip + '$'):
            if self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + chassis_ip + '$').State == 'ready':
                self.log.info(f"{chassis_ip} chassis is connected in the session")
                return True
        else:
            self.log.info(f"{chassis_ip} chassis is not connected in the session")
            return False

    def chassis_connection_status(self, chassis_ip):
        """
        Get Boolean connected status of the specified chassis.

        :param chassis_ip: Chassis information
        :return: True if chassis connected in the session else False
        """
        self.log.info(f"Checking connection status of the Chassis {chassis_ip}")
        return self._is_connected(chassis_ip)

    def set_port_mode(self, port_name,
                      port_mode="starFourHundredGigLanFcoe",
                      ieee_mode="ieee802.1Qbb",
                      pfc_queue_group_size="4",
                      pfc_priority_map=None,
                      enable_pfc_delay=False,
                      delay_quanta="1"):
        """
        Set a vport's L1 settings to FCoE mode safely.

        :param port_name: Name of the vport (string)
        :param port_mode: port mode to be set
        :param ieee_mode: port IEEE mode to be set
        :param pfc_queue_group_size: Port Priority Group Size
        :param pfc_priority_map: PFC Priority Group
        :param enable_pfc_delay: PFC Delay
        :param delay_quanta: PFC Delay Quanta

        :Available Port Modes supported -
                     - str(ethernet | ethernetvm | ethernetcm | novusmini | novusminipro | ethernetFcoe | atm | pos |
                           tenGigLan | tenGigLanFcoe | fortyGigLan | fortyGigLanFcoe | tenGigWan | tenGigWanFcoe | hundredGigLan |
                           hundredGigLanFcoe | tenFortyHundredGigLan | tenFortyHundredGigLanFcoe | fc | ethernetImpairment |
                           novusHundredGigLan | novusHundredGigLanFcoe | novusTenGigLan | novusTenGigLanFcoe | krakenFourHundredGigLan |
                           krakenFourHundredGigLanFcoe | aresOneFourHundredGigLan | aresOneFourHundredGigLanFcoe | uhdOneHundredGigLan |
                           novus5GTenTwentyFiveGigLan | novus5GTenTwentyFiveGigLanFcoe | starFourHundredGigLan | starFourHundredGigLanFcoe |
                           ravenEightHundredGigLan | ravenEightHundredGigLanFcoe | aresOneEightHundredGigLanQddC | aresOneEightHundredGigLanQddCFcoe |
                           sertHundredGigLan | aresOneEightHundredGigLanOsfpC | aresOneEightHundredGigLanOsfpCFcoe | aresOneM | aresOneMFcoe)

        :Example: set_port_mode(port_name="1/1", port_mode= starFourHundredGigLanFcoe',pfc_queue_group_size=4,pfc_priority_map = [1,2,-1,4,1,2,3,4])

        :return: True if successful, False otherwise
        """
        try:
            vport = self.ixNetwork.Vport.find(Name=f'^{re.escape(port_name)}$')
            if len(vport) != 1:
                self.log.error(f"[{port_name}] Vport not found or not unique.")
                return False

            vport_l1 = vport.L1Config.find()
            if vport_l1.CurrentType != port_mode:
                self.log.debug(f"[{port_name}] Switching L1 CurrentType: {vport_l1.CurrentType} -> {port_mode}")
                vport_l1.update(CurrentType=port_mode)
                vport_l1 = vport.L1Config.find()
                if vport_l1.CurrentType != port_mode:
                    self.log.error(f"[{port_name}] Failed to set FCoE mode. Reported: {vport_l1.CurrentType}")
                    return False
                self.log.info(f"[{port_name}] L1 CurrentType set to {vport_l1.CurrentType}")

            type_name = vport_l1.CurrentType.replace("Fcoe", "")
            try:
                type_node = getattr(vport_l1, type_name[0].upper() + type_name[1:]).find()
                fcoe = type_node.Fcoe.find()
            except AttributeError as err:
                self.log.error(f"[{port_name}] Could not resolve FCoE node under L1Config. {err}")
                return False

            if ieee_mode == "ieee802.1Qbb":
                try:
                    fcoe.FlowControlType = ieee_mode
                    fcoe.PfcQueueGroupSize = f"pfcQueueGroupSize-{pfc_queue_group_size}"
                    fcoe.PfcQueueGroups = pfc_priority_map
                    fcoe.EnablePFCPauseDelay = bool(enable_pfc_delay)
                    fcoe.PfcPauseDelay = str(delay_quanta)
                    self.log.info(f"[{port_name}] Configured in {ieee_mode} with PFC fields applied.")
                except Exception as inner_e:
                    self.log.error(f"[{port_name}] Failed to apply PFC settings: {inner_e}")
                    return False
            elif ieee_mode == "ieee802.3x":
                try:
                    fcoe.FlowControlType = ieee_mode
                    self.log.info(f"[{port_name}] Configured in {ieee_mode} (basic flow control, no PFC).")
                except Exception as inner_e:
                    self.log.error(f"[{port_name}] Failed to apply ieee802.3x flow control: {inner_e}")
                    return False
            else:
                self.log.error(
                    f"[{port_name}] Invalid ieee_mode '{ieee_mode}'. Must be 'ieee802.1Qbb' or 'ieee802.3x'.")
                return False
            return True

        except Exception as err:
            self.log.exception(f"[{port_name}] Error setting DCB: {err}")
            return False

    def diagnostics_cleanup(self, server_ip, username, password):
        """
        Cleans up diagnostics and log files on a remote IxNetwork API server.

        Connects to the IxNetwork REST API server and triggers the Diagnostics > Cleanup
        subsystem to remove logs and profiles older than 1 day. This helps reclaim disk space
        and reset diagnostics for long-running or shared servers.

        :param server_ip: IP address or hostname of the IxNetwork server.
        :param username: Username for server authentication.
        :param password: Password for server authentication.
        :return: None
        """
        self.log.info(f"Connecting to IxNetwork server {server_ip} for cleanup...")
        try:
            # Create a standalone RESTPy session
            session = SessionAssistant(
                IpAddress=server_ip,
                UserName=username if username else "admin",
                Password=password if password else "admin",
                RestPort=11009,
                SessionName=None,
                ClearConfig=False)

            ixnetwork = session.Ixnetwork
            cleanup = ixnetwork.Globals.Diagnostics.Cleanup.find()

            for each in cleanup:
                each.ChassisDaysOld = 1
                each.ClientDaysOld = 1
                each.CleanupChassis = True
                each.CleanupClient = True
                each.ProfileAllprofiles = True
                each.ProfileAes = True
                each.ProfileHlapi = True
                each.ProfileAnalyzer = True
                each.ProfileQuicktests = True
                each.ProfileImpairment = True
                each.ProfileIxloadlite = True
                each.ProfileMiddleware = True
                each.ProfileStackmanager = True
                each.ProfileStatviewerreporter = True

            cleanup.CleanupLogs()
            ixnetwork.Globals.Diagnostics.Cleanup.ClientDaysOld = 1
            ixnetwork.Globals.Diagnostics.Cleanup.CleanupClient = True
            ixnetwork.Globals.Diagnostics.Cleanup.ProfileAllprofiles = True
            ixnetwork.Globals.Diagnostics.Cleanup.CleanupLogs()
            self.log.success(f"Cleanup completed on {server_ip}")
            # terminate the session
            session.Session.remove()
        except:
            pass

    def health_check(self, server_list={}, **kwargs):
        """
        Performs a comprehensive health check across multiple IxNetwork API servers.

        For each IxNetwork Web API server, the API:
        - Authenticates and retrieves an API key.
        - Fetches the current session dashboard and resource utilization (CPU, Memory, Disk).
        - Optionally displays the dashboard and inactive session table.
        - Triggers automatic cleanup if disk/memory usage exceed thresholds.

        :param server_list: A list of IxNetwork servers, each containing: {"ip": "<server_ip>","username": "<username>","password": "<password>"}
        :param kwargs:
                show_dashboard: (kwarg) Boolean flag to display per-server session dashboard.
                show_inactive: (kwarg) Boolean flag to list inactive sessions older than `max_days`.
                cleanup_logs: (kwarg) Boolean flag to trigger diagnostics cleanup when thresholds exceed.
                max_days: (kwarg) Integer threshold in days for session inactivity detection. Default = 2.
                max_memory_usage: (kwarg) Integer max allowed memory usage in percent. Default = 70.
                max_disk_usage: (kwarg) Integer max allowed disk usage in percent. Default = 100.

        :Example: health_check(server_list=[{'ip':'10.1.2.3', 'username': 'test','password': '***'}], show_dashboard= True, show_inactive = True)
                  health_check(server_list=[{"ip": "10.6.74.5", "username": "admin", "password": "***"}], show_dashboard=True, show_inactive=True,
                  cleanup_logs=True, max_days=3, max_memory_usage=75, max_disk_usage=90)
        :return: None
        """
        # Toggle this flag to enable/disable dashboard output
        show_dashboard = kwargs.get('show_dashboard', False)
        show_inactive = kwargs.get('show_inactive', False)
        cleanup_logs = kwargs.get("cleanup_logs",False)
        max_days = kwargs.get('max_days', 2)
        max_memory_usage = kwargs.get('max_memory_usage', 70)
        max_disk_usage = kwargs.get('max_disk_usage', 100)

        def get_api_key(server_ip, creds):
            """
            Authenticates to the IxNetwork Web API server and retrieves an API key.

            :param server_ip: IxNetwork server IP or hostname.
            :param creds: Dictionary with 'username' and 'password'.
            :return: API key string if successful, None otherwise.
            """
            url = f"https://{server_ip}/api/v1/auth/session"
            headers = {"content-type": "application/json"}
            try:
                response = requests.post(url, data=json.dumps(creds), headers=headers, verify=False)
                response.raise_for_status()
                return response.json()["apiKey"]
            except Exception as err:
                self.log.error(f" Failed to authenticate to {self.server_ip}: {err}")
                return None

        def get_dashboard(server_ip, api_key):
            """
            Retrieves the IxNetwork Web API session dashboard summary.

            :param server_ip: IxNetwork server IP or hostname.
            :param api_key: Valid IxNetwork API key.
            :return: List of active session details from the dashboard.
            """
            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }
            payload = {
                "arg1": "/api/v1/sessions/9999/ixnetworkglobals/currentuser"
            }
            url = f"https://{server_ip}/api/v1/sessions/9999/ixnetworkglobals/currentuser/operations/getsessiondashboardsummary"

            try:
                response = requests.post(url, headers=headers, json=payload, verify=False, timeout=10)
                response.raise_for_status()
                return response.json().get("result", [])
            except Exception as err:
                self.log.error(f" Failed to fetch dashboard from {self.server_ip}: {err}")
                return False

        def display_dashboard_table(dashboard, server_ip):
            """
            Displays the IxNetwork session dashboard in a formatted table view.

            :param dashboard: Dashboard data as a list of session dicts.
            :param server_ip: Server IP where the dashboard was fetched from.
            :return: None
            """
            if not dashboard:
                self.log.error("No session dashboard data available.")
                return False

            headers = [
                "Session ID", "PID", "Login Name", "Config File Name", "Session Start Time",
                "Session Status", "Protocol Status", "Protocol Detailed Status", "Traffic Status", "Age (Days)"
            ]

            table = []
            now = datetime.datetime.now()

            for session in dashboard:
                start_time_str = session.get("SessionStartTime", "")
                age_days = ""

                if start_time_str:
                    try:
                        start_time = datetime.datetime.strptime(start_time_str, "%m/%d/%Y %I:%M:%S %p")
                        age_days = (now - start_time).days
                    except Exception:
                        age_days = "?"

                table.append([
                    session.get("SessionId"),
                    session.get("Pid"),
                    session.get("LoginName"),
                    session.get("ConfigFileName"),
                    start_time_str,
                    session.get("SessionStatus"),
                    session.get("ProtocolStatus"),
                    session.get("ProtocolDetailedStatus"),
                    session.get("TrafficStatus"),
                    age_days
                ])

            self.log.info(f"IxNetwork Web API Server {server_ip} Session Dashboard:")
            self.log.info(f"\n {tabulate.tabulate(table, headers=headers, tablefmt='grid')}")

        def check_status(url,api_key):

            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }

            for _ in range(500):
                response = requests.get(url,headers= headers, verify = False)
                if response.json().get("state") == "SUCCESS":
                    break
                else:
                    time.sleep(2)
                    continue

        def create_temp_session(server_ip, api_key):
            """
            Create a temporary IxNetwork Session to get session id.

            :param server_ip: IxNetwork server IP or hostname.
            :param api_key: Valid IxNetwork API key.
            :return: Session ID.
            """

            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }
            payload = {"applicationType": "ixnrest", "Name": "health_check_temp"}

            url = f"https://{server_ip}/api/v1/sessions"
            try:
                #create session
                response1 = requests.post(url, headers=headers, data=json.dumps(payload), verify=False, timeout=10)
                response1.raise_for_status()
                id = response1.json()["id"]

            except Exception as err:
                self.log.error(f" Failed to create temp session on {server_ip}: {err}")
                return None
            
            payload2 = {"applicationType": "ixnrest"}
            try:
                #start session
                url2 = f"https://{server_ip}/api/v1/sessions/{id}/operations/start"
                response2 = requests.post(url2, headers=headers, data=json.dumps(payload2), verify=False, timeout=10)
                response2.raise_for_status()

            except Exception as err:
                self.log.error(f" Failed to start temp session on {id}: {err}")
                return None

            get_url = response2.json().get("url")
            check_status(get_url, api_key)
            return id

        def delete_temp_session(server_ip, api_key, session_id):
            """
            Deletes the temporary IxNetwork Session.

            :param server_ip: IxNetwork server IP or hostname.
            :param api_key: Valid IxNetwork API key.
            :param session_id: Session ID of the session you want to delete.

            """

            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }
            payload2 = {"applicationType": "ixnrest"}

            try:
                #stop session
                url2 = f"https://{server_ip}/api/v1/sessions/{session_id}/operations/stop"
                response2 = requests.post(url2, headers=headers, data=json.dumps(payload2), verify=False, timeout=10)
                response2.raise_for_status()

            except Exception as err:
                self.log.error(f" Failed to start temp session on {id}: {err}")
                return None
            
            get_url = response2.json().get("url")
            check_status(get_url, api_key)

            url = f"https://{server_ip}/api/v1/sessions/{session_id}"
            try:
            #delete session
                requests.delete(url, headers=headers, verify=False, timeout=10)
            except Exception as e:
                raise e

        def get_ixnetwork_version(server_ip,api_key,session_id):

            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }

            url = f"https://{server_ip}/api/v1/sessions/{session_id}/ixnetwork/globals/"

            response = requests.get(url,headers= headers, verify = False)
            version = response.json().get("protocolbuildNumber") 
            return version

        def get_resource_monitor(server_ip, api_key, session_id):
            """
            Retrieves system resource statistics (Disk, CPU, Memory) for a given session.

            :param server_ip: IxNetwork server IP or hostname.
            :param api_key: Valid IxNetwork API key.
            :param session_id: Active IxNetwork session ID.
            :return: Dictionary containing system resource details.
            """
            headers = {
                "content-type": "application/json",
                "x-api-key": api_key
            }
            payload = {"arg1": "true"}
            url = f"https://{server_ip}/api/v1/sessions/{session_id}/ixnetwork/operations/getsystemresources"

            try:
                response = requests.post(url, headers=headers, json=payload, verify=False, timeout=10)
                response.raise_for_status()
                result = response.json().get("result", {})

                if isinstance(result, str):
                    result = json.loads(result)

                return {
                    "SystemDiskInfo": result.get("SystemDiskInfo", {}),
                    "SystemCPUUsage": result.get("SystemCPUUsage", {}),
                    "SystemMemoryInfo": result.get("SystemMemoryInfo", {})
                }

            except Exception as err:
                self.log.warning(f" Failed to fetch resource monitor from {server_ip}: {err}")
                return None

        def collect_resource_summary(resource_data, server_ip, api_key, session_id):
            """
            Formats raw resource monitor data into a summary table row.

            :param resource_data: Dictionary returned by get_resource_monitor().
            :param server_ip: Server IP corresponding to the resource data.
            :return: List containing disk, CPU, and memory usage metrics.
            """
            disk = resource_data.get("SystemDiskInfo", {})
            cpu = resource_data.get("SystemCPUUsage", {})
            memory = resource_data.get("SystemMemoryInfo", {})
            version = get_ixnetwork_version(server_ip, api_key, session_id)

            return [
                server_ip,
                version,
                disk.get("Total", ""),
                disk.get("Available", ""),
                disk.get("Used", ""),
                disk.get("Used%", ""),
                cpu.get("CPUUsage(%)", ""),
                memory.get("Total", ""),
                memory.get("Available", ""),
                memory.get("Used", ""),
                memory.get("Used%", "")
            ]

        def calculate_session_age_days(start_time_str):
            """
            Calculates the number of days since a session was started.

            :param start_time_str: Session start time string (MM/DD/YYYY hh:mm:ss AM/PM).
            :return: Integer representing session age in days, or None if invalid.
            """
            try:
                return (datetime.datetime.now() - datetime.datetime.strptime(start_time_str, "%m/%d/%Y %I:%M:%S %p")).days
            except:
                return None

        def filter_inactive_old_sessions(dashboard):
            """
            Filters inactive IxNetwork sessions older than `max_days`.

            :param dashboard: Dashboard data as a list of session dicts.
            :return: List of inactive session summaries exceeding max_days.
            """
            filtered = []
            for session in dashboard:
                age_days = calculate_session_age_days(session.get("SessionStartTime", ""))
                if age_days is not None and age_days > max_days:
                    if (session.get("SessionStatus") == "NOT STARTED" and
                            session.get("ProtocolStatus") == "STOPPED" and
                            session.get("TrafficStatus") == "UNAPPLIED"):
                        filtered.append({
                            "SessionId": session.get("SessionId"),
                            "ConfigFile": session.get("ConfigFileName"),
                            "StartTime": session.get("SessionStartTime"),
                            "AgeDays": age_days
                        })
            return filtered

        def show_old_inactive_table(server_ip, filtered_sessions):
            """
            Displays a formatted table of old, inactive IxNetwork sessions.

            :param server_ip: IxNetwork server IP.
            :param filtered_sessions: List of filtered inactive session entries.
            :return: None
            """
            if not filtered_sessions:
                self.log.info(f" No inactive sessions older than {max_days} days on {server_ip}")
                return

            headers = ["Session ID", "Config Name", "Start Time", "Age (days)"]
            table = [
                [s["SessionId"], s["ConfigFile"], s["StartTime"], s["AgeDays"]]
                for s in filtered_sessions
            ]

            self.log.warning(f" Inactive Sessions Older Than {max_days} Days on {server_ip}")
            self.log.info(f"\n{tabulate.tabulate(table, headers=headers, tablefmt='grid')}")

        final_table = []

        for server in server_list:
            server_ip = server["ip"]
            username = server["username"]
            password = server["password"]

            creds = {
                "username": server["username"],
                "password": server["password"]
            }

            self.log.info(f"\nConnecting to {server_ip}...")
            api_key = get_api_key(server_ip, creds)

            if not api_key:
                self.log.debug(f"Skipping {server_ip} due to API key failure.")
                continue

            dashboard = get_dashboard(server_ip, api_key)
            if show_dashboard:
                display_dashboard_table(dashboard, server_ip)

            session_id = create_temp_session(server_ip, api_key)
            if not session_id:
                self.log.warning(f"No valid session ID found on {server_ip}.")
                continue
            
            time.sleep(5)
            resource_data = get_resource_monitor(server_ip, api_key, session_id)
            if not resource_data:
                continue

            summary = collect_resource_summary(resource_data, server_ip, api_key, session_id)

            try:
                disk_used_percent = float(summary[5])
                mem_used_percent = float(summary[10])

                if disk_used_percent > max_disk_usage or mem_used_percent >= max_memory_usage:
                    self.log.warning(f" {server_ip} has high resource usage.")
                    if disk_used_percent > max_disk_usage:
                        self.log.warning(f"  Disk Usage is {disk_used_percent}%, performing cleanup.")

                    if mem_used_percent >= max_memory_usage:
                        self.log.warning(f"  Memory Usage is {mem_used_percent}%, consider removing inactive session.")

                    # if cleanup_logs:
                    #     self.diagnostics_cleanup(server_ip, username, password)
                    #     self.log.info(f"Cleanup done on server ip = {server_ip}")

            except Exception as err:
                self.log.warning(f"Check failed for {server_ip}: {err}")

            final_table.append(summary)

            if show_inactive:
                filtered = filter_inactive_old_sessions(dashboard)
                show_old_inactive_table(server_ip, filtered)
        
            delete_temp_session(server_ip, api_key, session_id)

        if final_table:
            self.log.info("\n=======Resource Monitor Summary========\n")
            headers = [
                "Server IP", "Version",
                "Disk Total", "Disk Available", "Disk Used", "Disk Used%",
                "CPU Usage (%)",
                "Mem Total", "Mem Available", "Mem Used", "Mem Used%"
            ]
            self.log.info(f"\n{tabulate.tabulate(final_table, headers=headers, tablefmt='grid')}")
        else:
            self.log.info("No resource monitor summary data collected.")

    def start_arp_and_verify9(self,**kwargs):
        """
        starts the ARP and verifies the ARP status

        :return: true if successful else false if verify fails or exception in case error occurs

        :Example: start_arp_and_verify()
        """
        result_list = []
        scale_arp = kwargs.get('scale_arp', False)
        arp_retry = kwargs.get('arp_retry', 5)
        retry_delay = kwargs.get('retry_delay', 20)
        chunk_size = kwargs.get('chunk_size', 4000)

        topology = self.ixNetwork.Topology.find()
        with BatchFind(topology) as device_group:
            topology.DeviceGroup.find()

        device_obj_list = getattr(device_group.results, "deviceGroup")
        try:
            for device_obj in device_obj_list:
                if scale_arp == True:
                    self.log.info(f'Starting ARP in bulk on: {device_obj.Name}')
                    ipv4_objs = []
                    for eth in device_obj.Ethernet.find():
                        ipv4_objs.extend(eth.Ipv4.find())
                    if not ipv4_objs:
                        self.log.warning(f'IPv4 block not found in {device_obj.Name}')
                        result_list.append(False)
                        continue

                    for ipv4_obj in ipv4_objs:
                        total_sessions = ipv4_obj.Count
                        session_indices = list(range(1, total_sessions + 1))
                        success = False
                        for attempt in range(1, arp_retry + 1):
                            try:
                                for i in range(0, total_sessions, chunk_size):
                                    chunk = session_indices[i:i + chunk_size]
                                    self.log.info(f'{device_obj.Name}: Sending ARP for sessions {chunk[0]}-{chunk[-1]} (attempt {attempt})')
                                    ipv4_obj.SendArp(SessionIndices=chunk)
                                    time.sleep(5)  

                                success = self.verify_arp_status(ipType='ipv4', device=device_obj.Name)
                                if success:
                                    break
                                else:
                                    self.log.warning(f'ARP verification failed on {device_obj.Name}, retry {attempt}')
                                    time.sleep(retry_delay)
                            except Exception as e:
                                self.log.warning(f'ARP chunk send failed on {device_obj.Name} attempt {attempt}: {e}')
                                time.sleep(retry_delay)
                        result_list.append(success)

                else:
                    self.log.info(f'Starting Arp on: {device_obj.Name}')
                    if device_obj.Ethernet.find().Ipv4.find():
                        for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():
                            obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))
                            ipv4_obj.SendArp(SessionIndices=obj_count_list)
                            result_list.append(self.verify_arp_status(device=device_obj.Name))
                    else:
                        self.log.info(f'IPv4 block not found in {device_obj.Name}')
        except:
            self.log.error(f'Device Group {device_obj.Name} is not started')

        if not False in result_list:
            result = True
        else:
            result = False
        return result

    def retrieve_per_prefix_frame_loss_new(self, ip_type="ipv4", show_all=False, traffic_item_list=None):

        prefixesLossDict = {}
        all_traffic_items = self.get_traffic_items()

        if not traffic_item_list:
            traffic_item_list = self.get_active_streams()

        dest_ip_hint = "ipv4" if ip_type.lower() == "ipv4" else "ipv6"
        log.info(f"Processing traffic items: {traffic_item_list}")

        trafficItemStats = StatViewAssistant(self.ixNetwork, "Traffic Item Statistics")
        rowList = [i for i, stat in enumerate(trafficItemStats.Rows)
                if stat["Traffic Item"] in traffic_item_list]

        for rowIndex in rowList:
            prefixBaseStats = None
            drill_opts = trafficItemStats.DrillDownOptions(rowIndex)

            flat_opts = []
            for opt in drill_opts:
                if isinstance(opt, (list, tuple)):
                    flat_opts.extend(opt)
                else:
                    flat_opts.append(opt)

            for ddIndex, opt in enumerate(flat_opts[:5]):
                try:
                    prefixBaseStats = trafficItemStats.Drilldown(
                        rowIndex, opt, trafficItemStats.TargetRowFilters()[rowIndex]
                    )
                    if prefixBaseStats and getattr(prefixBaseStats, "Rows", []):
                        log.info(f" Drilldown succeeded for "
                                f"{trafficItemStats.Rows[rowIndex]['Traffic Item']} "
                                f"at index {ddIndex} using option '{opt}'")
                        break
                except Exception as e:
                    log.warning(f"Drilldown {ddIndex} failed: {e}")
                    time.sleep(3)

            retry_count = 0
            while (not prefixBaseStats or not prefixBaseStats.Rows) and retry_count < 3:
                log.info(f"Waiting for drilldown rows (attempt {retry_count + 1})...")
                time.sleep(5)
                try:
                    prefixBaseStats = trafficItemStats.Drilldown(
                        rowIndex, flat_opts[0], trafficItemStats.TargetRowFilters()[rowIndex]
                    )
                except Exception:
                    pass
                retry_count += 1

            if not prefixBaseStats or not getattr(prefixBaseStats, "Rows", []):
                log.warning(f"No drilldown rows returned for traffic item row {rowIndex}")
                continue

            headers = prefixBaseStats.ColumnHeaders
            log.info(f"Available columns: {headers}")

            destType = next((c for c in headers
                            if "Destination" in c and dest_ip_hint in c.lower()), None)
            if not destType:
                destType = next((c for c in headers if "Destination" in c), None)

            lossCol = next((c for c in headers
                            if "Loss" in c and "Duration" in c), None)
            if not destType or not lossCol:
                log.warning(f"Could not find Destination or Loss Duration columns for {trafficItemStats.Rows[rowIndex]['Traffic Item']}")
                continue

            for stat in getattr(prefixBaseStats, "Rows", []):
                try:
                    prefixIp = stat.get(destType) if hasattr(stat, "get") else stat[destType]
                    lossDuration = stat.get(lossCol) if hasattr(stat, "get") else stat[lossCol]
                    if show_all or float(lossDuration or 0) > 0:
                        prefixesLossDict[prefixIp] = lossDuration
                except Exception as e:
                    log.warning(f"Error parsing stat row: {e}")

        if prefixesLossDict:
            log.info(f" Collected {len(prefixesLossDict)} prefixes with loss data")
            return prefixesLossDict
        else:
            log.error(f"No {ip_type} prefix data found  possible causes: "
                    f"traffic stopped too early, loss columns unavailable, or view not yet generated.")
            raise IxiaConfigException(f"No {ip_type} prefix data found (traffic stream not found or no loss columns)")


    def set_port_transmit_deviation2(self, port_list=None, deviation='enabled', deviation_value=0, **kwargs):
        """
        Sets the transmit deviation type and value for a given set of ports

        :param port_list: (list) The port(s) to configure
            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']
            Note - for IXIA all ports in the same group will be enabled/disabled regardless of port_list
        :param deviation: (str) Selects whether transmit deviation is enabled or disabled
            e.g. 'enabled', 'disabled'
        :param deviation_value: (int/str): The desired PPM deviation value
            e.g. 10, "10"
        :param kwargs:
                    wait_interval : (int) sleep time default 0
                    repetition : (int) Number of time opertaion to be repeated Ex : 5
                    operation : "increment"/"decrement" if "decrement" then negative deviation_value will be set EX : -10
        :return: True on success, exception otherwise

        :Example: set_port_transmit_deviation(deviation_value=10)
                  set_port_transmit_deviation(deviation_value=10,operation="increment",wait_interval=5, repetition=2)
        """

        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)
        operation = kwargs.get("operation", "increment")
        max_workers = kwargs.get("thread_count", 17)  

        if operation == "decrement":
            deviation_value = -deviation_value

        cardTypeList = ['atlasFourHundredGigLan',
                        'atm',
                        'ethernet',
                        'ethernetImpairment',
                        'ethernetvm',
                        'fc',
                        'fortyGigLan',
                        'hundredGigLan',
                        'krakenFourHundredGigLan',
                        'novusHundredGigLan',
                        'novusTenGigLan',
                        'pos',
                        'tenFortyHundredGigLan',
                        'tenGigLan',
                        'tenGigWan',
                        'aresOneFourHundredGigLan',
                        'starFourHundredGigLan']

        def _apply_ppm_on_port(port_identifier, port_type, card_type, deviation, deviation_value):
            try:
                if port_type == "NAME":
                    card_obj = eval(f'self.ixNetwork.Vport.find(Name=port_identifier).L1Config.{card_type}')
                else:
                    card_obj = eval(f'self.ixNetwork.Vport.find(AssignedTo=port_identifier).L1Config.{card_type}')

                card_obj.EnablePPM = (deviation.lower() == 'enabled')
                card_obj.Ppm = deviation_value
                status = "Enabled" if deviation.lower() == 'enabled' else "Disabled"
                self.log.info(f" On Port: {port_identifier} {status} deviation and value set to: {deviation_value}")
            except Exception as e:
                self.log.error(f" Failed to apply PPM on {port_identifier}: {e}")

        while repetition != 0:
            vports = self.ixNetwork.Vport.find()
            vports.ReleasePort()

            target_ports = port_list or [vport.Name for vport in vports]

            jobs = []
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                for port in target_ports:
                    if re.search(r'\d+\.\d+\.\d+\.\d+/\d+/\d+', port):
                        port_ip = port.replace("/", ":")
                        card_type = self.ixNetwork.Vport.find(AssignedTo=port_ip).Type
                        port_type = "IP"
                        port_identifier = port_ip
                    else:
                        card_type = self.ixNetwork.Vport.find(Name=port).Type
                        port_type = "NAME"
                        port_identifier = port

                    if card_type not in cardTypeList:
                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found.')
                    card_type = card_type[0].upper() + card_type[1:]

                    jobs.append(executor.submit(_apply_ppm_on_port, port_identifier, port_type, card_type, deviation, deviation_value))

                for f in as_completed(jobs):
                    _ = f.result()

            vports.ConnectPorts()
            time.sleep(wait_interval)
            repetition -= 1

        return True

    def set_auto_negotiate1(self, port_list=None, auto_negotiate=True, **kwargs):
        """
        Function to set auto-negotiation of port speeds (threaded).

        :param port_list: List of port names (optional)
        :param auto_negotiate: True or False
        :param kwargs:
                     max_threads: Max number of parallel threads (default=5)

        :Example: set_auto_negotiate(port_list=['port1'], auto_negotiate=False)
        """

        max_workers = kwargs.get("max_workers", 13)

        def _set_port_negotiation(vport, port_name):

            """Internal helper to safely configure a single port."""

            port_type = vport.Type
            capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)
            try:
                port_obj = getattr(vport.L1Config, capitalized_card_type)
                port_obj.update(AutoNegotiate=auto_negotiate)
                self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {port_name}")
                return True
            except TypeError:
                port_obj = getattr(vport.L1Config, capitalized_card_type)
                port_obj.update(EnableAutoNegotiation=auto_negotiate)
                self.log.info(f"auto negotiation is set to {auto_negotiate} on port: {port_name}")
                return True
            except Exception as e:
                self.log.info(f"card type {capitalized_card_type} might not support auto negotiation for port: {port_name} ({e})")
                return False

        vport_list = []

        if port_list is None:
            self.log.info("Setting Auto Negotiation of all available ports in the config")
            for vport in self.ixNetwork.Vport.find():
                vport_list.append((vport, vport.Name))

        else:
            self.log.info(f"Setting Auto Negotiation of ports - {port_list} in the config")
            for port in port_list:
                if re.search(r'\d+\.\d+\.\d+\.\d+/\d+/\d+', port):
                    port_ref = port.replace("/", ":")
                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + port_ref + '$')
                else:
                    vport = self.ixNetwork.Vport.find(Name='^' + port + '$')

                if vport:
                    vport_list.append((vport, port))
                else:
                    self.log.info(f"port {port} not available in the config")
                    return False

        with ThreadPoolExecutor(max_workers=min(max_workers, len(vport_list))) as executor:
            futures = {executor.submit(_set_port_negotiation, vp, name): name for vp, name in vport_list}
            results = [f.result() for f in as_completed(futures)]

        if all(results):
            self.log.info(" Auto Negotiation configured successfully on all requested ports.")
            return True
        else:
            self.log.warning(" Some ports failed to configure Auto Negotiation.")
            return False
        
    def generate_license_summary(self, chassis_ip, username='admin', password='admin', license_feature=None):
        """
        API used to retrieve license details based on Ixia chassis
        """
        USERNAME_PASSWORD = {'username': username, 'password': password}
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        JSON_USERNAME_PASS = json.dumps(USERNAME_PASSWORD)
        auth_key_call = f"https://{chassis_ip}/api/v1/auth/session"

        try:
            api_response = requests.post(auth_key_call, data=JSON_USERNAME_PASS,
                                         headers={'content-type': "application/json"}, verify=False, timeout=10)
            api_response.raise_for_status()
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Authentication failed: {err}")
            return None

        api_json = api_response.json()
        api_key = api_json.get("apiKey")
        if not api_key:
            self.log.error(f"[{chassis_ip}] No API key returned during authentication.")
            return None

        HEADERS = {
            'x-api-key': api_key,
            'content-type': "application/json"
        }

        for server_type in ['platform', 'ixnetworkweb']:
            license_server_url = f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/"
            try:
                license_server_response = requests.get(license_server_url, headers=HEADERS, verify=False, timeout=10)
                if license_server_response.status_code == 200:
                    break
            except Exception as err:
                self.log.debug(f"{chassis_ip}] Failed to connect to {license_server_url}: {err}")
                continue
        else:
            self.log.error(f"[{chassis_ip}] License Fetch failed for chassis/server.")
            return None

        try:
            server_id = license_server_response.json()[0]['id']
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Could not extract server ID: {err}")
            return None

        license_retrieval_url = f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/operations/retrievelicenses"

        try:
            license_retrieval_response = requests.post(license_retrieval_url, headers=HEADERS, verify=False, timeout=10)
            license_retrieval_response.raise_for_status()
            id_json = license_retrieval_response.json()
            license_id = id_json.get("id")
        except Exception as err:
            self.log.error(f"[{chassis_ip}] Failed to start license retrieval: {err}")
            return None

        if not license_id:
            self.log.error(f"[{chassis_ip}] No async operation ID received.")
            return None

        license_list_url = (
            f"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/"
            f"operations/retrievelicenses/{license_id}/result"
        )

        max_retries = 30
        wait_time = 1
        for attempt in range(max_retries):
            try:
                license_list_response = requests.get(license_list_url, headers=HEADERS, verify=False, timeout=10)
                status = license_list_response.status_code
                data = license_list_response.json()

                if status == 200 and isinstance(data, list):
                    break
                if isinstance(data, dict) and "no async operation" in str(data).lower():
                    time.sleep(wait_time)
                    wait_time = min(wait_time * 2, 5)
                    continue
                if status != 200 or "error" in str(data).lower():
                    time.sleep(wait_time)
                    continue

            except Exception as err:
                self.log.debug(f"[{chassis_ip}] Attempt {attempt + 1}/{max_retries} failed: {err}")
                time.sleep(wait_time)
                continue
        else:
            self.log.error(f"[{chassis_ip}] Timed out waiting for license result after {max_retries} retries.")
            return None

        license_data = license_list_response.json()
        if not isinstance(license_data, list):
            self.log.error(f"[{chassis_ip}] Unexpected license data format: {license_data}")
            return None

        required_keys = [
            "activationCode", "isExpired", "daysLeftToExpire",
            "quantity", "product", "description", "partNumber",
            "expiryDate","maintenanceDate"
        ]

        filtered_data = []
        for lic in license_data:
            filtered_lic = {k: lic.get(k) for k in required_keys if k in lic}
            filtered_data.append(filtered_lic)

        if license_feature:
            matched = []
            for lic in license_data:
                if "featuresList" in lic:
                    for f in lic["featuresList"]:
                        if license_feature.lower() in f.get("name", "").lower():
                            matched.append({k: lic.get(k) for k in required_keys if k in lic})
            if matched:
                self.log.info(f"[{chassis_ip}] Filtered license info for feature '{license_feature}':\n{json.dumps(matched, indent=2)}")
                return matched
            else:
                self.log.warning(f"[{chassis_ip}] License feature '{license_feature}' not found.")
                return False

        self.log.info(f"[{chassis_ip}] Filtered license info:\n{json.dumps(filtered_data, indent=2)}")
        return filtered_data

    def start_arp_on_streams_one(self, ports=()):
        """
        Starts ARP on all the streams under specified ports

        :param ports: port or list of ports Default all ports
        :return: True on success
        :Example: start_arp_on_streams()
        """
        self.log.info("Starting ARP at stream level")
        traffic_items_port_dict = {}

        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):
                with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')
                traffic_item_list = getattr(traffic_item.results, 'trafficItem')
                for traffic_item in traffic_item_list:
                    stream_list = traffic_item.HighLevelStream.find()
                    for count, stream in enumerate(stream_list):
                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)
                is_traffic_item = True
            else:
                self.log.warning('No Raw Traffic Streams in the configuration')
                return False
        else:
            with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                self.ixNetwork.Traffic.TrafficItem.find()
            is_traffic_item = False
            traffic_item_list = getattr(traffic_item.results, 'trafficItem')
            for traffic_item in traffic_item_list:
                stream_list = traffic_item.HighLevelStream.find()
                for count, stream in enumerate(stream_list):
                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)

        vport_dest_mac_dict = {}
        vports = [vport.href for vport in self.ixNetwork.Vport.find()]

        def collect_one_mac_per_topology(vport):
            try:
                for topology in self.ixNetwork.Topology.find():
                    if not topology.Ports:
                        continue
                    if topology.Ports[0] == vport:
                        ipv4_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()
                        for ipv4_block in ipv4_blocks:
                            for mac in ipv4_block.ResolvedGatewayMac:
                                if mac and mac != 'removePacket[Unresolved]':
                                    return (vport, mac)
                        ipv6_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()
                        for ipv6_block in ipv6_blocks:
                            for mac in ipv6_block.ResolvedGatewayMac:
                                if mac and mac != 'removePacket[Unresolved]':
                                    return (vport, mac)
            except Exception as e:
                self.log.warning(f'MAC address collection failed on {vport}: {e}')
            return None

        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_vport = {executor.submit(collect_one_mac_per_topology, v): v for v in vports}
            for future in as_completed(future_to_vport):
                result = future.result()
                if result:
                    vport_dest_mac_dict[result[0]] = result[1]

        self.log.debug(f"Resolved Gateway MACs per vPort: {vport_dest_mac_dict}")

        if not vport_dest_mac_dict:
            self.log.error("No valid resolved gateway MACs found  IP stack might be down")
            return False

        traffic_name_mac_mapping = {}
        for traffic_item_name, flows in traffic_items_port_dict.items():
            try:
                unique_macs = set()
                for flow in flows:
                    mac = vport_dest_mac_dict.get(flow)
                    if mac:
                        unique_macs.add(mac)
                if unique_macs:
                    traffic_name_mac_mapping[traffic_item_name] = [list(unique_macs)[0]]
                else:
                    self.log.warning(f"No MAC found for traffic item {traffic_item_name}")
            except Exception as e:
                self.log.error(f"MAC mapping failed for {traffic_item_name}: {e}")

        self.log.debug(f"Final Traffic -> MAC Mapping: {traffic_name_mac_mapping}")

        for traffic_name, mac_list in traffic_name_mac_mapping.items():
            traffic = re.escape(traffic_name)
            mac_value = mac_list[0]
            try:
                self.log.debug(f"Updating MAC for traffic item: {traffic_name} -> {mac_value}")
                if is_traffic_item:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').ConfigElement.find()
                            for count, config_element in enumerate(config_element_list):
                                if config_element.Stack.find(DisplayName='Ethernet II'):
                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        existing_mac = None
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,
                                                                                                         'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field,
                                                                                                        'SingleValue',
                                                                                                        None)
                                        except Exception:
                                            existing_mac = None

                                        if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                            skip = True
                                        else:
                                            try:
                                                ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')
                                                ipv4_field = None
                                                if ipv4_stackobj and ipv4_stackobj.href:
                                                    ipv4_field = ipv4_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')
                                                ipv6_field = None
                                                if ipv6_stackobj and ipv6_stackobj.href:
                                                    ipv6_field = ipv6_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                for ip_field in [ipv4_field, ipv6_field]:
                                                    if ip_field and ip_field.StartValue:
                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:
                                                            skip = True
                                            except Exception:
                                                pass
                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})")
                                            continue

                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
                else:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').HighLevelStream.find()
                            for count, high_stream in enumerate(high_stream_list):
                                if high_stream.Stack.find(DisplayName='Ethernet II'):
                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,
                                                                                                         'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field,
                                                                                                        'SingleValue',
                                                                                                        None)
                                        except Exception:
                                            existing_mac = None

                                        if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                            skip = True
                                        else:
                                            try:

                                                ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')
                                                ipv4_field = None
                                                if ipv4_stackobj and ipv4_stackobj.href:
                                                    ipv4_field = ipv4_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')
                                                ipv6_field = None
                                                if ipv6_stackobj and ipv6_stackobj.href:
                                                    ipv6_field = ipv6_stackobj.Field.find(
                                                        DisplayName='Destination Address')

                                                for ip_field in [ipv4_field, ipv6_field]:
                                                    if ip_field and ip_field.StartValue:
                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:
                                                            skip = True
                                            except Exception:
                                                pass
                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac}) ")
                                            continue
                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
            except Exception as err_msg:
                self.log.error(f'MAC Update failed in Traffic streams {traffic_name}: {err_msg}')

        self.log.info('Starting ARP on Streams completed successfully')
        return True

    def rocev2_flow_config_txport(self, tx_port, enable = False, **kwargs):
        """
        Enable/Disable all RoCEv2 flow groups by Tx Port .

        :param tx_port: The port for which you want the flow groups to be disabled | A single  port(str) or a list of ports(list)
        :param enable: True/False to enable or disable | Default(False)
        :return: True on success

        Example:
            tgnObj.rocev2_flow_config_txport(tx_port=['Ethernet - 001','Ethernet - 002'], enable= True)
            tgnObj.rocev2_flow_config_txport(tx_port='Ethernet - 002', enable= False)
        """

        if enable == True:
            action = 'Enabling'
        else:
            action = 'Disabling'

        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()
        
        if not rocev2:
            self.log.error("No RoCev2 traffic item found in the configuration")
            return False

        if isinstance(tx_port, str):

            if not self.ixNetwork.Vport.find(Name=f'^{re.escape(tx_port)}$' ):
                raise ValueError(f"No Tx Port with name {tx_port} found in config")

            self.log.info(f"{action} all flow groups on Tx Port: {tx_port} ")
            for flows in rocev2.RoceV2Stream.find(TxPort= f'^{re.escape(tx_port)}$'):
                flows.Enabled = enable

        if isinstance(tx_port, list):

            for tx in tx_port:
                if not self.ixNetwork.Vport.find(Name=f'^{re.escape(tx)}$' ):
                    raise ValueError(f"No Tx Port with name {tx} found in config")
                
                self.log.info(f"{action} all flow groups on Tx Port: {tx} ")
                for flows in rocev2.RoceV2Stream.find(TxPort= f'^{re.escape(tx)}$'):
                    flows.Enabled = enable

        return True

    def _link_local_restart1(self, device_groups):
        """
        Check each IPv6 stack under all (or selected) topologies for 'removePacket[Unknown]'
        in link-local address, and restart only that IPv6 instance.

        If after RestartDown() the IPv6 link-local still shows 'Unknown', perform ipv6.Start().

        :param topology_name: (str) Optional topology name to limit scope.
        :param device_groups: (str | list) Optional device group name or list of names to target.
        :return: Count of IPv6 instances restarted or started.
        """
        restart_count = 0
        retry_delay = 10

        # Normalize device_groups input
        if isinstance(device_groups, str):
            device_groups = [device_groups]

        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():
            if device_groups and dg.Name not in device_groups:
                continue

            for eth in dg.Ethernet.find():
                for ipv6 in eth.Ipv6.find():
                    try:
                        link_local_values = ipv6.LinkLocalAddress
                    except Exception as err:
                        self.log.error(f" Failed to fetch LinkLocalAddress for {dg.Name}: {err}")
                        continue

                    if any("Unknown" in str(addr) for addr in link_local_values):
                        self.log.warning(
                            f" Found 'Unknown' under {dg.Name}/{eth.Name}. Restarting IPv6..."
                        )
                        try:
                            ipv6.RestartDown()
                            time.sleep(retry_delay)
                            restart_count += 1

                            # Recheck if IPv6 recovered
                            link_local_values_after = ipv6.LinkLocalAddress
                            if any("Unknown" in str(addr) for addr in link_local_values_after):
                                self.log.warning(
                                    f"IPv6 still showing 'Unknown' after RestartDown(). Trying Start()..."
                                )
                                ipv6.Start()
                                time.sleep(20)

                        except Exception as err:
                            self.log.error(
                                f" Failed to restart IPv6 for {dg.Name}/{eth.Name}: {err}"
                            )

        if restart_count == 0:
            self.log.info(" No IPv6 interfaces found with '[Unknown]'.")
        else:
            self.log.info(f" Restarted/started {restart_count} IPv6 instance(s) with unknown link-local addresses.")

        return restart_count

    def _restart_ipv6_if_unknown_dg2(self, device_groups=None, **kwargs):
        """
        Check each IPv6 stack under all (or selected) device groups for 'removePacket[Unknown]'
        in link-local address, and restart only those IPv6 address instances.

        If after RestartDown() the IPv6 link-local still shows 'Unknown', perform ipv6.Start()
        on that address instance.

        :param device_groups: (str | list | None)
            Optional device group name or list of names to target. If None, applies to all.
        :return: Count of IPv6 addresses restarted or started.
        :Example: tgnObj.restart_ipv6_if_unknown_dg2(device_group='Device Group 1')
                  tgnObj.restart_ipv6_if_unknown_dg2()
        """
        ipv6_restart_count = 0
        retry_delay = 10
        verify_delay = 15

        if isinstance(device_groups, str):
            device_groups = [device_groups]

        for topo in self.ixNetwork.Topology.find():
            for dg in topo.DeviceGroup.find():
                if device_groups and dg.Name not in device_groups:
                    continue

                for eth in dg.Ethernet.find():
                    for ipv6 in eth.Ipv6.find():
                        try:
                            link_local_values = list(ipv6.LinkLocalAddress)
                        except Exception as err:
                            self.log.error(f" Failed to fetch LinkLocalAddress for {dg.Name}: {err}")
                            continue

                        unknown_indices = [
                            idx + 1 for idx, addr in enumerate(link_local_values) if "Unknown" in str(addr)
                        ]
                        if not unknown_indices:
                            continue

                        self.log.warning(
                            f"[{dg.Name}] Found 'Unknown' in {len(unknown_indices)} IPv6 instance(s). Restarting only those..."
                        )

                        try:
                            ipv6.RestartDown(SessionIndices=unknown_indices, async_operation= True)
                            ipv6_restart_count += len(unknown_indices)
                            time.sleep(retry_delay)

                            link_local_after = list(ipv6.LinkLocalAddress)
                            still_unknown = [
                                idx + 1 for idx, addr in enumerate(link_local_after)
                                if (idx + 1) in unknown_indices and "Unknown" in str(addr)
                            ]

                            if still_unknown:
                                self.log.warning(
                                    f"[{dg.Name}/{eth.Name}] Still 'Unknown' after RestartDown. Trying Start() on {len(still_unknown)} instance(s)..."
                                )
                                ipv6.Stop(SessionIndices=still_unknown,async_operation=True)
                                time.sleep(10)
                                ipv6.Start(SessionIndices=still_unknown, async_operation=True)
                                ipv6_restart_count += len(still_unknown)
                                time.sleep(verify_delay)

                        except Exception as err:
                            self.log.error(
                                f"[{dg.Name}] Failed to restart IPv6 for indices {unknown_indices}: {err}"
                            )

        if ipv6_restart_count == 0:
            self.log.info(" No IPv6 addresses found with '[Unknown]'.")
        else:
            self.log.info(
                f" Restarted/started {ipv6_restart_count} individual IPv6 address instance(s) with 'Unknown' link-local addresses."
            )

        return ipv6_restart_count


    def start_arp_on_streams_one_mac(self, ports=(), mac_check=True):
        """
        Starts ARP on all the streams under specified ports

        :param ports: port or list of ports Default all ports
        :param mac_check: bool, default True
                        If False, skip multicast MAC/IP filtering logic and update all MACs
        :return: True on success
        :Example: start_arp_on_streams_one(mac_check=False)
        """
        self.log.info("Starting ARP at stream level")
        traffic_items_port_dict = {}

        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):
                with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')
                traffic_item_list = getattr(traffic_item.results, 'trafficItem')
                for traffic_item in traffic_item_list:
                    stream_list = traffic_item.HighLevelStream.find()
                    for count, stream in enumerate(stream_list):
                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)
                is_traffic_item = True
            else:
                self.log.warning('No Raw Traffic Streams in the configuration')
                return False
        else:
            with BatchFind(self.ixNetwork.Traffic) as traffic_item:
                self.ixNetwork.Traffic.TrafficItem.find()
            is_traffic_item = False
            traffic_item_list = getattr(traffic_item.results, 'trafficItem')
            for traffic_item in traffic_item_list:
                stream_list = traffic_item.HighLevelStream.find()
                for count, stream in enumerate(stream_list):
                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)

        vport_dest_mac_dict = {}
        vports = [vport.href for vport in self.ixNetwork.Vport.find()]

        def collect_one_mac_per_topology(vport):
            try:
                for topology in self.ixNetwork.Topology.find():
                    if not topology.Ports:
                        continue
                    if topology.Ports[0] == vport:
                        ipv4_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()
                        for ipv4_block in ipv4_blocks:
                            for mac in ipv4_block.ResolvedGatewayMac:
                                if mac and mac != 'removePacket[Unresolved]':
                                    return (vport, mac)
                        ipv6_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()
                        for ipv6_block in ipv6_blocks:
                            for mac in ipv6_block.ResolvedGatewayMac:
                                if mac and mac != 'removePacket[Unresolved]':
                                    return (vport, mac)
            except Exception as e:
                self.log.warning(f'MAC address collection failed on {vport}: {e}')
            return None

        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_vport = {executor.submit(collect_one_mac_per_topology, v): v for v in vports}
            for future in as_completed(future_to_vport):
                result = future.result()
                if result:
                    vport_dest_mac_dict[result[0]] = result[1]

        self.log.debug(f"Resolved Gateway MACs per vPort: {vport_dest_mac_dict}")

        if not vport_dest_mac_dict:
            self.log.error("No valid resolved gateway MACs found  IP stack might be down")
            return False

        traffic_name_mac_mapping = {}
        for traffic_item_name, flows in traffic_items_port_dict.items():
            try:
                unique_macs = set()
                for flow in flows:
                    mac = vport_dest_mac_dict.get(flow)
                    if mac:
                        unique_macs.add(mac)
                if unique_macs:
                    traffic_name_mac_mapping[traffic_item_name] = [list(unique_macs)[0]]
                else:
                    self.log.warning(f"No MAC found for traffic item {traffic_item_name}")
            except Exception as e:
                self.log.error(f"MAC mapping failed for {traffic_item_name}: {e}")

        self.log.debug(f"Final Traffic -> MAC Mapping: {traffic_name_mac_mapping}")

        for traffic_name, mac_list in traffic_name_mac_mapping.items():
            traffic = re.escape(traffic_name)
            mac_value = mac_list[0]
            try:
                self.log.debug(f"Updating MAC for traffic item: {traffic_name} -> {mac_value}")
                if is_traffic_item:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').ConfigElement.find()
                            for count, config_element in enumerate(config_element_list):
                                if config_element.Stack.find(DisplayName='Ethernet II'):
                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        existing_mac = None
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field, 'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field, 'SingleValue', None)
                                        except Exception:
                                            existing_mac = None

                                        # --- mac_check-controlled skip logic ---
                                        if mac_check:
                                            if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                                skip = True
                                            else:
                                                try:
                                                    ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')
                                                    ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')
                                                    for stackobj in [ipv4_stackobj, ipv6_stackobj]:
                                                        if stackobj and stackobj.href:
                                                            field_obj = stackobj.Field.find(DisplayName='Destination Address')
                                                            if field_obj and field_obj.StartValue:
                                                                if ipaddress.ip_address(field_obj.StartValue).is_multicast:
                                                                    skip = True
                                                except Exception:
                                                    pass
                                        # --- end mac_check section ---

                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})")
                                            continue

                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
                else:
                    with (BatchUpdate(self.ixNetwork)):
                        for traffic_name in traffic_name_mac_mapping:
                            traffic = re.escape(traffic_name)
                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(
                                Name=f'^{traffic}$').HighLevelStream.find()
                            for count, high_stream in enumerate(high_stream_list):
                                if high_stream.Stack.find(DisplayName='Ethernet II'):
                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(
                                        DisplayName='Destination MAC Address')
                                    if len(traffic_name_mac_mapping[traffic_name]):
                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]

                                        skip = False
                                        existing_mac = None
                                        try:
                                            if field.ValueType in ('increment', 'decrement') and hasattr(field, 'StartValue'):
                                                existing_mac = field.StartValue
                                            else:
                                                existing_mac = getattr(field, 'Value', None) or getattr(field, 'SingleValue', None)
                                        except Exception:
                                            existing_mac = None

                                        # --- mac_check-controlled skip logic ---
                                        if mac_check:
                                            if existing_mac and str(existing_mac).upper().startswith(("01:00:5E", "33:33")):
                                                skip = True
                                            else:
                                                try:
                                                    ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')
                                                    ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')
                                                    for stackobj in [ipv4_stackobj, ipv6_stackobj]:
                                                        if stackobj and stackobj.href:
                                                            field_obj = stackobj.Field.find(DisplayName='Destination Address')
                                                            if field_obj and field_obj.StartValue:
                                                                if ipaddress.ip_address(field_obj.StartValue).is_multicast:
                                                                    skip = True
                                                except Exception:
                                                    pass
                                        # --- end mac_check section ---

                                        if skip:
                                            self.log.info(
                                                f"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})")
                                            continue

                                        if field.ValueType in ('increment', 'decrement'):
                                            field.StartValue = mac_to_set
                                        else:
                                            self._update_field_values(field, mac_to_set)
            except Exception as err_msg:
                self.log.error(f'MAC Update failed in Traffic streams {traffic_name}: {err_msg}')

        self.log.info('Starting ARP on Streams completed successfully')
        return True

    def verify_arp_status1(self, ipType='ipv4', device=None, **kwargs):
        """
        Verifies the ARP (IPv4) or ND (IPv6) status of all device groups.

        If `scale_traffic=True`, only checks for 'resolveMacFailed' entries in SessionInfo
        (for large-scale scenarios) instead of performing detailed per-IP verification.

        :param ipType: 'ipv4' or 'ipv6'
        :param device: Device Group name or list of names
        :param scale_traffic: Boolean; enables faster ARP verification for scale traffic
        :return: True if all resolved, False otherwise
        """

        scaleConfig=kwargs.get("scaleConfig",True)

        self.log.info(f"Verification of ARP started (type={ipType}, scale_traffic={scaleConfig})")

        if isinstance(device, str):
            device = [device]
        
        unresolved_list = []
        device_notstarted_list = []
        unresolved_arp_list = []
        gateway_ip_list = []
        timeout = 20
        result = True
        ip_type = ipType.lower()

        if device:
            device_obj_list = [
                dg for dg in self.ixNetwork.Topology.find().DeviceGroup.find()
                if dg.Name in device
            ]
        else:
            topology = self.ixNetwork.Topology.find()
            if topology:
                with BatchFind(topology) as device_group:
                    self.ixNetwork.Topology.find().DeviceGroup.find()
                device_obj_list = getattr(device_group.results, 'deviceGroup', [])
            else:
                self.log.warning("Topology not found in the config.")
                return result

        if not device_obj_list:
            msg = f'Device Group "{device}" not found'
            raise IxiaOperationException(msg)

        for device_obj in device_obj_list:
            for counter in range(0, timeout, 2):
                if device_obj.Status == 'notStarted':
                    device_notstarted_list.append(device_obj.Name)
                if counter < timeout and device_obj.Status == 'starting':
                    time.sleep(2)
                    continue
                if counter < timeout and device_obj.Status in ['started', 'mixed']:
                    break
                if counter == timeout and device_obj.Status not in ['started', 'mixed']:
                    msg = f'Device Group failed to come up: {device_obj.Name}'
                    raise IxiaOperationException(msg)
                
        if device_notstarted_list:
            self.log.warning(f'Device Group(s) {set(device_notstarted_list)}  not started')

        for device_obj in device_obj_list:
            with BatchFind(device_obj) as ip_obj_list:
                eval('device_obj.Ethernet.find().' + ip_type[0].upper() + ip_type[1:] + '.find()')

            if device_obj.Status == 'notStarted':
                self.log.info(f'[SKIP] Device {device_obj.Name} is not started')
                continue

            try:
                ip_obj_list = getattr(ip_obj_list.results, ip_type)
            except:
                ip_obj_list = []
                self.log.info(f'{ip_type} block not configured in device {device_obj.Name}')
                continue
            
            # pdb.set_trace()
            if scaleConfig:
                total_failed = 0
                failed_ip_list = []
                failed_gw_list = []

                def process_ip_obj(ip_obj):
                    """Process one IPv4/IPv6 object ."""
                    local_failed_ips = []
                    local_failed_gws = []
                    session_info = getattr(ip_obj, "ResolvedGatewayMac", [])
                    if not session_info:
                        return (0, local_failed_ips, local_failed_gws)

                    failed_indices = [i for i, s in enumerate(session_info) if s == "removePacket[Unresolved]"]
                    if not failed_indices:
                        return (0, local_failed_ips, local_failed_gws)

                    addr_values = getattr(ip_obj.Address, "Values", [])
                    gw_values = getattr(ip_obj.GatewayIp, "Values", [])

                    for i in failed_indices:
                        if i < len(addr_values):
                            local_failed_ips.append(addr_values[i])
                        if i < len(gw_values):
                            local_failed_gws.append(gw_values[i])

                    return (len(failed_indices), local_failed_ips, local_failed_gws)

                with ThreadPoolExecutor(max_workers=50) as executor:
                    future_to_ip = {executor.submit(process_ip_obj, ip_obj): ip_obj for ip_obj in ip_obj_list}
                    for future in as_completed(future_to_ip):
                        count, ips, gws = future.result()
                        total_failed += count
                        failed_ip_list.extend(ips)
                        failed_gw_list.extend(gws)

                if total_failed > 0:
                    self.log.warning(
                        f"[{device_obj.Name}] Found {total_failed} IP(s) with MAC resolution failed (scale traffic)."
                    )
                    sample_count = len(failed_ip_list)
                    self.log.debug(
                        f"[{device_obj.Name}] Example failed entries: "
                        f"{list(zip(failed_ip_list[:sample_count], failed_gw_list[:sample_count]))}"
                    )
                else:
                    self.log.info(f"[{device_obj.Name}] ARP Verification passed for scale traffic.")
                continue

            unresolved_mac = False
            for ip_obj in ip_obj_list:
                for index, each_state in enumerate(ip_obj.SessionStatus):
                    if each_state != "up":
                        unresolved_arp_list.append(ip_obj.Address.Values[index])
                        gateway_ip_list.append(ip_obj.GatewayIp.Values[index])
                        unresolved_mac = True

            if unresolved_mac:
                # self.log.info(f'ARP Verification Failed for {ip_type} in "{device_obj.Name}"')
                unresolved_list.append(device_obj.Name)
        
        if unresolved_list:
            self.log.info(f'ARP Verification Failed for {ip_type} in "{unresolved_list}"')

        if not scaleConfig and unresolved_arp_list:
            self.log.warning(
                f"\nFailed to Resolve ARP: srcIp: {unresolved_arp_list}, \ngateway: {gateway_ip_list}"
            )
            result = False
        elif not scaleConfig and result:
            self.log.info(f"ARP Verification Successful for {ip_type}")

        return result

    def _wait_for_protocol_action_complete(self, timeout=120, interval=2, operation_name=None, progress_log_gap=180):
        """
        Wait until IxNetwork finishes all protocol actions (like ARP, StartAll, etc.).
        Raises an exception if it exceeds the timeout.
        Automatically detects which API called it unless an operation_name is provided.

        :param timeout: Max seconds to wait before raising timeout error.
        :param interval: Polling interval in seconds.
        :param operation_name: Optional label for which API is waiting.
        :param progress_log_gap: Minimum seconds between progress log messages.
        """

        if operation_name is None:
            operation_name = inspect.stack()[1].function

        start_time = time.time()
        last_log_time = 0

        while time.time() - start_time < timeout:
            try:
                in_progress = self.ixNetwork.Globals.Topology.ProtocolActionsInProgress
                if not in_progress or len(in_progress) == 0:
                    elapsed = round(time.time() - start_time, 1)
                    self.log.debug(f"[{operation_name}] Protocol actions completed successfully in {elapsed}s.")
                    return True
                

                elapsed = round(time.time() - start_time, 1)
                # pdb.set_trace()
                if elapsed > 30:
                    for elements in in_progress:
                        # self.log.info(elements)
                        # if elements.lower() in ['dhcp','scenario']:
                        # if ['dhcp','scenario'] in elements.lower()
                        if 'dhcp' in elements.lower() or 'scenario' in elements.lower():
                            self.log.info(f"{elements} still in progress, Skipping")
                            return True

                if elapsed - last_log_time >= progress_log_gap:
                    self.log.debug(f"[{operation_name}] [{elapsed}s] Protocol action still in progress: {in_progress}")
                    last_log_time = elapsed

            except Exception as e:
                self.log.warning(f"[{operation_name}] Could not fetch protocol action status: {e}")

            time.sleep(interval)

        msg = f"[{operation_name}] Protocol action did not complete within {timeout}s. Operation timed out."
        self.log.error(msg)
        raise IxiaOperationException(msg)

    def verify_arp_status2(self, ipType='ipv4', device=None):
        """
        Verifies the ARP/ND status of all device groups on the TGN session.
        Uses threading (50 workers) to check unresolved IPs faster.
        """
        self.log.info(f"Verification of ARP started (type={ipType})")
        ip_type = ipType.lower()
        unresolved_arp_list = []
        gateway_ip_list = []
        timeout = 20
        result = True

        if isinstance(device, str):
            device = [device]

        if device:
            device_obj_list = [
                dg for dg in self.ixNetwork.Topology.find().DeviceGroup.find()
                if dg.Name in device
            ]
        else:
            topology = self.ixNetwork.Topology.find()
            if topology:
                with BatchFind(topology) as device_group:
                    self.ixNetwork.Topology.find().DeviceGroup.find()
                device_obj_list = getattr(device_group.results, 'deviceGroup')
            else:
                self.log.warning("Topology not found in the config")
                return True

        if not device_obj_list:
            raise IxiaOperationException(f'Device Group "{device}" not found')

        for dg in device_obj_list:
            for counter in range(0, timeout, 2):
                if dg.Status == 'notStarted':
                    self.log.warning(f'Device Group {dg.Name} is not started')
                if counter < timeout and dg.Status == 'starting':
                    time.sleep(2)
                    continue
                if dg.Status in ['started', 'mixed']:
                    break
                if counter == timeout and dg.Status not in ['started', 'mixed']:
                    raise IxiaOperationException(f"Device Group failed to come up: {dg.Name}")

        for device_obj in device_obj_list:
            local_failed_ips = []
            local_failed_gws = []
            total_failed = 0

            with BatchFind(device_obj) as ip_obj_list:
                eval(f"device_obj.Ethernet.find().{ip_type.capitalize()}.find()")

            try:
                ip_obj_list = getattr(ip_obj_list.results, ip_type)
            except AttributeError:
                self.log.info(f'{ip_type} block not configured in {device_obj.Name}')
                continue

            # --- Worker for each IP object ---
            def process_ip_obj(ip_obj):
                local_ips, local_gws = [], []
                session_status = getattr(ip_obj, "ResolvedGatewayMac", [])
                if not session_status:
                    return 0, local_ips, local_gws

                failed_indices = [i for i, s in enumerate(session_status) if s == "removePacket[Unresolved]"]
                if not failed_indices:
                    return 0, local_ips, local_gws

                addr_values = getattr(ip_obj.Address, "Values", [])
                gw_values = getattr(ip_obj.GatewayIp, "Values", [])

                for i in failed_indices:
                    if i < len(addr_values):
                        local_ips.append(addr_values[i])
                    if i < len(gw_values):
                        local_gws.append(gw_values[i])

                return len(failed_indices), local_ips, local_gws

            with ThreadPoolExecutor(max_workers=50) as executor:
                futures = {executor.submit(process_ip_obj, ip_obj): ip_obj for ip_obj in ip_obj_list}
                for future in as_completed(futures):
                    count, ips, gws = future.result()
                    total_failed += count
                    local_failed_ips.extend(ips)
                    local_failed_gws.extend(gws)

            if total_failed > 0:
                self.log.warning(f"[{device_obj.Name}] Found {total_failed} {ip_type} instance(s) unresolved.")
                sample_count =  len(local_failed_ips)
                self.log.info(
                    f"[{device_obj.Name}] Unresolved entries - "
                    f"\nIP Addresses : {local_failed_ips[:sample_count]}," 
                    f"\nGateway IP Addresses : {local_failed_gws[:sample_count]}"
                )
                unresolved_arp_list.extend(local_failed_ips)
                gateway_ip_list.extend(local_failed_gws)
            else:
                self.log.info(f"[{device_obj.Name}] ARP Verification passed.")

        if unresolved_arp_list:
            total = len(unresolved_arp_list)
            self.log.warning(f"[{device_obj.Name}]ARP Verification Failed: {total} unresolved entries ")

    def start_arp_and_verify_global(self, **kwargs):
        """
        Starts the ARP/ND process and verifies the ARP status.

        Automatically waits for protocol actions (like SendArpGlobal)
        to complete using _wait_for_protocol_action_complete().
        """
        
        ip_type = kwargs.get("ip_type", "ipv4")
        timeout = kwargs.get("timeout", 240) 
        result_list = []

        topology = self.ixNetwork.Topology.find()
        with BatchFind(topology) as device_group:
            topology.DeviceGroup.find()

        device_obj_list = getattr(device_group.results, "deviceGroup", [])
        if not device_obj_list:
            self.log.warning("No device groups found in topology.")
            return False

        try:
            for device_obj in device_obj_list:
                self.log.info(f"Starting ARP on: {device_obj.Name}")

                if ip_type == "ipv4":
                    device_obj.SendArpGlobal()
                elif ip_type == "ipv6":
                    device_obj.SendNsGlobal()
                else:
                    raise IxiaOperationException("Invalid ip_type: use 'ipv4' or 'ipv6'")

                self.log.debug(f"Waiting for ARP/NS action to complete on {device_obj.Name}...")
                self._wait_for_protocol_action_complete(timeout=timeout)

                result = self.verify_arp_status2(ipType=ip_type, device=device_obj.Name)
                result_list.append(result)

        except Exception as e:
            self.log.error(f"Error during ARP process on {device_obj.Name}: {e}")
            return False

        if all(result_list):
            self.log.info(f"ARP Verification Successful for all device groups ({ip_type})")
            return True
        else:
            self.log.warning(f"One or more ARP verifications failed for {ip_type}")
            return False

    def start_arp_and_verify_global1(self, **kwargs):
        """
        Starts the ARP/ND process and verifies the ARP status.

        Automatically waits for protocol actions (like SendArpGlobal)
        to complete using _wait_for_protocol_action_complete().
        """
        
        ip_type = kwargs.get("ip_type", "ipv4")
        timeout = kwargs.get("timeout", 240) 
        result_list = []

        topology = self.ixNetwork.Topology.find()
        with BatchFind(topology) as device_group:
            topology.DeviceGroup.find()

        device_obj_list = getattr(device_group.results, "deviceGroup", [])
        if not device_obj_list:
            self.log.warning("No device groups found in topology.")
            return False

        try:
            for device_obj in device_obj_list:
                self.log.info(f"Starting ARP on: {device_obj.Name}")

                if ip_type == "ipv4":
                    if device_obj.Ethernet.find().Ipv4.find():
                        for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():
                            obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))
                            ipv4_obj.SendArp(SessionIndices=obj_count_list)
                elif ip_type == "ipv6":
                    if device_obj.Ethernet.find().Ipv6.find():
                        for ipv6_obj in device_obj.Ethernet.find().Ipv6.find():
                            obj_count_list = list(range(1, ipv6_obj.Count + 1, 1))
                            ipv6_obj.SendArp(SessionIndices=obj_count_list)
                else:
                    raise IxiaOperationException("Invalid ip_type: use 'ipv4' or 'ipv6'")

                self.log.debug(f"Waiting for ARP/NS action to complete on {device_obj.Name}...")
                self._wait_for_protocol_action_complete(timeout=timeout)

                result = self.verify_arp_status2(ipType=ip_type, device=device_obj.Name)
                result_list.append(result)

        except Exception as e:
            self.log.error(f"Error during ARP process on {device_obj.Name}: {e}")
            return False

        if all(result_list):
            self.log.info(f"ARP Verification Successful for all device groups ({ip_type})")
            return True
        else:
            self.log.warning(f"One or more ARP verifications failed for {ip_type}")
            return False

    def fetch_unresolved(self,device_group):

        dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name = device_group)

        count = 0
        sessioninfo = dg.Ethernet.find().Ipv4.find().SessionInfo
        for i in sessioninfo:
            if i == 'resolveMacFailed':
                count = count +1
        print(count)

    def _link_local_restart3(self, device_groups=None):

        restart_count = 0
        self.log.info("Checking for any 'Unknown' Local link address in the configuration")
        if isinstance(device_groups, str):
            device_groups = [device_groups]

        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():
            if device_groups and dg.Name not in device_groups:
                continue

            for eth in dg.Ethernet.find():
                for ipv6 in eth.Ipv6.find():
                    try:
                        
                        link_local_vals = list(ipv6.LinkLocalAddress)
                        state_list = list(ipv6.SessionStatus)
                    except:
                        continue

                    # pdb.set_trace()
                    unknown_indices = []
                    for idx, ll_value in enumerate(link_local_vals, start=1):
                        if "removePacket[Unknown]" in str(ll_value):
                            state = state_list[idx-1].strip().lower()
                            if state == "notstarted":
                                unknown_indices.append(idx)

                    if not unknown_indices:
                        continue

                    self.log.warning(
                        f"[{dg.Name}/{eth.Name}] LinkLocal='Unknown' at indices {unknown_indices}. Performing Stop/Start..."
                    )

                    restart_count += len(unknown_indices)

                    retry = 0
                    while retry < 3:
                        retry += 1

                        try:
                            ipv6.Stop(SessionIndices=unknown_indices)
                            self._wait_for_protocol_action_complete(timeout=180)
                        except Exception as e:
                            self.log.error(f"Stop failed for {dg.Name}/{eth.Name} indices {unknown_indices}: {e}")
                            break

                        try:
                            ipv6.Start(SessionIndices=unknown_indices)
                            self._wait_for_protocol_action_complete(timeout=180)
                        except Exception as e:
                            self.log.error(f"Start failed for {dg.Name}/{eth.Name} indices {unknown_indices}: {e}")
                            break

                        
                        
                        link_local_vals_after = list(ipv6.LinkLocalAddress)
                        pdb.set_trace()
                        self.log.info(link_local_vals_after)


                        still_unknown = [
                            i for i in unknown_indices
                            if "Unknown" in str(link_local_vals_after[i-1])
                        ]

                        if not still_unknown:
                            self.log.info(
                                f"[{dg.Name}/{eth.Name}] Link-local recovered on indices {unknown_indices}"
                            )
                            break

                        self.log.warning(
                            f"[{dg.Name}/{eth.Name}] Still Unknown after retry {retry}: {still_unknown}"
                        )
                        unknown_indices = still_unknown

                    else:
                        self.log.warning(
                            f"[{dg.Name}/{eth.Name}] Could not clear Unknown after retries: {unknown_indices}"
                        )

        if restart_count == 0:
            self.log.info("No IPv6 link-local 'Unknown' entries requiring action.")
        else:
            self.log.info(f"Restarted {restart_count} IPv6 instances with Unknown link-local.")

        return restart_count

    def _link_local_restart(self, device_groups=None):

        restart_count = 0
        self.log.info("Checking for any 'Unknown' link-local IPv6 entries")

        if isinstance(device_groups, str):
            device_groups = [device_groups]

        topo = self.ixNetwork.Topology.find()
        if not topo:
            self.log.error("No topology found")
            return 0

        dg_list = topo.DeviceGroup.find()
        if device_groups:
            dg_list = [dg for dg in dg_list if dg.Name in device_groups]

        ipv6_info = []

        for dg in dg_list:
            with BatchFind(dg) as finder:
                dg.Ethernet.find().Ipv6.find()
            eth_list = getattr(finder.results, 'ethernet')

            if not eth_list:
                continue

            for eth in eth_list:
                for ipv6 in eth.Ipv6.find():
                    ipv6_info.append((dg, eth, ipv6))

        def inspect_ipv6(entry):

            dg, eth, ipv6 = entry
            try:
                ll = list(ipv6.LinkLocalAddress)
                ss = list(ipv6.SessionStatus)
            except:
                return None

            unknown = []
            for idx, val in enumerate(ll, start=1):
                if "Unresolved" in str(val) and ss[idx - 1].lower() == "down":
                    unknown.append(idx)

            
            if unknown:
                return (dg, eth, ipv6, unknown)
            return False

        results = []
        with ThreadPoolExecutor(max_workers=50) as pool:
            for res in pool.map(inspect_ipv6, ipv6_info):
                if res:
                    results.append(res)

        for dg, eth, ipv6, indices in results:
            self.log.warning(f"[{dg.Name}/{eth.Name}] Unknown Link Local @index : {indices}")

            restart_count += len(indices)

            retry = 0
            while retry < 3:
                retry += 1

                try:
                    ipv6.Stop(SessionIndices=indices)
                    self.log.debug("Action: Stop() in progress")
                    self._wait_for_protocol_action_complete(timeout=180)
                except Exception as e:
                    self.log.error(f"Stop failed {dg.Name}/{eth.Name}: {e}")
                    break

                try:
                    ipv6.Start(SessionIndices=indices)
                    self.log.debug("Action: Start() in progress")
                    self._wait_for_protocol_action_complete(timeout=180)
                except Exception as e:
                    self.log.error(f"Start failed {dg.Name}/{eth.Name}: {e}")
                    break

                time.sleep(10)
                
                ipv6 = eth.Ipv6.find()
                after = list(ipv6.LinkLocalAddress)

                still = [i for i in indices if "Unresolved" in str(after[i - 1])]
                if not still:
                    self.log.success(f"[{dg.Name}/{eth.Name}] Recovered on {indices}")
                    break

                self.log.warning(f"[{dg.Name}/{eth.Name}] Still Unknown after retry {retry}: {still}")
                indices = still

            else:
                self.log.warning(f"[{dg.Name}/{eth.Name}] Could not clear Unknown: {indices}")

        if restart_count == 0:
            self.log.info("No IPv6 link-local Unknown entries requiring action.")
            return True
        else:
            self.log.info(f"Restarted {restart_count} IPv6 instances with Unknown link-local.")
            return False

    def restart_ip_stack1(self, device_group_name=None, ip_version='ipv4', max_retries=25,**kwargs):
        """
        API that RestartDown all IPs that are in 'Down' or 'Not Started' state within the given device group(s).

        :param device_group_name: str or list of device group names to "restartDown" the IPs
        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.
        :param max_retries: number of retries for the "restartDown"
        """
        ipv6_unknown = kwargs.get('ipv6_unknown', False)
        interval_sec, max_threads, chunk_size = 5, 10, 500
        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'
        assert ip_version.lower() in ['ipv4', 'ipv6'], "Invalid IP version. Use 'ipv4' or 'ipv6'."


        if ipv6_unknown == True:

            self._link_local_restart()

        else:
            def _chunked(seq, size):
                return (seq[i:i + size] for i in range(0, len(seq), size))

            def _build_summary(stats):
                return {
                    device_grp: {
                        "Total IPs": d['total_ips'], "IP Version": ip_version,
                        "Up": d['up'], "Down": d['down'], "Not Started": d['not started']
                                } for device_grp, d in stats.items()}

            stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)
            # restartable_ips = {
            #     ip_addr: status for d in stats.values()
            #     for ip_addr, status in d['ip_status_map'].items()
            #     if status.strip().lower() in ['down', 'notstarted', 'not started']}

            # NEW: Restart only DGs that actually have bad IPs
            restart_dgs = {}

            for dg_name, d in stats.items():
                bad_ips = [
                    ip for ip, status in d['ip_status_map'].items()
                    if status.strip().lower() in ('down', 'notstarted', 'not started')
                ]

                if bad_ips:
                    restart_dgs[dg_name] = {
                                                "bad_ips": bad_ips
                                            }



            if not restart_dgs:
                self.log.success(f"All {ip_version.upper()} IPs are already UP.")
                summary = _build_summary(stats)
                return summary

            # count_down = sum(1 for s in restartable_ips.values() if s.strip().lower() == 'down')
            # count_notstarted = len(restartable_ips) - count_down
            # self.log.warning(f"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED")
            count_down = sum(
                1
                for d in restart_dgs.values()
                for ip in d["bad_ips"]
                if stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower() == 'down'
            )
            count_notstarted = sum(
                1
                for d in restart_dgs.values()
                for ip in d["bad_ips"]
                if stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower() != 'down'
            )

            self.log.warning(f"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED")


            if isinstance(device_group_name, list):
                pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'
            elif isinstance(device_group_name, str):
                pattern = re.escape(device_group_name)
            else:
                pattern = '.*'

            dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)
            # ip_stack_refs = {
            #     ip_addr: ip_stack
            #     for device_grp in dgs for eth in device_grp.Ethernet.find()
            #     for ip_stack in getattr(eth, stack_attr).find()
            #     for ip_addr in ip_stack.Address.Values
            #     if ip_addr in restartable_ips
            # }
            ip_stack_refs = {}

            for device_grp in dgs:
                dg_name = device_grp.Name
                if dg_name not in restart_dgs:
                    continue  # skip UP device groups

                bad_ips = set(restart_dgs[dg_name]["bad_ips"])

                for eth in device_grp.Ethernet.find():
                    for ip_stack in getattr(eth, stack_attr).find():
                        for ip_addr in ip_stack.Address.Values:
                            if ip_addr in bad_ips:
                                ip_stack_refs.setdefault(ip_stack, []).append(ip_addr)


            self.log.info("Checking for any ongoing protocol actions")
            self._wait_for_protocol_action_complete()
            restart_stack = lambda s: s.RestartDown()
            self._wait_for_protocol_action_complete(timeout=240, operation_name="RestartDown")

            

            for attempt in range(1, max_retries + 1):
                # pdb.set_trace()
                pdb.set_trace()
                unique_stacks = list(ip_stack_refs.keys())
                stack_to_ips = ip_stack_refs   # Already grouped

                # Log detailed info
                # pdb.set_trace()
                self.log.info("RestartDown Details (Attempt %s):" % attempt)
                for stack, ip_list in stack_to_ips.items():
                    try:
                        dg_name = stack.parent.parent.Name  # IP -> Ethernet -> DeviceGroup
                    except:
                        dg_name = "<unknown>"

                    self.log.info(
                        f"  DeviceGroup: {dg_name}, Stack: {stack.href}, "
                        f"IP Count: {len(ip_list)}, IPs: {ip_list[:5]}{' ...' if len(ip_list) > 5 else ''}"
                    )
                # self.log.debug(f"RETRY {attempt}/{max_retries}: Restarting {len(unique_stacks)} stacks...")
                for chunk in _chunked(unique_stacks, chunk_size):
                    with ThreadPoolExecutor(max_workers=max_threads) as executor:
                        list(executor.map(restart_stack, chunk))

                    self.log.debug("Waiting for RestartDown action(s) to complete...")
                    try:
                        self._wait_for_protocol_action_complete(timeout=240, operation_name="RestartDown")
                    except IxiaOperationException as e:
                        self.log.warning(f"RestartDown operation timed out after 240s: {e}")

                    time.sleep(interval_sec)

                updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)

                # restartable_ips = {
                #     ip_addr: status
                #     for d in updated.values()
                #     for ip_addr, status in d['ip_status_map'].items()
                #     if status.strip().lower() in ['down', 'notstarted', 'not started', 'unknown']
                # }
                ip_stack_refs = {}

                for device_grp in dgs:
                    dg_name = device_grp.Name
                    if dg_name not in restart_dgs:
                        continue

                    bad_ips = set(restart_dgs[dg_name]["bad_ips"])

                    for eth in device_grp.Ethernet.find():
                        for ip_stack in getattr(eth, stack_attr).find():
                            for ip_addr in ip_stack.Address.Values:
                                if ip_addr in bad_ips:
                                    ip_stack_refs.setdefault(ip_stack, []).append(ip_addr)

                restart_dgs = {}   # < CRITICAL FIX

                for dg_name, d in updated.items():
                    bad_ips = [
                        ip for ip, status in d['ip_status_map'].items()
                        if status.strip().lower() in ('down', 'notstarted', 'not started', 'unknown')
                    ]
                    if bad_ips:
                        restart_dgs[dg_name] = {"bad_ips": bad_ips}



                if not restart_dgs:
                    self.log.success(f"All IPs are UP after '{attempt}' attempt(s)")
                    break


            summary = _build_summary(self.get_ip_stack_status(device_group_name, ip_version, display_table=True))

            if restart_dgs:
                self.log.fail(f"{len(restart_dgs)} IPs remained DOWN or NOT STARTED after {max_retries} retries. \n{summary}")
                return summary
        
            if not restart_dgs:
                self.log.success(f"All IPs are UP after '{attempt}' attempt(s). \n{summary}")
                return True


    def _restart_ipv6_indices(self, ipv6, indices, dg_name, eth_name):
        """
        Performs only STOP / START on the given IPv6 session indices.
        No verification here. Verification is done by the caller.
        """

        try:
            self.log.info(f"[{dg_name}/{eth_name}] STOP -> indices {indices}")
            ipv6.Stop(SessionIndices=indices)
            self._wait_for_protocol_action_complete(timeout=180)
        except Exception as e:
            self.log.error(
                f"[{dg_name}/{eth.Name}] Stop failed for indices {indices}: {e}"
            )
            return False

        try:
            self.log.info(f"[{dg_name}/{eth_name}] START -> indices {indices}")
            ipv6.Start(SessionIndices=indices)
            self._wait_for_protocol_action_complete(timeout=180)
        except Exception as e:
            self.log.error(
                f"[{dg_name}/{eth.Name}] Start failed for indices {indices}: {e}"
            )
            return False

        return True

    def _link_local_restart4(self, device_groups=None):

        restart_count = 0
        max_cycles = 3

        if isinstance(device_groups, str):
            device_groups = [device_groups]

        self.log.info("Checking for any 'Unknown' IPv6 link-local addresses")

        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():
            if device_groups and dg.Name not in device_groups:
                continue

            for eth in dg.Ethernet.find():
                for ipv6 in eth.Ipv6.find():

                    try:
                        link_local_vals = list(ipv6.LinkLocalAddress)
                        state_list = list(ipv6.SessionStatus)
                    except:
                        continue

                    unknown_indices = [
                        idx for idx, ll in enumerate(link_local_vals, start=1)
                        if "removePacket[Unknown]" in str(ll)
                        and state_list[idx-1].strip().lower() == "notstarted"
                    ]

                    if not unknown_indices:
                        continue

                    restart_count += len(unknown_indices)
                    self.log.warning(
                        f"[{dg.Name}/{eth.Name}] Unknown detected at {unknown_indices}."
                    )

                    # =========================================================
                    #   MAIN LOOP: helper start/stop  verify  repeat
                    # =========================================================
                    remaining = unknown_indices[:]

                    for cycle in range(1, max_cycles+1):

                        self.log.info(
                            f"[{dg.Name}/{eth.Name}] Cycle {cycle}: running stop/start on {remaining}"
                        )

                        ok = self._restart_ipv6_indices(
                            ipv6, remaining, dg.Name, eth.Name
                        )
                        time.sleep(60)

                        if not ok:
                            break  # cannot proceed

                        # ---- VERIFY HERE (not inside helper) ----
                        ipv6 = eth.Ipv6.find()
                        link_after = list(ipv6.LinkLocalAddress)
                        self.log.debug(link_after)

                        pdb.set_trace()
                        still_unknown = [
                            i for i in remaining
                            if "Unknown" in str(link_after[i-1])
                        ]

                        if not still_unknown:
                            self.log.info(
                                f"[{dg.Name}/{eth.Name}] Recovered: {remaining}"
                            )
                            break

                        self.log.warning(
                            f"[{dg.Name}/{eth.Name}] After cycle {cycle} still unknown: {still_unknown}"
                        )

                        remaining = still_unknown[:]

                    # After max cycles
                    if remaining:
                        self.log.error(
                            f"[{dg.Name}/{eth.Name}] Could not fix after {max_cycles} cycles: {remaining}"
                        )

        self.log.info(f"Restarted {restart_count} IPv6 instances with Unknown link-local.")
        return restart_count

    def rocev2_config_device(self):


        ibmtu = self.ixNetwork \
        .Topology.find() \
        .DeviceGroup.find() \
        .Ethernet.find() \
        .Ipv4.find() \
        .Rocev2.find() \
        .IbMTU

        pdb.set_trace()
        print(ibmtu.AvailablePatterns)

    def set_rocev2_ib_mtu(self, ib_mtu, device_groups=None, ip_type = 'ipv4'):
        """
        Set IB MTU for all or selected RoCEv2 stacks.

        :param ib_mtu: MTU value as int (1024, 2048, 4096, etc.)
        :param device_groups: str or list of DG names. If None, apply to all.
        :param ip_type: for which IP type to modify IBMtu | 'ipv4' or 'ipv6'
        :return: True on success
        """

        valid_mtu = [1024, 2048, 4096]
        if ib_mtu not in valid_mtu:
            raise ValueError(f"Invalid IB MTU {ib_mtu}. Allowed: {valid_mtu}")

        if isinstance(device_groups, str):
            device_groups = [device_groups]

        topo = self.ixNetwork.Topology.find()

        if not topo:
            self.log.error("No topology found.")
            return False

        dg_list = topo.DeviceGroup.find()

        final_dg_list = []
        if device_groups:
            for pattern in device_groups:
                matched = topo.DeviceGroup.find(Name=f'^{re.escape(pattern)}$')
                final_dg_list.extend(matched)
        else:
            final_dg_list = topo.DeviceGroup.find()

        if not dg_list:
            self.log.warning("No matching device groups found.")
            return False

        updated_count = 0

        for dg in final_dg_list:
            for eth in dg.Ethernet.find():

                # IPv4
                if ip_type == 'ipv4':
                    for ipv4 in eth.Ipv4.find():
                        roc = ipv4.Rocev2.find()
                        if roc:
                            for r in roc:
                                try:
                                    r.IbMTU.Single(ib_mtu)
                                    updated_count += 1
                                    self.log.info(f"Set IBMTU={ib_mtu} on {dg.Name}/{eth.Name}/RoCEv2")
                                except Exception as e:
                                    self.log.error(f"Failed RoCEv2 IPv4 MTU update @ {dg.Name}: {e}")

                if ip_type == 'ipv6':
                    for ipv6 in eth.Ipv6.find():
                        roc = ipv6.Roce6v2.find()
                        if roc:
                            for r in roc:
                                try:
                                    r.IbMTU.Single(ib_mtu)
                                    updated_count += 1
                                    self.log.info(f"Set IBMTU={ib_mtu} on {dg.Name}/{eth.Name}/RoCEv2-")
                                except Exception as e:
                                    self.log.error(f"Failed RoCEv6 MTU update @ {dg.Name}: {e}")

        if updated_count == 0:
            self.log.warning("No RoCEv2 stacks found to update.")
            return False


        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

        self.log.success(f"Updated IB MTU={ib_mtu} on {updated_count} RoCEv2 stacks.")
        return True

    def add_device2(self,
                   port_list=None,
                   ipv4_address_start=None,
                   ipv6_address_start=None,
                   igmp_group_start=None,
                   mld_group_start=None,
                   new_config=False,
                   **kwargs):
        """
        Add new device to topology

        Mandatory Args:

        :param port_list: List of physical port name,Format of physical port name: 'chassisIP'/'card'/'port', 'card'/'port'
        :param ipv4_address_start: The starting address for ipv4 devices
        :param ipv6_address_start: The starting address for ipv6 devices
        :param igmp_group_start: The starting group for igmp devices
        :param mld_group_start: The starting group for mld devices
        :param new_config: True if you want to wipe out the old config, False to use the existing one

        Optional Args:

        :param assign_to_physical_port: CHOICES True, False. Default True
                True: Asign physical port to the vport created
                False: Create vport only
        :param port_name_list: CHOICES None, list of string. Default None
                None: use format 'card'/'port'
        :param device_name: Name of the device group name to be created
        :param interface_no_vlan_count: CHOICES integer. Default is 1 for main interface
        :param interface_vlan_disable: CHOICES integer - 0,1. To enable/disable Vlan. Default is 0
        :param vlan_count: CHOICES integer. Number of vlan per device. Default 1
        :param vlan_id_count: CHOICES 0, integer. Number of vlan per port.
        :param vlan_id_start: CHOICES List RANGE 0 - 4096.
                Default None for no change, Example: [<outer vlan start id>,<inner vlan start id>]
        :param vlan_id_step: CHOICES integer. Default 0
        :param vlan_id_port_step: CHOICES integer. Default 0
        :param vlan_id_sequence_length: CHOICES integer.
        :param vlan_id_repeat_value: CHOICES integer.
        :param vlan_id_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_id_step_enable: CHOICE bool.
        :param vlan_priority_start: CHOICES integer, list RANGE 0 - 7. Default 0
        :param vlan_priority_step: CHOICES integer. Default 0
        :param vlan_priority_port_step: CHOICES integer. Default 0
        :param vlan_priority_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_priority_step_enable: CHOICES bool.
        :param vlan_priority_sequence_length: CHOICES integer.
        :param vlan_priority_repeat_value: CHOICES integer.
        :param vlan_tpid: CHOICES '0x8100', '0x88a8', '0x9100', '0x9200', '0x9300'
        :param ipv4_address_start: IPv4 address for first interface
        :param ipv4_address_step: IPv4 address for step
        :param ipv4_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_prefix: CHOICES integer
        :param ipv4_address_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_address_repeat_value(int): repeat value Ex: 1
        :param ipv4_address_sequence_length: CHOICES integer
        :param ipv4_gateway_start: IPv4 address for first interface gateway
        :param ipv4_gateway_step: IPv4 address for step
        :param ipv4_gateway_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_port_step_enable: CHOICES bool.
        :param ipv4_gateway_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_gateway_repeat_value (int): repeat value Ex: 1
        :param ipv4_gateway_sequence_length: CHOICES integer
        :param ipv4_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv4_gateway_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv4_routerid = '192.0.0.1'
        :param ipv4_routerid_step = 2
        :param ipv6_address_repeat_increment (str): Ex: "0::1"
        :param ipv6_gateway_repeat_increment (str): Ex: "0::1"
        :param ipv6_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_start: IPv6 address for first interface
        :param ipv6_address_step: IPv6 address for step
        :param ipv6_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_prefix: CHOICES integer
        :param ipv6_address_repeat_value(int): repeat value Ex: 1
        :param ipv6_address_sequence_length: CHOICES integer
        :param ipv6_address_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_gateway_start: IPv6 address for first interface gateway
        :param ipv6_gateway_step: IPv6 address for step
        :param ipv6_gateway_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_port_step_enable: CHOICES bool.
        :param ipv6_gateway_repeat_value(int): repeat value Ex: 1
        :param ipv6_gateway_sequence_length: CHOICES integer
        :param ipv6_gateway_direction: CHOICES 'increment', 'decrement'
        :param ipv6_routerid: '192.0.0.1'
        :param ipv6_routerid_step: 2
        :param igmp_version: CHOICES string/list. 'version1','version2','version3'
        :param igmp_num_of_group_range: CHOICES integer
        :param igmp_group_start: IPv4 multicast address.Default None for no configure igmp
        :param igmp_group_step: IPv4 address. Default '0.0.0.1'
        :param igmp_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_group_port_step: CHOICES 'disable', 'enable', IPv4 address
        :param igmp_group_port_step_enable: CHOICES 'disable', 'enable'
        :param igmp_group_address_count: CHOICES integer.
        :param igmp_group_address_increment: CHOICES IPv4 address
        :param igmp_group_repeat_value(int): repeat value Ex: 1
        :param igmp_group_sequence_length: CHOICES integer.
        :param igmp_source_mode: CHOICES 'include', 'exclude'
        :param igmp_num_source_range: CHOICES integer
        :param igmp_source_start: IPv4 address
        :param igmp_source_step: IPv4 address. Default '0.0.0.1'
        :param igmp_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_source_port_step: CHOICES 'disabled', IPv4 address
        :param igmp_source_port_step_enable: CHOICES 'disabled','enabled'
        :param igmp_source_addree_increment: IPv4 address
        :param igmp_source_address_count: CHOICES integer
        :param igmp_source_repeat_value(int): repeat value Ex: 1
        :param igmp_source_sequence_length: CHOICES integer
        :param igmp_rate_interval: rate to be configured
        :param mld_version: CHOICES string/list. 'version1','version2'
        :param mld_num_of group_range: CHOICES integer
        :param mld_group_start: IPv6 multicast address, Default None for no configure mld
        :param mld_group_step: IPv6 address. Default '::1'
        :param mld_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_group_port_step: CHOICES 'disabled', IPv6 address
        :param mld_group_port_step_enable: CHOICES 'disabled', 'enabled'
        :param mld_group_address_count: CHOICES integer
        :param mld_group_address_increment: CHOICE IPv6 address
        :param mld_group_repeat_value(int): repeat value Ex: 1
        :param mld_group_sequence_length: CHOICES integer
        :param mld_source_mode: CHOICES 'include', 'exclude'
        :param mld_num_source_range: CHOICES integer
        :param mld_source_start: IPv6 address
        :param mld_source_step: IPv6 address. Default '::1'
        :param mld_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_source_port_step: CHOICES 'disabled', IPv6 address
        :param mld_source_port_step_enable: CHOICES 'disabled','enabled'
        :param mld_source_address_increment: IPv6 address
        :param mld_source_address_count: CHOICES integer
        :param mld_source_repeat_value(int): repeat value Ex: 1
        :param mld_source_sequence_length: CHOICES integer
        :param mld_rate_interval: rate to be configured
        :param multiple_ports_per_topo: CHOICES bool
        :return: device_obj dictionary {'vport':<obj>, 'ipv4':<obj>....}

        #Create device BGP config
        :param bgp_v4_active = True,
        :param bgp_v4_dut = '100.1.0.2',
        :param bgp_v4_dut_ip_address = '100.1.0.2',
        :param bgp_v4_2_byte_as = 100,
        :param bgp_v4_type = 'external'
        :param bgp_v4_enable_4_byte_as = 'True',
        :param bgp_v4_4_byte_as = 66000,
        :param bgp_v4_hold_time_interval = 60,
        :param bgp_v4_keep_alive_interval = 20,
        :param bgp_v4_configure_keep_alive_timer = True,
        :param bgp_v4_enable_graceful_restart = True,
        :param bgp_v4_route_count = 5,
        :param bgp_v4_route_start ='11.11.11.1',
        :param bgp_v4_route_prefix = 28,
        :param bgp_v4_route_prefix_step = 2,
        :param bgp_v4_route_active = True,
        :param bgp_v4_route_segment_type = 'assetconfederation',
        :param bgp_v4_ttl =32,
        :param bgp_v4_authentication = 'md5',
        :param bgp_v4_password = 'ixia1',
        :param bgp_v4_minimum_label =20
        :param bgp_v4_aspath = 200
        :param bgp_v4_asnum_stepvalue = 2

        #Create device BGPv6 config
        :param bgp_v6_active=True,
        :param bgp_v6_dut='2000:1:1:1::1',
        :param bgp_v6_dut_ip_address='2000:1:1:1::1',
        :param bgp_v6_type: 'external',
        :param bgp_v6_enable_2_byte_as = 100,
        :param bgp_v6_enable_4_byte_as=True,
        :param bgp_v6_4_byte_as=66000,
        :param bgp_v6_hold_time_interval=60,
        :param bgp_v6_keep_alive_interval=20,
        :param bgp_v6_configure_keep_alive_timer=True,
        :param bgp_v6_enable_graceful_restart=True,
        :param bgp_v6_route_count=10,
        :param bgp_v6_route_start='2000:1:1:1::1',
        :param bgp_v6_route_prefix = 28,
        :param bgp_v6_route_prefix_step = 2,
        :param bgp_v6_route_active=True,
        :param bgp_v6_route_segment_type='assetconfederation',
        :param bgp_v6_ttl=32,
        :param bgp_v6_authentication='md5',
        :param bgp_v6_password='ixia1',
        :param bgp_v6_minimum_label = 20
        :param bgp_v6_aspath = 200
        :param bgp_v6_asnum_stepvalue = 2


        :Example: add_device(port_list= ["10.39.60.2/1/1"])
        """
        self.log.info("Adding New Device to the Topology")
        disable_diag_log = kwargs.get('disable_diag_log', False)
        self.disable_diag_log = disable_diag_log
        self.disable_trace_log = kwargs.get('disable_trace_log', True)
        device_obj = kwargs.get('device_obj', {})
        port_name_list = kwargs.get('port_name_list', None)
        assign_to_physical_port = kwargs.get('assign_to_physical_port', True)
        interface_no_vlan_count = kwargs.get('interface_no_vlan_count', 1)
        interface_vlan_disable = kwargs.get('interface_vlan_disable', 0)
        vlan_id_count = kwargs.get('vlan_id_count', 0)
        igmp_rate_interval = kwargs.get('igmp_rate_interval', 0)
        mld_rate_interval = kwargs.get('mld_rate_interval', 0)
        device_name = kwargs.get('device_name', None)
        devicegroup_name = kwargs.get('devicegroup_name', None)
        forceTakePortOwnership = True
        existingDeviceObj = None
        testPorts = []
        vportList = []
        if self.update_license == False and new_config == True:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        if new_config:
            self.ixNetwork.NewConfig()
        if not new_config:
            vportData = [(vportConnect.AssignedTo).replace(':', '/') for vportConnect in self.get_list_ports()]
            self._update_media_type()
        else:
            vportData = None
        if kwargs.get('multiple_vports_topo', None):
            port_list = [port_list]

        if not port_list:
            return True
        
        for port in port_list:

            if kwargs.get('multiple_vports_topo', None):
                for vport in port_list[0]:
                    if vportData:
                        if vportData:
                            # vportInfo = [port[port.index('/') + 1:] for port in vportData]
                            vportInfo = [port.replace(':', '/') for port in vportData]
                        else:
                            vportInfo = None
                        if vportInfo:
                            if vport in vportInfo:
                                for portObj in self.ixNetwork.Vport.find():
                                    portAssigned = (portObj.AssignedTo).replace(':', '/')
                                    if vport == portAssigned[portAssigned.index('/') + 1:]:
                                        portName = portObj.Name
                                        device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                        break
                                    existingDeviceObj = True
                            else:
                                self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                                    forceTakePortOwnership)
                    else:
                        self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)
            else:
                if 'vport' not in device_obj and existingDeviceObj is None:
                    if port_name_list:
                        if len(port_list) != len(port_name_list):
                            msg = 'port name:%s do not match ports:%s' % (port_name_list, port_list)
                            self.log.error(msg)
                            raise CafyException.TgenConfigMissingError(msg)

                    if vportData:

                        # vportInfo = [port[port.index('/') + 1:] for port in vportData]
                        vportInfo = [port.replace(':', '/') for port in vportData]
                    else:
                        vportInfo = None
                    if vportInfo:
                        temp_port = port
                        port = port[port.index('/') + 1:]
                        if port in vportInfo:
                            for portObj in self.ixNetwork.Vport.find():
                                assigned = (portObj.AssignedTo).replace(':', '/')
                                if assigned == port: 
                                    portName = portObj.Name
                                    device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                    break
                            existingDeviceObj = True
                        else:
                            port = temp_port
                            self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                                forceTakePortOwnership)
                    else:
                        self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)

            if 'topology' not in device_obj:
                topologyObj = None
                if kwargs.get('multiple_vports_topo', None):
                    port = port[0]
                if vportData:
                    vportInfo = [port.replace(':', '/') for port in vportData]
                    if port in vportInfo:
                        for topology in self.ixNetwork.Topology.find():
                            for portObj in self.ixNetwork.Vport.find():
                                # if port in (portObj.AssignedTo).replace(':', '/'):   - old
                                portAssigned = (portObj.AssignedTo).replace(':', '/')
                                if port == portAssigned[portAssigned.index('/') + 1:]:
                                    portName = portObj.Name.replace('/', r'\/').replace('(', r'\(').replace(')', r'\)') + '$'
                                    break
                            if self.ixNetwork.Vport.find(Name=portName).href in topology.Vports:
                                device_obj['topology'] = topology
                                topologyObj = True
                                break
                if not topologyObj:
                    if vportList == []:
                        for portObj in self.ixNetwork.Vport.find():
                            if temp_port in (portObj.AssignedTo).replace(':', '/'):
                                vportList.append(portObj.href)
                    device_obj['topology'] = self.ixNetwork.Topology.add(Vports=vportList)

            if 'interface_no_vlan_count' in kwargs:
                multiplier = interface_no_vlan_count + vlan_id_count
            elif 'interface_vlan_disable' in kwargs :
                multiplier = interface_vlan_disable + vlan_id_count
            elif vlan_id_count:
                multiplier = vlan_id_count
            else:
                multiplier = 1
            if 'devicegroup_name' not in kwargs:
                kwargs['devicegroup_name'] = None
            if 'device_name' in kwargs:
                kwargs['devicegroup_name'] = kwargs['device_name']
            if 'devicegroup' not in device_obj and existingDeviceObj is None:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            else:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            vlanIdKwargs = {key: kwargs[key] for key in kwargs if "id" in key and kwargs[key] != ""}
            vlanPriorityKwargs = {key: kwargs[key] for key in kwargs if "priority" in key and kwargs[key] != ""}
            if ('ethernet' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                device_obj['ethernet'] = device_obj['devicegroup'].Ethernet.add(Name=None,
                                                                                VlanCount=kwargs.get('vlan_count',
                                                                                                     None))
                if kwargs.get('vlan_count', None) or kwargs.get('vlan_id_step', None):
                    device_obj['ethernet'].UseVlans = True
                if 'interface_no_vlan_count' in kwargs:
                    valueList = ['false' if i <= interface_no_vlan_count else 'true' for i in
                                 range(1, interface_no_vlan_count + vlan_id_count + 1)]
                    device_obj['ethernet'].EnableVlans.ValueList(valueList)
                if 'interface_vlan_disable' in kwargs:
                    valueList = ['true'] * (interface_vlan_disable + vlan_id_count)
                    if 0 <= interface_vlan_disable < len(valueList):
                        valueList[interface_vlan_disable] = 'false'
                    device_obj['ethernet'].EnableVlans.ValueList(valueList)
                if 'vlan_id_start' in kwargs:
                    vlanIdKwargs['vlan_id_direction'] = kwargs.get('vlan_id_direction', 'increment')
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanIdKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Id Info configured successfully")

                if 'vlan_priority_start' in kwargs:
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanPriorityKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Priority Info configured successfully")

            if 'ipv4_address_direction' not in kwargs and 'ipv4_address_step' in kwargs:
                kwargs['ipv4_address_direction'] = 'increment'
            if 'ipv4_gateway_direction' not in kwargs and 'ipv4_gateway_step' in kwargs:
                kwargs['ipv4_gateway_direction'] = 'increment'
            if 'ipv6_address_direction' not in kwargs and 'ipv6_address_step' in kwargs:
                kwargs['ipv6_address_direction'] = 'increment'
            if 'ipv6_gateway_direction' not in kwargs and 'ipv6_gateway_step' in kwargs:
                kwargs['ipv6_gateway_direction'] = 'increment'
            ipv4Kwargs = {key: kwargs[key] for key in kwargs if "ipv4" in key and kwargs[key] != ""}
            ipv6Kwargs = {key: kwargs[key] for key in kwargs if "ipv6" in key and kwargs[key] != ""}
            igmpKwargs = {key: kwargs[key] for key in kwargs if "igmp" in key and kwargs[key] != ""}
            mldKwargs = {key: kwargs[key] for key in kwargs if "mld" in key and kwargs[key] != ""}
            bgpv4Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v4" in key and kwargs[key] != ""}
            bgpv6Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v6" in key and kwargs[key] != ""}

            if ('ipv4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv4_address_start:
                    device_obj['ipv4'] = device_obj['ethernet'].Ipv4.add()
                    ipv4Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv4_address_start=ipv4_address_start, **ipv4Kwargs)
                    ipv4Obj.config()
                    self.log.info("Ipv4 Info configured successfully")

            if ('ipv6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv6_address_start:
                    device_obj['ipv6'] = device_obj['ethernet'].Ipv6.add()
                    ipv6Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv6_address_start=ipv6_address_start, **ipv6Kwargs)
                    ipv6Obj.config()
                    self.log.info("IPv6 Info configured successfully")

            # Create IGMP
            if ('igmp' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if igmpKwargs:
                    if 'ipv4' in device_obj:
                        igmpObj = IGMP(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'],
                                       igmp_group_start=igmp_group_start,
                                       **igmpKwargs)
                        igmpObj.config()
                        self.log.info("Igmp Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
                    if igmp_rate_interval:
                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name,
                                               device_name=device_name)
            # Create MLD
            if ('mld' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if mldKwargs:
                    if 'ipv6' in device_obj:
                        mldObj = MLD(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], mld_group_start=mld_group_start,
                                     **mldKwargs)
                        mldObj.config()
                        self.log.info("Mld Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")
                    if mld_rate_interval:
                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name,
                                               device_name=device_name)
            # Create BGPv4
            if ('bgp_v4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv4Kwargs != {}:
                    if 'ipv4' in device_obj:
                        bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'], **bgpv4Kwargs)
                        bgpv4Obj.config()
                        self.log.info("BGPv4 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
            # Create BGPv6
            if ('bgp_v6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv6Kwargs != {}:
                    if 'ipv6' in device_obj:
                        bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], **bgpv6Kwargs)
                        bgpv6Obj.config()
                        self.log.info("BGPv6 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")

            #Create ipv4 routerId
            if kwargs.get('ipv4_routerid', None) != None:
                router_obj = device_obj['devicegroup'].RouterData.find().RouterId
                if kwargs.get('ipv4_router_step'):
                    router_obj.Increment(start_value = kwargs.get('ipv4_routerid'),
                                            step_value = '0.0.0.' + str(kwargs.get('ipv4_router_step')))
                else:
                    router_obj.Single(kwargs.get('ipv4_routerid'))

            #Create ipv6 routerId
            if kwargs.get('ipv6_routerid', None) != None:
                router_obj = device_obj['devicegroup'].RouterData.find().RouterId
                if kwargs.get('ipv6_router_step'):
                    router_obj.Increment(start_value = kwargs.get('ipv6_routerid'),
                                            step_value = '0.0.0.' + str(kwargs.get('ipv6_router_step')))
                else:
                    router_obj.Single(kwargs.get('ipv6_routerid'))

            retryCount = 0
            while True:
                if retryCount == 10: break
                try:
                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                    break
                except:
                    time.sleep(3)
                    retryCount = retryCount + 1

        if self.primary:
            self.connect_to_chassis([self.primary])
            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find() if
                                      chassis.Hostname != self.primary]
            if connected_chassis_list:
                self.set_chassis_mode(primary=self.primary, secondary=connected_chassis_list)
        return device_obj

    def start_stop_rocev2_1(self, action = 'start',device_name = None,ip_type = 'ipv4'):
        """
        Start or stop RoCEv2 protocol stacks.

        :param action: Operation to perform on RoCEv2 protocol.
                       Options: 'start' (default) or 'stop'.
        :param device_name: DeviceGroup selection.
                       - None (default): operate on all RoCEv2 stacks.
                       - str: a single device group name.
                       - list[str]: list of multiple device group names.
        :param ip_type: IP protocol type under which RoCEv2 is configured.
                       Options: 'ipv4' (default) or 'ipv6'.

        Example:
            # Start all RoCEv2 IPv4 stacks
            ApData.TGEN.start_stop_rocev2(action='start')

            # Stop only the RoCEv2 stack under device group 'DG1'
            ApData.TGEN.start_stop_rocev2(action='stop', device_name='DG1')

            # Start RoCEv2 on multiple device groups (IPv6)
            ApData.TGEN.start_stop_rocev2(
                action='start',
                device_name=['DG1', 'DG2'],
                ip_type='ipv6'
            )
        """

        
        self.log.info("Initialising start/stop on RoCE Protocol")
        action = action.lower()
        rocev_list = []

        if device_name == None:
            if ip_type.lower() == 'ipv4':
                for roce_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Rocev2.find():
                    rocev_list.append(roce_obj)
            elif ip_type.lower() == 'ipv6':
                for roce_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Roce6v2.find():
                    rocev_list.append(roce_obj)
            else:
                raise ValueError("ip_type must be 'ipv4' or 'ipv6'")
            
        else:
            if isinstance(device_name,str):
                device_name = [device_name]
            else:
                pass
            for device in device_name:
                if ip_type.lower()== 'ipv4':
                    roce_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name  = f'^{re.escape(device)}$').Ethernet.find().Ipv4.find().Rocev2.find()
                    rocev_list.append(roce_obj)
                elif ip_type.lower()== 'ipv6':
                    roce_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name  = f'^{re.escape(device)}$').Ethernet.find().Ipv6.find().Roce6v2.find()
                    rocev_list.append(roce_obj)
                else:
                    raise ValueError("ip_type must be 'ipv4' or 'ipv6'")

        if not rocev_list:
            raise RuntimeError("No RoCEv2 protocol stacks found matching input criteria.")

        for roce in rocev_list:
            try:
                self.log.info(f"Performing {action.upper()} on RoCE Stack: {roce.Name}")
                roce.Start() if action == 'start' else roce.Stop()
                self._wait_for_protocol_action_complete(operation_name=f'[RoCE {action.upper()}]',timeout = 500)
            except Exception as e:
                self.log.error(f"Failed to {action} RoCE protocol on {roce.Name}: {e}")
                raise

    def get_traffic_type(self, traffic_item = None):
        """
        Fetch Traffic Item(s) type

        :param traffic_item: Name of the traffic item | str or list.
                             Default None, meaning all traffic items in the config
        
        return: Dict of traffic item name and type

        Example: tgnObj.get_traffic_type(traffic_item=['Traffic Item 1','Traffic Item 2']
                 tgnObj.get_traffic_type()

        """
        
        self.log.info("Fetching Traffic Item(s) type")
        traffic_obj = self.ixNetwork.Traffic.TrafficItem.find()
        if not traffic_obj:
            raise Exception("No traffic items configured")

        traffic_type = {}
        if traffic_item == None:
            for traffic in traffic_obj:
                type = traffic.TrafficType
                name = traffic.Name
                traffic_type[name] = type
        else:

            if isinstance(traffic_item,str):
                traffic_item = [traffic_item]
            for traffic in traffic_item:
                t_obj = self.ixNetwork.Traffic.TrafficItem.find(Name= f'^{re.escape(traffic)}$')
                if not t_obj:
                    raise Exception(f"No such traffic item(s) found with Name : {traffic}")
                type = t_obj.TrafficType
                traffic_type[traffic] = type
        
        return traffic_type

    def start_stop_rocev2(self,action = 'start',ip_type = 'ipv4'):

        rocev_list = []
        if ip_type.lower() == 'ipv4':

            for rocev2_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Rocev2.find():
                rocev_list.append(rocev2_obj)
            for rocev2_nest_obj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find().Rocev2.find():
                rocev_list.append(rocev2_nest_obj)
            for rocev2_dg_nest in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ipv4Loopback.find().Rocev2.find():
                rocev_list.append(rocev2_dg_nest)

        if ip_type.lower() == 'ipv6':

            for rocev2_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Roce6v2.find():
                rocev_list.append(rocev2_obj)
            for rocev2_nest_obj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find().Roce6v2.find():
                rocev_list.append(rocev2_nest_obj)
            for rocev2_dg_nest in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ipv6Loopback.find().Roce6v2.find():
                rocev_list.append(rocev2_dg_nest)

        if not rocev_list:
            raise RuntimeError("No RoCEv2 protocol stacks found matching input criteria.")

        for roce in rocev_list:
            try:
                self.log.info(f"Performing {action.upper()} on RoCE Stack: {roce.Name}")
                # roce.Start() if action == 'start' else roce.Stop()
                roce_name = roce.Name
                self.log.info(roce_name)
                self._wait_for_protocol_action_complete(operation_name=f'[RoCE {action.upper()}]',timeout = 500)
            except Exception as e:
                self.log.error(f"Failed to {action} RoCE protocol on {roce.Name}: {e}")


    def start_stop_rocev2_2(self, action='start', ip_type='ipv4'):

        ip_type = ip_type.lower()
        valid_actions = ['start', 'stop']

        if action not in valid_actions:
            raise ValueError(f"Invalid action '{action}'. Expected one of: {valid_actions}")

        if ip_type not in ['ipv4', 'ipv6']:
            raise ValueError("ip_type must be either 'ipv4' or 'ipv6'.")

        topo = self.ixNetwork.Topology.find()
        rocev_list = []

        # Helper function to avoid repeating code
        def collect(base, protocol):
            try:
                rocev_list.extend(base.find(protocol).find())
            except:
                pass  # If path does not exist, ignore

        if ip_type == 'ipv4':
            collect(topo.DeviceGroup.find().Ethernet.find().Ipv4.find(), 'Rocev2')
            collect(topo.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find(), 'Rocev2')
            collect(topo.DeviceGroup.find().DeviceGroup.find().Ipv4Loopback.find(), 'Rocev2')

        else:  # ipv6
            collect(topo.DeviceGroup.find().Ethernet.find().Ipv6.find(), 'Roce6v2')
            collect(topo.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find(), 'Roce6v2')
            collect(topo.DeviceGroup.find().DeviceGroup.find().Ipv6Loopback.find(), 'Roce6v2')

        if not rocev_list:
            raise RuntimeError("No RoCEv2 protocol stacks found matching input criteria.")

        for roce in rocev_list:
            try:
                self.log.info(f"{action.upper()} RoCE protocol on: {roce.Name}")

                # if action == 'start':
                #     roce.Start()
                # else:
                #     roce.Stop()

                self._wait_for_protocol_action_complete(
                    operation_name=f'[RoCE {action.upper()}]',
                    timeout=500
                )

            except Exception as e:
                self.log.error(f"Failed to {action} RoCE protocol on {roce.Name}: {e}")

    def start_stop_rocev2_3(self, action='start', roce_type='roce6v2'):
        """
        Start or stop RoCEv2 protocol stacks all across topology.

        :param action: Operation to perform on RoCEv2 protocol.
                       Options: 'start' (default) or 'stop'.

        :param roce_version: IP protocol type under which RoCEv2 is configured.
                       Options: 'roce6v2' (default) or 'rocev2'.

        :Example: start_stop_rocev2(ip_type = 'ipv6', action='stop')
        """

        self.log.info("Initialising start/stop on RoCE Protocol")
        topo = self.ixNetwork.Topology.find()
        rocev_list = []

        def _safe_find(obj, child):
            try:
                found = getattr(obj, child).find()
                return found if found else []
            except:
                return []

        def _collect_roce(path_list, roce_attr):
            obj = topo
            for step in path_list:
                found = _safe_find(obj, step)
                if not found:
                    return None     
                obj = found
            rocev_list.extend(_safe_find(obj, roce_attr))

        if roce_type.lower() == 'rocev2':
            _collect_roce(["DeviceGroup", "Ethernet", "Ipv4"], "Rocev2")
            _collect_roce(["DeviceGroup", "NetworkGroup", "DeviceGroup", "Ipv4Loopback"], "Rocev2")
            _collect_roce(["DeviceGroup", "DeviceGroup", "Ipv4Loopback"], "Rocev2")

        elif roce_type.lower() == 'roce6v2':
            _collect_roce(["DeviceGroup", "Ethernet", "Ipv6"], "Roce6v2")
            _collect_roce(["DeviceGroup", "NetworkGroup", "DeviceGroup", "Ipv6Loopback"], "Roce6v2")
            _collect_roce(["DeviceGroup", "DeviceGroup", "Ipv6Loopback"], "Roce6v2")

        if not rocev_list:
            raise IxiaConfigException("No RoCEv2 protocol stacks found.")

        for roce in rocev_list:
            self.log.info(f"{action.upper()} RoCE on: {roce.Name}")
            getattr(roce, action.capitalize())()
            self._wait_for_protocol_action_complete(operation_name=f"[RoCE {action.upper()}]", timeout=500)
        
        return True

    def _get_restart_dgs(self, stats):

        restart_dgs = {}

        for dg_name, d in stats.items():
            down_ips = []
            not_started_ips = []
            bad_ips = []

            for ip, status in d['ip_status_map'].items():
                s = status.strip().lower()
                if s in ("down", "notstarted", "not started"):
                    bad_ips.append(ip)
                    if s == "down":
                        down_ips.append(ip)
                    if s in ["notstarted", "not started"]:
                        not_started_ips.append(ip)

            if bad_ips:
                restart_dgs[dg_name] = {
                    "bad_ips": bad_ips,
                    "down_ips": down_ips,
                    "not_started_ips": not_started_ips,
                    "down_count": len(down_ips),
                    "not_started_count": len(not_started_ips),
                }

        return restart_dgs

    def _build_ip_stack_refs(self, dgs, restart_dgs, stack_attr):

        ip_stack_refs = {}

        for dg in dgs:
            name = dg.Name
            if name not in restart_dgs:
                continue

            bad_ips = set(restart_dgs[name]["bad_ips"])

            for eth in dg.Ethernet.find():
                for ip_stack in getattr(eth, stack_attr).find():
                    for ip in ip_stack.Address.Values:
                        if ip in bad_ips:
                            ip_stack_refs.setdefault(ip_stack, []).append(ip)

        return ip_stack_refs

    def _refresh_restart_dgs(self, stats):

        restart_dgs = {}

        for dg_name, d in stats.items():
            bad_ips = [
                ip for ip, status in d['ip_status_map'].items()
                if status.strip().lower() in ('down', 'notstarted', 'not started')
            ]
            if bad_ips:
                restart_dgs[dg_name] = {"bad_ips": bad_ips}

        return restart_dgs

    # def _compute_bad_ip_summary(self, restart_dgs, stats):

        # count_down, count_not = 0, 0

        # for d in restart_dgs.values():
        #     for ip in d["bad_ips"]:
        #         st = stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower()
        #         if st == 'down':
        #             count_down += 1
        #         else:
        #             count_not += 1
        # return count_down, count_not

    def _refresh_restart_dgs_with_counts(self, stats):
        restart_dgs = {}
        for dg_name, d in stats.items():
            bad_ips = [
                ip for ip, status in d['ip_status_map'].items()
                if status.strip().lower() in ('down', 'notstarted', 'not started')
            ]
            if bad_ips:
                restart_dgs[dg_name] = {
                    "bad_ips": bad_ips,
                    "down_count": d.get("down", 0),
                    "not_started_count": d.get("not started", 0),
                }
        return restart_dgs

    def _build_final_summary(self, stats, ip_version):
        return {
            dg: {
                "Total IPs": d['total_ips'],
                "IP Version": ip_version,
                "Up": d['up'],
                "Down": d['down'],
                "Not Started": d['not started']
            }
            for dg, d in stats.items()
        }

    def _restart_device_group_ips(self, dg_name, bad_ips, ip_type):
        """
        RestartDown only the sessions whose IP address (IPv4 or IPv6)
        appears in bad_ips.

        :param dg_name: Device Group name (string)
        :param bad_ips: list of IPs that were DOWN
        :param ip_type: "ipv4" or "ipv6"
        """

        ip_type = ip_type.lower()
        if ip_type not in ("ipv4", "ipv6"):
            raise ValueError("ip_type must be 'ipv4' or 'ipv6'")

        topo = self.ixNetwork.Topology.find()
        dg = topo.DeviceGroup.find(Name=f'^{re.escape(dg_name)}$')

        if len(dg) == 0:
            self.log.error(f"Device Group '{dg_name}' not found")
            return

        dg = dg[0]
        restart_indices = []

        stack_attr = "Ipv4" if ip_type == "ipv4" else "Ipv6"

        for eth in dg.Ethernet.find():
            proto_list = getattr(eth, stack_attr).find()

            if not proto_list:
                continue

            proto = proto_list[0]

            try:
                all_ips = proto.Address.Values
            except Exception:
                all_ips = list(proto.Address.ValueList)

            for idx, ip in enumerate(all_ips, start=1):
                if ip in bad_ips:
                    restart_indices.append(idx)

        if not restart_indices:
            self.log.info(f"No {ip_type.upper()} IPs matched for DG={dg_name}")
            return

        for eth in dg.Ethernet.find():
            proto_list = getattr(eth, stack_attr).find()
            if proto_list:
                proto_list[0].RestartDown(SessionIndices=restart_indices)
                self._wait_for_protocol_action_complete(operation_name='Restart Down on IP indices')

    def restart_ip_stack3(self, device_group_name=None, ip_version='ipv4', max_retries=10, **kwargs):

        def _chunked(seq, size):
            return (seq[i:i + size] for i in range(0, len(seq), size))

        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'

        self.log.info("\n===== Initial Table =====\n")
        stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)
        # pdb.set_trace()
        restart_dgs = self._get_restart_dgs(stats)

        if not restart_dgs:
            self.log.success("All IPs already UP")
            return self._build_final_summary(stats, ip_version)

        pattern = (
            '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'
            if isinstance(device_group_name, list)
            else re.escape(device_group_name) if isinstance(device_group_name, str)
            else '.*'
        )

        dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)

        for attempt in range(1, max_retries + 1):

            self.log.info(f"\n\n===== Restart Attempt {attempt}/{max_retries} =====\n")

            ip_stack_refs = self._build_ip_stack_refs(dgs, restart_dgs, stack_attr)
            unique_stacks = list(ip_stack_refs.keys())

            self.log.info(f"Restarting {len(unique_stacks)} stacks ...")

            fresh_stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=False)
            restart_dgs = self._refresh_restart_dgs_with_counts(fresh_stats)

            for dg_name, data in restart_dgs.items():
                self.log.info(
                    f"Device Group : {dg_name} | DOWN: {data['down_count']} | NOT STARTED: {data['not_started_count']}"
                )

            if not unique_stacks:
                self.log.success(f"No stacks to restart in attempt {attempt}")
                break

            for chunk in _chunked(unique_stacks, 500):
                with ThreadPoolExecutor(max_workers=10) as ex:
                    list(ex.map(lambda s: s.RestartDown(), chunk))

                self._wait_for_protocol_action_complete(timeout=240, operation_name='Restart Down')
                time.sleep(5)

            updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)
            restart_dgs = self._refresh_restart_dgs_with_counts(updated)

            if not restart_dgs:
                self.log.success(f"All IPs UP after {attempt} attempt(s)")
                if ip_version == 'ipv6':
                    self._link_local_restart(device_groups= device_group_name)
                return self._build_final_summary(updated, ip_version)

        if restart_dgs:
            total_down = sum(d['down_count'] for d in restart_dgs.values())
            total_not_started = sum(d['not_started_count'] for d in restart_dgs.values())
            self.log.warning(f"After {max_retries} retries  total IPs still DOWN: {total_down}, "
                             f"NOT STARTED: {total_not_started}  attempting forced per-index restart")

            for dg_name, data in restart_dgs.items():
                bad_ips = data.get('bad_ips', [])
                if bad_ips:
                    self.log.info(f"Restarting {len(bad_ips)} bad IPs in Device Group {dg_name} ...")
                    self._restart_device_group_ips(dg_name=dg_name, bad_ips=bad_ips, ip_type=ip_version)

        final_stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)

        if not restart_dgs:
            self.log.success("No DGs with down IPs found for forced restart")
            return self._build_final_summary(updated, ip_version)


    def _topology_to_vport(self, **kwargs):

        src_groups = defaultdict(list)
        for item in self.ixNetwork.Traffic.TrafficItem.find():
            
            if item.TrafficType == 'raw':
                src_desc = item.EndpointSet.find().SourcesDescription
                if src_desc:
                    key = (src_desc,)
                    src_groups[key].append(item)
            else:
                for ep in item.EndpointSet.find():
                    src_href = ep.Sources
                    if not src_href:
                        continue
                    m = re.search(r'(.*?/ixnetwork/topology/\d+)/', src_href[0])
                    if not m:
                        self.log.warning(f"Could not extract topology from href: {src_href}")
                        continue
                    topo_base = m.group(1)
                    for topology in self.ixNetwork.Topology.find():
                        if topo_base in topology.href:
                            tx_ports = topology.Ports
                            for vport in self.ixNetwork.Vport.find():
                                if tx_ports[0] in vport.href:
                                    key = (vport.Name,)
                                    src_groups[key].append(item)

        return src_groups

    def change_traffic_transmission_mode2(self, config, traffic_item_list='all', port='all', **kwargs):
        """
        Changes the transmission control mode for a given set of traffic items.

        :param config: Dict including the transmission control data to be modified. \n
            valid Options:\n
            type: auto,continuous,custom,fixedDuration, fixedFrameCount,fixedIterationCount \n
            duration: The duration of time (in seconds) for traffic to run for applicable transmission control types \n
            extra options (case-sensitive): iterationCount,frameCount,startDelay,startDelayUnits,minGapBytes, burstPacketCount,repeatBurst,interBurstGap,interStreamGap,interBurstGapUnits \n
        :param traffic_item_list: List of traffic Items name.
        :param port: NA for IXIA
        :param kwargs:
                    - split_port_rate : (False by default) To be used for even distribution of load across Traffic Items
        :return: True on success, else reverts the config

        :Example: change_traffic_transmission_mode(config={'type': 'custom', 'interBurstGap': 25, 'burstPacketCount': 25}, traffic_item_list=["Traffic Item 3"])
        """

        self.log.info("Changing Traffic Transmission Mode")
        split_port_rate = kwargs.get('split_port_rate', False)
        rate_map_dict = {'fps': 'framesPerSecond', 'bps': 'bitsPerSecond',
                         'kps': 'kilobitsPerSecond', 'mps': 'megabitsPerSecond', 'percent': 'percentLineRate'}
        if traffic_item_list and traffic_item_list != 'all':
            if 'mode' in config.keys():
                if config['mode'] in ['stream_rate', 'port_rate']:
                    traffic_rate_dict = {}
                    if 'load' in config.keys():
                        if split_port_rate == False:
                            traffic_rate_dict.update({'rate': config['load']})
                        else:
                            src_groups = self._topology_to_vport()

                            total_load = config.get('load')
                            unit = config.get('load_unit')
                            for group, ti_list in src_groups.items():
                                per_ti_load = float(total_load / len(ti_list))
                                self.log.info(
                                    f"Source group {group} has {len(ti_list)} Traffic Item(s). Per-Traffic Item load: {per_ti_load} {unit}")
                                for item in ti_list:
                                    try:
                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')
                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)
                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)
                                    except Exception as err:
                                        self.log.error(f"Failed to set load on Traffic Item '{item.Name}': {err}")
                    if 'load_unit' in config.keys():
                        if config['load_unit'] in rate_map_dict.keys():
                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})
                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():
                        self.change_traffic_rate(cfg_dict=traffic_rate_dict, traffic_item_list=traffic_item_list)
                    if 'duration_mode' in config.keys():
                        if config['duration_mode'] == 'seconds':
                            config['type'] = 'fixedDuration'
                            config['startDelayUnits'] = config['duration_mode']
                        elif config['duration_mode'] == 'continuous':
                            config['type'] = 'continuous'
            for traffic_item in traffic_item_list:
                traffic_item = re.escape(traffic_item)
                for transmission_control in self.ixNetwork.Traffic.TrafficItem.find(
                        Name=f'^{traffic_item}$').ConfigElement.find().TransmissionControl:
                    for key in config:
                        if 'interBurstGap' in key:
                            setattr(transmission_control, 'EnableInterBurstGap', True)
                        try:
                            setattr(transmission_control, key[0].upper() + key[1:], config[key])
                        except:
                            pass
        else:
            if 'mode' in config.keys():
                if config['mode'] in ['stream_rate', 'port_rate']:
                    traffic_rate_dict = {}
                    if 'load' in config.keys():
                        if split_port_rate == False:
                            traffic_rate_dict.update({'rate': config['load']})
                        else:
                            src_groups = self._topology_to_vport()

                            total_load = config.get('load')
                            unit = config.get('load_unit')
                            for group, ti_list in src_groups.items():

                                per_ti_load = float(total_load / len(ti_list))
                                self.log.info(f"Port {group} has {len(ti_list)} Traffic Item(s). Per-Traffic Item load: {per_ti_load} {unit}")
                                for item in ti_list:
                                    try:
                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')

                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)
                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)
                                    except Exception as err:
                                        self.log.error(f"Failed to set load on Traffic Item '{item.Name}': {err}")
                    if 'load_unit' in config.keys():
                        if config['load_unit'] in rate_map_dict.keys():
                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})
                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():
                        self.change_traffic_rate(cfg_dict=traffic_rate_dict)
                    if 'duration_mode' in config.keys():
                        if config['duration_mode'] == 'seconds':
                            config['type'] = 'fixedDuration'
                            config['startDelayUnits'] = config['duration_mode']
                        elif config['duration_mode'] == 'continuous':
                            config['type'] = 'continuous'
            for transmission_control in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().TransmissionControl:
                for key in config:
                    if 'interBurstGap' in key:
                        setattr(transmission_control, 'EnableInterBurstGap', True)
                    try:
                        setattr(transmission_control, key[0].upper() + key[1:], config[key])
                    except:
                        pass
        self.log.info("Traffic Transmission mode updated in Traffic Items")
        return True


    def topology_to_vport1(self, topology_name=None):


        pdb.set_trace()
        self.ixNetwork.Traffic.TrafficItem.find(Name = "").ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(DisplayName='Precedence').FieldValue = 6
        src_groups = defaultdict(list)

        #
        # ---- Batch-find all TrafficItem and EndpointSet lookups ----
        #
        with BatchFind(self.ixNetwork):
            ti_list = self.ixNetwork.Traffic.TrafficItem.find()
            # EndpointSet.find() will be cached inside the batch
            for ti in ti_list:
                _ = ti.EndpointSet.find()

        #
        # ---- Batch-find all topology & vport lookups ----
        #
        with BatchFind(self.ixNetwork):
            topo_list = self.ixNetwork.Topology.find()
            vport_list = self.ixNetwork.Vport.find()

        # --------------------------------------------------------------------

        for item in ti_list:

            # ============================================================
            # RAW traffic  use SourcesDescription directly
            # ============================================================
            if item.TrafficType == 'raw':
                for ep in item.EndpointSet.find():     # this is still cached
                    desc = ep.SourcesDescription
                    if desc:
                        src_groups[(desc,)].append(item)
                continue

            # ============================================================
            # Non-RAW traffic
            # ============================================================
            for ep in item.EndpointSet.find():
                src_href = ep.Sources
                if not src_href:
                    continue

                # Extract "/ixnetwork/topology/<n>/" base
                m = re.search(r'(.*?/ixnetwork/topology/\d+)/', src_href[0])
                if not m:
                    self.log.warning(f"Could not extract topology from href: {src_href}")
                    continue

                topo_base = m.group(1)

                # -------- Find matching topology --------
                matching_topo = None
                for topo in topo_list:
                    if topo.href.startswith(topo_base):
                        matching_topo = topo
                        break

                if not matching_topo:
                    self.log.warning(f"No topology matched {topo_base}")
                    continue

                # Get tx ports
                tx_ports = matching_topo.Ports
                if not tx_ports:
                    continue

                target_port_href = tx_ports[0].href

                # -------- Find matching Vport --------
                matched_vport = None
                for vp in vport_list:
                    if vp.href == target_port_href:
                        matched_vport = vp
                        break

                if not matched_vport:
                    continue

                src_groups[(matched_vport.Name,)].append(item)

        return src_groups

    def create_device_groups_with_ethernet_ipv4_ipv6(self, vport1, vport2, multiplier=10):
        """
        Create two device groups, each with Ethernet, IPv4, and IPv6 stacks.

        :param vport1: Virtual port 1
        :param vport2: Virtual port 2
        :param multiplier: Multiplier for the device groups (default: 10)
        :return: None
        """
        try:
            # Create the first device group
            device_group1 = self.ixNetwork.Vport.find(Name=vport1).DeviceGroup.add()
            device_group1.Name = f"DeviceGroup1_{vport1}"
            device_group1.Multiplier = multiplier

            # Add Ethernet stack to the first device group
            ethernet1 = device_group1.Ethernet.add()
            ethernet1.Name = f"Ethernet1_{vport1}"

            # Add IPv4 stack to the first device group
            ipv4_1 = device_group1.IPv4.add()
            ipv4_1.Name = f"IPv4_1_{vport1}"
            ipv4_1.GatewayIp = "192.0.2.1"
            ipv4_1.ResolveGateway = True

            # Add IPv6 stack to the first device group
            ipv6_1 = device_group1.IPv6.add()
            ipv6_1.Name = f"IPv6_1_{vport1}"
            ipv6_1.GatewayIp = "2001:db8::1"
            ipv6_1.ResolveGateway = True

            # Create the second device group
            device_group2 = self.ixNetwork.Vport.find(Name=vport2).DeviceGroup.add()
            device_group2.Name = f"DeviceGroup2_{vport2}"
            device_group2.Multiplier = multiplier

            # Add Ethernet stack to the second device group
            ethernet2 = device_group2.Ethernet.add()
            ethernet2.Name = f"Ethernet2_{vport2}"

            # Add IPv4 stack to the second device group
            ipv4_2 = device_group2.IPv4.add()
            ipv4_2.Name = f"IPv4_2_{vport2}"
            ipv4_2.GatewayIp = "192.0.2.2"
            ipv4_2.ResolveGateway = True

            # Add IPv6 stack to the second device group
            ipv6_2 = device_group2.IPv6.add()
            ipv6_2.Name = f"IPv6_2_{vport2}"
            ipv6_2.GatewayIp = "2001:db8::2"
            ipv6_2.ResolveGateway = True

            self.log.info("Successfully created two device groups with Ethernet, IPv4, and IPv6 stacks.")
        except Exception as ex:
            self.log.error(f"Failed to create device groups: {ex}")
            raise IxiaConfigException(f"Failed to create device groups: {ex}")