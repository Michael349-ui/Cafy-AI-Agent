[
  {
    "id": "edf3b540-8258-4d3c-b8b8-2ec431a4bf3c",
    "text": "\nclass Cafy:\n    def get_traffic_items_dict(self):\n        \"\"\"\n        Get a dictionary of traffic items with keys as Traffic Item Name and values as Traffic Item Type.\n\n        :return: Dictionary of traffic items with keys as Traffic Item Name and values as Traffic Item Type.\n                If failed, raise IxiaOperationException.\n\n        :Example: get_traffic_items_dict()\n        \"\"\"\n        self.log.info(\"Retrieving traffic items dictionary\")\n        traffic_items_dict = {}\n        try:\n            traffic_items = self.ixNetwork.Traffic.TrafficItem.find()\n            for traffic_item in traffic_items:\n                traffic_items_dict[traffic_item.Name] = traffic_item.TrafficItemType\n            return traffic_items_dict\n        except Exception as ex:\n            raise IxiaOperationException(f\"Failed to retrieve traffic items dictionary: {ex}\")\n\n\n\n    def create_bgp_router_config(self, topology_name, device_group_name, router_name, as_num, dut_as_num, dut_ipv4_addr):\n        \"\"\"\n        Create a BGP router configuration under a device group.\n\n        Args:\n            topology_name (str): Name of the topology.\n            device_group_name (str): Name of the device group.\n            router_name (str): Name of the BGP router.\n            as_num (str): AS number for the BGP router.\n            dut_as_num (str): DUT AS number.\n            dut_ipv4_addr (str): DUT IPv4 address.\n\n        Returns:\n            str: Handle to the created BGP router configuration.\n        \"\"\"\n        # Get the topology\n        topology = self.ixNetwork.Topology.find(Name=topology_name)\n        if not topology:\n            raise Exception(f\"Topology '{topology_name}' not found.\")\n\n        # Get the device group\n        device_group = topology.DeviceGroup.find(Name=device_group_name)\n        if not device_group:\n            raise Exception(f\"Device group '{device_group_name}' not found in topology '{topology_name}'.\")\n\n        # Create BGP router configuration\n        bgp_router = device_group.BgpRouterConfig.add()\n        bgp_router.Name = router_name\n        bgp_router.AsNum = as_num\n        bgp_router.DutasNum = dut_as_num\n        bgp_router.DutIpv4Addr = dut_ipv4_addr\n\n        return bgp_router\n\n    def add_bgp_ipv4_route(self, bgp_router, route_name, network, prefix_length, as_path=None, community=None, local_pref=None):\n        \"\"\"\n        Add a BGP IPv4 route to a BGP router configuration.\n\n        Args:\n            bgp_router (str): Handle to the BGP router configuration.\n            route_name (str): Name of the BGP route.\n            network (str): Network address for the route.\n            prefix_length (str): Prefix length for the route.\n            as_path (list, optional): AS path for the route.\n            community (str, optional): Community attribute for the route.\n            local_pref (str, optional): Local preference for the route.\n\n        Returns:\n            str: Handle to the created BGP IPv4 route.\n        \"\"\"\n        # Create BGP IPv4 route\n        bgp_route = bgp_router.BgpIpv4RouteConfig.add()\n        bgp_route.Name = route_name\n\n        # Configure network block\n        network_block = bgp_route.Ipv4NetworkBlock.add()\n        network_block.StartIpList = network\n        network_block.PrefixLength = prefix_length\n        network_block.NetworkCount = 1\n\n        # Configure AS path if provided\n        if as_path:\n            bgp_route.AsPath = as_path\n\n        # Configure community if provided\n        if community:\n            bgp_route.Community = community\n\n        # Configure local preference if provided\n        if local_pref:\n            bgp_route.LocalPreference = local_pref\n\n        return bgp_route\n\n    def add_bgp_ipv6_route(self, bgp_router, route_name, network, prefix_length, as_path=None, community=None, local_pref=None):\n        \"\"\"\n        Add a BGP IPv6 route to a BGP router configuration.\n\n        Args:\n            bgp_router (str): Handle to the BGP router configuration.\n            route_name (str): Name of the BGP route.\n            network (str): Network address for the route.\n            prefix_length (str): Prefix length for the route.\n            as_path (list, optional): AS path for the route.\n            community (str, optional): Community attribute for the route.\n            local_pref (str, optional): Local preference for the route.\n\n        Returns:\n            str: Handle to the created BGP IPv6 route.\n        \"\"\"\n        # Create BGP IPv6 route\n        bgp_route = bgp_router.BgpIpv6RouteConfig.add()\n        bgp_route.Name = route_name\n\n        # Configure network block\n        network_block = bgp_route.Ipv6NetworkBlock.add()\n        network_block.StartIpList = network\n        network_block.PrefixLength = prefix_length\n        network_block.NetworkCount = 1\n\n        # Configure AS path if provided\n        if as_path:\n            bgp_route.AsPath = as_path\n\n        # Configure community if provided\n        if community:\n            bgp_route.Community = community\n\n        # Configure local preference if provided\n        if local_pref:\n            bgp_route.LocalPreference = local_pref\n\n        return bgp_route\n\n    def create_traffic_stream(self, topology_name, device_group_name, stream_name, source_device, destination_routes):\n        \"\"\"\n        Create a traffic stream between source and destination routes.\n\n        Args:\n            topology_name (str): Name of the topology.\n            device_group_name (str): Name of the device group.\n            stream_name (str): Name of the traffic stream.\n            source_device (str): Handle to the source device.\n            destination_routes (list): List of destination route handles.\n\n        Returns:\n            str: Handle to the created traffic stream.\n        \"\"\"\n        # Get the topology\n        topology = self.ixNetwork.Topology.find(Name=topology_name)\n        if not topology:\n            raise Exception(f\"Topology '{topology_name}' not found.\")\n\n        # Get the device group\n        device_group = topology.DeviceGroup.find(Name=device_group_name)\n        if not device_group:\n            raise Exception(f\"Device group '{device_group_name}' not found in topology '{topology_name}'.\")\n\n        # Create traffic stream\n        traffic_stream = self.ixNetwork.Traffic.TrafficItem.add()\n        traffic_stream.Name = stream_name\n\n        # Configure source and destination bindings\n        source_binding = source_device\n        destination_binding = \" \".join(destination_routes)\n\n        traffic_stream.EndpointSet.add(SrcBinding=source_binding, DstBinding=destination_binding)\n\n        return traffic_stream\n\n\n    def get_device_group_names_from_port(self, port_name=None):\n        \"\"\"\n        Retrieve device group names associated with a specific port or all ports.\n\n        Args:\n            port_name (str, optional): The name of the port to query. If None, returns device groups for all ports.\n\n        Returns:\n            dict: A dictionary where keys are port names and values are lists of device group names.\n                If `port_name` is provided, the dictionary will contain only that port.\n        \"\"\"\n        device_group_info = {}\n\n        if port_name:\n            vport = self.ixNetwork.Vport.find(Name=port_name)\n            if not vport:\n                return device_group_info\n\n            vport_href = vport.href\n            device_group_names = []\n\n            for topology in self.ixNetwork.Topology.find():\n                if vport_href in topology.Vports:\n                    device_group_names.extend([dg.Name for dg in topology.DeviceGroup.find()])\n\n            device_group_info[port_name] = device_group_names\n        else:\n            for vport in self.ixNetwork.Vport.find():\n                vport_href = vport.href\n                device_group_names = []\n\n                for topology in self.ixNetwork.Topology.find():\n                    if vport_href in topology.Vports:\n                        device_group_names.extend([dg.Name for dg in topology.DeviceGroup.find()])\n\n                device_group_info[vport.Name] = device_group_names\n\n        return device_group_info\n\n\n\n\ndef get_device_names(self, port_name=None):\n    \"\"\"\n    Retrieve device group names associated with a specific port or all ports.\n\n    :param port_name: Name of the port or a list of port names. If None, retrieves device group names for all ports.\n    :return: Dictionary containing port names as keys and lists of device group names as values.\n    \"\"\"\n    device_group_info = {}\n\n    if port_name:\n        if isinstance(port_name, str):\n            port_name = [port_name]\n\n        for port in port_name:\n            vport = self.ixNetwork.Vport.find(Name=f\"^{re.escape(port)}$\")\n            if not vport:\n                continue\n\n            vport_href = vport.href\n            device_group_names = []\n\n            for topology in self.ixNetwork.Topology.find():\n                if vport_href in topology.Vports:\n                    device_group_names.extend([dg.Name for dg in topology.DeviceGroup.find()])\n\n            device_group_info[port] = device_group_names\n\n    else:\n        for vport in self.ixNetwork.Vport.find():\n            vport_href = vport.href\n            device_group_names = []\n\n            for topology in self.ixNetwork.Topology.find():\n                if vport_href in topology.Vports:\n                    device_group_names.extend([dg.Name for dg in topology.DeviceGroup.find()])\n\n            device_group_info[vport.Name] = device_group_names\n\n    return device_group_info\n\n\n\n    def get_device_names(self, port_name=None):\n        \"\"\"\n        Get device names associated with a port or all ports, including nested device groups.\n\n        :param port_name: Name of the port or list of port names. If None, all ports are considered.\n        :return: Dictionary with port names as keys and lists of device group names as values.\n        \"\"\"\n        device_group_info = {}\n\n        def get_nested_device_groups(topology, vport_href):\n            \"\"\"\n            Recursively retrieve device group names, including nested ones.\n\n            :param topology: Topology object.\n            :param vport_href: Href of the vport.\n            :return: List of device group names.\n            \"\"\"\n            device_group_names = []\n\n            for device_group in topology.DeviceGroup.find():\n                if vport_href in device_group.Vports:\n                    device_group_names.append(device_group.Name)\n\n                # Check for nested device groups\n                for network_group in device_group.NetworkGroup.find():\n                    for nested_device_group in network_group.DeviceGroup.find():\n                        if vport_href in nested_device_group.Vports:\n                            device_group_names.append(nested_device_group.Name)\n\n            return device_group_names\n\n        if port_name:\n            if isinstance(port_name, str):\n                port_name = [port_name]\n\n            for port in port_name:\n                vport = self.ixNetwork.Vport.find(Name=f\"^{re.escape(port)}$\")\n                if not vport:\n                    continue\n\n                vport_href = vport.href\n                device_group_names = []\n\n                for topology in self.ixNetwork.Topology.find():\n                    if vport_href in topology.Vports:\n                        device_group_names.extend(get_nested_device_groups(topology, vport_href))\n\n                device_group_info[port] = device_group_names\n\n        else:\n            for vport in self.ixNetwork.Vport.find():\n                vport_href = vport.href\n                device_group_names = []\n\n                for topology in self.ixNetwork.Topology.find():\n                    if vport_href in topology.Vports:\n                        device_group_names.extend(get_nested_device_groups(topology, vport_href))\n\n                device_group_info[vport.Name] = device_group_names\n\n        return device_group_info\n",
    "metadata": {
      "type": "cafy_source",
      "file": "cafy_apis/ixia_generated.py"
    }
  },
  {
    "id": "c968e93e-a3da-4d60-8d68-bb33bf8e622f",
    "text": "#**************************************************\n# Copyright (c) 2024-2025 by Cisco Systems, Inc., and/or its affiliates.\n# All rights reserved.\n#**************************************************\nimport json\nimport re\nimport time,inspect\nimport csv\nimport datetime\nimport requests\nimport sys\nimport os,pdb\nimport tabulate\nimport urllib3 \nimport getpass\nimport netaddr\nimport ipaddress\nimport dpkt\nfrom dpkt.utils import inet_to_str\nfrom copy import deepcopy\nimport inspect\nfrom zipfile import ZipFile\nfrom itertools import islice, product\nimport functools\nimport random\nimport threading\nfrom scapy.layers.l2 import Ether\nfrom scapy.all import rdpcap\nos.environ['OPENBLAS_NUM_THREADS'] = '1'\nimport pandas as pd\nimport numpy as np\nfrom typing import List, Union, Optional, AnyStr, Dict, Any\nfrom ixnetwork_restpy import BatchFind\nfrom ixnetwork_restpy import SessionAssistant\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom collections import defaultdict\n# from stubit.stubit import StubitUtil\n\n\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n# from requests.packages.urllib3.exceptions import InsecureRequestWarning\n# requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n\nfrom logger.cafylog import CafyLog\nfrom utils.cafyexception import CafyException\nfrom utils.timer import Timer\nfrom utils.helper import Helper\nfrom tgn.ixia_utils import ScaleTraffic\nfrom tgn.base import TGN\nfrom tgn.ixia_ixnetwork import TrafficStats\ntry:\n    from tgn.ixia_ixnetwork import VLAN, IPV46, IGMP, MLD, OSPFv2, OSPFv3, LDPv4, LDPv6, BGPv4, BGPv6 , ISIS\nexcept:pass\nlog = CafyLog(\"ixia\")\n\n# Import Restpy library\nfrom ixnetwork_restpy.testplatform.testplatform import TestPlatform\nfrom ixnetwork_restpy.assistants.statistics.statviewassistant import StatViewAssistant\nfrom ixnetwork_restpy.files import Files\nfrom ixnetwork_restpy import BatchUpdate\n\nclass IxiaConfigException(Exception):\n    \"\"\"\n    IXIA config exception\n    \"\"\"\n    pass\n\nclass IxiaOperationException(Exception):\n    \"\"\"\n    IXIA operation exception\n    \"\"\"\n    pass\n\nclass IxiaStatsException(Exception):\n    \"\"\"\n    IXIA stats exception\n    \"\"\"\n    pass\n\ndef debug_log_decorator(func):\n    \"\"\"\n    Decorator to download debug files on Ixia exception.\n    :param None\n    :return: None\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper_decorator(*args, **kwargs):\n        try:\n            value = func(*args, **kwargs)\n            return value\n        except Exception as ex:\n            try:\n                args[0]._download_debug_files()\n            except:\n                pass\n            log.error(ex)\n            raise ex\n    return wrapper_decorator\n\ndef timing_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - start\n        log.info(f\"[TIME] {func.__qualname__} executed in {elapsed:.3f}s\")\n        return result\n    return wrapper\n\ndef decorator_for_class(cls):\n    \"\"\"\n    Class Decorator to apply decorator on all the public methods of Ixia class.\n    :param None\n    :return: None\n    \"\"\"\n    for name, method in inspect.getmembers(cls):\n        if (not inspect.ismethod(method) and not inspect.isfunction(method)) or inspect.isbuiltin(method):\n            continue\n        if name.startswith(\"_\"):\n            continue\n        \n        decorated = timing_decorator(debug_log_decorator(method))\n        setattr(cls, name, decorated)\n\n    return cls\n\n@decorator_for_class\nclass IXIA(TGN):\n    def get_handles(self):\n        \"\"\"\n        get handles\n\n        :return: list()\n        \"\"\"\n        return list()\n\n    def __init__(self, tgn_server_type='windows', server_ip=None, debug_print=False,\n                 time_factor=1.0, verbose=True, timeout=300, api_version=1, session_name=None, user_name=None, topology='', **kwargs):\n        \"\"\"\n        Initialize the REST API wrapper object.\n        IxNetwork version should be 8.0 or above for REST api's to work.\n        If the port to connect to is not specified by the port argument,then\n        try connecting on the default port, 11009\n        :param tgn_server_type (str): The type of IXIA lab server to be used\n            e.g. 'windows', 'linux', 'windows_cm' (windows connection manager)\n        :param use server_ip same as spirent lib\n                server: Ixia REST Tcl server to connect to.\n                    if None, raise IxiaConfigException\n        :param port: HTTP port to connect to server on.\n                    Default is '11009'\n        :param debug_print: if True, enable debug print statements\n        :param Use time_factor same as spirent lib\n                    timer_scale_factor: multiplication factor for the methods using\n        :param session_name: session_name for linux API server\n        :param user_name: user_name for linux API server\n        :param topology : Testbed name from topology file\n        :param kwargs:\n                    sessionId : sessionId for linux and windows\n        :param verbose: verbose\n        \"\"\"\n        self.log = CafyLog('IXIA')\n        self.exception = CafyException()\n        self.tgn_server_type = tgn_server_type\n        if self.tgn_server_type == 'windows':\n            self.port = kwargs.get('port', 11009)\n        elif self.tgn_server_type == 'linux':\n            self.port = kwargs.get('port', 443)\n        self.tgn_server_user = kwargs.get('tgn_server_user', 'admin')\n        self.tgn_server_pw = kwargs.get('tgn_server_pw', 'admin')\n\n        self.topology_name = topology\n\n        self._lab_servers = []\n        if type(server_ip) in (list, tuple):\n            self._lab_servers = server_ip\n            self.server_ip = self._lab_servers[0].split(':')[0]\n            if ':' in self._lab_servers[0]:\n                self.port = self._lab_servers[0].split(':')[1]\n        elif ':' in server_ip:\n            self.port = server_ip.split(':')[1]\n            self.server_ip = server_ip.split(':')[0]\n        else:\n            self.server_ip = server_ip\n\n        if not user_name:\n            self.user_name = getpass.getuser()\n        else:\n            self.user_name = user_name\n\n        if not session_name:\n            self.session_name = \"testbed\" + '_' + self.user_name\n        else:\n            self.session_name = session_name.replace('-', '_')\n            self.session_name = ' - '.join((self.session_name, self.user_name))\n\n        self.pxe = list()\n        self.interfaces_info = kwargs.get('interfaces', [])\n        self.interfaces = dict()\n        self.interfaces_by_alias = dict()\n        self.interfaces_in_zap = dict()\n        self.links = dict()\n        self.power_cycle_info = list()\n\n        self.config_file = None\n        self.timer_scale_factor = time_factor  # default timer  of 1s\n        self.verbose = verbose\n        self.device_type = kwargs.get('type')\n        self.name = kwargs.get('name')\n        self.alias = kwargs.get('alias')\n        self.platform = kwargs.get('platform')\n        self.chassis_ip = kwargs.get('chassis_ip')\n        self.slave_chassis = kwargs.get('slave_chassis')\n        self.primary = kwargs.get('primary')\n        self.streamblockrds = {'ReturnedResultDataSet': None}\n        self.timeout = timeout\n        self.api_version = api_version\n        self.session_id = None\n        self.update_license = False\n        self.bgp_devices = {}\n        self.bgp_routes_startip_rid_v4 = {}\n        self.bgp_routes_startip_device_name_v4 = {}\n        self.bgp_routes_startip_port_name_v4 = {}\n        self.bgp_routes_startip_rid_v6 = {}\n        self.bgp_routes_startip_device_name_v6 = {}\n        self.bgp_routes_startip_port_name_v6 = {}\n        self.license_server = kwargs.get('license_server')\n        self.disable_diag_log = False\n        self.disable_trace_log = True\n\n    def get_license_server(self):\n        \"\"\"\n        Retrieve the license server for the IXIA TGEN device.\n        :return: License server for IXIA TGEN\n        \"\"\"\n        return self.license_server\n\n    def _new_session(self, user_name=None, session_name=None, kill_existing=False):\n        \"\"\"\n        API used internally\n\n        :param user_name: user name\n        :param session_name: session name for linux API server\n        :param kill_existing: kill existing session in Linux API Server\n        :return:\n        \"\"\"\n        if self.tgn_server_type == 'windows':\n            if isinstance(self._lab_servers, (list, tuple)) and len(self._lab_servers) > 1:\n                # Multiple servers: try each until one works\n                connected = False\n                for srv in self._lab_servers:\n                    try:\n                        ip_addr, port = (srv.split(':') + [self.port])[:2]\n                        self.server_ip, self.port = ip_addr, int(port)\n\n                        self.log.info(f\"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                        self.test_platform = TestPlatform(ip_address=self.server_ip,rest_port=self.port,platform='windows',\n                                                         log_file_name=CafyLog.work_dir + '/restpy.log')\n                        connected = True\n                        break\n                    except Exception as err:\n                        self.log.warning(f\"Failed to connect to {srv} ({err}). Trying next server...\")\n                        continue\n\n                if not connected:\n                    raise IxiaConfigException(f\"Could not connect to any Ixia server: {self._lab_servers}\")\n            else:\n                try:\n                    self.log.info(f\"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='windows',\n                                                     log_file_name=CafyLog.work_dir + '/restpy.log')\n                except:\n                    self.log.info('Waiting before reconnecting to IxN API server')\n                    time.sleep(100)\n                    self.log.info(f\"Reconnecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='windows',\n                                                     log_file_name=CafyLog.work_dir + '/restpy.log')\n\n            # Console output verbosity: None|request|'request response'\n            if not self.disable_trace_log:\n                self.test_platform.Trace = 'all'\n            self.session = self.test_platform.Sessions.add()\n            self.ixNetwork = self.session.Ixnetwork\n            if kill_existing:\n                self.ixNetwork.NewConfig()\n            self.session_id = 1\n            self.log.info(\"Ixia Lab Server - '%s'\" % (self.server_ip))\n\n        elif self.tgn_server_type == 'linux':\n            if isinstance(self._lab_servers, (list, tuple)) and len(self._lab_servers) > 1:\n                # Multiple servers: try each until one works\n                connected = False\n                for srv in self._lab_servers:\n                    try:\n                        ip_addr, port = (srv.split(':') + [self.port])[:2]\n                        self.server_ip, self.port = ip_addr, int(port)\n                        self.log.info(f\"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                        self.test_platform = TestPlatform(ip_address=self.server_ip,rest_port=self.port,platform='linux',\n                                                            log_file_name=CafyLog.work_dir + '/restpy.log')\n                        connected = True\n                        break\n                    except Exception as err:\n                        self.log.warning(f\"Failed to connect to {srv} ({err}). Trying next server...\")\n                        continue\n\n                if not connected:\n                    raise IxiaConfigException(f\"Could not connect to any Ixia server: {self._lab_servers}\")\n            else:\n                try:\n                    self.log.info(f\"Connecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='linux',\n                                                     log_file_name=CafyLog.work_dir + '/restpy.log')\n                except:\n                    self.log.info('Waiting before reconnecting to IxN API server')\n                    time.sleep(150)\n                    self.log.info(f\"Reconnecting to Ixia API server - '{self.server_ip}' and REST port - '{self.port}'\")\n                    self.test_platform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='linux',\n                                                     log_file_name=CafyLog.work_dir + '/restpy.log')\n\n            if not self.disable_trace_log:\n                self.test_platform.Trace = 'all'\n            self.test_platform.Authenticate(self.tgn_server_user, self.tgn_server_pw)\n\n            self.log.info(\"Ixia Lab Server - '%s'\" % (self.server_ip))\n            self.get_sessions()\n\n            if session_name and kill_existing == True:\n                for session in self.test_platform.Sessions.find(Name=session_name):\n                    session.remove()\n                    Helper.sleep(15, msg='Waiting for Session Deletion')\n                self.session = self.test_platform.Sessions.add(Name=session_name)\n                self.log.info(f\"Ixia Session Created - '{session_name}', Session ID - '{self.session.Id}'\")\n            elif session_name and kill_existing == False:\n                if not self.test_platform.Sessions.find(Name=session_name):\n                    raise IxiaConfigException(\"Session Name '%s' not configured or Failed to connect\" % session_name)\n                else:\n                    self.session = self.test_platform.Sessions.find(Name=session_name)\n            else:\n                if self.test_platform.Sessions.find(Name=self.session_name):\n                    self.session = self.test_platform.Sessions.find(Name=self.session_name)\n                    self.log.info(f\"Connecting to existing Ixia Session - '{self.session_name}', Session ID - '{self.session.Id}'\")\n                else:\n                    self.session = self.test_platform.Sessions.add(Name=self.session_name)\n                    self.log.info(f\"Ixia Session Created - '{session_name}', Session ID - '{self.session.Id}'\")\n            self.ixNetwork = self.session.Ixnetwork\n            self.session_name = self.session.Name\n\n        # RestPy main entry point object self.ixNetwork\n\n        self.ixNetworkSession = self.test_platform.Sessions\n\n    def get_remote(self, link):\n        \"\"\"\n        Get remote interface\n\n        :param link: link in topology. Ex: 'R1_R2_1'\n        :return: Remote interface of link in current device object\n\n        :Example: get_remote('R1_R2_1')\n        \"\"\"\n        int1 = link.interface1\n        int2 = link.interface2\n\n        if int1.device == self:\n            return int2\n        return int1\n\n    def get_local(self, link):\n        \"\"\"\n        Get local interface\n\n        :param link: link in topology. Ex: 'R1_R2_1'\n        :return: Local interface of link in current device object\n\n        :Example: get_local('R1_R2_1')\n        \"\"\"\n        int1 = link.interface1\n        int2 = link.interface2\n\n        if int1.device == self:\n            return int1\n        return int2\n\n    def get_links(self, peer=None, link_type=None):\n        \"\"\"\n        Returns links between IXIA and its peer\n\n        :param peer: Peer device object\n        :param link_type: Link type\n\n        :Example: get_links()\n        \"\"\"\n        if peer is None:\n            return self.links\n        links = {}\n        for _interface, int_obj in self.interfaces.items():\n            if int_obj.remote is not None and int_obj.remote.device.name == peer:\n                if link_type is None:\n                    links[int_obj.link.name] = int_obj.link\n                else:\n                    if int_obj.type == link_type:\n                        links[int_obj.link.name] = int_obj.link\n        return links\n\n    def get_list_ports(self):\n        \"\"\"\n        To get ports in config file\n\n        :return: list of ports in configuration\n\n        :Example: get_list_ports()\n        \"\"\"\n        self.log.info(\"Getting List of Ports\")\n        return self.ixNetwork.Vport.find()\n\n    def get_list_port_name(self):\n        \"\"\"\n        Get list of port names in config\n\n        :return: list of ports in user readable format in the session\n\n        :Example: get_list_port_name()\n        \"\"\"\n        self.log.info(\"vport name list\")\n        vport_name_list =[vport.Name for vport in self.ixNetwork.Vport.find()]\n        return vport_name_list\n\n    def new_blank_config(self):\n        \"\"\"\n        Upload a new blank config file before loading a new config file\n\n        :Example: new_blank_config()\n        \"\"\"\n        self.log.info(\"Creating new blank config\")\n        self.ixNetwork.NewConfig()\n\n    def get_traffic_items(self):\n        \"\"\"\n        Get trafficItem Names available in the config\n\n        :return: List of enabled traffic name.If failed, raise IxiaOperationException\n\n        :Example: get_traffic_items()\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info(\"Available traffic Items\")\n        try:\n            trafficItems = []\n            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                trafficItems.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find()])\n            if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():\n                trafficItems.append([quickFlow.Name for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find()])\n            return trafficItems[0]\n        except:\n            raise IxiaOperationException(\"No Traffic Items Found\")\n\n    def get_active_streams(self):\n        \"\"\"\n        Get list of enabled(active) streams in config\n\n        :return: list of active stream names in config\n\n        :Example: get_active_streams()\n        \"\"\"\n        self.log.info(\"Streams in Active State\")\n        trafficItems = []\n        try :\n            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                trafficItems = self.ixNetwork.Traffic.TrafficItem.find(Enabled=True)\n                return [trafficItem.Name for trafficItem in trafficItems if trafficItem]\n        except:\n            self.log.info(\"re-trying traffic config element\")\n            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                trafficItems = self.ixNetwork.Traffic.TrafficItem.find(Enabled=True)\n                return [trafficItem.Name for trafficItem in trafficItems if trafficItem]\n            elif self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():\n                if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True):\n                    trafficItems = self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True)\n                    return [trafficItem.Name for trafficItem in trafficItems if trafficItem]\n        if not trafficItems:\n            self.log.error(\"No Active Traffic Streams\")\n\n    def get_interface(self, alias=None, name=None):\n        \"\"\"\n        Gets a single interface object based on a name or alias\n\n        :param alias: Alias of interface\n        :param name:  Name of the interface\n        :return: Interface object\n\n        :Example: get_interface()\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return        \n        if name:\n            return self.interfaces[name]\n        return self.interfaces_by_alias[alias]\n\n    def get_interfaces(self, peer=None, int_type=None, zap_only=False, by_name=False, sub_interfaces=False):\n        \"\"\"\n        Gets a dict of interface objects based on a name or alias\n\n        :param peer: Per device object\n        :param int_type: Interface type\n        :param zap_only: True if you want only interfaces defined in zap\n        :param by_name: True if key needs to be interface name instead of alias in dictionary of interfaces returned\n        :param sub_interfaces: True if sub interfaces are to be included\n        :return: Dictionary of interfaces\n\n        :Example: get_interfaces()\n        \"\"\"\n        if zap_only:\n            interfaces = self.interfaces_in_zap\n        else:\n            interfaces = self.interfaces\n\n        new_interfaces = {}\n\n        if by_name:\n                intf_by_name = {}\n                for intf,intf_obj in interfaces.items():\n                    intf_by_name[intf_obj.name] = intf_obj\n                interfaces = intf_by_name\n\n        if int_type:\n            int_type = int_type.upper()\n            for intf, intf_obj in interfaces.items():\n                if intf_obj.type == int_type:\n                    new_interfaces[intf] = intf_obj\n            interfaces = new_interfaces\n\n        new_interfaces = {}\n\n        if peer:\n            for intf, intf_obj in interfaces.items():\n                if intf_obj.remote is not None and intf_obj.remote.device == peer:\n                    new_interfaces[intf_obj] = intf_obj.remote\n            interfaces = new_interfaces\n\n        for intf, intf_obj in interfaces.items():\n                if intf_obj.type == 'vlan':\n                    if sub_interfaces:\n                        new_interfaces[intf] = intf_obj\n                else:\n                     new_interfaces[intf] = intf_obj\n        interfaces = new_interfaces\n        return interfaces\n\n    def get_interfaces_by_name(self, peer=None, int_type=None, zap_only=False):\n        \"\"\"\n        get interface by name\n\n        :param peer: The name of the peer\n        :param int_type: The interface type\n        :param zap_only: Whether or not this interface is zap only\n\n        :Example: get_interfaces_by_name()\n        \"\"\"\n        new_interfaces = {}\n        if zap_only:\n            interfaces = self.interfaces_in_zap\n        else:\n            interfaces = self.interfaces\n        if peer:\n            for intf, intf_obj in interfaces.items():\n                if intf_obj.remote is not None and intf_obj.remote.device == peer:\n                    if int_type:\n                        int_type = int_type.upper()\n                        if intf_obj.type == int_type:\n                            new_interfaces[intf] = intf_obj.remote.name\n                    else:\n                        new_interfaces[intf] = intf_obj.remote.name\n            return list(new_interfaces.keys())\n        return list(interfaces.keys())\n\n    def connect_to_chassis(self, chassis_ip_list):\n        \"\"\"\n        Connect to IXIA Chassis\n\n        :param chassis_ip_list: list of chassis' IPs to which session has to connect\n        :return: True if successful\n\n        :Example: connect_to_chassis([\"10.39.60.120\"])\n        \"\"\"\n        self.log.info(\"Connection to the Chassis:%s\" % (chassis_ip_list))\n        timeout = 300\n        for chassisIp in chassis_ip_list:\n            self.ixNetwork.AvailableHardware.Chassis.add(Hostname=chassisIp)\n            for counter in range(1, timeout):\n                if self.ixNetwork.AvailableHardware.Chassis.find(Hostname=chassisIp).State == 'ready':\n                    self.log.info(f\"Connected to chassis -'{chassisIp}' successfully\")\n                    break\n                else:\n                    time.sleep(1)\n                if counter == 299:\n                    raise IxiaConfigException('Connect Chassis: Connecting to chassis {0} failed'.format(chassisIp))\n        return True\n\n    def _update_media_type(self):\n        \"\"\"\n        Internal function to update the ports media type to 'Fiber' for NOVUS10G Load Modules\n        :return:\n        \"\"\"\n        for vport in self.ixNetwork.Vport.find():\n            cardType = vport.Type\n            if cardType == 'novusTenGigLan':\n                cardType = cardType[0].upper() + cardType[1:]\n                cardObj = eval('vport.L1Config.' + cardType)\n                cardObj.Media = 'fiber'\n            if cardType == 'novusHundredGigLan':\n                cardType = cardType[0].upper() + cardType[1:]\n                cardObj = eval('vport.L1Config.' + cardType)\n                cardObj.IeeeL1Defaults = True\n\n    def _assign_ports(self, port_tuple, update_portname=False):\n        \"\"\"\n        Function used internally by other APIS,Assign Ports and Verify\n\n        :param port_tuple: [[chassisIP, card, port], [chassisIP, card, port],..]\n        :param update_portname: True/False\n        \"\"\"\n        forceTakePortOwnership = True\n        # Forcefully take port ownership if the portList are owned by other users.\n        testPorts = []\n        self.ixNetwork.Vport.find().UnassignPorts(arg2=False)\n        vportList = [vport.href for vport in self.ixNetwork.Vport.find()]\n        for port in port_tuple:\n            testPorts.append(dict(Arg1=port[0], Arg2=port[1], Arg3=port[2]))\n        self.ixNetwork.AssignPorts(testPorts, [], vportList, forceTakePortOwnership)\n        self._update_media_type()\n        if update_portname:\n            for portObj in self.ixNetwork.Vport.find():\n                assignedCard = portObj.AssignedTo.split(\":\")[1]\n                assignedPort = portObj.AssignedTo.split(\":\")[2]\n                portObj.Name = assignedCard + '/' + assignedPort\n\n    def _update_port_name(self):\n        \"\"\"\n        update the port name accordingly as connected to Chassis\n\n        :return:\n        \"\"\"\n        for vport in self.ixNetwork.Vport.find():\n            assignedCard = vport.AssignedTo.split(\":\")[1]\n            assignedPort = vport.AssignedTo.split(\":\")[2]\n            portName = vport.Name\n            if re.search(r'//(\\d+)/(\\d+)', portName):\n                existingCard = re.search(r'//(\\d+)/(\\d+)', portName).group(1)\n                existingPort = re.search(r'//(\\d+)/(\\d+)', portName).group(2)\n\n                existing = '//' + existingCard + '/' + existingPort\n                assigned = '//' + assignedCard + '/' + assignedPort\n                portName = portName.replace(existing, assigned)\n                vport.Name = portName\n\n    def load_config(self, config_file=None, port_tuple=None, debug_print=False, reserve_ports=True, **kwargs):\n        \"\"\"\n        API used to load existing config file with extension .ixncfg or .json\n\n        :param config_file: The full path including the saved config file\n        :param port_tuple: [chassisIP/card/port,chassisIP/card/port,...]\n        :param debug_print: Enables the debug - optional\n        :param reserve_ports: Reserve the mapped ports in the config - optional\n        :return: True if successful else raise Exception\n\n        :Example: load_config(config_file='ospf_bgp_ldp_config.ixncfg', port_tuple=[\"10.39.60.120/1/1\",\"10.39.60.120/1/2\"])\n        \"\"\"\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n        #     return\n\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n\n        if self.update_license == False:\n            self._new_session(self.user_name, self.session_name, kill_existing=True)\n        if config_file:\n            self.log.info(\"Loading config file {0}\".format(config_file))\n            self.ixNetwork.LoadConfig(Files(config_file, local_file=True))\n        else:\n            self.log.debug('No config file given, attaching to existing session')\n            self.new_blank_config()\n        self.ixNetwork.Traffic.UseRfc5952 = True\n        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True\n        if self.chassis_ip and ',' in self.chassis_ip:\n            chassis_to_be_connected = self.chassis_ip.split(',')\n            chassis_to_be_connected = [item.strip() for item in chassis_to_be_connected]\n            self.connect_to_chassis(chassis_to_be_connected)\n            self.chassis_ip = chassis_to_be_connected[0]\n        if port_tuple:\n            self.log.info('List of ports {0}'.format(port_tuple))\n            chassis_list = []\n            port_list = []\n            for port in port_tuple:\n                chassis_list_temp = port.split('/')\n                port_list_temp = port.split('/')\n                if len(chassis_list_temp) < 3 and self.chassis_ip:\n                    chassis_list.append(self.chassis_ip)\n                    port_list_temp.insert(0, self.chassis_ip)\n                else:\n                    chassis_list.append(port.split('/')[0])\n                port_list.append(port_list_temp)\n            chassis_list = list(set(chassis_list))\n            if self.primary:\n                self.connect_to_chassis([self.primary])\n            self.connect_to_chassis(chassis_list)\n            port_info_list = ['IsAvailable', 'IsBusy', 'IsLinkUp', 'IsUsable', 'Owner']\n            aresone_info_list = ['IsAvailable', 'IsConnected', 'IsMapped', 'AdminMode', 'ConnectionState']\n            port_name_list = self.get_list_ports()\n            if len(port_tuple) > len(port_name_list):\n                for _ in range(len(port_tuple) - len(port_name_list)):\n                    self.ixNetwork.Vport.add()\n                port_name_list = self.get_list_ports()\n            if len(port_name_list) > len(port_tuple):\n                raise IxiaConfigException(\n                    f\"Invalid port assignment, config has {len(port_name_list)} port but given \"\n                    f\"only {len(port_tuple)} port\")\n            self.ixNetwork.Vport.find().UnassignPorts(arg2=False)\n            share_info = True\n            session_assistant = SessionAssistant(IpAddress=self.server_ip, RestPort=self.port,\n                                                 UserName=self.tgn_server_user,\n                                                 Password=self.tgn_server_pw,\n                                                 SessionName=self.session_name, SessionId=None, ApiKey=None,\n                                                 ClearConfig=False,\n                                                 LogFilename='restpy.log')\n            port_map = session_assistant.PortMapAssistant()\n            for port in port_list:\n                vport_info_dict = {}\n                port_info_dict = {}\n                port_index = port_list.index(port)\n                port_name = ''.join([_ for _ in port_name_list[port_index].Name if _ not in '()[]$^?.*+'])\n                port_name_list[port_index].Name = port_name\n                chassis_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname=port[0])\n                if re.search(r'aresOne', chassis_obj.ChassisType, re.IGNORECASE):\n                    port_info_dict = {}\n                    if share_info:\n                        self.log.info(f'Assigning ports for {chassis_obj.ChassisType} chassis')\n                        share_info = False\n                    port_info_dict.update({port_tuple[port_index]: {}})\n                    for aresone_info in aresone_info_list:\n                        port_info_dict[port_tuple[port_index]].update(\n                            {aresone_info: getattr(port_name_list[port_index], aresone_info)})\n                    self.log.info(port_info_dict)\n                    try:\n                        location = f'{port[0]}/{port[1]}.{port[2]}'\n                        vport_info_dict[port_name] = port_map.Map(Location=location,\n                                                                  Name=port_name_list[port_index].Name)\n                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)\n                    except:\n                        location = f'{port[0]};{port[1]};{port[2]}'\n                        vport_info_dict[port_name] = port_map.Map(Location=location,\n                                                                  Name=port_name_list[port_index].Name)\n                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)\n                else:\n                    port_obj = chassis_obj.Card.find(\n                        CardId='^' + port[1] + '$').Port.find(PortId='^' + port[2] + '$')\n                    if port_obj:\n                        port_info_dict.update({'/'.join(port): {}})\n                        location = f'{port[0]};{port[1]};{port[2]}'\n                        for port_info in port_info_list:\n                            port_info_dict['/'.join(port)].update({port_info: eval('port_obj' + '.' + port_info)})\n                            \n                        # ---- NEW INFO ----\n                        extra_info = {}\n\n                        try:\n                            extra_info[\"Port Type\"] = port_obj.Description\n                        except:\n                            extra_info[\"Port Type\"] = \"N/A\"\n\n                        try:\n                            extra_info[\"Card\"] = chassis_obj.Card.find(\n                                CardId='^' + port[1] + '$').Description\n                        except:\n                            extra_info[\"Card Speed\"] = \"N/A\"\n\n                        try:\n                            extra_info[\"Chassis Version\"] = chassis_obj.ChassisVersion\n                        except:\n                            extra_info[\"Chassis Version\"] = \"N/A\"\n\n                        port_info_dict.update(extra_info)\n                        self.log.info(port_info_dict)\n                        vport_info_dict[port_name] = port_map.Map(Location=location, Name=port_name)\n                        port_map.Connect(ForceOwnership=True, IgnoreLinkUp=True)\n                    else:\n                        self.log.error(f'Port {port[1]}/{port[2]} not found in the chassis {port[0]}')\n            self._update_media_type()\n            self.log.info(\"Given ports are assigned and connected\")\n            if self.primary:\n                self.set_chassis_mode(primary=self.primary, secondary=chassis_list)\n            self._update_port_name()\n            # Check if existing session is active\n            if self.ixNetworkSession.find().Id == 0:\n                raise IxiaConfigException(\"Existing session inactive\")\n        # if config_file:\n        #     try:\n        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Start()\n        #         self.log.debug(\"Waiting for Ethernet to start completely\")\n        #         self._wait_for_protocol_action_complete(timeout=300,operation_name='Start Ethernet')\n        #     except:\n        #         pass\n        #     try:\n        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Start()\n        #         self.log.debug(\"Waiting for IPv4 to start completely\")\n        #         self._wait_for_protocol_action_complete(timeout=300, operation_name='Start IPv4')\n        #     except:\n        #         pass\n        #     try:\n        #         self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Start()\n        #         self.log.debug(\"Waiting for IPv6 to start completely\")\n        #         self._wait_for_protocol_action_complete(timeout=300, operation_name='Start IPv6')            \n        #     except:\n        #         pass\n\n        self.log.info(\"Loading config file complete\")\n        return True\n\n    def _perform(self, clear_value=None, **kwargs):\n        \"\"\"\n        Clears the traffic statistics on the chassis\n\n        :param clear_value: NA for IXIA\n        :return: True if success, false if error\n        \"\"\"\n\n        self.clear_traffic_stats()\n\n    def start_all_protocols(self, **kwargs):\n        \"\"\"\n        Start all the configured protocols in config file\n\n        :return: True if successful else Raise Exception\n\n        :Example: start_all_protocols()\n        \"\"\"\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n        #     return\n        # pdb.set_trace()\n        self.log.info(\"Starting all Protocols\")\n        # try: self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().SendNs()\n        # except: pass\n        self.ixNetwork.StartAllProtocols(Arg1='sync')\n        self._wait_for_protocol_action_complete(timeout=1000)\n        return True\n\n    def stop_all_protocols(self, **kwargs):\n        \"\"\"\n        Stop all the configured protocols in config file\n\n        :return: True if successful else Raise Exception\n\n        :Example: stop_all_protocols()\n        \"\"\"\n        self.log.info(\"Stopping all Protocols\")\n        self.ixNetwork.StopAllProtocols(Arg1='sync')\n        return True\n\n    def regenerate_traffic(self):\n        \"\"\"\n        Regenerate all traffic items\n\n        :return: True else Raise IxiaOperationException if failed\n\n        :Example: regenerate_traffic()\n        \"\"\"\n        try:\n            self.log.info('Regenerating Traffic Items')\n            if self.ixNetwork.Traffic.State == 'started':\n                pass\n            else:\n                trafficItem = self.ixNetwork.Traffic.TrafficItem.find()\n                trafficItem.Generate()\n        except:\n            raise IxiaOperationException(\"Failed to Re-Generate Traffic\")\n        return True\n\n    def get_license_details(self):\n        \"\"\"\n        Get the Chassis license details from global licensing settings\n\n        :return: License details\n\n        :Example: get_license_details()\n        \"\"\"\n\n        self.log.info(\"Current License Info: {}\".format(self.ixNetwork.Globals.Licensing))\n        return self.ixNetwork.Globals.Licensing\n\n    def update_license_server(self, server_ip=None, mode=None, tier=None, port='hw', **kwargs):\n        \"\"\"\n        Update the license server ip, mode, tier\n\n        :param server_ip: license server ip in list\n        :param mode: license mode: subscription, perpetual,aggregation or mixed.\n        :param tier: tier1, tier2, tier3, tier3-10g etc\n        :param port: Port mode like hardware(hw) or virtual\n        :param kwargs: optional arguments, new_session to create or connect to existing session\n\n        :Examples:\n        #tgnObj.update_license_server(server_ip=[\"10.36.237.189\"],port='virtual',mode='aggregation')\n        #tgnObj.update_license_server(server_ip=[\"10.36.237.189\"],port='hw',mode='subscription')\n        #tgnObj.update_license_server(server_ip=[\"10.36.237.189\"],port='virtual',mode='perpetual')\n        #tgnObj.update_license_server(server_ip=[\"10.36.237.189\"],mode='subscription')\n        #tgnObj.update_license_server(mode='subscription')\n        #update_license_server(server_ip=server_ip, port='virtual', mode='subscription', tier='tier2', new_session=False)\n        \"\"\"\n        kill = kwargs.get(\"new_session\", True)\n        self._new_session(self.user_name, self.session_name, kill_existing=kill)\n        if not kill:\n            ports = self.ixNetwork.Vport.find()\n            ports.ReleasePort()\n            Helper.sleep(5, msg='Waiting for ports to be released')\n        if server_ip:\n            self.log.info(f\"setting license info for server: {server_ip}\")\n            self.ixNetwork.Globals.Licensing.LicensingServers = server_ip\n        if port == 'hw':\n            if mode:\n                try:\n                    self.log.info(f\"setting hw license mode: {mode}\")\n                    self.ixNetwork.Globals.Licensing.HwMode = mode\n                except:\n                    self.log.error(\"HW Mode setting failed\")\n        elif port == 'virtual':\n            if mode:\n                try:\n                    self.log.info(f\"setting virtual license mode: {mode}\")\n                    self.ixNetwork.Globals.Licensing.VmMode = mode\n                except:\n                    self.log.error(\"Virtual Mode setting failed\")\n        else:\n            self.log.warning(\"Please select valid mode\")\n        if tier:\n            try:\n                self.log.info(f\"setting license tier: {tier}\")\n                self.ixNetwork.Globals.Licensing.Tier = tier\n            except:\n                self.log.error('License Tier Setting failed')\n        if not kill:\n            ports = self.ixNetwork.Vport.find()\n            ports.ConnectPorts(arg2=True)\n            Helper.sleep(5, msg='Waiting for ports to come up')\n        self.update_license = True\n\n    def _apply_traffic(self):\n        \"\"\"\n        API to apply the traffic\n        :return:\n        \"\"\"\n        self.ixNetwork.Traffic.Apply()\n        globals = self.ixNetwork.Globals\n        for apperrors in globals.AppErrors.find():\n            for error in apperrors.Error.find():\n                if hasattr(error, 'Description'):\n                    if \"One or more destination MACs or VPNs are invalid\" in error.Description:\n                        try:\n                            self.verify_arp()\n                        except Exception as err:\n                            self.log.info(f'{err}')\n                        try:\n                            self.verify_arp(ip_type='ipv6')\n                        except Exception as err:\n                            self.log.info(f'{err}')\n                        raise IxiaOperationException(\"Failed to apply traffic as packets are not generated properly\")\n                else:\n                    self.log.warning('No Errors: %s' % error)\n\n    def start_traffic(self, traffic_list=None, **kwargs):\n        \"\"\"\n        Starts traffic on streams on all Ports or selected Stream blocks\n\n        :param traffic_list: Traffic stream list names on which traffic will be started.\n                             If None traffic starts with streams that are already active in config\n        :param kwargs: Spirent specific optional argument\n                       start_object: Port or Stream\n                       ignore_errors : Default is False, send True if want to avoid errors\n                       duration : time duration in sec for traffic flow\n        :return: True on success\n\n        :Example: start_traffic()\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info('Starting traffic...')\n        timeout = 200\n        ignore_errors = kwargs.get(\"ignore_errors\",False)\n        quick_flow_group = kwargs.get(\"quick_flow_group\", False)\n        ignore_regenerate = kwargs.get(\"ignore_regenerate\", False)\n        start_only = kwargs.get(\"start_only\", False)\n        start_arp = kwargs.get(\"verify_arp\", True)\n        duration = kwargs.get(\"duration\", 0)\n\n        if start_arp:\n            self.start_arp()\n            Helper.sleep(5, msg='Waiting for Sending ARP/NS')\n        if not start_only:\n            if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:\n                self.stop_traffic()\n\n        if 'traffic_item_list' in kwargs:\n            traffic_list = kwargs['traffic_item_list']\n        start_object = kwargs.get('start_object', 'stream')\n        if start_object.lower() != 'port':\n            start_object = 'stream'\n\n        if not start_only:\n            for _ in range(1, timeout):\n                if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:\n                    time.sleep(1)\n                else:\n                    break\n\n        if not start_only:\n            if traffic_list:\n                if not quick_flow_group:\n                    self.enable_traffic_item(traffic_item_list=traffic_list)\n                if quick_flow_group:\n                    for traffic_stream in traffic_list:\n                        traffic_stream = traffic_stream.replace('+', r'\\+').replace('*', r'\\*').replace('(',r'\\(').replace(')',r'\\)')\n                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Name='^' + traffic_stream + '$').Enabled = True\n\n        if not ignore_regenerate:\n            self.log.info('Regenerate traffic items')\n            self.regenerate_traffic()\n\n        if not start_only:\n            for _ in range(1, timeout):\n                if self.ixNetwork.Traffic.State not in ['stopped','stoppedWaitingForStats','unapplied']:\n                    time.sleep(1)\n                else:\n                    break\n\n        if not start_only:\n            self.log.info('Apply all traffic items')\n            if ignore_errors:\n                self.ixNetwork.Traffic.Apply()\n            else:\n                self._apply_traffic()\n\n        if not start_only:\n            for _ in range(1, timeout):\n                if self.ixNetwork.Traffic.State not in ['stopped', 'stoppedWaitingForStats', 'unapplied']:\n                    time.sleep(1)\n                else:\n                    break\n\n        if start_object == 'port':\n            if 'port_list' in kwargs:\n                for name in kwargs['port_list']:\n                    self.ixNetwork.Vport.find(Name=name).StartStatelessTraffic()\n            else:\n                for vport in self.ixNetwork.Vport.find():\n                    try:\n                        vport.StartStatelessTraffic()\n                    except:\n                        pass\n        elif traffic_list:\n            self.log.info(f\"Traffic streams list:{traffic_list}\")\n            try:\n                for traffic_stream in traffic_list:\n                    each_traffic = re.escape(traffic_stream)\n                    try:\n                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').StartStatelessTraffic()\n                        self.log.info(f\"Traffic started for: {traffic_stream}\")\n                    except:\n                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(\n                            Name=f'^{each_traffic}$').StartStatelessTraffic()\n                        self.log.info(f\"Traffic started for: {traffic_stream}\")\n            except Exception as err:\n                raise IxiaConfigException(f\"Failed to start Traffic on traffic_stream due to : {err}\")\n        else:\n            try:\n                if quick_flow_group:\n                    self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find().StartStatelessTraffic()\n                    self.log.info(\"Starting Traffic on all Enabled Quick Flow Groups\")\n                else:\n                    self.ixNetwork.Traffic.Start()\n                    self.log.info(\"Starting Traffic on all Enabled Traffic Items\")\n            except Exception as err:\n                raise IxiaConfigException(f\"Failed to start Traffic on traffic_stream due to : {err}\")\n\n        for _ in range(1, timeout):\n            if self.ixNetwork.Traffic.State == 'started':\n                self.log.info('Traffic started')\n                break\n            else:\n                time.sleep(1)\n        if duration != 0:\n            self.log.info(f'Traffic will run for {duration} seconds...')\n            time.sleep(duration)\n        return True\n\n    def stop_traffic(self,traffic_list=None,**kwargs):\n        \"\"\"\n        To Stop traffic\n\n        :param traffic_list: Traffic stream list names on which traffic will be stopped.\n                     If None traffic stops with streams that are already active in config\n        :return: True if successful else Raise Exception\n\n        :Example: stop_traffic()\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        timeout = 60\n        sleep_time = kwargs.get('sleep_time', 5)\n\n        if 'traffic_item_list' in kwargs:\n            traffic_list = kwargs['traffic_item_list']\n        if traffic_list:\n            self.log.info('Stopping traffic...')\n            try:\n                for traffic_stream in traffic_list:\n                    each_traffic = re.escape(traffic_stream)\n                    try:\n                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').StopStatelessTraffic()\n                        self.log.info(f\"Stopping Traffic stream : {traffic_stream}\")\n                    except:\n                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(\n                            Name=f'^{each_traffic}$').StopStatelessTraffic()\n                        self.log.info(f\"Stopping Traffic stream: {traffic_stream}\")\n            except Exception as err:\n                self.log.error(f'Traffic Stop For Stream: {each_traffic}, Failed with Exception: {err}')\n                raise IxiaOperationException(\"Failed to stop Traffic\")\n        else:\n            self.log.info('Stopping Traffic on All Traffic Items')\n            try:\n                self.ixNetwork.Traffic.Stop()\n            except Exception as err:\n                self.log.info(f'Traffic Stop Failed with Exception: {err}')\n                self.log.info(f'Traffic State: {self.ixNetwork.Traffic.State}')\n                self.log.warning(\"Traffic Stop retrying......\")\n                try:\n                    Helper.sleep(sleep_time, msg='Waiting before Stopping the traffic')\n                    self.ixNetwork.Traffic.Stop()\n                except Exception as err:\n                    self.log.error(f'Traffic Stop Retry Failed with Exception: {err}')\n                    self.log.info(f'Traffic State: {self.ixNetwork.Traffic.State}')\n                    raise IxiaOperationException(\"Failed to stop Traffic\")\n        self.log.info(f'Waiting for {sleep_time} seconds for traffic to fully stop...')\n        time.sleep(sleep_time)\n        for _ in range(1, timeout):\n            if self.ixNetwork.Traffic.State == 'stopped':\n                self.log.info(\"Traffic Stopped Successfully\")\n                break\n            else:\n                time.sleep(1)\n        return True\n\n    def check_traffic_state(self, expected='stopped', **kwargs):\n        \"\"\"\n        Check the traffic current state.\n        This is best used before getting stats when you want to assure\n        that the traffic is completely stopped to get accurate stats\n        Traffic states are:\n        startedWaitingForStats, startedWaitingForStreams, started, stopped,\n        stoppedWaitingForStats, txStopWatchExpected, locked, unapplied\n\n        :param expected: expected traffic state\n        :param kwargs: Optional\n        :return: True if state is same as expected value, False otherwise\n\n        :Example: check_traffic_state(expected='stopped')\n                check_traffic_state(expected='started')\n        \"\"\"\n        if self.ixNetwork.Traffic.State == \"unapplied\":\n            trafficState = \"stopped\"\n        else:\n            trafficState = self.ixNetwork.Traffic.State\n        self.log.info(trafficState)\n        if trafficState.lower() != expected.lower():\n            return False\n        else:\n            return True\n\n    def _portname_location_mapping(self):\n        \"\"\"\n        Internal API used by get_stats to map portname with location\n\n        :return:\n        \"\"\"\n        portnameLocationDict = {}\n        for vport in self.ixNetwork.Vport.find():\n            try:\n                assignedChassis = vport.AssignedTo.split(\":\")[0]\n                assignedCard = vport.AssignedTo.split(\":\")[1]\n                assignedPort = vport.AssignedTo.split(\":\")[2]\n                portnameLocationDict[vport.Name] = \"//\"+assignedChassis+\"/\"+assignedCard+\"/\"+assignedPort\n            except:\n                pass\n\n        return portnameLocationDict\n\n    def _change_to_int(self,value):\n        \"\"\"\n        internal API used by get_stats to change type\n        :param value: value whose datatype to be updated\n        :return:\n        \"\"\"\n        if value in ('' , ' ' , 'N/A'):\n            value = 0\n        elif (value != '' or value != ' ') and value != 'N/A':\n            value = int(float(value))\n        return value\n\n    def get_stats(self, csv_file=None, csv_enable_file_timestamp=False,\n                  view_name='Flow Statistics'):\n        \"\"\"\n        Get flow statistics and save it in a csv file\n\n        :param csv_file: None or <filename.csv>.\n               None will not create a CSV file.\n               Provide a <filename>.csv to record all stats to a CSV file.\n               Example: getStats(csv_file='Flow_Statistics.csv')\n        :param csv_enable_file_timestamp: True or False. If True, timestamp\n                will be appended to the filename.\n        :param view_name: view_name options (case sensitive):\n                \"Port Statistics\",\n                \"Tx-Rx Frame Rate Statistics\",\n                \"Port CPU Statistics\",\n                \"Global Protocol Statistics\",\n                \"Protocols Summary\",\n                \"Port Summary\",\n                \"OSPFv2-RTR Drill Down\",\n                \"OSPFv2-RTR Per Port\",\n                \"IPv4 Drill Down\",\n                \"L2-L3 Test Summary Statistics\",\n                \"Flow Statistics\",\n                \"Traffic Item Statistics\", \\n\n                Note: Not all of the view_names are listed here. You have to get the\n                exact names from the IxNetwork GUI in statistics based on your\n                protocol(s)\n        :return:  A dictionary of all the stats: stat_dict[rowNumber][columnName]== stat_value\n\n        :Example: get_stats() \\n\n                  get_stats(csv_file=None, csv_enable_file_timestamp=False,view_name='Port CPU Statistics') \\n\n                  get_stats(csv_file=\"TrafficItemStatistics.csv\", csv_enable_file_timestamp=False,view_name='Traffic Item Statistics')\n        \"\"\"\n        self.log.info('\\ngetStats: %s' % (view_name))\n        if csv_file:\n            try:\n                statsSummary = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)\n            except:\n                raise IxiaStatsException('getStats: Failed to get stats values')\n\n            csv_filename = csv_file.replace(' ', '_')\n            if csv_enable_file_timestamp:\n                timestamp = datetime.datetime.now().strftime('%H%M%S')\n                if '.' in csv_filename:\n                    csv_filename_temp = csv_filename.split('.')[0]\n                    csv_filename_extension = csv_filename.split('.')[1]\n                    csv_filename = csv_filename_temp + '_' + timestamp + '.' + \\\n                                   csv_filename_extension\n                else:\n                    csv_filename = csv_filename + '_' + timestamp\n\n            csv_file = open(csv_filename, 'w')\n            csv_write_obj = csv.writer(csv_file)\n            # Get the stat column names\n            columnCaptions = statsSummary.ColumnHeaders\n            if csv_file != None:\n                csv_write_obj.writerow(columnCaptions)\n                for rowNumber, stat in enumerate(statsSummary.Rows):\n                    rowStats = stat.RawData\n                for row in rowStats:\n                    csv_write_obj.writerow(row)\n            return statsSummary, csv_file.name\n        else:\n            portNameLocationMapping = self._portname_location_mapping()\n            try:\n                TrafficItemStats = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)\n            except:\n                Helper.sleep(10, msg=f'Retrying Traffic stats for - {view_name}')\n                TrafficItemStats = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)\n            column_list = TrafficItemStats.ColumnHeaders\n\n            sequence_check = False\n            if self.ixNetwork.Traffic.Statistics.SequenceChecking.Enabled:\n                sequence_check = True\n\n            # columns to be deleted from ColumnHeader\n            if 'Gap' in column_list:\n                column_list.remove('Gap')\n\n            traffic_rows = TrafficItemStats.Rows\n            try:\n                flow_stats = pd.DataFrame(traffic_rows.RawData, columns=traffic_rows.Columns)\n            except:\n                self.log.info('printing stats first row')\n                self.log.info(traffic_rows.RawData[0])\n                self.log.info('printing column names')\n                self.log.info(traffic_rows.Columns)\n                raise IxiaOperationException(\"data and columns length doesn't match Exiting !!\")\n\n            if 'Packet Loss Duration (ms)' in flow_stats:\n                flow_stats['Packet Loss Duration (ms)'] = flow_stats['Packet Loss Duration (ms)'].apply(\n                    self._change_to_int)\n            if 'Tx Frames' in flow_stats and 'Frames Tx.' not in flow_stats:\n                flow_stats['Tx Frames'] = flow_stats['Tx Frames'].apply(self._change_to_int)\n            elif 'Tx Frames' not in flow_stats and 'Frames Tx.' in flow_stats:\n                flow_stats['Tx Frames'] = flow_stats['Frames Tx.'].apply(self._change_to_int)\n\n            if 'Rx Frames' in flow_stats and 'Valid Frames Rx.' not in flow_stats:\n                flow_stats['Rx Frames'] = flow_stats['Rx Frames'].apply(self._change_to_int)\n            elif 'Rx Frames' not in flow_stats and 'Valid Frames Rx.' in flow_stats:\n                flow_stats['Rx Frames'] = flow_stats['Valid Frames Rx.'].apply(self._change_to_int)\n\n            if 'Tx Rate (Bps)' in flow_stats:\n                flow_stats['Tx Rate (Bps)'] = flow_stats['Tx Rate (Bps)'].apply(self._change_to_int)\n            if 'Rx Rate (Bps)' in flow_stats:\n                flow_stats['Rx Rate (Bps)'] = flow_stats['Rx Rate (Bps)'].apply(self._change_to_int)\n\n            if 'Tx Rate (bps)' in flow_stats and not 'Tx. Rate (bps)' in flow_stats:\n                flow_stats['Tx Rate (bps)'] = flow_stats['Tx Rate (bps)'].apply(self._change_to_int)\n            if not 'Tx Rate (bps)' in flow_stats and 'Tx. Rate (bps)' in flow_stats:\n                flow_stats['Tx Rate (bps)'] = flow_stats['Tx. Rate (bps)'].apply(self._change_to_int)\n\n            if 'Rx Rate (bps)' in flow_stats and not 'Rx. Rate (bps)' in flow_stats:\n                flow_stats['Rx Rate (bps)'] = flow_stats['Rx Rate (bps)'].apply(self._change_to_int)\n            if not 'Rx Rate (bps)' in flow_stats and 'Rx. Rate (bps)' in flow_stats:\n                flow_stats['Rx Rate (bps)'] = flow_stats['Rx. Rate (bps)'].apply(self._change_to_int)\n\n            if 'Rx L1 Rate (bps)' in flow_stats:\n                flow_stats['Rx L1 Rate (bps)'] = flow_stats['Rx L1 Rate (bps)'].apply(self._change_to_int)\n            if 'Tx L1 Rate (bps)' in flow_stats:\n                flow_stats['Tx L1 Rate (bps)'] = flow_stats['Tx L1 Rate (bps)'].apply(self._change_to_int)\n\n            if 'Loss %' in flow_stats:\n                flow_stats['Loss %'] = np.where(flow_stats['Loss %'] == '', '0.00', flow_stats['Loss %'])\n\n            if 'Tx Port' in flow_stats:\n                flow_stats['Tx Port Location'] = [portNameLocationMapping[port] if 'Multiple Tx ports' not in port else ''\n                                                    for port in flow_stats['Tx Port'].to_list()]\n            if 'Rx Port' in flow_stats:\n                flow_stats['Rx Port Location'] = [portNameLocationMapping[port] if 'Multiple Rx ports' not in port else ''\n                                                    for port in flow_stats['Rx Port'].to_list()]\n\n            if 'IPv4 :Source Address' in flow_stats:\n                flow_stats['IP :Source Address'] = flow_stats['IPv4 :Source Address']\n            if 'IPv4 :Destination Address' in flow_stats:\n                flow_stats['IP :Destination Address'] = flow_stats['IPv4 :Destination Address']\n            if 'IPv6 :Source Address' in flow_stats:\n                flow_stats['IP :Source Address'] = flow_stats['IPv6 :Source Address']\n            if 'IPv6 :Destination Address' in flow_stats:\n                flow_stats['IP :Destination Address'] = flow_stats['IPv6 :Destination Address']\n\n            if sequence_check:\n                if 'Small Error' in flow_stats:\n                    flow_stats['Small Error'] = flow_stats['Small Error'].apply(self._change_to_int)\n                if 'Big Error' in flow_stats:\n                    flow_stats['Big Error'] = flow_stats['Big Error'].apply(self._change_to_int)\n                if 'Reverse Error' in flow_stats:\n                    flow_stats['Reverse Error'] = flow_stats['Reverse Error'].apply(self._change_to_int)\n\n                if 'Small Error' in flow_stats and 'Big Error' in flow_stats and \\\n                        'Reverse Error' in flow_stats:\n                    flow_stats['ReorderedFrameCount'] = flow_stats['Small Error'] + flow_stats['Big Error'] + \\\n                                                        flow_stats['Reverse Error']\n                    flow_stats['ReorderedFrameCount'] = flow_stats['ReorderedFrameCount'].apply(self._change_to_int)\n\n                    flow_stats['InOrderFrameCount'] = flow_stats['Rx Frames'] - flow_stats['ReorderedFrameCount']\n                    flow_stats['InOrderFrameCount'] = flow_stats['InOrderFrameCount'].apply(self._change_to_int)\n\n                    flow_stats['OutSeqFrameCount'] = flow_stats['ReorderedFrameCount']\n        flow_stats.index = np.arange(1, len(flow_stats) + 1)\n        return flow_stats.to_dict('index')\n\n    def _traffic_verify(self, RxFrames, TxFrames, FrameDelta, Loss):\n        \"\"\"\n        Function used internally by API verify_traffic\n\n        :param RxFrames: Received Frames\n        :param TxFrames: Transmitted Frames\n        :param FrameDelta: User Passed FrameDelta Value\n        :param Loss: Traffic Loss\n        \"\"\"\n        if self.expected != None and self.expected_mode == 'percent':\n            self.verify_mode = 'Expected Percent'\n            actualRate = 100.0 * RxFrames / TxFrames\n            expectMax = float(self.expected) + float(self.tolerance)\n            expectMin = float(self.expected) - float(self.tolerance)\n            if expectMin < 0:\n                expectMin = 0\n            if actualRate > expectMax or actualRate < expectMin:\n                verifyResults = False\n            else:\n                verifyResults = True\n        elif self.expected and self.expected_mode == 'frame':\n            self.verify_mode = 'Expected Frame'\n            expectMax = TxFrames + int(self.tolerance)\n            expectMin = TxFrames - int(self.tolerance)\n            if int(RxFrames) > expectMax or int(RxFrames) < expectMin:\n                verifyResults = False\n            else:\n                verifyResults = True\n        elif self.tolerance_mode == 'percent':\n            self.verify_mode = 'Loss Percent'\n            if Loss.isdigit():\n                actualRate = float(0)\n            else:\n                actualRate = float(Loss)\n            if actualRate > float(self.tolerance):\n                verifyResults = False\n            else:\n                verifyResults = True\n        else:\n            self.verify_mode = 'Loss Frame'\n            expectMax = int(self.tolerance)\n            actualRate = int(FrameDelta)\n            if actualRate > expectMax:\n                verifyResults = False\n            else:\n                verifyResults = True\n\n        return verifyResults\n\n    def _mode_flow_stats(self, port, flowStats, modeValue, flowStatHeaderValues, flowStatHeader, flowStatResults):\n        \"\"\"\n        Function used internally by API verify_traffic\n\n        :param port: port passed by user\n        :param flowStats: Flow Statistics from csv file\n        :param modeValue: Mode Value\n        :param flowStatHeaderValues: Flow Statistics Header Values from csv file\n        :param flowStatHeader: Flow Statistics Header\n        :param flowStatResults: Flow Statistics Results\n        \"\"\"\n        for rowNumber, flowStat in enumerate(flowStats.Rows):\n            if flowStat[modeValue].lower() == port.lower():\n                # flowStatHeaderValues.append([flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'],flowStat['Store-Forward Avg Latency (ns)'], flowStat['Frames Delta'], flowStat['Loss %']])\n                flowStatHeaderValues.append(\n                    [flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'], flowStat['Frames Delta'],\n                     flowStat['Loss %']])\n                RxFrames = flowStat['Rx Frames']\n                TxFrames = flowStat['Tx Frames']\n                FrameDelta = flowStat['Frames Delta']\n                Loss = flowStat['Loss %']\n                flowStatResults.append(self._traffic_verify(RxFrames, TxFrames, FrameDelta, Loss))\n        flowStatTable = tabulate.tabulate(flowStatHeaderValues, headers=flowStatHeader, tablefmt='rst')\n        self.log.info('Flow Stats for Port: %s',port)\n        self.log.info(flowStatTable)\n\n    def verify_traffic(self,\n                       traffic_items=None,\n                       mode='trafficItem',\n                       ports=None,\n                       debug=True,\n                       tolerance_mode='percent',\n                       tolerance=0,\n                       expected_mode='percent',\n                       expected=None,\n                       verify_mode='tx_rx',\n                       **kwargs):\n        \"\"\"\n        API used to verify traffic\n\n        :param traffic_items: CHOICES Nested dictionary for Traffic Item, tolerance and expect_loss.\n                            Default value : {'all_traffic_items':True}\n                            OR list of traffic items. Ex: ['traffic item1', 'traffic item2']\n        :param mode: CHOICES 'trafficItem', 'rx_port', 'tx_port' Default is 'trafficItem'\n        :param ports: A list of ports to verify against\n        :param debug: CHOICES None, True (Default)\n                    Debug value None is for traffic item or port level verification\n                    Debug value is True, verify traffic loss in flow level, when\n                    when traffic loss is seen in traffic item or port level, which defined in configuration for flow tracking\n        :param tolerance_mode: CHOICES percent, frame. Default is percent\n        :param tolerance: CHOICES 0, integer/float. Default is 0\n        :param expected_mode: CHOICES percent, frame. Default is percent\n        :param expected: CHOICES None, integer/float. Default is None\n        :param verify_mode: The verify mode (Spirent only)\n        :param kwargs: verify_mode, return_fromat, flow_per_stream\n        :return: When no traffic loss,and None for debug option, return stats dictionary of STREAMBLOCK level\n                When traffic loss or unexpected traffic, and None for debug option, raise Exception\n                with stats dictionary of STREAMBLOCK level\n                When traffic loss or unexpected traffic, and debug option is not None, raise Exception\n                with 2 stats dictionary. First one is for STREAMBLOCK level and second one is for STREAM level\n\n        :Example: verify_traffic() \\n\n                  verify_traffic(tolerance=10)\n        \"\"\"\n        # hash_key_value = StubitUtil.stubit_sha256_hash_generator(self.verify_traffic.__name__,traffic_items)\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(\"Playing traffic in stubit mode\")\n        #     return_data = StubitUtil.stubit_play(hash_key_value)\n        #     if return_data:\n        #         return_data = json.loads(return_data)\n        #     return return_data\n\n        traffic_dump = kwargs.get('traffic_dump',False)\n        self.log.info(\"Traffic Verification Started\")\n        if 'tolerance_frame' in kwargs.keys():\n            tolerance_mode = 'frame'\n            tolerance = kwargs['tolerance_frame']\n        elif 'tolerance_percent' in kwargs.keys():\n            tolerance = kwargs['tolerance_percent']\n        if traffic_items is None:\n            traffic_items = {'all_traffic_items': True}\n        elif isinstance(traffic_items, list):\n            _tmp = {'all_traffic_items': False}\n            for one_item in traffic_items:\n                _tmp[one_item] = {}\n            traffic_items = _tmp\n        elif isinstance(traffic_items, dict):\n            traffic_items['all_traffic_items'] = False\n\n        # check if traffic items passed are present in config\n        active_streams = self.get_active_streams()\n        traffic_items_to_verify = list(traffic_items)\n        if 'all_traffic_items' in traffic_items_to_verify:\n            traffic_items_to_verify.remove('all_traffic_items')\n        streams_not_in_config = []\n        for traffic_item in traffic_items_to_verify:\n            if traffic_item not in active_streams:\n                streams_not_in_config.append(traffic_item)\n        if streams_not_in_config:\n            err_msg = 'Streams %s are not in config' % streams_not_in_config\n            raise CafyException.InvalidValueError(err_msg)\n\n        if traffic_items_to_verify == []:\n            traffic_items_to_verify = active_streams\n        if ports is None:\n            ports = {'all_ports': True}\n        item_stats = self.get_stats(view_name='Traffic Item Statistics')\n        if mode == 'trafficItem' and debug == None:\n            flow_stats = None\n        else:\n            flow_stats = self.get_stats()\n\n        stats_objs = TrafficStats(debug=debug,\n                                  item_stats=item_stats,\n                                  flow_stats=flow_stats,\n                                  tolerance_mode=tolerance_mode,\n                                  tolerance=tolerance,\n                                  expected=expected,\n                                  expected_mode=expected_mode,\n                                  **kwargs)\n\n        if mode == 'trafficItem':\n            stats_objs.drilldown(traffic_items=traffic_items)\n        elif mode == 'rx_port' or mode == 'tx_port':\n            stats_objs.port_drilldown(ports=ports,\n                                      mode=mode,\n                                      traffic_items=traffic_items)\n        else:\n            tmp_msg = \"mode:%s not supported\" % mode\n            return tmp_msg\n\n        item_tb = stats_objs.report(objs=stats_objs.item_objs,\n                                    **kwargs)\n        if debug:\n            flow_tb = stats_objs.report(objs=stats_objs.flow_sorted_objs,\n                                        **kwargs)\n        if not stats_objs.verify_results:\n            self.log.error('Traffic Item:\\n' + item_tb)\n            if debug:\n                self.log.error('Flow:\\n' + flow_tb)\n            time.sleep(10)\n            stats_dict = {}\n            i = 1\n            for obj in stats_objs.item_objs:\n                stats_dict[i] = (obj.traffic_stats)\n                i += 1\n            max_flows = 10\n            if flow_stats and len(flow_stats) > max_flows:\n                self.log.debug(f\"Flow stats has {len(flow_stats)} entries, limiting to first {max_flows} to avoid flooding logs\")\n                flow_stats_limited = dict(list(flow_stats.items())[:max_flows])\n            else:\n                flow_stats_limited = flow_stats\n            if kwargs.get('full_logs', None):\n                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()}\n                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats, flow_stats_limited])\n            else:\n                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()\n                                         if stats_dict[key]['Status'] == \"fail\"}\n                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats])\n            exception.item_stats = stats_objs.item_stats\n            exception.flow_stats = flow_stats_limited\n            # self._get_protocol_stats()\n            self._get_port_stats()\n            if traffic_dump:\n                raise Exception(\"Traffic Verification Failed\")\n            else:\n                raise exception\n\n        self.log.info('Traffic Item:\\n' + item_tb)\n        if debug:\n            self.log.info('Flow:\\n' + flow_tb)\n            for item in stats_objs.item_stats.values():\n                if 'Traffic Item' in item:\n                    if item['Traffic Item'] in traffic_items_to_verify:\n                        if item['Tx Frames'] == 0:\n                            msg = f\"Tx frames of 0 found for traffic item {item['Traffic Item']}: A problem has occurred\\n\\\n                                   Item Stats: {stats_objs.item_stats}\\nFlow Stats: {next(iter(flow_stats.values()),{})}\"\n                            raise IxiaOperationException(msg)\n                else:\n                    if item['Tx Frames'] == 0:\n                        msg = f\"Tx frames of 0 found for traffic item {item['Rx Port']}: A problem has occurred\\n\\\n                                                           Item Stats: {stats_objs.item_stats}\"\n                        raise IxiaOperationException(msg)\n\n        # record the data\n        # if StubitUtil.is_stubit_record():\n        #     log.info(\"Recording traffic in stubit mode\")\n        #     return_value = json.dumps((stats_objs.item_stats, flow_stats))\n        #     StubitUtil.stubit_record(hash_key_value,return_value)\n\n        self.log.info(\"Traffic Verified Successfully\")\n        return stats_objs.item_stats, flow_stats\n\n    def get_convergence_time(self,\n                             traffic_control=False,\n                             traffic_duration=None,\n                             return_by='Traffic Item',\n                             traffic_items=None,\n                             tolerance=0.01,\n                             retry_count=1,\n                             report_mode='streams',\n                             print_flows=True,\n                             verify_mode='tx_rx',\n                             **kwargs):\n        \"\"\"\n        Calculates when the last flow converges in the traffic item and returns the convergence time in sec\n        IXIA flow tracking is needed for traffic stats view\n\n        :param traffic_control: optional, default set to False. Make sure the traffic is stopped before calling traffic_control\n        :param traffic_duration: must have when traffic_control is set to True\n        :param return_by: return convergence time by 'Traffic Item' or 'Source/Dest Port Pair', defaut set to 'Traffic Item'\n                raise exceptions when return_by type is not existed in keys of flow.\n        :param traffic_items: Traffic Item level stats view, if None is given, all the traffic item will be returned\n        :param tolerance: Tolerance percentage for tx and rx rate comparison as rx rate might be a little less than tx\n        :param retry_count: number of times to retry\n        :param report_mode: (str) Determines the report output type e.g. 'streams', 'flows'\n        :param print_flows: Print convergence times for each flow if True\n        :param verify_mode: (str) Can be either tx_rx or dropped_frames\n        :return: convergence time in ms (milli sec) and last convergence flow for each/given traffic_items.\n                If None is returned by convergence time, the flow/traffic item is not converged yet with Loss % 100% loss\n\n        :Example: get_convergence_time() \\n\n                  get_convergence_time(traffic_items=[\"Traffic Item 1\", \"Traffic Item 2\"])\n        \"\"\"\n\n        # updated as requested by Olivia(oliviaj@cisco.com)\n\n        self.log.info(\"Calculating Convergence Time\")\n        if not traffic_items:\n            traffic_items = {'all_traffic_items': True}\n        elif isinstance(traffic_items, list):\n            _tmp = {'all_traffic_items': False}\n            for one_item in traffic_items:\n                _tmp[one_item] = {}\n            traffic_items = _tmp\n\n        if not isinstance(return_by, str):\n            msg = \"Only take str for return_by. %s is %s\" % (return_by, type(return_by))\n            raise TypeError(msg)\n\n        if not isinstance(retry_count, int) or retry_count < 0:\n            msg = \"Retry count should be int and >=0. %s is %s\" % (retry_count, type(retry_count))\n            raise TypeError(msg)\n\n        trials = retry_count\n        while (trials != 0):\n            itemDict = {}\n            if traffic_control:\n                self.start_traffic()\n                if traffic_duration:\n                    time.sleep(int(traffic_duration))\n                else:\n                    msg = 'Cannot control traffic start/stop without duration'\n                    self.log.error(msg)\n                    raise IxiaOperationException(msg)\n                self.stop_traffic()\n            if report_mode == 'streams':\n                flowStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics', LocalCsvStorage=CafyLog.work_dir)\n            else:\n                flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)\n            convergence = True\n            flowHeadersList = flowStats.ColumnHeaders\n            flowStatHeaderValues = []\n\n            for rowNumber, stat in enumerate(flowStats.Rows):\n                headerDict = {}\n                for column in flowHeadersList:\n                    headerDict[column] = stat[column]\n\n                    # try:\n                    #     headerDict[column] = stat[column]\n                    # except (IndexError, KeyError):\n                    #     headerDict[column] = None\n                flowStatHeaderValues.append(headerDict)\n\n            # pdb.set_trace()\n            for flowDict in flowStatHeaderValues:\n                if flowDict[return_by]:\n                    item = flowDict[return_by]\n                else:\n                    msg = 'The return_by %s is not support in IXIA flow' % return_by\n                    self.log.error(msg)\n                    raise IxiaOperationException(msg)\n                if return_by in 'Traffic Item' and not traffic_items['all_traffic_items']:\n                    if item not in traffic_items:\n                        continue\n                itemDict.setdefault(item, []).append(flowStatHeaderValues.index(flowDict))\n\n            for item, flow in itemDict.items():\n                flowItemDict = {}\n                for one_flow in flow:\n                    flowValues = flowStatHeaderValues[one_flow]\n                    firstTime = flowValues['First TimeStamp']\n                    lastTime = flowValues['Last TimeStamp']\n                    convergenceTime = float(flowValues['Packet Loss Duration (ms)'])\n                    txFrames = int(float(flowValues['Tx Frames']))\n                    rxFrames = int(float(flowValues['Rx Frames']))\n                    rateDelta = txFrames - rxFrames\n                    try:\n                        loss = float('%.3f' % float(100 * rateDelta / txFrames))\n                    except:\n                        loss = float(0)\n                    flowValues[\"Convergence Time\"] = convergenceTime\n                    flowValues[\"Loss %\"] = loss\n\n                    if not firstTime or not lastTime:\n                        convergenceTime, convergence = None, False\n                        self.log.error('\"%s\" Did NOT converge. Check if traffic is running.' % (item))\n                    else:\n                        if report_mode == 'streams':\n                            self.log.info('\"%s\" Converges after %f ms' % (item, convergenceTime))\n                        elif print_flows:\n                            self.log.info('\"Flow-%s\" Converges after %f ms' % (one_flow+1, convergenceTime))\n                    if report_mode == 'streams':\n                        itemDict[item] = flowValues\n                    else:\n                        flowItemDict.update({\"Flow-\" + str(one_flow+1): flowValues})\n                        itemDict[item] = flowItemDict\n\n            if convergence:\n                break\n            trials -= 1\n        self.clear_traffic_stats()\n        return itemDict\n\n    def disable_traffic_item(self, traffic_item_list=None):\n        \"\"\"\n        Disable the given traffic items in the list, if no traffic\n        items provided, then disable all traffic items instead.\n\n        :param traffic_item_list: (list) list of traffic items to be disabled. if None, disable all\n        :return: True if successful else raise exception\n\n        :Example: disable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info(\"Disabling Traffic Item/Items\")\n        if traffic_item_list:\n            self.log.info(f'Disabling the traffic items - {traffic_item_list}')\n            if isinstance(traffic_item_list, list):\n                try:\n                    for each_traffic in traffic_item_list:\n                        each_traffic = re.escape(each_traffic)\n                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = False\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to disable\")\n            if isinstance(traffic_item_list, str):\n                try:\n                    each_traffic = re.escape(traffic_item_list)\n                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = False\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to disable\")\n        else:\n            self.log.info(\"Disabling all available Traffic Item/Items\")\n            try:\n                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():\n                    trafficItem.Enabled = False\n            except:\n                raise IxiaOperationException(\"Failed to disable TrafficItem\")\n        self.log.info(\"Traffic Item/Items Disabled Successfully\")\n        return True\n\n    def enable_traffic_item(self, traffic_item_list=None):\n        \"\"\"\n        Enable the given traffic items in the list, if None given enable all the traffic items\n\n        :param traffic_item_list: list of traffic items to be enabled. if None, enable all\n        :return: True if successful else raise Exception\n\n        :Example: enable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info(\"Enabling Traffic Item/Items\")\n        if traffic_item_list:\n            self.log.info(f'Enabling the traffic items - {traffic_item_list}')\n            if isinstance(traffic_item_list, list):\n                try:\n                    for each_traffic in traffic_item_list:\n                        each_traffic = re.escape(each_traffic)\n                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = True\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to Enable\")\n            if isinstance(traffic_item_list, str):\n                try:\n                    each_traffic = re.escape(traffic_item_list)\n                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').Enabled = True\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to Enable\")\n        else:\n            self.log.info(\"Enabling all available Traffic Item/Items\")\n            try:\n                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():\n                    trafficItem.Enabled = True\n            except:\n                raise IxiaOperationException(\"Failed to enable TrafficItem\")\n        self.log.info(\"Traffic Item/Items enabled Successfully\")\n        return True\n\n    def delete_traffic_items(self,traffic_item_list=None):\n        \"\"\"\n        API to deleted traffic items\n\n        :param traffic_item_list: list of traffic items to be deleted. if None, delete all\n        :return: True\n        \"\"\"\n        if traffic_item_list:\n            if isinstance(traffic_item_list, list):\n                try:\n                    for each_traffic in traffic_item_list:\n                        each_traffic = re.escape(each_traffic)\n                        self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').remove()\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to Delete\")\n            elif isinstance(traffic_item_list, str):\n                try:\n                    each_traffic = re.escape(traffic_item_list)\n                    self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{each_traffic}$').remove()\n                except:\n                    raise IxiaOperationException(\"Not able to find the TrafficItem to Delete\")\n        else:\n            trafficItems = self.ixNetwork.Traffic.TrafficItem.find()\n            trafficItems.remove()\n        self.log.info(\"Traffic Item/Items Deleted Successfully\")\n        return True\n\n    def change_ipv4_tos(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Changes the Type of Service (ToS) values in ipv4 stack for a given set of traffic streams\n\n        :param cfg_dict: Dict including the data need to be modified\\n\n                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',\n                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \\n\n                Example: cfg_dict={'displayName':'unused','valueType':'increment','fieldValue':'000 Routine','startValue':'2','stepValue':'1','countValue':'15',\n                'randomMask':'3','seed':'1','maxValue':'11','minValue':'0','onTheFlyMask':'6','singleValue':'10'}\n        :param traffic_item_list: List of traffic Items name. All Items if it is None. \\n\n                Example: traffic_item_list=[\"Traffic Item 1\", \"Traffic Item 2\"]\n        :return: Returns True in case no exceptions\n\n        :Example: change_ipv4_diff_serv(traffic_item_list=['Traffic Item 1'],\n        cfg_dict={'displayName':'assuredForwarding','valueType':'singleValue','singleValue':'AF33'})\n        \"\"\"\n        tos_config = cfg_dict.copy()\n\n        if 'list' in tos_config.keys():\n            tos_config['valueType'] = 'valueList'\n            tos_config['valueList'] = tos_config['list']\n\n        precedence_dict = {'00':0,'20':1,'40':2,'60':3,'80':4,'A0':5,'C0':6,'E0':7}\n        diff_serve_af_dict = {'28': 10,'30': 12, '38': 14, '48': 18, '50': 20, '58': 22, '68': 26, '70': 28,\n                                '78': 30,'88': 34, '90': 36, '98': 38}\n\n        display_name = lambda value:'Precedence' if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) \\\n                                                    else ('assuredForwarding' if value in diff_serve_af_dict.keys() \\\n                                                        else 'expeditedForwarding')\n        diff_serv_value = lambda value:precedence_dict[value.upper()] \\\n                                        if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) \\\n                                        else (diff_serve_af_dict[value] if value in diff_serve_af_dict.keys() else 46 )\n        tos_value = lambda value:True if (value.lower() in precedence_dict.keys() or value.upper() in precedence_dict.keys()) else False\n\n        if 'singleValue' in tos_config:\n            if tos_config['singleValue'].startswith('0x'):\n                tos_value_modified = tos_config['singleValue'][2:]\n                tos_config['singleValue'] = tos_value_modified\n            tos_value = tos_value(tos_config['singleValue'])\n            tos_config.update({'displayName': display_name(tos_config['singleValue'])})\n            tos_config['singleValue'] = diff_serv_value(tos_config['singleValue'])\n        elif 'valueList' in tos_config:\n            if tos_config['valueList'][0].startswith('0x'):\n                tos_value_modified = [value[2:] for value in tos_config['valueList']]\n                tos_config['valueList'] = tos_value_modified\n            tos_value = tos_value(tos_config['valueList'][0])\n            tos_config.update({'displayName': display_name(tos_config['valueList'][0])})\n            tos_config['valueList'] = list(map(diff_serv_value, tos_config['valueList']))\n        elif 'startValue' in tos_config:\n            if not 'stepValue' in tos_config:\n                tos_config['stepValue'] = 1\n            if not 'countValue' in tos_config:\n                tos_config['countValue'] = 1\n            if tos_config['startValue'].startswith('0x'):\n                tos_value_modified = tos_config['startValue'][2:]\n                tos_config['startValue'] = tos_value_modified\n            tos_value = tos_value(tos_config['startValue'])\n            tos_config.update({'displayName': display_name(tos_config['startValue'])})\n            tos_config['startValue'] = diff_serv_value(tos_config['startValue'])\n        elif 'minValue' in tos_config:\n            tos_value = True\n            tos_config.update({'displayName':'Precedence'})\n            if not 'maxValue' in tos_config:\n                tos_config['maxValue'] = 7\n\n            if tos_config['minValue'].startswith('0x'):\n                tos_value_modified = tos_config['minValue'][2:]\n                tos_config['minValue'] = tos_value_modified\n            tos_config['minValue'] = diff_serv_value(tos_config['minValue'])\n\n        if tos_value:\n            self.log.info(\"Changing TOS values in Ipv4\")\n            if 'header_index' not in tos_config:\n                tos_config['header_index'] = 1\n            header_index = tos_config['header_index'] - 1\n            if 'displayName' not in tos_config:\n                tos_config['displayName'] = 'Precedence'\n            if not traffic_item_list:\n                with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                    self.ixNetwork.Traffic.TrafficItem.find()\n                traffic_item_list = list(map(lambda traffic_item:traffic_item.Name,getattr(traffic_item.results, 'trafficItem')))\n            for traffic_item in traffic_item_list:\n                traffic_item_modified = re.escape(traffic_item)\n                traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_modified}$')\n                if traffic_item_obj:\n                    for config_element in traffic_item_obj.ConfigElement.find():\n                        if config_element.Stack.find(DisplayName=\"IPv4\"):\n                            stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")[header_index]\n                            setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),\n                                    'ActiveFieldChoice',True)\n                            for key in tos_config:\n                                if key != 'displayName':\n                                    stack_obj.Field.find(DisplayName=tos_config['displayName']).ValueType = tos_config[\n                                        'valueType']\n                                    if 'valueList' in tos_config['valueType']:\n                                        setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),\n                                                tos_config['valueType'][0].upper() + tos_config['valueType'][1:],\n                                                tos_config['valueList'])\n                                    if 'singleValue' in tos_config['valueType']:\n                                        setattr(stack_obj.Field.find(DisplayName=tos_config['displayName']),\n                                                tos_config['valueType'][0].upper() + tos_config['valueType'][1:],\n                                                tos_config['singleValue'])\n                                    if 'increment' in tos_config['valueType']:\n                                        field_obj = stack_obj.Field.find(DisplayName=tos_config['displayName'])\n                                        field_value = {'start': tos_config['startValue'], 'step': tos_config['stepValue'],\n                                                       'count': tos_config['countValue']}\n                                        self._update_field_values(field_obj,field_value)\n                                    if 'random' in tos_config['valueType']:\n                                        field_obj = stack_obj.Field.find(DisplayName=tos_config['displayName'])\n                                        field_value = {'min':tos_config['minValue'],'max':tos_config['maxValue']}\n                                        self._update_field_values(field_obj, field_value)\n                        else:\n                            raise IxiaConfigException(f\"IPv4 stack not configured on {traffic_item}\")\n                else:\n                    raise IxiaConfigException(f\"{traffic_item} not configured\")\n            self.log.info(\"IPv4 TOS Values Updated in Traffic Items\")\n        else:\n            self.change_ipv4_diff_serv(tos_config,traffic_item_list)\n        return True\n\n    def change_ipv6_traffic_class(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Changes the IPv6 traffic class configuration for a given set of traffic streams\n\n        :param cfg_dict: Dict including the data need to be modified \\n\n                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',\n                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None. \\n\n                Example: traffic_item_list=[\"Traffic Item 1\", \"Traffic Item 2\"]\n        :return: Returns True in case no exceptions\n\n        :Example: change_ipv6_traffic_class(traffic_item_list=[\"Traffic Item 3\"],\n                    cfg_dict={'singleValue':'5'})\n        \"\"\"\n        self.log.info(\"Changing Ipv6 Traffic Class\")\n        if 'displayName' not in cfg_dict:\n            cfg_dict['displayName'] = 'Traffic Class'\n        if 'valueType' not in cfg_dict:\n            if 'valueList' in cfg_dict:\n                cfg_dict['valueType'] = 'valueList'\n            elif 'singleValue' in cfg_dict:\n                cfg_dict['valueType'] = 'singleValue'\n\n        if not traffic_item_list:\n            with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                self.ixNetwork.Traffic.TrafficItem.find()\n            traffic_item_list = list(\n                map(lambda traffic_item: traffic_item.Name, getattr(traffic_item.results, 'trafficItem')))\n\n        for traffic_item in traffic_item_list:\n            traffic_item_modified = re.escape(traffic_item)\n            for config_obj in self.ixNetwork.Traffic.TrafficItem.find(\n                    Name='^' + traffic_item_modified + '$').ConfigElement.find():\n                if config_obj.Stack.find(StackTypeId='^' + 'ipv6' + '$'):\n                    stack_obj = config_obj.Stack.find(StackTypeId='^' + 'ipv6' + '$')\n                    field_value = stack_obj.Field.find(DisplayName=cfg_dict['displayName'])\n                    field_value.ValueType = cfg_dict['valueType']\n\n                    if 'valueList' in cfg_dict['valueType']:\n                        if not cfg_dict['valueList'][0].startswith('0x'):\n                            setattr(field_value,\n                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                    cfg_dict['valueList'])\n                        else:\n                            cfg_dict['decValueList'] = [int(value, 16) for value in cfg_dict['valueList'] if value]\n                            setattr(field_value,\n                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                    cfg_dict['decValueList'])\n                    if 'singleValue' in cfg_dict['valueType']:\n                        if not cfg_dict['singleValue'].startswith('0x'):\n                            setattr(field_value,\n                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                    cfg_dict['singleValue'])\n                        else:\n                            cfg_dict['decSingleValue'] = int(cfg_dict['singleValue'], 16)\n                            setattr(field_value,\n                                    cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                    cfg_dict['decSingleValue'])\n                else:\n                    raise IxiaConfigException(f\"Ipv6 stack not configured on {traffic_item}\")\n\n        self.log.info(f\"IPv6 Traffic Class updated in {traffic_item_list} Items\")\n        return True\n\n    def _update_prefix_step(self, prefix_step:Union[str, int, dict], pool_handle):\n        \"\"\"\n        Internal Method to Set Network group prefix step based on prefix step type and pool handle.\n        :param prefix_step: Prefix step value Integer/String/dict\n        Ex : to set single value int/str prefix_step = 1 or prefix_step = \"1\"\n        dict type to prefix step in increment/decrement/random type\n        Ex : prefix_step = {'mode' : 'increment','start' : 10, 'step' : '1'}\n        :param pool_handle: PrefixPool Handle\n        \"\"\"\n        if isinstance(prefix_step, (str, int)):\n            pool_handle.PrefixAddrStep.Single(prefix_step)\n        elif isinstance(prefix_step, dict):\n            if 'mode' in prefix_step.keys():\n                if prefix_step['mode'] == 'increment':\n                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():\n                        pool_handle.PrefixAddrStep.Increment(prefix_step['start'], prefix_step['step'])\n                    else:\n                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')\n                elif prefix_step['mode'] == 'decrement':\n                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():\n                        pool_handle.PrefixAddrStep.Decrement(prefix_step['start'], prefix_step['step'])\n                    else:\n                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')\n                elif prefix_step['mode'] == 'random':\n                    pool_handle.PrefixAddrStep.Random()\n            else:\n                raise IxiaConfigException('Please pass Prefix Step Mode increment/decrement/random')\n\n    def _set_bgp_network_group_options(self, pool_handle, route_count, prefix_ip=None, prefixlen=None, prefix_step=None, router_id=None):\n        \"\"\"\n        Set Route count and prefix based on Protocol handle.\n        :param pool_handle: PrefixPool Handle\n        :param route_count: route_count to be updated\n        :param prefix_ip: prefix_ip as reference\n        :param prefixlen: prefixlen as reference\n        :param prefix_step: prefix_step as reference\n        :param router_id: router_id as reference\n        :return:\n        \"\"\"\n        # BuildNumber will return the ixNetwork API server version. Here we are interested in the major version of ixNetwork.\n        # Ex: 10.00.2312.4 will be returned as BuildNumber. Hence, split('.')[0] will returns '10'.\n        if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:\n            if prefix_ip and router_id:\n                if prefix_ip in pool_handle.NetworkAddress.Values:\n                    ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)\n                    value_list = pool_handle.NumberOfAddressesAsy.Values\n                    value_list[ip_prefix_index] = route_count\n                    pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)\n                    if prefixlen:\n                        value_list = pool_handle.PrefixLength.Values\n                        value_list[ip_prefix_index] = prefixlen\n                        pool_handle.PrefixLength.ValueList(values=value_list)\n                    if prefix_step:\n                        value_list = pool_handle.PrefixAddrStep.Values\n                        value_list[ip_prefix_index] = prefix_step\n                        pool_handle.PrefixAddrStep.ValueList(values=value_list)\n            elif router_id and prefix_ip is None:\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                            router_id_index = (deviceGroupObj.RouterData.find().RouterId.Values).index(router_id)\n                            value_list = pool_handle.NumberOfAddressesAsy.Values\n                            value_list[router_id_index] = route_count\n                            pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)\n                            if prefixlen:\n                                value_list = pool_handle.PrefixLength.Values\n                                value_list[router_id_index] = prefixlen\n                                pool_handle.PrefixLength.ValueList(values=value_list)\n                            if prefix_step:\n                                value_list = pool_handle.PrefixAddrStep.Values\n                                value_list[router_id_index] = prefix_step\n                                pool_handle.PrefixAddrStep.ValueList(values=value_list)\n            else:\n                pool_handle.NumberOfAddressesAsy.Single(route_count)\n                if str(pool_handle.NumberOfAddressesAsy) == str(route_count):\n                    self.log.info('Route count updated successfully')\n                else:\n                    self.log.error('Route count update failed')\n\n                if prefixlen:\n                    pool_handle.PrefixLength.Single(prefixlen)\n                if prefix_step:\n                    self._update_prefix_step(prefix_step, pool_handle)\n\n        # This block for 8.50 version\n        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:\n            pool_handle.NumberOfAddresses = route_count\n            if str(pool_handle.NumberOfAddresses) == str(route_count):\n                self.log.info('Route count updated successfully')\n            else:\n                self.log.error('Route count update failed')\n\n            if prefixlen:\n                pool_handle.PrefixLength.Single(prefixlen)\n            if prefix_step:\n                self._update_prefix_step(prefix_step, pool_handle)\n\n    def _modify_bgp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix, prefix_step,\n                                router_id, **kwargs):\n        \"\"\"\n        Internal API to support setting route count and prefix length of BGP network group\n\n        :param network_group: Network Group for which Route Count should be modified\n        :param route_count: Route count\n        :param ip_type: ipv4 or ipv6\n        :param start_ip_prefix: start ip prefix as reference\n        :param prefix: prefix\n        :param prefix_step: prefix step\n        :param router_id: router ID\n        :return: result\n        \"\"\"\n        protocolStatus = False\n        deviceGroupName = None\n        nested_network_group = kwargs.get('nested_network_group')\n        network_group_name_list = []\n        deviceGrpList = self.ixNetwork.Topology.find().DeviceGroup.find()\n        for deviceGroupObj in deviceGrpList:\n            if deviceGroupObj.RouterData.find():\n                for routerId in router_id:\n                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:\n                        deviceGroupName = deviceGroupObj.Name\n                        break\n        if network_group and not nested_network_group:\n            try:\n                network_group_name_list = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()\n                                        if network_group in networkObj.Name]\n            except:\n                pass\n        if nested_network_group and network_group:\n            try:\n                network_group_name_list = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()\n                                        if network_group in networkObj.Name]\n            except:\n                pass\n\n            try:\n                network_group_name_list = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).\n                                            DeviceGroup.find().DeviceGroup.find().NetworkGroup.find()\n                                        if network_group == networkObj.Name]\n            except:\n                pass\n\n            try:\n                network_group_name_list = [networkObj.Name for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).\n                            NetworkGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find() if nested_network_group in networkObj.Name]\n            except:\n                pass\n\n        if network_group_name_list:\n            for each_network_group in network_group_name_list:\n                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + each_network_group + '$')\n                if nested_network_group:\n                    try:\n                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + each_network_group + '$')\n                    except:\n                        pass\n                    try:\n                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).DeviceGroup.find().\\\n                            DeviceGroup.find().NetworkGroup.find(Name='^' + each_network_group + '$')\n                    except:\n                        pass\n                    try:\n                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find().\\\n                            DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + each_network_group + '$')\n                    except:\n                        pass\n                if ip_type.lower() == \"ipv4\":\n                    for network_group_obj in network_obj.Ipv4PrefixPools.find():\n                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \\\n                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():\n                            protocolStatus = True\n                            network_obj.Enabled.Single(True)\n                            for routerid in router_id:\n                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,\n                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)\n                if ip_type.lower() == \"ipv6\":\n                    for network_group_obj in network_obj.Ipv6PrefixPools.find():\n                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \\\n                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():\n                            network_obj.Enabled.Single(True)\n                            protocolStatus = True\n                            for routerid in router_id:\n                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,\n                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)\n        elif router_id != None and deviceGroupName != None:\n            networkGrpList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()\n            if ip_type.lower() == \"ipv4\":\n                for networkObj in networkGrpList:\n                    for network_group_obj in networkObj.Ipv4PrefixPools.find():\n                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \\\n                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():\n                            protocolStatus = True\n                            networkObj.Enabled.Single(True)\n                            for routerid in router_id:\n                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,\n                                                                    prefixlen=prefix,prefix_step=prefix_step, router_id=routerid)\n            if ip_type.lower() == \"ipv6\":\n                for networkObj in networkGrpList:\n                    for network_group_obj in networkObj.Ipv6PrefixPools.find():\n                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \\\n                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():\n                            networkObj.Enabled.Single(True)\n                            protocolStatus = True\n                            for routerid in router_id:\n                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,\n                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)\n        else:\n            raise IxiaConfigException(\"Router Id or network_group not found \")\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        if protocolStatus:\n            return protocolStatus\n        else:\n            raise IxiaConfigException(\"BGP protocol not configured or Configuration issue.\")\n\n    def set_bgp_route_count(self, route_count, ip_type=\"ipv4\", **kwargs):\n        \"\"\"\n        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                router_id: Router ID of the device\n                route_block_name: route block name from config\n                start_ip: represents the first IP of the route block\n                prefix: Integer/String representing the new prefix\n                prefix_step: Prefix step value Integer/String Ex : 1 or \"1\"\n                nested_network_group : if nested network group, Need to pass Nested Network Group Name\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_bgp_route_count(route_count=10, ports=[\"Ethernet - 001\"], network_group=\"Network Group 9\")\n        \"\"\"\n        route_block_name = kwargs.get(\"route_block_name\")\n        router_id = kwargs.get(\"router_id\")\n\n        if isinstance(router_id, list) and isinstance(route_block_name, list) and isinstance(route_count, list):\n            if not (len(router_id) == len(route_block_name) == len(route_count)):\n                raise Exception(\"router_id, route_block_name, and route_count must all be the same length\")\n\n            for idx, dg_name in enumerate(router_id):\n                try:\n                    route_block_index = route_block_name[idx] - 1\n                    count = route_count[idx]\n                    self.log.debug(f\" Updating DG '{dg_name}', block {route_block_index} to route count {count}\")\n\n                    # Find nested Device group (add dg.find().ng.find() combination according to the config)\n                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dg_name + '$')\n                    if not device_objs:\n                        device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                            Name='^' + dg_name + '$')\n                    if not device_objs:\n                        self.log.warning(f\"DeviceGroup '{dg_name}' not found. Skipping.\")\n                        continue\n\n                    network_groups = device_objs.NetworkGroup.find()\n                    if not network_groups:\n                        self.log.warning(f\"No NetworkGroups under '{dg_name}'. Skipping.\")\n                        continue\n\n                    prefix_pool = None\n                    for net_group in network_groups:\n                        if ip_type[idx].lower() == \"ipv4\":\n                            pool_list = net_group.Ipv4PrefixPools.find()\n                        else:\n                            pool_list = net_group.Ipv6PrefixPools.find()\n\n                        if pool_list:\n                            prefix_pool = pool_list[0]\n                            break\n\n                    if not prefix_pool:\n                        self.log.warning(f\"No prefix pool found under '{dg_name}'. Skipping.\")\n                        continue\n\n                    count_values = prefix_pool.NumberOfAddressesAsy.Values\n                    prefix_pool.NumberOfAddressesAsy.ClearOverlays()\n                    if route_block_index >= len(count_values):\n                        self.log.warning(f\"Route-block index {route_block_index} out of range - '{dg_name}'.Found only {len(count_values)} blocks\")\n                        continue\n\n                    count_values[route_block_index] = count\n                    prefix_pool.NumberOfAddressesAsy.ValueList(values=count_values)\n                    self.log.success(f\" Updated DG '{dg_name}', index {route_block_index} to route count {count}\")\n\n                except Exception as err:\n                    self.log.error(f\" Error updating index {idx}: {err}\")\n                    continue\n\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            self.log.info(\" All route counts updated successfully.\")\n            return True\n        else:\n            network_group = kwargs.get('route_block_name')\n            if 'network_group' in kwargs:\n                network_group = kwargs.get('network_group')\n            self.log.info(f\"Setting Bgp Route Count for route_block_name: {network_group}\")\n            start_ip = kwargs.get('start_ip')\n            prefix_length = kwargs.get('prefix')\n            prefix_step = kwargs.get('prefix_step')\n            router_id = kwargs.get('router_id')\n            if not isinstance(router_id, list):\n                router_id = [router_id]\n            nested_group = kwargs.get('nested_network_group', False)\n            if not network_group and router_id is None:\n                raise IxiaConfigException('Please pass either Network group/Router Id')\n            return self._modify_bgp_route_count(network_group, route_count, ip_type, start_ip_prefix=start_ip,\n                                                prefix=prefix_length,prefix_step=prefix_step, router_id=router_id,\n                                                nested_network_group=nested_group)\n\n    def get_frame_l4_information(self):\n        \"\"\"\n        Check if L4 header is in traffic stream. Infomation is in the log\n\n        :return: True if all streams with L4 header. False if any stream without L4 header\n\n        :Example: get_frame_l4_information()\n        \"\"\"\n        self.log.info(\"Checking L4 Information is Available in TrafficItem\")\n        withL4 = []\n        withoutL4 = []\n        result = False\n        if not self.ixNetwork.Traffic.TrafficItem.find():\n            self.log.warning('Traffic Stream not configured')\n        else:\n            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]\n            for trafficItemName in trafficItemNameList:\n                stackTypeIdList = [stackObj.StackTypeId for stackObj in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find()]\n                if \"tcp\" in stackTypeIdList:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId=\"tcp\").DisplayName:\n                        withL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])\n                elif \"udp\" in stackTypeIdList:\n                    if (self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId=\"udp\").DisplayName):\n                        withL4.append(trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName[0])\n                else:\n                    withoutL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])\n            if withL4:\n                result = True\n                self.log.info('Stream with L4 Header:%s' % withL4)\n            if withoutL4:\n                result = False\n                self.log.info('Stream without L4 Header:%s' % withoutL4)\n            return result\n\n    def get_ipv4_tos_information(self):\n        \"\"\"\n        Get IPv4 Type of Service (ToS) configuration for a given traffic stream\n\n        :return: True if all streams have a ToS configuration.\n                False if there is at least one stream without\n                a ToS configuration\n\n        :Example: get_ipv4_tos_information()\n        \"\"\"\n        self.log.info(\"Checking Ipv4 TOS information is available in TrafficItem\")\n        withTos = []\n        withoutTos = []\n        result = False\n        if not self.ixNetwork.Traffic.TrafficItem.find():\n            self.log.warning('Traffic Stream not configured')\n        else:\n            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]\n            for trafficItemName in trafficItemNameList:\n                try:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName=\"IPv4\").Field.find(Name='precedence').ActiveFieldChoice == True:\n                        withTos.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName=\"IPv4\").Field.find(Name='precedence').ActiveFieldChoice)\n                except:\n                    withoutTos.append(trafficItemName)\n        if withoutTos:\n            result = False\n            self.log.warning('Stream without IPv4 TOS:%s' % withoutTos)\n        else:\n            if withTos:\n                result = True\n                self.log.info(withTos)\n        return result\n\n    def get_ipv6_traffic_class_information(self):\n        \"\"\"\n        Get IPv6 Traffic Class (TC) configuration for a given traffic stream\n\n        :return: True if all streams have a TC configuration.\n                False if there is at least one stream without\n                a TC configuration\n\n        :Example: get_ipv6_traffic_class_information()\n        \"\"\"\n\n        withTrafficClass = []\n        withoutTrafficClass = []\n        result = False\n        if not self.ixNetwork.Traffic.TrafficItem.find():\n            self.log.warning('Traffic Stream not configured')\n        else:\n            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]\n            for trafficItemName in trafficItemNameList:\n                try:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName=\"IPv6\").Field.find(Name='trafficClass'):\n                        withTrafficClass.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName=\"IPv6\").Field.find(Name='trafficClass'))\n                except:\n                    withoutTrafficClass.append(trafficItemName)\n        if withoutTrafficClass:\n            result = False\n            self.log.warning('Stream without IPv6 Traffic Class:%s' % withoutTrafficClass)\n        else:\n            if withTrafficClass:\n                result = True\n                self.log.info(withTrafficClass)\n        return result\n\n    def _connect_ports(self, port, testPorts, vportList, assign_to_physical_port, device_obj, forceTakePortOwnership):\n        \"\"\"\n        Connect ports\n        :param port:  virtual port\n        :param testPorts: physical ports\n        :param vportList: vportList\n        :param assign_to_physical_port:  True or False\n        :param device_obj: Device object\n        :param forceTakePortOwnership: True or False\n\n        :return:\n        \"\"\"\n        tmp = port.split('/')\n        if len(tmp) == 2:\n            chassis = self.chassis_ip\n            card, port = tmp\n        else:\n            chassis = tmp[0]\n            card = tmp[1]\n            port = tmp[2]\n        vportList.append(self.ixNetwork.Vport.add().href)\n        if assign_to_physical_port:\n            # Assign ports\n            if self.chassis_ip == chassis:\n                testPorts.append(dict(Arg1=self.chassis_ip, Arg2=card, Arg3=port))\n            else:\n                testPorts.append(dict(Arg1=chassis, Arg2=card, Arg3=port))\n        # self.ixNetwork.Vport.find()[-1].Name = card + \"/\" + port - old\n        self.ixNetwork.Vport.find()[-1].Name = f\"{chassis}/{card}/{port}\"\n        if vportList and testPorts:\n            device_obj['vport'] = self.ixNetwork.AssignPorts(testPorts, [], vportList,\n                                                             forceTakePortOwnership)\n        self._update_media_type()\n        self.ixNetwork.Vport.find().ConnectPorts()\n\n    def add_device(self,\n                   port_list=None,\n                   ipv4_address_start=None,\n                   ipv6_address_start=None,\n                   igmp_group_start=None,\n                   mld_group_start=None,\n                   new_config=False,\n                   **kwargs):\n        \"\"\"\n        Add new device to topology\n\n        Mandatory Args:\n\n        :param port_list: List of physical port name,Format of physical port name: 'chassisIP'/'card'/'port', 'card'/'port'\n        :param ipv4_address_start: The starting address for ipv4 devices\n        :param ipv6_address_start: The starting address for ipv6 devices\n        :param igmp_group_start: The starting group for igmp devices\n        :param mld_group_start: The starting group for mld devices\n        :param new_config: True if you want to wipe out the old config, False to use the existing one\n\n        Optional Args:\n\n        :param assign_to_physical_port: CHOICES True, False. Default True\n                True: Asign physical port to the vport created\n                False: Create vport only\n        :param port_name_list: CHOICES None, list of string. Default None\n                None: use format 'card'/'port'\n        :param device_name: Name of the device group name to be created\n        :param interface_no_vlan_count: CHOICES integer. Default is 1 for main interface\n        :param interface_vlan_disable: CHOICES integer - 0,1. To enable/disable Vlan. Default is 0\n        :param vlan_count: CHOICES integer. Number of vlan per device. Default 1\n        :param vlan_id_count: CHOICES 0, integer. Number of vlan per port.\n        :param vlan_id_start: CHOICES List RANGE 0 - 4096.\n                Default None for no change, Example: [<outer vlan start id>,<inner vlan start id>]\n        :param vlan_id_step: CHOICES integer. Default 0\n        :param vlan_id_port_step: CHOICES integer. Default 0\n        :param vlan_id_sequence_length: CHOICES integer.\n        :param vlan_id_repeat_value: CHOICES integer.\n        :param vlan_id_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param vlan_id_step_enable: CHOICE bool.\n        :param vlan_priority_start: CHOICES integer, list RANGE 0 - 7. Default 0\n        :param vlan_priority_step: CHOICES integer. Default 0\n        :param vlan_priority_port_step: CHOICES integer. Default 0\n        :param vlan_priority_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param vlan_priority_step_enable: CHOICES bool.\n        :param vlan_priority_sequence_length: CHOICES integer.\n        :param vlan_priority_repeat_value: CHOICES integer.\n        :param vlan_tpid: CHOICES '0x8100', '0x88a8', '0x9100', '0x9200', '0x9300'\n        :param ipv4_address_start: IPv4 address for first interface\n        :param ipv4_address_step: IPv4 address for step\n        :param ipv4_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_address_prefix: CHOICES integer\n        :param ipv4_address_port_step: CHOICES 'disabled', IPv4 address\n        :param ipv4_address_repeat_value(int): repeat value Ex: 1\n        :param ipv4_address_sequence_length: CHOICES integer\n        :param ipv4_gateway_start: IPv4 address for first interface gateway\n        :param ipv4_gateway_step: IPv4 address for step\n        :param ipv4_gateway_port_step: CHOICES 'disabled', IPv4 address\n        :param ipv4_port_step_enable: CHOICES bool.\n        :param ipv4_gateway_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_gateway_repeat_value (int): repeat value Ex: 1\n        :param ipv4_gateway_sequence_length: CHOICES integer\n        :param ipv4_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_address_repeat_increment (str): Ex: \"0.0.0.1\"\n        :param ipv4_gateway_repeat_increment (str): Ex: \"0.0.0.1\"\n        :param ipv4_routerid = '192.0.0.1'\n        :param ipv4_routerid_step = 2\n        :param ipv6_address_repeat_increment (str): Ex: \"0::1\"\n        :param ipv6_gateway_repeat_increment (str): Ex: \"0::1\"\n        :param ipv6_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv6_address_start: IPv6 address for first interface\n        :param ipv6_address_step: IPv6 address for step\n        :param ipv6_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv6_address_prefix: CHOICES integer\n        :param ipv6_address_repeat_value(int): repeat value Ex: 1\n        :param ipv6_address_sequence_length: CHOICES integer\n        :param ipv6_address_port_step: CHOICES 'disabled', IPv6 address\n        :param ipv6_gateway_start: IPv6 address for first interface gateway\n        :param ipv6_gateway_step: IPv6 address for step\n        :param ipv6_gateway_port_step: CHOICES 'disabled', IPv6 address\n        :param ipv6_port_step_enable: CHOICES bool.\n        :param ipv6_gateway_repeat_value(int): repeat value Ex: 1\n        :param ipv6_gateway_sequence_length: CHOICES integer\n        :param ipv6_gateway_direction: CHOICES 'increment', 'decrement'\n        :param ipv6_routerid: '192.0.0.1'\n        :param ipv6_routerid_step: 2\n        :param igmp_version: CHOICES string/list. 'version1','version2','version3'\n        :param igmp_num_of_group_range: CHOICES integer\n        :param igmp_group_start: IPv4 multicast address.Default None for no configure igmp\n        :param igmp_group_step: IPv4 address. Default '0.0.0.1'\n        :param igmp_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param igmp_group_port_step: CHOICES 'disable', 'enable', IPv4 address\n        :param igmp_group_port_step_enable: CHOICES 'disable', 'enable'\n        :param igmp_group_address_count: CHOICES integer.\n        :param igmp_group_address_increment: CHOICES IPv4 address\n        :param igmp_group_repeat_value(int): repeat value Ex: 1\n        :param igmp_group_sequence_length: CHOICES integer.\n        :param igmp_source_mode: CHOICES 'include', 'exclude'\n        :param igmp_num_source_range: CHOICES integer\n        :param igmp_source_start: IPv4 address\n        :param igmp_source_step: IPv4 address. Default '0.0.0.1'\n        :param igmp_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param igmp_source_port_step: CHOICES 'disabled', IPv4 address\n        :param igmp_source_port_step_enable: CHOICES 'disabled','enabled'\n        :param igmp_source_addree_increment: IPv4 address\n        :param igmp_source_address_count: CHOICES integer\n        :param igmp_source_repeat_value(int): repeat value Ex: 1\n        :param igmp_source_sequence_length: CHOICES integer\n        :param igmp_rate_interval: rate to be configured\n        :param mld_version: CHOICES string/list. 'version1','version2'\n        :param mld_num_of group_range: CHOICES integer\n        :param mld_group_start: IPv6 multicast address, Default None for no configure mld\n        :param mld_group_step: IPv6 address. Default '::1'\n        :param mld_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param mld_group_port_step: CHOICES 'disabled', IPv6 address\n        :param mld_group_port_step_enable: CHOICES 'disabled', 'enabled'\n        :param mld_group_address_count: CHOICES integer\n        :param mld_group_address_increment: CHOICE IPv6 address\n        :param mld_group_repeat_value(int): repeat value Ex: 1\n        :param mld_group_sequence_length: CHOICES integer\n        :param mld_source_mode: CHOICES 'include', 'exclude'\n        :param mld_num_source_range: CHOICES integer\n        :param mld_source_start: IPv6 address\n        :param mld_source_step: IPv6 address. Default '::1'\n        :param mld_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param mld_source_port_step: CHOICES 'disabled', IPv6 address\n        :param mld_source_port_step_enable: CHOICES 'disabled','enabled'\n        :param mld_source_address_increment: IPv6 address\n        :param mld_source_address_count: CHOICES integer\n        :param mld_source_repeat_value(int): repeat value Ex: 1\n        :param mld_source_sequence_length: CHOICES integer\n        :param mld_rate_interval: rate to be configured\n        :param multiple_ports_per_topo: CHOICES bool\n        :return: device_obj dictionary {'vport':<obj>, 'ipv4':<obj>....}\n\n        #Create device BGP config\n        :param bgp_v4_active = True,\n        :param bgp_v4_dut = '100.1.0.2',\n        :param bgp_v4_dut_ip_address = '100.1.0.2',\n        :param bgp_v4_2_byte_as = 100,\n        :param bgp_v4_type = 'external'\n        :param bgp_v4_enable_4_byte_as = 'True',\n        :param bgp_v4_4_byte_as = 66000,\n        :param bgp_v4_hold_time_interval = 60,\n        :param bgp_v4_keep_alive_interval = 20,\n        :param bgp_v4_configure_keep_alive_timer = True,\n        :param bgp_v4_enable_graceful_restart = True,\n        :param bgp_v4_route_count = 5,\n        :param bgp_v4_route_start ='11.11.11.1',\n        :param bgp_v4_route_prefix = 28,\n        :param bgp_v4_route_prefix_step = 2,\n        :param bgp_v4_route_active = True,\n        :param bgp_v4_route_segment_type = 'assetconfederation',\n        :param bgp_v4_ttl =32,\n        :param bgp_v4_authentication = 'md5',\n        :param bgp_v4_password = 'ixia1',\n        :param bgp_v4_minimum_label =20\n        :param bgp_v4_aspath = 200\n        :param bgp_v4_asnum_stepvalue = 2\n\n        #Create device BGPv6 config\n        :param bgp_v6_active=True,\n        :param bgp_v6_dut='2000:1:1:1::1',\n        :param bgp_v6_dut_ip_address='2000:1:1:1::1',\n        :param bgp_v6_type: 'external',\n        :param bgp_v6_enable_2_byte_as = 100,\n        :param bgp_v6_enable_4_byte_as=True,\n        :param bgp_v6_4_byte_as=66000,\n        :param bgp_v6_hold_time_interval=60,\n        :param bgp_v6_keep_alive_interval=20,\n        :param bgp_v6_configure_keep_alive_timer=True,\n        :param bgp_v6_enable_graceful_restart=True,\n        :param bgp_v6_route_count=10,\n        :param bgp_v6_route_start='2000:1:1:1::1',\n        :param bgp_v6_route_prefix = 28,\n        :param bgp_v6_route_prefix_step = 2,\n        :param bgp_v6_route_active=True,\n        :param bgp_v6_route_segment_type='assetconfederation',\n        :param bgp_v6_ttl=32,\n        :param bgp_v6_authentication='md5',\n        :param bgp_v6_password='ixia1',\n        :param bgp_v6_minimum_label = 20\n        :param bgp_v6_aspath = 200\n        :param bgp_v6_asnum_stepvalue = 2\n\n\n        :Example: add_device(port_list= [\"10.39.60.2/1/1\"])\n        \"\"\"\n        self.log.info(\"Adding New Device to the Topology\")\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n        device_obj = kwargs.get('device_obj', {})\n        port_name_list = kwargs.get('port_name_list', None)\n        assign_to_physical_port = kwargs.get('assign_to_physical_port', True)\n        interface_no_vlan_count = kwargs.get('interface_no_vlan_count', 1)\n        interface_vlan_disable = kwargs.get('interface_vlan_disable', 0)\n        vlan_id_count = kwargs.get('vlan_id_count', 0)\n        igmp_rate_interval = kwargs.get('igmp_rate_interval', 0)\n        mld_rate_interval = kwargs.get('mld_rate_interval', 0)\n        device_name = kwargs.get('device_name', None)\n        devicegroup_name = kwargs.get('devicegroup_name', None)\n        forceTakePortOwnership = True\n        existingDeviceObj = None\n        testPorts = []\n        vportList = []\n        if self.update_license == False and new_config == True:\n            self._new_session(self.user_name, self.session_name, kill_existing=True)\n        if new_config:\n            self.ixNetwork.NewConfig()\n        if not new_config:\n            vportData = [(vportConnect.AssignedTo).replace(':', '/') for vportConnect in self.get_list_ports()]\n            self._update_media_type()\n        else:\n            vportData = None\n        if kwargs.get('multiple_vports_topo', None):\n            port_list = [port_list]\n\n        if not port_list:\n            return True\n        \n        for port in port_list:\n            if kwargs.get('multiple_vports_topo', None):\n                for vport in port_list[0]:\n                    if vportData:\n                        if vportData:\n                            vportInfo = [port[port.index('/') + 1:] for port in vportData]\n                        else:\n                            vportInfo = None\n                        if vportInfo:\n                            if vport in vportInfo:\n                                for portObj in self.ixNetwork.Vport.find():\n                                    portAssigned = (portObj.AssignedTo).replace(':', '/')\n                                    if vport == portAssigned[portAssigned.index('/') + 1:]:\n                                        portName = portObj.Name\n                                        device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)\n                                        break\n                                    existingDeviceObj = True\n                            else:\n                                self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,\n                                                    forceTakePortOwnership)\n                    else:\n                        self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,\n                                            forceTakePortOwnership)\n            else:\n                if 'vport' not in device_obj and existingDeviceObj is None:\n                    if port_name_list:\n                        if len(port_list) != len(port_name_list):\n                            msg = 'port name:%s do not match ports:%s' % (port_name_list, port_list)\n                            self.log.error(msg)\n                            raise CafyException.TgenConfigMissingError(msg)\n\n                    if vportData:\n                        vportInfo = [port[port.index('/') + 1:] for port in vportData]\n                    else:\n                        vportInfo = None\n                    if vportInfo:\n                        temp_port = port\n                        port = port[port.index('/') + 1:]\n                        if port in vportInfo:\n                            for portObj in self.ixNetwork.Vport.find():\n                                if port in (portObj.AssignedTo).replace(':', '/'):\n                                    portName = portObj.Name\n                                    device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)\n                                    break\n                            existingDeviceObj = True\n                        else:\n                            port = temp_port\n                            self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,\n                                                forceTakePortOwnership)\n                    else:\n                        self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,\n                                            forceTakePortOwnership)\n\n            if 'topology' not in device_obj:\n                topologyObj = None\n                if kwargs.get('multiple_vports_topo', None):\n                    port = port[0]\n                if vportData:\n                    vportInfo = [port[port.index('/') + 1:] for port in vportData]\n                    if port in vportInfo:\n                        for topology in self.ixNetwork.Topology.find():\n                            for portObj in self.ixNetwork.Vport.find():\n                                portAssigned = (portObj.AssignedTo).replace(':', '/')\n                                if port == portAssigned[portAssigned.index('/') + 1:]:\n                                    portName = portObj.Name.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n                                    break\n                            if self.ixNetwork.Vport.find(Name=portName).href in topology.Vports:\n                                device_obj['topology'] = topology\n                                topologyObj = True\n                                break\n                if not topologyObj:\n                    if vportList == []:\n                        for portObj in self.ixNetwork.Vport.find():\n                            if temp_port in (portObj.AssignedTo).replace(':', '/'):\n                                vportList.append(portObj.href)\n                    device_obj['topology'] = self.ixNetwork.Topology.add(Vports=vportList)\n\n            if 'interface_no_vlan_count' in kwargs:\n                multiplier = interface_no_vlan_count + vlan_id_count\n            elif 'interface_vlan_disable' in kwargs :\n                multiplier = interface_vlan_disable + vlan_id_count\n            elif vlan_id_count:\n                multiplier = vlan_id_count\n            else:\n                multiplier = 1\n            if 'devicegroup_name' not in kwargs:\n                kwargs['devicegroup_name'] = None\n            if 'device_name' in kwargs:\n                kwargs['devicegroup_name'] = kwargs['device_name']\n            if 'devicegroup' not in device_obj and existingDeviceObj is None:\n                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],\n                                                                                   Multiplier=multiplier)\n            else:\n                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],\n                                                                                   Multiplier=multiplier)\n            vlanIdKwargs = {key: kwargs[key] for key in kwargs if \"id\" in key and kwargs[key] != \"\"}\n            vlanPriorityKwargs = {key: kwargs[key] for key in kwargs if \"priority\" in key and kwargs[key] != \"\"}\n            if ('ethernet' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                device_obj['ethernet'] = device_obj['devicegroup'].Ethernet.add(Name=None,\n                                                                                VlanCount=kwargs.get('vlan_count',\n                                                                                                     None))\n                if kwargs.get('vlan_count', None) or kwargs.get('vlan_id_step', None):\n                    device_obj['ethernet'].UseVlans = True\n                if 'interface_no_vlan_count' in kwargs:\n                    valueList = ['false' if i <= interface_no_vlan_count else 'true' for i in\n                                 range(1, interface_no_vlan_count + vlan_id_count + 1)]\n                    device_obj['ethernet'].EnableVlans.ValueList(valueList)\n                if 'interface_vlan_disable' in kwargs:\n                    valueList = ['true'] * (interface_vlan_disable + vlan_id_count)\n                    if 0 <= interface_vlan_disable < len(valueList):\n                        valueList[interface_vlan_disable] = 'false'\n                    device_obj['ethernet'].EnableVlans.ValueList(valueList)\n                if 'vlan_id_start' in kwargs:\n                    vlanIdKwargs['vlan_id_direction'] = kwargs.get('vlan_id_direction', 'increment')\n                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanIdKwargs)\n                    vlanObj.config()\n                    self.log.info(\"Vlan Id Info configured successfully\")\n\n                if 'vlan_priority_start' in kwargs:\n                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanPriorityKwargs)\n                    vlanObj.config()\n                    self.log.info(\"Vlan Priority Info configured successfully\")\n\n            if 'ipv4_address_direction' not in kwargs and 'ipv4_address_step' in kwargs:\n                kwargs['ipv4_address_direction'] = 'increment'\n            if 'ipv4_gateway_direction' not in kwargs and 'ipv4_gateway_step' in kwargs:\n                kwargs['ipv4_gateway_direction'] = 'increment'\n            if 'ipv6_address_direction' not in kwargs and 'ipv6_address_step' in kwargs:\n                kwargs['ipv6_address_direction'] = 'increment'\n            if 'ipv6_gateway_direction' not in kwargs and 'ipv6_gateway_step' in kwargs:\n                kwargs['ipv6_gateway_direction'] = 'increment'\n            ipv4Kwargs = {key: kwargs[key] for key in kwargs if \"ipv4\" in key and kwargs[key] != \"\"}\n            ipv6Kwargs = {key: kwargs[key] for key in kwargs if \"ipv6\" in key and kwargs[key] != \"\"}\n            igmpKwargs = {key: kwargs[key] for key in kwargs if \"igmp\" in key and kwargs[key] != \"\"}\n            mldKwargs = {key: kwargs[key] for key in kwargs if \"mld\" in key and kwargs[key] != \"\"}\n            bgpv4Kwargs = {key: kwargs[key] for key in kwargs if \"bgp_v4\" in key and kwargs[key] != \"\"}\n            bgpv6Kwargs = {key: kwargs[key] for key in kwargs if \"bgp_v6\" in key and kwargs[key] != \"\"}\n\n            if ('ipv4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if ipv4_address_start:\n                    device_obj['ipv4'] = device_obj['ethernet'].Ipv4.add()\n                    ipv4Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],\n                                    ipv4_address_start=ipv4_address_start, **ipv4Kwargs)\n                    ipv4Obj.config()\n                    self.log.info(\"Ipv4 Info configured successfully\")\n\n            if ('ipv6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if ipv6_address_start:\n                    device_obj['ipv6'] = device_obj['ethernet'].Ipv6.add()\n                    ipv6Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],\n                                    ipv6_address_start=ipv6_address_start, **ipv6Kwargs)\n                    ipv6Obj.config()\n                    self.log.info(\"IPv6 Info configured successfully\")\n\n            # Create IGMP\n            if ('igmp' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if igmpKwargs:\n                    if 'ipv4' in device_obj:\n                        igmpObj = IGMP(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'],\n                                       igmp_group_start=igmp_group_start,\n                                       **igmpKwargs)\n                        igmpObj.config()\n                        self.log.info(\"Igmp Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv4 object not found\")\n                    if igmp_rate_interval:\n                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name,\n                                               device_name=device_name)\n            # Create MLD\n            if ('mld' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if mldKwargs:\n                    if 'ipv6' in device_obj:\n                        mldObj = MLD(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], mld_group_start=mld_group_start,\n                                     **mldKwargs)\n                        mldObj.config()\n                        self.log.info(\"Mld Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv6 object not found\")\n                    if mld_rate_interval:\n                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name,\n                                               device_name=device_name)\n            # Create BGPv4\n            if ('bgp_v4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if bgpv4Kwargs != {}:\n                    if 'ipv4' in device_obj:\n                        bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'], **bgpv4Kwargs)\n                        bgpv4Obj.config()\n                        self.log.info(\"BGPv4 Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv4 object not found\")\n            # Create BGPv6\n            if ('bgp_v6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if bgpv6Kwargs != {}:\n                    if 'ipv6' in device_obj:\n                        bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], **bgpv6Kwargs)\n                        bgpv6Obj.config()\n                        self.log.info(\"BGPv6 Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv6 object not found\")\n\n            #Create ipv4 routerId\n            if kwargs.get('ipv4_routerid', None) != None:\n                router_obj = device_obj['devicegroup'].RouterData.find().RouterId\n                if kwargs.get('ipv4_router_step'):\n                    router_obj.Increment(start_value = kwargs.get('ipv4_routerid'),\n                                            step_value = '0.0.0.' + str(kwargs.get('ipv4_router_step')))\n                else:\n                    router_obj.Single(kwargs.get('ipv4_routerid'))\n\n            #Create ipv6 routerId\n            if kwargs.get('ipv6_routerid', None) != None:\n                router_obj = device_obj['devicegroup'].RouterData.find().RouterId\n                if kwargs.get('ipv6_router_step'):\n                    router_obj.Increment(start_value = kwargs.get('ipv6_routerid'),\n                                            step_value = '0.0.0.' + str(kwargs.get('ipv6_router_step')))\n                else:\n                    router_obj.Single(kwargs.get('ipv6_routerid'))\n\n            retryCount = 0\n            while True:\n                if retryCount == 10: break\n                try:\n                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                    break\n                except:\n                    time.sleep(3)\n                    retryCount = retryCount + 1\n\n        if self.primary:\n            self.connect_to_chassis([self.primary])\n            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find() if\n                                      chassis.Hostname != self.primary]\n            if connected_chassis_list:\n                self.set_chassis_mode(primary=self.primary, secondary=connected_chassis_list)\n        return device_obj\n\n    def _update_traffic_vlan_data(self, configElement, **kwargs):\n\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param configElement: Config Element of Traffic Item, related to IXIA\n        :param kwargs: optional\n        \"\"\"\n\n        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName=\"VLAN\")]\n        if kwargs.get('stack_id', None):\n            stackObj = stackObjList[kwargs.get('stack_id', None)]\n        else:\n            stackObj = stackObjList[0]\n        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n        for fieldName in fieldNames:\n            if fieldName == \"VLAN-ID\":\n                if kwargs.get('vlan_mod_mode', None) == \"INCR\" or kwargs.get('vlan_mod_mode', None) is None:\n                    kwargs['vlan_mod_mode'] = 'increment'\n                if kwargs.get('vlan_count', None):\n                    kwargs['vlan_mod_count'] = kwargs.get('vlan_count', None)\n                if kwargs.get('vlan_id_count', None):\n                    kwargs['vlan_mod_count'] = kwargs.get('vlan_id_count', None)\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get('vlan_mod_mode', None), \\\n                        kwargs.get('vlan_id_start',None), kwargs.get('vlan_mod_count', None), kwargs.get('vlan_id_start', None), kwargs.get('vlan_mod_step', 1)\n            if fieldName == \"Protocol-ID\":\n                if kwargs.get('vlan_type', None):\n                    kwargs['vlan_type'] = kwargs.get('vlan_type', None)\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    field.ValueType, field.SingleValue, field.Auto, field.FieldValue = 'singleValue', kwargs.get(\n                        'vlan_type', None), 'True', kwargs.get('vlan_type', None)\n\n    def _ipv6_address_rfc5952(self, ip):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param ip: ipv6 address\n        :return: ipv6 address in rfc5952 format\n        \"\"\"\n        output=ipaddress.IPv6Address(ip)\n        output=output.compressed\n        return output\n\n    def _endpoint_source_handles(self, ip, sourcesList, topology, **kwargs):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param ip:  ipv4,ipv6 address\n        :param sourcesList: Traffic Endpoints\n        :param topology: TopologyName/TopologyObj which is endpoint\n        Optional kwargs :\n        :param src_network_group_name (list): Network group name if source is route start address\n        \"\"\"\n        sources_route_name = kwargs.get('sources_route_name', None)\n        if isinstance(ip,str):\n            ip = [ip]\n        if isinstance(ip,list):\n            for ip in ip:\n                if topology:\n                    if '.' in ip:\n                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            ipv4_list = ipv4.Address.Values\n                            if ip in ipv4_list:\n                                sourcesList.append(\n                                    {\"arg1\": ipv4.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv4_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if sources_route_name:\n                                for network_group in sources_route_name:\n                                    for ipv4_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\\\n                                            Ipv4PrefixPools.find():\n                                        ipv4_prefix_poolList = ipv4_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv4_prefix_poolList:\n                                            sourcesList.append({\"arg1\": ipv4_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv4_prefix_poolList.index(ip) + 1,\n                                                                \"arg5\": 1})\n                            else:\n                                for ipv4_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                    ipv4_prefix_poolList = ipv4_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv4_prefix_poolList:\n                                        sourcesList.append({\"arg1\": ipv4_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                            \"arg4\": ipv4_prefix_poolList.index(ip) + 1,\n                                                            \"arg5\": 1})\n                        except:\n                            pass\n                    elif ':' in ip:\n                        ip = self._ipv6_address_rfc5952(ip)\n                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            ipv6_list = ipv6.Address.Values\n                            if ip in ipv6_list:\n                                sourcesList.append(\n                                    {\"arg1\": ipv6.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv6_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if sources_route_name:\n                                for network_group in sources_route_name:\n                                    for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')\\\n                                            .Ipv6PrefixPools.find():\n                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv6_prefix_pool_list:\n                                            sourcesList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n                            else:\n                                for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv6_prefix_pool_list:\n                                        sourcesList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                            \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                            \"arg5\": 1})\n                        except:\n                            pass\n                    else:\n                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):\n                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href\n                            sourcesList.append(device_group_obj)\n                        else:\n                            for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():\n                                for vlan_obj in ethernet_obj.Vlan.find():\n                                    vlan_obj_list = vlan_obj.VlanId.Values\n                                    for value in vlan_obj_list:\n                                        if value == ip:\n                                            sourcesList.append({\"arg1\": ethernet_obj.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": vlan_obj_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n                else:\n                    if '.' in ip:\n                        for ipv4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            ipv4_list = ipv4.Address.Values\n                            if ip in ipv4_list:\n                                sourcesList.append(\n                                    {\"arg1\": ipv4.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv4_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if sources_route_name:\n                                for network_group in sources_route_name:\n                                    for ipv4_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find\\\n                                                (Name='^' + network_group + '$').Ipv4PrefixPools.find():\n                                        ipv4_prefix_pool_list = ipv4_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv4_prefix_pool_list:\n                                            sourcesList.append({\"arg1\": ipv4_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv4_prefix_pool_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n                            else:\n                                for ipv4_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                    ipv4_prefix_pool_list = ipv4_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv4_prefix_pool_list:\n                                        sourcesList.append({\"arg1\": ipv4_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                            \"arg4\": ipv4_prefix_pool_list.index(ip) + 1,\n                                                            \"arg5\": 1})\n                        except:\n                            pass\n                    elif ':' in ip:\n                        ip = self._ipv6_address_rfc5952(ip)\n                        for ipv6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            ipv6_list = ipv6.Address.Values\n                            if ip in ipv6_list:\n                                sourcesList.append(\n                                    {\"arg1\": ipv6.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv6_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if sources_route_name:\n                                for network_group in sources_route_name:\n                                    for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find()\\\n                                    .NetworkGroup.find(Name = '^' + network_group + '$').Ipv6PrefixPools.find():\n                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv6_prefix_pool_list:\n                                            sourcesList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n                            else:\n                                for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv6_prefix_pool_list:\n                                        sourcesList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                            \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                            \"arg5\": 1})\n                        except:\n                            pass\n                    else:\n                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):\n                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href\n                            sourcesList.append(device_group_obj)\n                        elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):\n                            networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href\n                            sourcesList.append(networkGroupObj)\n                        else:\n                            for ethernet_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():\n                                for vlan_obj in ethernet_obj.Vlan.find():\n                                    vlan_obj_list = vlan_obj.VlanId.Values\n                                    for value in vlan_obj_list:\n                                        if value == ip:\n                                            sourcesList.append({\"arg1\": ethernet_obj.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": vlan_obj_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n        return sourcesList\n\n    def _endpoint_destination_handles(self, ip, destinationsList, topology, **kwargs):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param ip: ipv4,ipv6 address\n        :param destinationsList: Traffic Endpoints\n        :param topology: TopologyName/TopologyObj which is endpoint\n        Optional kwargs :\n        :param dst_network_group_name (list): Network group name if destination is route start address\n        \"\"\"\n        destinations_route_name = kwargs.get('destinations_route_name', None)\n        if isinstance(ip,str):\n            ip = [ip]\n        if isinstance(ip,list):\n            for ip in ip:\n                if topology:\n                    if '.' in ip:\n                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            ipv4_list = ipv4.Address.Values\n                            if ip in ipv4_list:\n                                destinationsList.append(\n                                    {\"arg1\": ipv4.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv4_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if destinations_route_name:\n                                for network_group in destinations_route_name:\n                                    for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$')\\\n                                            .Ipv4PrefixPools.find():\n                                        ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values\n                                        if ip in ipv4PrefixPoolList:\n                                            destinationsList.append({\"arg1\": ipv4PrefixPool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": ipv4PrefixPoolList.index(ip) + 1, \"arg5\": 1})\n                            else:\n                                for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                    ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values\n                                    if ip in ipv4PrefixPoolList:\n                                        destinationsList.append({\"arg1\": ipv4PrefixPool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv4PrefixPoolList.index(ip) + 1, \"arg5\": 1})\n                        except:\n                            pass\n\n                    elif \":\" in ip:\n                        ip = self._ipv6_address_rfc5952(ip)\n                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            ipv6_list = ipv6.Address.Values\n                            if ip in ipv6_list:\n                                destinationsList.append(\n                                    {\"arg1\": ipv6.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv6_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if destinations_route_name:\n                                for network_group in destinations_route_name:\n                                    for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')\\\n                                            .Ipv6PrefixPools.find():\n                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv6_prefix_pool_list:\n                                            destinationsList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": ipv6_prefix_pool_list.index(ip) + 1, \"arg5\": 1})\n                            else:\n                                for ipv6_prefix_pool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv6_prefix_pool_list:\n                                        destinationsList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv6_prefix_pool_list.index(ip) + 1, \"arg5\": 1})\n\n                        except:\n                            pass\n                    else:\n                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):\n                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href\n                            destinationsList.append(device_group_obj)\n                        else:\n                            for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():\n                                for vlan_obj in ethernet_obj.Vlan.find():\n                                    vlan_obj_list = vlan_obj.VlanId.Values\n                                    for value in vlan_obj_list:\n                                        if value == ip:\n                                            destinationsList.append({\"arg1\": ethernet_obj.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": vlan_obj_list.index(ip) + 1, \"arg5\": 1})\n\n                else:\n                    if '.' in ip:\n                        for ipv4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            ipv4_list = ipv4.Address.Values\n                            if ip in ipv4_list:\n                                destinationsList.append(\n                                    {\"arg1\": ipv4.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv4_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if destinations_route_name:\n                                for network_group in destinations_route_name:\n                                    for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().\\\n                                            NetworkGroup.find(Name='^'+network_group+'$').Ipv4PrefixPools.find():\n                                        ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values\n                                        if ip in ipv4PrefixPoolList:\n                                            destinationsList.append({\"arg1\": ipv4PrefixPool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": ipv4PrefixPoolList.index(ip) + 1,\n                                                                    \"arg5\": 1})\n                            else:\n                                for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                    ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values\n                                    if ip in ipv4PrefixPoolList:\n                                        destinationsList.append({\"arg1\": ipv4PrefixPool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv4PrefixPoolList.index(ip) + 1,\n                                                                \"arg5\": 1})\n                        except:\n                            pass\n\n                    elif \":\" in ip:\n                        ip = self._ipv6_address_rfc5952(ip)\n                        for ipv6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            ipv6_list = ipv6.Address.Values\n                            if ip in ipv6_list:\n                                destinationsList.append(\n                                    {\"arg1\": ipv6.href, \"arg2\": 1, \"arg3\": 1, \"arg4\": ipv6_list.index(ip) + 1, \"arg5\": 1})\n                        try:\n                            if destinations_route_name:\n                                for network_group in destinations_route_name:\n                                    for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().\\\n                                            NetworkGroup.find(Name='^'+network_group+'$').Ipv6PrefixPools.find():\n                                        ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                        if ip in ipv6_prefix_pool_list:\n                                            destinationsList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                                    \"arg5\": 1})\n                            else:\n                                for ipv6_prefix_pool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                    ipv6_prefix_pool_list = ipv6_prefix_pool.NetworkAddress.Values\n                                    if ip in ipv6_prefix_pool_list:\n                                        destinationsList.append({\"arg1\": ipv6_prefix_pool.href, \"arg2\": 1, \"arg3\": 1,\n                                                                \"arg4\": ipv6_prefix_pool_list.index(ip) + 1,\n                                                                \"arg5\": 1})\n                        except:\n                            pass\n                    else:\n                        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):\n                            device_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href\n                            destinationsList.append(device_group_obj)\n                        elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):\n                            network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href\n                            destinationsList.append(network_group_obj)\n                        else:\n                            for ethernet_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():\n                                for vlan_obj in ethernet_obj.Vlan.find():\n                                    vlan_obj_list = vlan_obj.VlanId.Values\n                                    for value in vlan_obj_list:\n                                        if value == ip:\n                                            destinationsList.append({\"arg1\": ethernet_obj.href, \"arg2\": 1, \"arg3\": 1,\n                                                                    \"arg4\": vlan_obj_list.index(ip) + 1,\n                                                                    \"arg5\": 1})\n        return destinationsList\n\n    def _update_traffic_ipv4_data(self, configElement, **kwargs):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param configElement:  Traffic Item Config Element\n        :param kwargs: Optional\n        \"\"\"\n\n        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName=\"IPv4\")]\n        if kwargs.get('stack_id', None):\n            stackObj = stackObjList[kwargs.get('stack_id', None)]\n        else:\n            stackObj = stackObjList[0]\n        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n        for fieldName in fieldNames:\n            if fieldName == \"Source Address\":\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    if isinstance(kwargs['v4_src_value'], str):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs['v4_src_value']\n                        field.StepValue = kwargs.get('v4_src_step', \"0.0.0.1\")\n                        field.CountValue = kwargs.get('v4_src_count', 1)\n                    if isinstance(kwargs.get('v4_src_value'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs['v4_src_value']\n            if fieldName == \"Destination Address\":\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    if isinstance(kwargs['v4_dst_value'], str):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs['v4_dst_value']\n                        field.StepValue = kwargs.get('v4_dst_step', \"0.0.0.1\")\n                        field.CountValue = kwargs.get('v4_dst_count', 1)\n                    if isinstance(kwargs.get('v4_dst_value'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs['v4_dst_value']\n            if fieldName == 'TTL (Time to live)':\n                field_obj_list = stackObj.Field.find(Name='ttl')\n                for field in field_obj_list:\n                    if isinstance(kwargs.get('v4_ttl', None), int):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs.get('v4_ttl')\n                        field.StepValue = kwargs.get('v4_ttl_step', 1)\n                        field.CountValue = kwargs.get('v4_ttl_count', 1)\n                    if isinstance(kwargs.get('v4_ttl', None), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs.get('v4_ttl')\n            if fieldName == \"Protocol\":\n                field_obj_list = stackObj.Field.find(DisplayName=fieldName)\n                for field in field_obj_list:\n                    if isinstance(kwargs.get('v4_protocol', None), int):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs.get('v4_protocol', None)\n                        field.StepValue = kwargs.get('v4_protocol_step', 1)\n                        field.CountValue = kwargs.get('v4_protocol_count', 1)\n                    if isinstance(kwargs.get('v4_protocol', None), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs.get('v4_protocol', None)\n                    if isinstance(kwargs.get('v4_protocol', None), str):\n                        field.Auto = False\n                        field.ValueType = 'singleValue'\n                        field.FieldValue = kwargs.get('v4_protocol', None)\n\n\n    def _update_traffic_ipv6_data(self, configElement, **kwargs):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param configElement:  Traffic Item Config Element\n        :param kwargs: Optional\n        \"\"\"\n\n        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName=\"IPv6\")]\n        if kwargs.get('stack_id', None):\n            stackObj = stackObjList[kwargs.get('stack_id', None)]\n        else:\n            stackObj = stackObjList[0]\n        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n        for fieldName in fieldNames:\n            if fieldName == \"Source Address\":\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    if isinstance(kwargs['v6_src_value'], str):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs['v6_src_value']\n                        field.StepValue = kwargs.get('v6_src_step', \"0::1\")\n                        field.CountValue = kwargs.get('v6_src_count', 1)\n                    if isinstance(kwargs.get('v6_src_value'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs['v6_src_value']\n            if fieldName == \"Destination Address\":\n                fieldObjList = stackObj.Field.find(DisplayName=fieldName)\n                for field in fieldObjList:\n                    if isinstance(kwargs['v6_dst_value'], str):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs['v6_dst_value']\n                        field.StepValue = kwargs.get('v6_dst_step', \"::1\")\n                        field.CountValue = kwargs.get('v6_dst_count', 1)\n                    if isinstance(kwargs.get('v6_dst_value'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs['v6_dst_value']\n            if fieldName == \"Flow Label\":\n                field_obj_list = stackObj.Field.find(DisplayName=fieldName)\n                for field in field_obj_list:\n                    if isinstance(kwargs.get('v6_flow_label'), int):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs.get('v6_flow_label', None)\n                        field.StepValue = kwargs.get('v6_label_step', 1)\n                        field.CountValue = kwargs.get('v6_label_count', 1)\n                    if isinstance(kwargs.get('v6_flow_label'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs.get('v6_flow_label', None)\n            if fieldName == \"Hop Limit\":\n                field_obj_list = stackObj.Field.find(DisplayName=fieldName)\n                for field in field_obj_list:\n                    if isinstance(kwargs.get('v6_ttl'), int):\n                        field.Auto = False\n                        field.ValueType = 'increment'\n                        field.StartValue = kwargs.get('v6_ttl')\n                        field.StepValue = kwargs.get('v6_ttl_step', 1)\n                        field.CountValue = kwargs.get('v6_ttl_count', 1)\n                    if isinstance(kwargs.get('v6_ttl'), list):\n                        field.Auto = False\n                        field.ValueType = 'valueList'\n                        field.ValueList = kwargs['v6_ttl']\n\n    def _expand_ipv6_address(self, ip):\n        \"\"\"\n        Function used internally by API add_traffic_stream\n\n        :param ip: ipv6 address\n        :return: expanded ipv6 address\n        \"\"\"\n        if \"::\" in ip:\n            match = re.search(\"^([a-fA-F0-9]+):([a-fA-F0-9]+):([a-fA-F0-9]+)::([a-fA-F0-9]+)$\", ip)\n            ip = match.group(1) + \":\" + match.group(2) + \":\" + match.group(3) + \":0:0:0:0:\" + match.group(4)\n        if \"::\" in ip:\n            match = re.search(\"^([a-fA-F0-9]+)::([a-fA-F0-9]+)$\", ip)\n            ip = match.group(1) + \":0:0:0:0:0:0:\" + match.group(2)\n        return ip\n\n    def add_traffic_stream(self,\n                           sources,\n                           destinations,\n                           mcast_destinations=None,\n                           traffic_type='ipv4',\n                           **kwargs):\n        \"\"\"\n        API for adding a new L2/L3 traffic item in IXIA config\n        :param sources: A list of sources\n        :param destinations: A list of destinations\n        :param mcast_destinations: A list of mcast destinations\n        :param mcast_destinations_index : A list of mcast destinations index. Default is all\n        :param traffic_type: The traffic type to use (ipv4/ipv6)\n        Mandatory Args:\n        :param sources (list): A list of address sources\n            e.g. ['172.16.0.1', '172.16.50.1', '172.16.100.1']\n        :param destinations (list): A list of addresses or route ranges\n            e.g. ['225.0.0.1', '225.1.0.1', '225.1.0.21']\n        Optional Args:\n        :param traffic_type (str): The address family that you wish to use for\n            this traffic item ['ipv4'|'ipv6']\n        :param is_mcast_dest (bool): Designates if this\n        Optional kwargs (for creating stream objects via zap):\n        :param src_ports (list): Source ports. Ex: src_ports = ['2/9']\n        :param dst_ports (list): Destionation ports. Ex: dst_ports = ['2/10']\n        Traffic\n        :param traffic_item_name (str): The traffic items name\n        :param src_dest_mesh_type (str): Options are fullMesh,manyToMany,none,oneToOne\n        :param route_mesh_type (str): Options are fullMesh,oneToOne\n        :param bidirectional (bool): If true, enables bidirectional for a traffic item\n        :param transmit_mode (str): Options are interleaved,sequential\n        :param enabled (boo): If true, enable the traffic item\n        Frame Payload\n        :param payload_type (str): Options are CJPAT,CRPAT,custom,decrementByte,\n                decrementWord,incrementByte,incrementWord,random\n        :param payload_custom_pattern (str): The custom pattern in hex format\n        :param payload_custom_repeat (bool): If true, repeat the custom pattern\n        Frame Rate\n        :param rate_type (str): Options are bitsPerSecond,framesPerSecond,\n                interPacketGap,percentLineRate\n        :param bit_rate_units (str): Options are bitsPerSec,bytesPerSec,kbitsPerSec,\n                kbytesPerSec,mbitsPerSec,mbytesPerSec\n        :param frame_rate (int): The frame transmission rate\n        :param enforce_min_inter_packet_gap (int): Sets the minimum inter-packet gap\n        :param inter_packet_gap_units_type (str): Options are bytes,nanoseconds\n        Frame Rate Distribution\n        :param port_distribution (str): applyRateToAll,splitRateEvenly\n        :param stream_distribution (str): applyRateToAll,splitRateEvenly\n        Frame Size\n        :param frame_size_type (str): Options are auto,fixed,increment,presetDistribution,\n                 quadGaussian,random,weightedPairs\n        :param frame_size_fixed_size (int): Sets a fixed frame size\n        :param frame_size_increment_start (int): Specifies the Start Value if the Frame\n                Size is incremented\n        :param frame_size_increment_stop (int): Specifies the Final Value if the Frame\n                Size is Incremented\n        :param frame_size_increment_step (int): Specifies the Step Value if the Frame\n                Size is Incremented\n        :param frame_size_preset_distribution (str): Options are cisco,imix,ipSecImix,ipV6Imix,\n                prQuar,rprTri,standardImix,tcpImix,tolly\n        :param frame_size_quad_gaussian (list): Please reference the below address for details\n                <IXIA_API_SERVER>:25445/api/v1/meta/traffic/trafficItem/configElement/frameSize\n        :param frame_size_random_min (int): Minimum frame size length (in bytes). Max is 64\n        :param frame_size_random_max (int): Maximum frame size length (in bytes). Max is 1518\n        :param frame_size_weighted_pairs (list): Defines the values for a list of weighted pairs\n        :param frame_size_weighted_pairs_range (list): Defines the range for a list of weighted pairs\n        :param sources_route_name (list): source network group name\n        :param ipv4_precedence_full_mesh (bool): ipv4 precedence full meshed\n        :param destinations_route_name (list): destination network group name\n        :param stats_track_by (list): track the traffic item by  ['customOverride', 'sourceDestValuePair0',\n                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',\n                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',\n                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',\n                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',\n                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',\n                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',\n                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']\n        :return: (obj): The stream object\n        :Example: add_traffic_stream(sources=['109.1.0.2'],destinations=['109.1.0.1'],mcast_destinations=['225.0.0.1'], rate_type='framesPerSecond', frame_rate=20, frame_size_fixed_size=128)\n        \"\"\"\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n        #     return\n\n        sources_route_name = kwargs.get('sources_route_name', None)\n        destinations_route_name = kwargs.get('destinations_route_name', None)\n        stats_track_by = kwargs.get('stats_track_by', None)\n        mcast_destinations_index = kwargs.get('mcast_destinations_index', 'all')\n        traffic_stream_type = kwargs.get('traffic_stream_type', None)\n        if traffic_stream_type and traffic_stream_type != 'bound':\n            traffic_type = traffic_stream_type\n        if 'port_name' in kwargs:\n            if kwargs['port_name'].startswith(\"Port\"):\n                kwargs['port_name'] = kwargs['port_name'].split(\"Port //\")[1]\n\n        if 'src_ports' in kwargs:\n            temp_src_ports = []\n            for src_port in kwargs['src_ports']:\n                if src_port.startswith(\"Port\"):\n                    temp_src_ports.append(src_port.split(\"Port //\")[1])\n            if temp_src_ports:\n                kwargs['src_ports'] = temp_src_ports\n            if sources:\n                sources = None\n\n        if 'dst_ports' in kwargs:\n            temp_dst_ports = []\n            for dst_port in kwargs['dst_ports']:\n                if dst_port.startswith(\"Port\"):\n                    temp_dst_ports.append(dst_port.split(\"Port //\")[1])\n            if temp_dst_ports:\n                kwargs['dst_ports'] = temp_dst_ports\n            if destinations:\n                destinations = None\n\n        self.log.info(\"Adding New Traffic Stream\")\n        self.ixNetwork.Traffic.UseRfc5952 = True\n        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True\n        stream_obj = kwargs.get('stream_obj', {})\n        if 'traffic' not in stream_obj and 'traffic_item' not in stream_obj:\n            if traffic_type == 'eth' or traffic_type == 'ethernetVlan':\n                traffic_type = 'ethernetVlan'\n                if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None):\n                    traffic_type = 'raw'\n                if sources is None or destinations is None:\n                    traffic_type = 'raw'\n            elif traffic_type == \"ipv4\" and kwargs.get(\"v4_src_value\", None) is None and kwargs.get(\"v4_src_count\",\n                                                                                                    None) is None:\n                traffic_type = 'ipv4'\n            elif traffic_type == \"ipv6\" and kwargs.get(\"v6_src_value\", None) is None and kwargs.get(\"v6_src_count\",\n                                                                                                    None) is None:\n                traffic_type = 'ipv6'\n            else:\n                traffic_type = 'raw'\n            if traffic_type == 'ethernetVlan':\n                if sources or destinations:\n                    for source in sources:\n                        if '.' in source or ':' in source:\n                            raise IxiaConfigException(\n                                \"For Ethernet stream please pass deviceGroup name instead of Ip address\")\n                    for destination in destinations:\n                        if '.' in destination or ':' in destination:\n                            raise IxiaConfigException(\n                                \"For Ethernet stream please pass deviceGroup name instead of Ip address\")\n            trafficItem = self.ixNetwork.Traffic.TrafficItem.add(TrafficType=traffic_type,\n                                                                 SrcDestMesh=kwargs.get('src_dest_mesh_type', None),\n                                                                 RouteMesh=kwargs.get('route_mesh_type', None),\n                                                                 BiDirectional=kwargs.get('bidirectional', None),\n                                                                 TransmitMode=kwargs.get('transmit_mode', None),\n                                                                 Enabled=kwargs.get('enabled', True))\n            self.ixNetwork.Traffic.EnableMinFrameSize = 'True'\n            if 'traffic_item_name' in kwargs:\n                trafficItem.Name = kwargs['traffic_item_name']\n            stream_obj['traffic'] = trafficItem\n        # self.log.info(\"Adding Endpoints for Traffic stream %s\" % stream_obj['traffic'])\n        self.log.info(\"Added Traffic Stream %s\" % stream_obj['traffic'])\n        self.log.info(\"Adding Endpoints for Traffic stream - '%s'\" % trafficItem.Name) # Change the log info to TI Name\n        if 'endpoint_sets' not in stream_obj:\n            sourcesList = []\n            destinationsList = []\n            multicastDestinations = []\n            multicast_address = []\n            if traffic_type == 'raw':\n                if kwargs.get('src_ports', None):\n                    portName = kwargs.get(\"port_name\", None)\n                    for srcPort in kwargs['src_ports']:\n                        portNameList = self._get_port_name_list([srcPort])\n                        for portName in portNameList:\n                            vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                            sourcesList.append(vportHref + '/protocols')\n                else:\n                    portName = kwargs.get(\"port_name\", None)\n                    vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                    sourcesList.append(vportHref + '/protocols')\n            else:\n                if kwargs.get('src_ports', None):\n                    portNameList = self._get_port_name_list(kwargs['src_ports'])\n                    portName = kwargs.get(\"port_name\", None)\n                    if portName in portNameList:\n                        for topology in self.ixNetwork.Topology.find():\n                            if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                if sources:\n                                    for sourceIp in sources:\n                                        self._endpoint_source_handles(sourceIp, sourcesList, topology)\n                                else:\n                                    for srcPort in kwargs['src_ports']:\n                                        portNameList = self._get_port_name_list([srcPort])\n                                        if portName in portNameList:\n                                            vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                                            sourcesList.append(vportHref + '/protocols')\n                else:\n                    if sources:\n                        for sourceIp in sources:\n                            self._endpoint_source_handles(sourceIp, sourcesList, topology=None, sources_route_name=sources_route_name)\n                    if kwargs.get('src_ports', None):\n                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n                        portName = kwargs.get(\"port_name\", None)\n                        if portName in portNameList:\n                            vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                            sourcesList.append(vportHref + '/protocols')\n                    if kwargs.get(\"v4_src_addr\", None):\n                        self._endpoint_source_handles(kwargs[\"v4_src_addr\"], sourcesList, topology=None)\n                    if kwargs.get(\"v6_src_addr\", None):\n                        self._endpoint_source_handles(kwargs[\"v6_src_addr\"], sourcesList, topology=None)\n            if traffic_type == 'raw':\n                if kwargs.get('dst_ports', None):\n                    portname = kwargs.get(\"port_name\", None)\n                    for dstPort in kwargs['dst_ports']:\n                        portNameList = self._get_port_name_list([dstPort])\n                        for portName in portNameList:\n                            if portName != portname:\n                                vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                                destinationsList.append(vportHref + '/protocols')\n                else:\n                    portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n                    portname = kwargs.get(\"port_name\", None)\n                    for portName in portNameList:\n                        if portName != portname:\n                            vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                            destinationsList.append(vportHref + '/protocols')\n            else:\n                if kwargs.get('dst_ports', None):\n                    portNameList = self._get_port_name_list(kwargs['dst_ports'])\n                    portname = kwargs.get(\"port_name\", None)\n                    for portName in portNameList:\n                        if portName != portname:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                    if destinations:\n                                        for dstIp in destinations:\n                                            self._endpoint_destination_handles(dstIp, destinationsList, topology)\n                                    else:\n                                        if kwargs.get('dst_ports', None):\n                                            for dstPort in kwargs['dst_ports']:\n                                                portNameList = self._get_port_name_list([dstPort])\n                                                for portName in portNameList:\n                                                    if portName != portname:\n                                                        vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                                                        destinationsList.append(vportHref + '/protocols')\n                else:\n                    if destinations:\n                        for dstIp in destinations:\n                            self._endpoint_destination_handles(dstIp, destinationsList, topology=None, destinations_route_name=destinations_route_name)\n                    if kwargs.get('dst_ports', None):\n                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n                        portname = kwargs.get(\"port_name\", None)\n                        for portName in portNameList:\n                            if portName != portname:\n                                vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                                destinationsList.append(vportHref + '/protocols')\n                    if kwargs.get(\"v4_dst_addr\", None):\n                        self._endpoint_destination_handles(kwargs[\"v4_dst_addr\"], destinationsList, topology=None)\n                    if kwargs.get(\"v6_dst_addr\", None):\n                        self._endpoint_destination_handles(kwargs[\"v6_dst_addr\"], destinationsList, topology=None)\n\n            if kwargs.get('src_ports', None) is None and sources is None:\n                if traffic_type == 'raw':\n                    if kwargs.get('v4_src_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        if kwargs.get('port_name', None) in portNameList:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == self.ixNetwork.Vport.find(\n                                        Name=kwargs.get('port_name', None)).href:\n                                    if '.' in kwargs['v4_src_addr']:\n                                        nameList = [name.Name for name in\n                                                    topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]\n                                        for name in nameList:\n                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(\n                                                Name=name).Address\n                                            if kwargs['v4_src_addr'] in address.Values:\n                                                sourcesList.append(self.ixNetwork.Vport.find(\n                                                    Name=kwargs.get('port_name', None)).href + '/protocols')\n                    if kwargs.get('v6_src_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        if kwargs.get('port_name', None) in portNameList:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == self.ixNetwork.Vport.find(\n                                        Name=kwargs.get('port_name', None)).href:\n                                    if ':' in kwargs['v6_src_addr']:\n                                        nameList = [name.Name for name in\n                                                    topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]\n                                        for name in nameList:\n                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(\n                                                Name=name).Address\n                                            if kwargs['v6_src_addr'] in address.Values:\n                                                sourcesList.append(self.ixNetwork.Vport.find(\n                                                    Name=kwargs.get('port_name', None)).href + '/protocols')\n                else:\n                    if kwargs.get('v4_src_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        if kwargs.get('port_name', None) in portNameList:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == self.ixNetwork.Vport.find(\n                                        Name=kwargs.get('port_name', None)).href:\n                                    self._endpoint_source_handles(kwargs['v4_src_addr'], sourcesList, topology)\n                    if kwargs.get('v6_src_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        if kwargs.get('port_name', None) in portNameList:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == self.ixNetwork.Vport.find(\n                                        Name=kwargs.get('port_name', None)).href:\n                                    self._endpoint_source_handles(kwargs['v6_src_addr'], sourcesList, topology)\n            if kwargs.get('dst_ports', None) is None and destinations is None:\n                if traffic_type == 'raw':\n                    if kwargs.get('v4_dst_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        for portName in portNameList:\n                            if kwargs.get('port_name', None) != portName:\n                                for topology in self.ixNetwork.Topology.find():\n                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                        if '.' in kwargs['v4_dst_addr']:\n                                            nameList = [name.Name for name in\n                                                        topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]\n                                            for name in nameList:\n                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(\n                                                    Name=name).Address\n                                                if kwargs['v4_dst_addr'] in address.Values:\n                                                    destinationsList.append(self.ixNetwork.Vport.find(\n                                                        Name=kwargs.get('port_name', None)).href + '/protocols')\n                                                    break\n                    if kwargs.get('v6_dst_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        for portName in portNameList:\n                            if kwargs.get('port_name', None) != portName:\n                                for topology in self.ixNetwork.Topology.find():\n                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                        if ':' in kwargs['v6_dst_addr']:\n                                            nameList = [name.Name for name in\n                                                        topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]\n                                            for name in nameList:\n                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(\n                                                    Name=name).Address\n                                                if kwargs['v6_dst_addr'] in address.Values:\n                                                    destinationsList.append(self.ixNetwork.Vport.find(\n                                                        Name=kwargs.get('port_name', None)).href + '/protocols')\n                                                    break\n                else:\n                    if kwargs.get('v4_dst_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        for portName in portNameList:\n                            if kwargs.get('port_name', None) != portName:\n                                for topology in self.ixNetwork.Topology.find():\n                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                        self._endpoint_source_handles(kwargs['v4_dst_addr'], destinationsList, topology)\n                    if kwargs.get('v6_dst_addr', None):\n                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]\n                        for portName in portNameList:\n                            if kwargs.get('port_name', None) != portName:\n                                for topology in self.ixNetwork.Topology.find():\n                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                        self._endpoint_source_handles(kwargs['v6_dst_addr'], destinationsList, topology)\n            if mcast_destinations:\n                # search igmp/mld\n                if traffic_type == 'ipv4':\n                    try:\n                        for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find():\n                            igmpStartMcastAddressList = igmpMcastObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values\n                            for mcast_dest_ip in mcast_destinations:\n                                if mcast_dest_ip in igmpStartMcastAddressList:\n                                    if mcast_destinations_index == 'all':\n                                        multicast_address.append({\"arg1\": False, \"arg2\": \"none\",\n                                                                 \"arg3\": mcast_dest_ip, \"arg4\": str(\n                                                igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrIncr),\n                                                                 'arg5': str(\n                                                                     igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrCnt)})\n                                    else:\n                                        device_group_href = re.sub(r'/ethernet/\\d+/ipv4/\\d+/igmpHost/\\d+', '',\n                                                                   igmpMcastObj.href)\n                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(\n                                            device_group_href).Multiplier\n\n                                        for index in mcast_destinations_index:\n                                            multicastDestinations.append(\n                                                {\"arg1\": igmpMcastObj.IgmpMcastIPv4GroupList.href,\n                                                 \"arg2\": ((index - 1) // device_multiplier),\n                                                 \"arg3\": ((index - 1) % device_multiplier), \"arg4\": 0})\n\n                        for pimv4_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find():\n                            pimv4_group_address_list = pimv4_obj.PimV4JoinPruneList.GroupV4Address.Values\n                            for mcast_dest_ip in mcast_destinations:\n                                if mcast_dest_ip in pimv4_group_address_list:\n                                    if mcast_destinations_index == 'all':\n                                        multicast_address.append({\"arg1\": False, \"arg2\": \"none\",\n                                                                 \"arg3\": mcast_dest_ip, \"arg4\": \"0.0.0.1\", 'arg5': str(\n                                                pimv4_obj.PimV4JoinPruneList.GroupAddressCount)})\n                                    else:\n                                        device_group_href = re.sub(r'/ethernet/\\d+/ipv4/\\d+/pimV4Interface/\\d+', '',\n                                                                   pimv4_obj.href)\n                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(\n                                            device_group_href).Multiplier\n\n                                        for index in mcast_destinations_index:\n                                            multicastDestinations.append(\n                                                {\"arg1\": pimv4_obj.PimV4JoinPruneList.href,\n                                                 \"arg2\": ((index - 1) // device_multiplier),\n                                                 \"arg3\": ((index - 1) % device_multiplier), \"arg4\": 0})\n                    except:\n                        pass\n                if traffic_type == 'ipv6':\n                    try:\n                        for mldMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find():\n                            mldStartMcastAddressList = mldMcastObj.MldMcastIPv6GroupList.StartMcastAddr.Values\n                            for mcast_dest_ip in mcast_destinations:\n                                mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)\n                                if mcast_ip in mldStartMcastAddressList:\n                                    if mcast_destinations_index == 'all':\n                                        multicast_address.append({\"arg1\": False, \"arg2\": \"none\",\n                                                                 \"arg3\": mcast_ip, \"arg4\": str(\n                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrIncr), 'arg5': str(\n                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrCnt)})\n                                    else:\n                                        device_group_href = re.sub(r'/ethernet/\\d+/ipv6/\\d+/mldHost/\\d+', '',\n                                                                   mldMcastObj.href)\n                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(\n                                            device_group_href).Multiplier\n                                        for index in mcast_destinations_index:\n                                            multicastDestinations.append(\n                                                {\"arg1\": mldMcastObj.MldMcastIPv6GroupList.href,\n                                                 \"arg2\": ((index - 1) // device_multiplier),\n                                                 \"arg3\": ((index - 1) % device_multiplier), \"arg4\": 0})\n                        for pimv6_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find():\n                            pimv6_group_address_list = pimv6_obj.PimV6JoinPruneList.GroupV6Address.Values\n                            for mcast_dest_ip in mcast_destinations:\n                                if mcast_dest_ip in pimv6_group_address_list:\n                                    mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)\n                                    if mcast_destinations_index == 'all':\n                                        if mcast_ip in pimv6_group_address_list:\n                                            multicast_address.append({\"arg1\": False, \"arg2\": \"none\",\n                                                                     \"arg3\": mcast_ip, \"arg4\": \"::0.0.0.1\", 'arg5': str(\n                                                    pimv6_obj.PimV6JoinPruneList.GroupAddressCount)})\n                                    else:\n                                        device_group_href = re.sub(r'/ethernet/\\d+/ipv6/\\d+/pimV6Interface/\\d+', '',\n                                                                   pimv6_obj.href)\n                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(\n                                            device_group_href).Multiplier\n                                        for index in mcast_destinations_index:\n                                            multicastDestinations.append(\n                                                {\"arg1\": pimv6_obj.PimV6JoinPruneList.href,\n                                                 \"arg2\": ((index - 1) // device_multiplier),\n                                                 \"arg3\": ((index - 1) % device_multiplier), \"arg4\": 0})\n                    except:\n                        pass\n                if not kwargs.get('src_dest_mesh_type', '') == 'manyToMany':\n                    for source in sourcesList:\n                        for destination in multicastDestinations:\n                            if source['arg1'] in destination['arg1']:\n                                del multicastDestinations[multicastDestinations.index(destination)]\n            if sourcesList == []:\n                self.log.error('sourcesList are empty')\n                raise IxiaConfigException('sourcesList are empty')\n\n        if destinationsList:\n            try:\n                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]\n            except:\n                destinations_list = destinationsList\n            if 'src_ports' in kwargs and 'dst_ports' in kwargs or \\\n                isinstance(sourcesList[0], str) and isinstance(destinations_list[0], str):\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,\n                                                                          Destinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n            elif isinstance(destinations_list[0], dict) and isinstance(sourcesList[0], str):\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,\n                                                                          ScalableDestinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n            elif isinstance(destinations_list[0], str) and isinstance(sourcesList[0], dict):\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,\n                                                                          Destinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n            else:\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,\n                                                                          ScalableDestinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n        if multicastDestinations:\n            try:\n                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]\n            except:\n                destinations_list = destinationsList\n            if isinstance(multicastDestinations[0], dict) and isinstance(sourcesList[0], str):\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,\n                                                                          ScalableDestinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n            else:\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,\n                                                                          ScalableSources=sourcesList,\n                                                                          ScalableDestinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n        if multicast_address:\n            try:\n                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]\n            except:\n                destinations_list = destinationsList\n            if isinstance(multicast_address[0], dict) and isinstance(sourcesList[0], str):\n                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,\n                                                                          ScalableDestinations=destinations_list,\n                                                                          MulticastReceivers=multicastDestinations)\n            else:\n                if mcast_destinations_index == 'all':\n                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,\n                                                                              ScalableSources=sourcesList,\n                                                                              ScalableDestinations=destinations_list,\n                                                                              MulticastDestinations=multicast_address)\n                else:\n                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,\n                                                                              ScalableSources=sourcesList,\n                                                                              ScalableDestinations=destinations_list,\n                                                                              MulticastReceivers=multicastDestinations)\n        # self.log.info(\"Added Endpoints %s\" % stream_obj['endpoint_sets'])\n        self.log.info(\"Added Endpoints for Traffic stream - '%s'\" % trafficItem.Name)\n        configElement = trafficItem.ConfigElement.find()[0]\n\n        if kwargs.get('vlan_id_start', None) or kwargs.get('vlan_id_count', None):\n            ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')\n            vlanStack = configElement.Stack.find(StackTypeId='^vlan$')\n            if ethernetStack and not vlanStack:\n                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))\n                self._update_traffic_vlan_data(configElement, **kwargs)\n            else:\n                self._update_traffic_vlan_data(configElement, **kwargs)\n        vlanEnable = True\n        if kwargs.get('vlan_mod_dict', None):\n            vlanList = kwargs.get('vlan_mod_dict', None)\n            count = 0\n            for key, value in vlanList.items():\n                kwargs['vlan_id_start'] = key\n                kwargs['stack_id'] = count\n                for vlanParam, vlanValue in value.items():\n                    kwargs[vlanParam] = vlanValue\n                portName = kwargs.get('port_name', None)\n                if traffic_type !='raw':\n                    if self.ixNetwork.Topology.find():\n                        for topology in self.ixNetwork.Topology.find():\n                            if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                                for ethernet_obj in topology.DeviceGroup.find().Ethernet.find():\n                                    for value in ethernet_obj.EnableVlans.Values:\n                                        if value == \"false\":\n                                            vlan_enable = False\n                                    if traffic_type == 'raw':\n                                        vlan_enable = False\n                                if count == 0:\n                                    if vlan_enable == False:\n                                        ethernet_stack = configElement.Stack.find(StackTypeId='^ethernet$')\n                                        vlan_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                                        configElement.Stack.read(ethernet_stack.AppendProtocol(vlan_template))\n                                else:\n                                    if vlan_enable == False:\n                                        vlan_stack = configElement.Stack.find(StackTypeId='^vlan$')\n                                        vlan_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                                        configElement.Stack.read(vlan_stack.AppendProtocol(vlan_template))\n                else:\n                    if vlanEnable == True and count == 0:\n                        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')\n                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                        configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))\n                    else:\n                        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')\n                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                        configElement.Stack.read(vlanStack.AppendProtocol(vlanTemplate))\n                count = count + 1\n                self._update_traffic_vlan_data(configElement, **kwargs)\n            self.log.info(\"Added Ethernet/Vlan for Stream %s\" % stream_obj['traffic'])\n\n        if traffic_type == 'raw':\n            if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',\n                                                                                                None) is None or kwargs.get(\n                'eth_dst_mac', None) is None:\n                stream_obj['field'] = configElement.Stack.find().Field.find()\n                if kwargs.get('eth_dst_mac_mode', None) == \"INCR\" or kwargs.get('eth_dst_mac_mode', None) is None:\n                    kwargs['eth_dst_mac_mode'] = 'increment'\n                field = configElement.Stack.find().Field.find(DisplayName=\"Destination MAC Address\")\n                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                    'eth_dst_mac_mode', None), \\\n                                                                                                         kwargs.get(\n                                                                                                             'eth_dst_mac',\n                                                                                                             \"00:00:00:00:01:01\"), kwargs.get(\n                    'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', \"00:00:00:00:01:01\"), kwargs.get(\n                    'eth_dst_mac_step', \"00:00:00:00:00:01\")\n\n                if kwargs.get('eth_src_mac_mode', None) == \"INCR\" or kwargs.get('eth_src_mac_mode', None) is None:\n                    kwargs['eth_src_mac_mode'] = 'increment'\n                field = configElement.Stack.find().Field.find(DisplayName=\"Source MAC Address\")\n                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                    'eth_src_mac_mode', None), \\\n                                                                                                         kwargs.get(\n                                                                                                             'eth_src_mac',\n                                                                                                             \"00:00:00:00:00:01\"), kwargs.get(\n                    'eth_src_mac_count', 1), kwargs.get('eth_src_mac', \"00:00:00:00:00:01\"), kwargs.get(\n                    'eth_src_mac_step', \"00:00:00:00:00:01\")\n            if kwargs.get('v4_src_addr', None):\n                kwargs['v4_src_value'] = kwargs['v4_src_addr']\n            if kwargs.get('v4_dst_addr', None):\n                kwargs['v4_dst_value'] = kwargs['v4_dst_addr']\n            if kwargs.get('v4_src_value', None) or kwargs.get('v4_src_count', None):\n                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')\n                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')\n                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')\n                if ipv4Stack:\n                    kwargs['stack_id'] = 0\n                    self._update_traffic_ipv4_data(configElement, **kwargs)\n                else:\n                    if ethernetStack and vlanStack and not ipv4Stack:\n                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\n                        configElement.Stack.read(vlanStack.AppendProtocol(ipv4Template))\n                    if ethernetStack and not vlanStack and not ipv4Stack:\n                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\n                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv4Template))\n                    kwargs['stack_id'] = 0\n                    self._update_traffic_ipv4_data(configElement, **kwargs)\n            if kwargs.get('v6_src_addr', None):\n                kwargs['v6_src_value'] = kwargs['v6_src_addr']\n            if kwargs.get('v6_dst_addr', None):\n                kwargs['v6_dst_value'] = kwargs['v6_dst_addr']\n            if kwargs.get('v6_src_value', None) or kwargs.get('v6_src_count', None):\n                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')\n                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')\n                ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')\n                if ipv6Stack:\n                    kwargs['stack_id'] = 0\n                    self._update_traffic_ipv6_data(configElement, **kwargs)\n                else:\n                    if ethernetStack and vlanStack and not ipv6Stack:\n                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                        configElement.Stack.read(vlanStack.AppendProtocol(ipv6Template))\n                    if ethernetStack and not vlanStack and not ipv6Stack:\n                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv6Template))\n                    kwargs['stack_id'] = 0\n                    self._update_traffic_ipv6_data(configElement, **kwargs)\n\n            if kwargs.get('tcp_src_port', None) or kwargs.get('tcp_dst_port', None):\n                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')\n                tcpStack = configElement.Stack.find(StackTypeId='^tcp$')\n                if tcpStack:\n                    field = configElement.Stack.find().Field.find(DisplayName=\"TCP-Source-Port\")\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', 'singleValue'), \\\n                                                                                                                         kwargs.get(\n                                                                                                                             'tcp_src_port',\n                                                                                                                             None), kwargs.get(\n                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"TCP-Dest-Port\")\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', 'singleValue'), \\\n                                                                                                                         kwargs.get(\n                                                                                                                             'tcp_dst_port',\n                                                                                                                             None), kwargs.get(\n                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)\n\n                else:\n                    if ipv4Stack and not tcpStack:\n                        tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^tcp$\")\n                        configElement.Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))\n                    field = configElement.Stack.find().Field.find(DisplayName=\"TCP-Source-Port\")\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', 'singleValue'), \\\n                                                                                                                         kwargs.get(\n                                                                                                                             'tcp_src_port',\n                                                                                                                             None), kwargs.get(\n                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"TCP-Dest-Port\")\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', 'singleValue'), \\\n                                                                                                                         kwargs.get(\n                                                                                                                             'tcp_dst_port',\n                                                                                                                             None), kwargs.get(\n                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)\n            if kwargs.get('mpls_label', None) or kwargs.get('mpls_exp', None) or kwargs.get('mpls_bos',None) or kwargs.get('mpls_ttl', None):\n                ethernet_stack = configElement.Stack.find(StackTypeId='^ethernet$')\n                ipv4_stack = configElement.Stack.find(StackTypeId='^ipv4$')\n                mpls_stack = configElement.Stack.find(StackTypeId='^mpls$')\n                if mpls_stack:\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Label Value\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                    'mpls_label_mode', 'singleValue'), kwargs.get('mpls_label', None), kwargs.get(\n                    'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"MPLS Exp\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                    'mpls_exp_mode', 'singleValue'), kwargs.get('mpls_exp', None), kwargs.get(\n                    'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Bottom of Stack Bit\")[0]\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_bos_auto', True), kwargs.get(\n                        'mpls_bos_mode', 'singleValue'), kwargs.get('mpls_bos', 1), kwargs.get(\n                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Time To Live\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_ttl_mode', 'singleValue'), kwargs.get('mpls_ttl', None), kwargs.get(\n                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)\n                else:\n                    mpls_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^mpls$\")\n                    if ipv4_stack and not mpls_stack:\n                        if kwargs.get('mpls_stack_top', True):\n                            for _ in range(kwargs.get('mpls_count', 1)):\n                                configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))\n                        else:\n                            for _ in range(kwargs.get('mpls_count', 1)):\n                                configElement.Stack.read(ipv4_stack.AppendProtocol(mpls_template))\n                    elif not ipv4_stack and not mpls_stack:\n                        for _ in range(kwargs.get('mpls_count', 1)):\n                            configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Label Value\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_label_mode', 'singleValue'), kwargs.get('mpls_label', None), kwargs.get(\n                        'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"MPLS Exp\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_exp_mode', 'singleValue'), kwargs.get('mpls_exp', None), kwargs.get(\n                        'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Bottom of Stack Bit\")[0]\n                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_bos_auto', True), kwargs.get(\n                        'mpls_bos_mode', 'singleValue'), kwargs.get('mpls_bos', 1), kwargs.get(\n                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)\n                    field = configElement.Stack.find().Field.find(DisplayName=\"Time To Live\")[0]\n                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                        'mpls_ttl_mode', 'singleValue'), kwargs.get('mpls_ttl', None), kwargs.get(\n                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)\n\n        frameRateDict = {'rate_type': 'Type', 'frame_rate': 'Rate', 'bit_rate_units': 'BitRateUnitsType',\n                         'enforce_min_inter_packet_gap': 'InterPacketGapUnitsType'}\n        frameRateOptions = list(set(frameRateDict.keys()).intersection(kwargs.keys()))\n        if frameRateOptions:\n            for key in kwargs:\n                if key in frameRateDict:\n                    setattr(configElement.FrameRate, frameRateDict[key], kwargs[key])\n\n        frameSizeDict = {'frame_size_type': 'Type', 'frame_size_fixed_size': 'FixedSize',\n                         'frame_size_increment_start': 'IncrementFrom', 'frame_size_increment_stop': 'IncrementTo',\n                         'frame_size_increment_step': 'IncrementStep',\n                         'frame_size_preset_distribution': 'PresetDistribution',\n                         'frame_size_quad_gaussian': 'QuadGaussian',\n                         'frame_size_random_min': 'RandomMin', 'frame_size_random_max': 'RandomMax',\n                         'frame_size_weighted_pairs': 'WeightedPairs',\n                         'frame_size_weighted_pairs_range': 'WeightedRangePairs'}\n        frameSizeOptions = list(set(frameSizeDict.keys()).intersection(kwargs.keys()))\n        if frameSizeOptions:\n            for key in kwargs:\n                if key in frameSizeDict:\n                    setattr(configElement.FrameSize, frameSizeDict[key], kwargs[key])\n\n        payLoadDict = {'payload_type': 'Type', 'payload_custom_pattern': 'CustomPattern',\n                       'payload_custom_repeat': 'CustomRepeat'}\n        payLoadOptions = list(set(payLoadDict.keys()).intersection(kwargs.keys()))\n        if payLoadOptions:\n            for key in kwargs:\n                if key in payLoadDict:\n                    setattr(configElement.FramePayload, payLoadDict[key], kwargs[key])\n\n        rateDistributionDict = {'port_distribution': 'PortDistribution', 'stream_distribution': 'StreamDistribution'}\n        rateDistributionOptions = list(set(rateDistributionDict.keys()).intersection(kwargs.keys()))\n        if rateDistributionOptions:\n            for key in kwargs:\n                if key in rateDistributionDict:\n                    setattr(configElement.FrameRateDistribution, rateDistributionDict[key], kwargs[key])\n\n        if stats_track_by:\n            stats_track_by.append('trackingenabled0')\n        else:\n            stats_track_by = ['trackingenabled0']\n        ipv4_precedence_full_mesh = kwargs.get(\"ipv4_precedence_full_mesh\", False)\n        self.change_traffic_flow_tracking(traffic_item_list=[trafficItem.Name], cfg_dict={'trackBy': stats_track_by},\n                                          ipv4_precedence_full_mesh=ipv4_precedence_full_mesh)\n\n        if 'ip_priority' in kwargs:\n            ip_priority = kwargs['ip_priority']\n            protocol = ip_priority[\"priority\"][\"protocol\"]\n            if protocol == \"ipv4\":\n                del ip_priority[\"priority\"][\"protocol\"]\n                self.change_ipv4_tos(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority[\"priority\"])\n            if protocol == \"ipv6\":\n                del ip_priority[\"priority\"][\"protocol\"]\n                self.change_ipv6_traffic_class(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority[\"priority\"])\n        if traffic_type == \"raw\":\n            if 'dst_ports' in kwargs:\n                if len(kwargs.get('dst_ports')) > 1:\n                    self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItem.Name).RawTrafficRxPortsBehavior = 'loadBalanced'\n        if kwargs.get(\"v4_ttl\", None):\n            self.set_ipv4_traffic_ttl(traffic_item=trafficItem.Name, ttl=kwargs['v4_ttl'])\n        if kwargs.get(\"v6_ttl\", None):\n            self.set_ipv6_traffic_hop_limit(traffic_item=trafficItem.Name, hop_limit=kwargs['v6_ttl'])\n\n        return stream_obj\n\n    def _set_route_count(self, pool_handle, routecount, prefix_ip=None, prefix_step_value=None):\n        \"\"\"\n        Set Route count based on Protocol handle.\n\n        :param pool_handle: PrefixPool Handle\n        :param routecount: routecount to be updated\n        :param prefix_ip: prefix_ip as reference\n        :param prefix_step_value: prefix step to be updated\n        :return:\n        \"\"\"\n        if prefix_ip:\n            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:\n                # This block for 9.0 version\n                ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)\n                value_list = pool_handle.NumberOfAddressesAsy.Values\n                value_list[ip_prefix_index] = routecount\n                pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)\n            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) <= 8:\n                pool_handle.NumberOfAddresses = routecount\n        else:\n            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) >= 9:\n                # This block for 9.0 version\n                pool_handle.NumberOfAddressesAsy.Single(routecount)\n                if str(pool_handle.NumberOfAddressesAsy) == str(routecount):\n                    self.log.info('Route count updated successfully')\n                else:\n                    self.log.error('Route count update failed')\n            if int(self.ixNetwork.Globals.BuildNumber.split('.')[0]) <= 8:\n                # This block for 8.50 version\n                pool_handle.NumberOfAddresses = routecount\n                if str(pool_handle.NumberOfAddresses) == str(routecount):\n                    self.log.info('Route count updated successfully')\n                else:\n                    self.log.error('Route count update failed')\n        if prefix_step_value:\n            self._update_prefix_step(prefix_step_value, pool_handle)\n\n    def _modify_route_count(self, network_group, route_count, ports, ip_type, start_ip_prefix, protocol, prefix,\n                            router_id,prefix_step, **kwargs):\n        \"\"\"\n        Modifying address count for protocols. Internal API to support setting route count APIs\n\n        :param network_group: Network Group for which Route Count should be modified\n        :param route_count: Route count\n        :param ports: Ports\n        :param ip_type: ipv4 or ipv6\n        :param start_ip_prefix: start ip prefix as reference\n        :param protocol: protocol\n        :param prefix: prefix\n        :param router_id: router ID\n        :param prefix_step: prefix step\n        :return: result\n        \"\"\"\n        protocol_status = False\n        deviceGroupName = None\n        if (network_group and start_ip_prefix and prefix and router_id) or (\n                network_group and start_ip_prefix and router_id) or (\n                network_group is None and start_ip_prefix and router_id):\n            networkGroupNameList = []\n            if \".\" in router_id and protocol.lower() != 'isis':\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                            deviceGroupName = deviceGroupObj.Name\n                            break\n                try:\n                    if deviceGroupName:\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                            if network_group:\n                                if network_group in networkGroup.Name:\n                                    networkGroupNameList.append(networkGroup.Name)\n                                    break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            if \".\" not in router_id and protocol.lower() == 'isis':\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.Name == router_id:\n                        deviceGroupName = router_id\n                try:\n                    if deviceGroupName:\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                            if network_group:\n                                if network_group in networkGroup.Name:\n                                    networkGroupNameList.append(networkGroup.Name)\n                                    break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            else:\n                try:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                            Name='^' + router_id + '$').NetworkGroup.find():\n                        if network_group:\n                            if network_group in networkGroup.Name:\n                                networkGroupNameList.append(networkGroup.Name)\n                                break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    protocol_status = True\n                                    networkObj.Enabled.Single(True)\n                                    if prefix:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                    else:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.OspfRouteProperty.find():\n                                    protocol_status = True\n                                    networkObj.Enabled.Single(True)\n                                    if prefix:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix)\n                                    else:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix)\n                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                    if ip_type.lower() == \"ipv6\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    if prefix:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:\n                                            protocol_status = True\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                    else:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                            protocol_status = True\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.Ospfv3RouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    if prefix:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:\n                                            protocol_status = True\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix)\n                                    else:\n                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                            protocol_status = True\n                                            self._set_route_count(networkGroupObj, route_count,\n                                                                  prefix_ip=start_ip_prefix)\n                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n            else:\n                raise IxiaConfigException(\"Router Id not found on this '%s' Network Group\" % network_group)\n\n        if (network_group and start_ip_prefix is None and ports is None and prefix is None and router_id) or (\n                network_group is None and start_ip_prefix is None and prefix is None and router_id):\n            if \".\" in router_id:\n                if protocol == \"ISIS\":\n                    raise IxiaConfigException(\n                        \"ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')\")\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                            deviceGroupName = deviceGroupObj.Name\n                            break\n                networkGroupNameList = []\n                if network_group and router_id:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                            Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                        if network_group in networkGroup.Name:\n                            networkGroupNameList.append(networkGroup.Name)\n                if network_group is None and router_id:\n                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]\n            else:\n                networkGroupNameList = []\n                if network_group and router_id:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                            Name='^' + router_id + '$').NetworkGroup.find():\n                        if network_group in networkGroup.Name:\n                            networkGroupNameList.append(networkGroup.Name)\n                if network_group is None and router_id:\n                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                Name='^' + router_id + '$').NetworkGroup.find()]\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    protocol_status = True\n                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.OspfRouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    protocol_status = True\n                                    self._set_route_count(networkGroupObj, route_count)\n                    if ip_type.lower() == \"ipv6\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    protocol_status = True\n                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.Ospfv3RouteProperty.find():\n                                    networkObj.Enabled.Single(True)\n                                    protocol_status = True\n                                    self._set_route_count(networkGroupObj, route_count)\n            else:\n                raise IxiaConfigException(\"Router Id not found on this '%s' Network Group\" % network_group)\n\n        if network_group and ports is None and start_ip_prefix is None and router_id is None:\n            networkGroupNameList = []\n            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                for networkGroupObj in deviceGroupObj.NetworkGroup.find():\n                    if network_group in networkGroupObj.Name:\n                        networkGroupNameList.append(networkGroupObj.Name)\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                                Name='^' + networkGroupName + '$'):\n                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if ipv4PoolObj.IsisL3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        self._set_route_count(ipv4PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                if protocol == \"OSPF\":\n                                    if ipv4PoolObj.OspfRouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        self._set_route_count(ipv4PoolObj, route_count)\n                    else:\n                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                                Name='^' + networkGroupName + '$'):\n                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if ipv6PoolObj.IsisL3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        self._set_route_count(ipv6PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                if protocol == \"OSPF\":\n                                    if ipv6PoolObj.Ospfv3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        self._set_route_count(ipv6PoolObj, route_count)\n            else:\n                raise IxiaConfigException(\n                    \"Network group name '%s' not found for Ip version '%s'\" % (network_group, ip_type))\n        if ports:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            for port in ports:\n                if port in vportNameList:\n                    for topologyObj in self.ixNetwork.Topology.find():\n                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:\n                            if ip_type.lower() == \"ipv4\":\n                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():\n                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():\n                                        if protocol == \"ISIS\":\n                                            if ipv4PoolObj.IsisL3RouteProperty.find():\n                                                networkObj.Enabled.Single(True)\n                                                protocol_status = True\n                                                self._set_route_count(ipv4PoolObj, route_count,\n                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                        if protocol == \"OSPF\":\n                                            if ipv4PoolObj.OspfRouteProperty.find():\n                                                networkObj.Enabled.Single(True)\n                                                protocol_status = True\n                                                self._set_route_count(ipv4PoolObj, route_count)\n                            else:\n                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():\n                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():\n                                        if protocol == \"ISIS\":\n                                            if ipv6PoolObj.IsisL3RouteProperty.find():\n                                                networkObj.Enabled.Single(True)\n                                                protocol_status = True\n                                                self._set_route_count(ipv6PoolObj, route_count,\n                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                        if protocol == \"OSPF\":\n                                            if ipv6PoolObj.Ospfv3RouteProperty.find():\n                                                networkObj.Enabled.Single(True)\n                                                protocol_status = True\n                                                self._set_route_count(ipv6PoolObj, route_count)\n        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (\n                start_ip_prefix and network_group and ports is None and router_id is None):\n            networkGroupNameList = []\n            if network_group and start_ip_prefix:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if\n                                        network_group in networkObj.Name]\n                # This condition for compact version\n                if networkGroupNameList == []:\n                    networkGroupNameList = [networkObj.Name for networkObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]\n            if start_ip_prefix and network_group is None:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        try:\n                            for network_group_obj in networkObj.Ipv4PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if network_group_obj.IsisL3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            self._set_route_count(network_group_obj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                                if protocol == \"OSPF\":\n                                    if network_group_obj.OspfRouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                        except:\n                            pass\n                    else:\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                        try:\n                            for network_group_obj in networkObj.Ipv6PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if network_group_obj.IsisL3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            self._set_route_count(network_group_obj, route_count,\n                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)\n                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                                if protocol == \"OSPF\":\n                                    if network_group_obj.Ospfv3RouteProperty.find():\n                                        networkObj.Enabled.Single(True)\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                        except:\n                            pass\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)\n        if protocol_status:\n            return protocol_status\n        else:\n            raise IxiaConfigException(\"%s protocol not configured or Configuration issue.\" % protocol)\n\n    def _ospf_routes_control(self, ports, ip_type, address_list, action, active, devices):\n        \"\"\"\n        Function used internally by API ospf_routes_start & ospf_routes_stop\n\n        :param ports: ports\n        :param ip_type: ipv4 or ipv6\n        :param address_list: Address list for action start/stop\n        :param action: Start/Stop\n        :param active: Active/ Deactive\n        :param devices: Name of the devices in the config\n\n        :return: True on success and raise exception if any failures\n        \"\"\"\n        self.log.info('OSPF Routes Control:%s' % (action) )\n        if ports==None and address_list==None and devices==None:\n            if ip_type.lower() == \"ipv4\":\n                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find() if name]\n                for name in nameList:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).'+action+'(None)')\n                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).Active.Single(active)\n            else:\n                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find() if name]\n                for name in nameList:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).'+action+'(None)')\n                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).Active.Single(active)\n        if ports:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in ports if portName in vportNameList]\n            for portName in portNameList:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        if ip_type.lower() == \"ipv4\":\n                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                for ospfRoute in ipv4Pools.OspfRouteProperty.find():\n                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):\n                                        eval('ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')\n                                        ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)\n                        else:\n                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                for ospfRoute in ipv6Pools.Ospfv3RouteProperty.find():\n                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):\n                                        eval('ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')\n                                        ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)\n        if address_list:\n            for lastaddress in address_list:\n                if ':' not in lastaddress:\n                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress\n                        if lastaddress in address:\n                            ipIndex = address.index(lastaddress) + 1\n                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().'+action+'(ipIndex)')\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().Active.Single(active)\n                else:\n                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress\n                        if lastaddress in address:\n                            ipIndex = address.index(lastaddress) + 1\n                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().'+action+'(ipIndex)')\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().Active.Single(active)\n        if devices:\n            for eachDevice in devices:\n                eachDevice = '^' + eachDevice.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                if ip_type.lower() == \"ipv4\":\n                    self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().Active.Single(\n                        active)\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().' + action + '(None)')\n                else:\n                    self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().Active.Single(\n                        active)\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().' + action + '(None)')\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def ospf_routes_start(self, ports=None, ip_type=\"ipv4\", address_list=None, devices=None):\n        \"\"\"\n        Start OSPF route ranges\n\n        :param ports: list of port names e.g. [\"Ethernet - 001\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: list of last network address in the route range defined for OSPF in TGN\n        :param devices: Name of the devices in the config\n        :return: True on success else raises exception\n\n        :Example: ospf_routes_start(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n                  ospf_routes_start(devices=[\"Device1\"], ip_type=\"ipv6\")\n        \"\"\"\n        return self._ospf_routes_control(ports, ip_type, address_list, \"Start\", \"true\", devices)\n\n    def ospf_routes_stop(self, ports=None, ip_type=\"ipv4\", address_list=None, devices=None):\n        \"\"\"\n        Stopping OSPF route ranges\n\n        :param ports: list of port names e.g. [\"Ethernet - 001\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: The list of network addresses in the route range defined for OSPF in TGN. In Spirent, the first address should be included per network range.\n                In IXIA, the last address should be included.\n        :param devices: Name of the devices in the config\n        :return: True on success else raises exception\n\n        :Example: ospf_routes_stop(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n                  ospf_routes_stop(devices=[\"Device1\"], ip_type=\"ipv6\")\n        \"\"\"\n        return self._ospf_routes_control(ports, ip_type, address_list, \"Stop\", \"false\", devices)\n\n    def set_ospf_route_count(self, route_count,router_id, ip_type=\"ipv4\", lsa_id=None, start_ip_prefix=None, **kwargs):\n        \"\"\"\n        Modifying address count for OSPF protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param router_id: Represents the Router ID of the router.\n        :param lsa_id: NA for IXIA\n        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                       For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_ospf_route_count(route_count=300, network_group='Network Group 2', ports=[\"Ethernet - 001\"])\n        \"\"\"\n        self.log.info(\"Setting OSPF Route Count\")\n        network_group = kwargs.get('network_group')\n        ports = kwargs.get('ports')\n        prefix_step = kwargs.get('prefix_step')\n        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix, protocol=\"OSPF\",\n                                        prefix=None, router_id=router_id, prefix_step=prefix_step)\n\n    def _ldp_routes_control(self, ports, ip_type, address_list, action, active):\n        \"\"\"\n        Function used internally by API ldp_routes_start & ldp_routes_stop\n\n        :param ports: Ports\n        :param ip_type: ipv4 or ipv6\n        :param address_list: address_list: list of last network address in the route range defined for LDP in TGN\n        :param action: start/stop\n        :param active: active/deactive\n        :return: True/Exception\n        \"\"\"\n        self.log.info('LDP Route Control:%s' % (action))\n        if ports == None and  address_list== None:\n            if ip_type.lower() == \"ipv4\":\n                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find() if name]\n                for name in nameList:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).'+action+'(None)')\n                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).Active.Single(active)\n            else:\n                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find() if name]\n                for name in nameList:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).'+action+'(None)')\n                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).Active.Single(active)\n\n        if ports:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in ports if portName in vportNameList]\n            for portName in portNameList:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        if ip_type.lower() == \"ipv4\":\n                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                for ldpRoute in ipv4Pools.LdpFECProperty.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):\n                                        eval('ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')\n                                        ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)\n                        else:\n                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                for ldpRoute in ipv6Pools.LdpIpv6FECProperty.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):\n                                        eval('ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')\n                                        ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)\n        if address_list:\n            for lastaddress in address_list:\n                if ':' not in lastaddress:\n                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress\n                        if lastaddress in address:\n                            ipIndex = address.index(lastaddress) + 1\n                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().'+action+'(ipIndex)')\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().Active.Single(active)\n                else:\n                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress\n                        if lastaddress in address:\n                            ipIndex = address.index(lastaddress) + 1\n                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().'+action+'(ipIndex)')\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().Active.Single(active)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n\n    def ldp_routes_start(self, ports=None, ip_type=\"ipv4\", address_list=None):\n        \"\"\"\n        Starting LDP route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: list of last network address in the route range defined for LDP in TGN\n        :return: True on success else raises exception\n\n        :Example: ldp_routes_start(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n        \"\"\"\n\n        return self._ldp_routes_control(ports, ip_type, address_list, \"Start\", \"true\")\n\n    def ldp_routes_stop(self, ports=None, ip_type=\"ipv4\", address_list=None):\n        \"\"\"\n        Starting LDP route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: list of last network address in the route range defined for LDP in TGN\n        :return: True on success else raises exception\n\n        :Example: ldp_routes_stop(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n        \"\"\"\n\n        return self._ldp_routes_control(ports, ip_type, address_list, \"Stop\", \"false\")\n\n    def _bgp_routes_control(self, ports, ip_type, address_list, action, active, devices, nested_nework_group):\n        \"\"\"\n        Function used internally by API bgp_routes_start & bgp_routes_stop\n\n        :param ports: list of ports\n        :param ip_type: ipv4 or ipv6\n        :param address_list: Address list for action start/stop\n        :param action: Start/Stop\n        :param active: Active/ Deactive\n        :param devices: list of Names of the devices in the config\n        :param nested_nework_group: Nested network group name\n        \"\"\"\n        self.log.info('BGP Routes Control:%s' % (action))\n        if ports == None and address_list == None and devices == None:\n            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                if ip_type.lower() == \"ipv4\":\n                    try:\n                        group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                        eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                    except:\n                        pass\n                else:\n                    try:\n                        group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                        eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                    except:\n                        pass\n                    try:\n                        group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)\n                        eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')\n                    except:\n                        pass\n        if (ports and devices == None and address_list == None):\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in ports if portName in vportNameList]\n            for portName in portNameList:\n                portName = '^' + portName.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        if ip_type.lower() == \"ipv4\":\n                            if nested_nework_group:\n                                try:\n                                    for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                        for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():\n                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):\n                                                eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')\n                                                ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)\n                                except:\n                                    pass\n                                try:\n                                    for ipv4_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().DeviceGroup.find().\\\n                                            NetworkGroup.find().Ipv4PrefixPools.find():\n                                        for route in ipv4_pools.BgpIPRouteProperty.find():\n                                            if re.match(topologyObj + '/deviceGroup', route.href):\n                                                eval('ipv4_pools.BgpIPRouteProperty.find(DescriptiveName=route.DescriptiveName).'+ action + '(None)')\n                                                ipv4_pools.BgpIPRouteProperty.find(DescriptiveName=route.DescriptiveName).Active.Single(active)\n                                except:\n                                    pass\n\n                            for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():\n                                    if re.match(topologyObj + '/deviceGroup', bgpRoute.href):\n                                        eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')\n                                        ipv4Pools.BgpIPRouteProperty.find( DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)\n                        else:\n                            if nested_nework_group:\n                                try:\n                                    for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                        for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():\n                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):\n                                                route_name = '^' + bgpRoute.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                                                eval( 'ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).' + action + '(None)')\n                                                ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).Active.Single(active)\n                                except:\n                                    pass\n\n                                try:\n                                    for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().\\\n                                            NetworkGroup.find().Ipv6PrefixPools.find():\n                                        for bgp_route in ipv6_pools.BgpV6IPRouteProperty.find():\n                                            if re.match(topologyObj + '/deviceGroup', bgp_route.href):\n                                                route_name = '^' + bgp_route.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                                                eval( 'ipv6_pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).' + action + '(None)')\n                                                ipv6_pools.BgpV6IPRouteProperty.find(DescriptiveName=route_name).Active.Single(active)\n                                except:\n                                    pass\n\n                                try:\n                                    for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().\\\n                                            DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                        for bgp_route in ipv6_pools.BgpIPRouteProperty.find():\n                                            if re.match(topologyObj + '/deviceGroup', bgp_route.href):\n                                                eval(\n                                                'ipv6_pools.BgpIPRouteProperty.find(DescriptiveName=bgp_route.DescriptiveName).' + action + '(None)')\n                                                ipv6_pools.BgpIPRouteProperty.find(\n                                                DescriptiveName=bgp_route.DescriptiveName).Active.Single(active)\n                                except:\n                                    pass\n\n                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                try:\n                                    for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():\n                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):\n                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*') + '$'\n                                            eval('ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')\n                                            ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).Active.Single(active)\n                                except:\n                                    pass\n                                try:\n                                    for bgpRoute in ipv6Pools.BgpIPRouteProperty.find():\n                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):\n                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*') + '$'\n                                            eval( 'ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')\n                                            ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).Active.Single(active)\n                                except:\n                                    pass\n        if (devices and ports and address_list) or (devices == None and ports and address_list) or (\n                devices and ports == None and address_list) or (devices == None and ports == None and address_list):\n            for startaddress in address_list:\n                if ':' not in startaddress:\n                    nameList = [name.Name for name in\n                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()\n                                if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(\n                            Name='^' + name + '$').NetworkAddress.Values\n                        if startaddress in address:\n                            ipIndex = address.index(startaddress)\n                            try:\n                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')\n                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values\n                                valuesList[ipIndex] = active.lower()\n                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active\n                                bgpIpObj.ClearOverlays()\n                                bgpIpObj.ValueList(values=valuesList)\n                            except:\n                                pass\n                            try:\n                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')\n                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values\n                                valuesList[ipIndex] = active.lower()\n                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active\n                                bgpIpObj.ClearOverlays()\n                                bgpIpObj.ValueList(values=valuesList)\n                            except:\n                                pass\n                else:\n                    nameList = [name.Name for name in\n                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()\n                                if name]\n                    for name in nameList:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').NetworkAddress.Values\n                        if startaddress in address:\n                            ipIndex = address.index(startaddress)\n                            try:\n                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')\n                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values\n                                valuesList[ipIndex] = active.lower()\n                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active\n                                bgpIpv6Obj.ClearOverlays()\n                                bgpIpv6Obj.ValueList(values=valuesList)\n                            except:\n                                pass\n\n                            try:\n                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')\n                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values\n                                valuesList[ipIndex] = active.lower()\n                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active\n                                bgpIpv6Obj.ClearOverlays()\n                                bgpIpv6Obj.ValueList(values=valuesList)\n\n                            except:\n                                pass\n        if (devices and ports == None and address_list == None) or (devices and ports and address_list == None):\n            for eachDevice in devices:\n                eachDevice = '^' + eachDevice.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find():\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        # for nested network groups\n                        try:\n                            group.DeviceGroup.find( Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)\n                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\\\n                                Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = group.DeviceGroup.find().NetworkGroup.find(Name='^'+nested_nework_group+'$')\n                            device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)\n                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\\\n                                Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            #eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find().\\\n                                DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$')\n                            device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('device_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                    else:\n                        try:\n                            group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        try:\n                            group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        # for nested network groups\n                        try:\n                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        try:\n                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = group.DeviceGroup.find().\\\n                                        NetworkGroup.find(Name='^' + nested_nework_group + '$')\n                            device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = group.NetworkGroup.find().DeviceGroup.find().\\\n                                        NetworkGroup.find(Name='^' + nested_nework_group + '$')\n                            device_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('device_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)\n                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\\\n                                Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)\n                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\\\n                                Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n                        try:\n                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find().\\\n                                DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$')\n                            device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            eval('device_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')\n                        except:\n                            pass\n\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def bgp_routes_start(self, ports=None, ip_type=\"ipv4\", address_list=None, devices=None, **kwargs):\n        \"\"\"\n        Start BGP route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: list of start network addresses of network group\n        :param devices: list of Names of the devices in the config\n        :param nested_nework_group : True if nested network group\n        :param nested_device : List of nested devices / if passing address_list, one nested device(str)\n        :return: True on success else raises exception\n\n        :Example: bgp_routes_start(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n                  bgp_routes_start(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])\n                  bgp_routes_start(nested_device= ['NG_PEER_1_IPv6'],devices=['ISIS_PEER_1'],ip_type='ipv6')\n                  bgp_routes_start(nested_device=\"NG_PEER_1_IPv4\", address_list=['20.1.0.0','90.0.0.0'])\n        \"\"\"\n        nested_nework_group = kwargs.get('nested_nework_group', None)\n        action = kwargs.get(\"action\", \"Start\")\n        flag = 'true'\n        nested_device = kwargs.get('nested_device', None)\n\n        if isinstance(nested_device, list) and not address_list:\n            for device_group in nested_device:\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_group + '$')\n\n                if not device_objs:\n                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                        Name='^' + device_group + '$')\n\n                if not device_objs:\n                    self.log.warning(f\"NetworkGroup '{device_group}' not found.\")\n                    continue\n\n                for dev_group in device_objs:\n                    if ip_type.lower() == 'ipv4':\n                        for pool in dev_group.NetworkGroup.find().Ipv4PrefixPools.find():\n                            try:\n                                values_list = pool.BgpIPRouteProperty.find().Active.Values\n                                values_list = [flag] * len(values_list)\n                                bgp_active = pool.BgpIPRouteProperty.find().Active\n                                bgp_active.ClearOverlays()\n                                bgp_active.ValueList(values=values_list)\n                                self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                                eval(f'pool.BgpIPRouteProperty.find().{action}(None)')\n                                self.log.debug(f\"{action} on {device_group} done successfully for IP type : {ip_type}\")\n                            except Exception as err:\n                                self.log.warning(f\"Failed to apply {flag} to BGP IPv4 routes in {device_group}: {err}\")\n\n                    elif ip_type.lower() == 'ipv6':\n                        for pool in dev_group.NetworkGroup.find().Ipv6PrefixPools.find():\n                            for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:\n                                try:\n                                    route_obj = getattr(pool, route_type).find()\n                                    if route_obj:\n                                        active_obj = route_obj.Active\n                                        values_list = active_obj.Values\n                                        values_list = [flag] * len(values_list)\n                                        active_obj.ClearOverlays()\n                                        active_obj.ValueList(values=values_list)\n                                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                                        eval(f'route_obj.{action}(None)')\n                                        self.log.debug(f\"{action} on {device_group} done successfully for IP type : {ip_type}\")\n                                except Exception as err:\n                                    self.log.warning(f\"Failed to apply {flag} to {route_type} in {device_group}: {err}\")\n\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            return True\n\n        if isinstance(nested_device, str) and address_list:\n            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + nested_device + '$')\n\n            if not device_objs:\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                    Name='^' + nested_device + '$')\n\n            if not device_objs:\n                self.log.warning(f\"DeviceGroup '{nested_device}' not found.\")\n\n            network_groups = device_objs.NetworkGroup.find()\n            for net_group in network_groups:\n                if ip_type.lower() == 'ipv4':\n                    for pool in net_group.Ipv4PrefixPools.find():\n                        route_props = pool.BgpIPRouteProperty.find()\n                        if not route_props:\n                            continue\n\n                        active_obj = route_props.Active\n                        addresses = pool.NetworkAddress.Values\n                        if not addresses:\n                            continue\n\n                        values_list = list(active_obj.Values)\n\n                        for i, addr in enumerate(addresses):\n                            if addr in address_list:\n                                values_list[i] = 'true' if action.lower() == \"start\" else \"false\"\n\n                        active_obj.ClearOverlays()\n                        active_obj.ValueList(values=values_list)\n                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                        if action.lower() == \"start\":\n                            route_props.Start()\n                        else:\n                            route_props.Stop()\n                        self.log.debug(\n                            f\"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}\")\n\n                elif ip_type.lower() == 'ipv6':\n                    for pool in net_group.Ipv6PrefixPools.find():\n                        for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:\n                            route_props = getattr(pool, route_type).find()\n                            if not route_props:\n                                continue\n\n                            active_obj = route_props.Active\n                            addresses = pool.NetworkAddress.Values\n                            if not addresses:\n                                continue\n\n                            values_list = list(active_obj.Values)\n\n                            for i, addr in enumerate(addresses):\n                                if addr in address_list:\n                                    values_list[i] = 'true' if action.lower() == \"start\" else \"false\"\n\n                            active_obj.ClearOverlays()\n                            active_obj.ValueList(values=values_list)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            if action.lower() == \"start\":\n                                route_props.Start()\n                            else:\n                                route_props.Stop()\n                            self.log.debug(\n                                f\"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}\")\n\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            return True\n        return self._bgp_routes_control(ports, ip_type, address_list, action, \"true\", devices, nested_nework_group)\n\n    def bgp_routes_stop(self, ports=None, ip_type=\"ipv4\", address_list=None, devices=None, **kwargs):\n        \"\"\"\n        Stop BGP route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param address_list: list of start network addresses of network group\n        :param devices: list of Names of the devices in the config\n        :param nested_nework_group : True if nested network group\n        :param nested_device : List of nested devices / if passing address_list, one nested device(str)\n        :return: True on success else raises exception\n\n        :Example: bgp_routes_stop(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n                  bgp_routes_stop(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])\n                  bgp_routes_stop(nested_device= ['NG_PEER_1_IPv6'],devices=['ISIS_PEER_1'],ip_type='ipv6')\n                  bgp_routes_stop(nested_device=\"NG_PEER_1_IPv4\", address_list=['20.1.0.0','90.0.0.0'])\n        \"\"\"\n        nested_nework_group = kwargs.get('nested_nework_group')\n        flag = 'false'\n        action = kwargs.get(\"action\", \"Stop\")\n        nested_device = kwargs.get('nested_device', None)\n\n        if isinstance(nested_device, list) and not address_list:\n            for device_group in nested_device:\n                device=re.escape(device_group)\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_group + '$')\n                if not device_objs:\n                    device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(Name='^' + device + '$')\n                if not device_objs:\n                    self.log.warning(f\"NetworkGroup '{device_group}' not found.\")\n                    continue\n\n                for dev_group in device_objs:\n                    if ip_type.lower() == 'ipv4':\n                        for pool in dev_group.NetworkGroup.find().Ipv4PrefixPools.find():\n                            try:\n                                values_list = pool.BgpIPRouteProperty.find().Active.Values\n                                values_list = [flag] * len(values_list)\n                                bgp_active = pool.BgpIPRouteProperty.find().Active\n                                bgp_active.ClearOverlays()\n                                bgp_active.ValueList(values=values_list)\n                                self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                                eval(f'pool.BgpIPRouteProperty.find().{action}(None)')\n                                self.log.debug(f\"{action} on {device_group} done successfully for IP type : {ip_type}\")\n                            except Exception as err:\n                                self.log.warning(f\"Failed to apply {flag} to BGP IPv4 routes in {device_group}: {err}\")\n\n                    elif ip_type.lower() == 'ipv6':\n                        for pool in dev_group.NetworkGroup.find().Ipv6PrefixPools.find():\n                            for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:\n                                try:\n                                    route_obj = getattr(pool, route_type).find()\n                                    if route_obj:\n                                        active_obj = route_obj.Active\n                                        values_list = active_obj.Values\n                                        values_list = [flag] * len(values_list)\n                                        active_obj.ClearOverlays()\n                                        active_obj.ValueList(values=values_list)\n                                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                                        eval(f'route_obj.{action}(None)')\n                                        self.log.debug(f\"{action} on {device_group} done successfully for IP type : {ip_type}\")\n                                except Exception as err:\n                                    self.log.warning(f\"Failed to apply {flag} to {route_type} in {device_group}: {err}\")\n\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            return True\n\n        if isinstance(nested_device, str) and address_list:\n            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + nested_device + '$')\n\n            if not device_objs:\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n\n            if not device_objs:\n                self.log.warning(f\"DeviceGroup '{nested_device}' not found.\")\n\n            network_groups = device_objs.NetworkGroup.find()\n            for net_group in network_groups:\n                if ip_type.lower() == 'ipv4':\n                    for pool in net_group.Ipv4PrefixPools.find():\n                        route_props = pool.BgpIPRouteProperty.find()\n                        if not route_props:\n                            continue\n\n                        active_obj = route_props.Active\n                        addresses = pool.NetworkAddress.Values\n                        if not addresses:\n                            continue\n\n                        values_list = list(active_obj.Values)\n\n                        for i, addr in enumerate(addresses):\n                            if addr in address_list:\n                                values_list[i] = 'false' if action.lower() == \"stop\" else \"true\"\n\n                        active_obj.ClearOverlays()\n                        active_obj.ValueList(values=values_list)\n                        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                        if action.lower() == \"stop\":\n                            route_props.Stop()\n                        else:\n                            route_props.Start()\n                        self.log.debug(f\"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}\")\n\n                elif ip_type.lower() == 'ipv6':\n                    for pool in net_group.Ipv6PrefixPools.find():\n                        for route_type in ['BgpIPRouteProperty', 'BgpV6IPRouteProperty']:\n                            route_props = getattr(pool, route_type).find()\n                            if not route_props:\n                                continue\n\n                            active_obj = route_props.Active\n                            addresses = pool.NetworkAddress.Values\n                            if not addresses:\n                                continue\n\n                            values_list = list(active_obj.Values)\n\n                            for i, addr in enumerate(addresses):\n                                if addr in address_list:\n                                    values_list[i] = 'false' if action.lower() == \"stop\" else \"true\"\n\n                            active_obj.ClearOverlays()\n                            active_obj.ValueList(values=values_list)\n                            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                            if action.lower() == \"stop\":\n                                route_props.Stop()\n                            else:\n                                route_props.Start()\n                            self.log.debug(f\"{action} on {nested_device} done successfully for IP type : {ip_type} on routes {address_list}\")\n\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            return True\n\n        return self._bgp_routes_control(ports, ip_type, address_list, \"Stop\", \"false\", devices, nested_nework_group)\n\n    def _isis_routes_control(self, ports: List[str], ip_type: str, address_list: List[str], devices: List[str], network_group: str,\n                             action: str = 'Start', active: str = 'true'):\n        \"\"\"\n        Function used internally by API isis_routes_start & isis_routes_stop\n\n        :param ports: list of ports\n        :param ip_type: ipv4 or ipv6\n        :param address_list: Address list for action start/stop\n        :param action: takes 'true' to start or 'false' to stop\n        :param active: takes 'Start' or 'Stop'\n        :param devices: list of Names of the devices in the config\n        :param network_group: ISIS network group name\n        \"\"\"\n        self.log.info(f\"ISIS Routes Control {action}\")\n        result = False\n        if ports is None and address_list is None and devices is None and network_group is None:\n            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                if ip_type.lower() == \"ipv4\":\n                    try:\n                        group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                        eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                        result = True\n                    except:\n                        pass\n                elif ip_type.lower() == \"ipv6\":\n                    try:\n                        group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                        eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                        result = True\n                    except:\n                        pass\n            if not result:\n                raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')\n\n        if (ports and devices is None and address_list is None and network_group is None):\n            vport_name_list = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            port_name_list = [port_name for port_name in ports if port_name in vport_name_list]\n            for port_name in port_name_list:\n                port_name = '^' + port_name.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port_name).href:\n                        topology_obj = topology.href\n                        if ip_type.lower() == \"ipv4\":\n                            for ipv4_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():\n                                for isis_route in ipv4_pools.IsisL3RouteProperty.find():\n                                    try:\n                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):\n                                            name = '^' + isis_route.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*') + '$'\n                                            eval('ipv4_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')\n                                            ipv4_pools.IsisL3RouteProperty.find( DescriptiveName=isis_route.DescriptiveName).Active.Single(active)\n                                    except:\n                                        raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')\n                        else:\n                            for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():\n                                try:\n                                    for isis_route in ipv6_pools.IsisL3RouteProperty.find():\n                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):\n                                            name = '^' + isis_route.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*') + '$'\n                                            eval('ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')\n                                            ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).Active.Single(active)\n                                except:\n                                    raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')\n\n        if address_list and (devices or ports or network_group):\n            for lastaddress in address_list:\n                namelist = list()\n                if ':' not in lastaddress:\n                    if devices:\n                        for device in devices:\n                            if network_group:\n                                namelist.extend([name.Name for name in\n                                                 self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                     Name='^' + device + '$').\n                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()\n                                                 if name])\n                            else:\n                                namelist.extend([name.Name for name in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').\n                                                NetworkGroup.find().Ipv4PrefixPools.find()\n                                            if name])\n\n                    elif devices is None and network_group:\n                        namelist.extend([name.Name for name in\n                                    self.ixNetwork.Topology.find().DeviceGroup.find().\n                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()\n                                    if name])\n                    else:\n                        namelist.extend([name.Name for name in\n                                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()\n                                    if name])\n\n                    for name in namelist:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find(). \\\n                            NetworkGroup.find().Ipv4PrefixPools.find(\n                            Name='^' + name + '$').LastNetworkAddress\n                        if lastaddress in address:\n                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]\n                            for index in ip_index_list:\n                                try:\n                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'\n                                         'Ipv4PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')\n                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                                        Ipv4PrefixPools.find(\n                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values\n                                    valueslist[index] = active.lower()\n                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                                        Ipv4PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active\n                                    isis_obj.ClearOverlays()\n                                    isis_obj.ValueList(values=valueslist)\n                                except:\n                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv4')\n\n                else:\n                    if devices:\n                        for device in devices:\n                            if network_group:\n                                namelist.extend([name.Name for name in\n                                                 self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                     Name='^' + device + '$').\n                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()\n                                                 if name])\n                            else:\n                                namelist.extend([name.Name for name in\n                                                 self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                     Name='^' + device + '$').\n                                                NetworkGroup.find().Ipv6PrefixPools.find()\n                                                 if name])\n\n                    elif devices is None and network_group:\n                        namelist.extend([name.Name for name in\n                                         self.ixNetwork.Topology.find().DeviceGroup.find().\n                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()\n                                         if name])\n                    else:\n                        namelist.extend([name.Name for name in\n                                         self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()\n                                         if name])\n                    for name in namelist:\n                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                            Ipv6PrefixPools.find(Name='^' + name + '$').LastNetworkAddress\n                        if lastaddress in address:\n                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]\n                            for index in ip_index_list:\n                                try:\n                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'\n                                         'Ipv6PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')\n                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                                        Ipv6PrefixPools.find(\n                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values\n                                    valueslist[index] = active.lower()\n                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                                        Ipv6PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active\n                                    isis_obj.ClearOverlays()\n                                    isis_obj.ValueList(values=valueslist)\n                                except:\n                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv6')\n\n        if devices and address_list is None and (ports or network_group):\n            for each_device in devices:\n                each_device = '^' + each_device.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                if network_group:\n                    for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$'):\n                        try:\n                            if ip_type.lower() == \"ipv4\":\n                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                            else:\n                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                        except Exception as err_msg:\n                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)\n                else:\n                    for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device).NetworkGroup.find():\n                        try:\n                            if ip_type.lower() == \"ipv4\":\n                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                            else:\n                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                        except Exception as err_msg:\n                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)\n\n        if devices is None and ports is None and address_list is None and network_group:\n            try:\n                network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')\n                if ip_type.lower() == \"ipv4\":\n                    network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                    eval('network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n                else:\n                    network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)\n                    eval('network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')\n            except Exception as err_msg:\n                raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)\n\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def isis_routes_start(self, ports: Optional[List[str]] = None,  address_list: Optional[List[str]] = None,\n                          devices: Optional[List[str]] = None, ip_type: str = 'ipv4',**kwargs):\n        \"\"\"\n        Starting ISIS route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.\n        :param devices: list of Names of the devices in the config\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param kwargs :\n            network_group : ISIS network group name\n        :return: True on success else raises exception\n\n        :Example: isis_routes_start(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n        \"\"\"\n        network_group = kwargs.get('network_group',None)\n        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, \"Start\", \"true\")\n\n    def isis_routes_stop(self, ports: Optional[List[str]] = None, address_list: Optional[List[str]] = None,\n                         devices: Optional[List[str]] = None, ip_type: str = 'ipv4', **kwargs):\n        \"\"\"\n        Stopping ISIS route ranges\n\n        :param ports: list of port names e.g. [\"egress1\"]\n        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.\n        :param devices: list of Names of the devices in the config\n        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present\n        :param kwargs :\n            network_group : ISIS network group name\n        :return: True on success else raises exception\n\n        :Example: isis_routes_stop(ports=[\"Ethernet - 001\"], ip_type=\"ipv6\")\n        \"\"\"\n        network_group = kwargs.get('network_group',None)\n        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, \"Stop\", \"false\")\n\n    def set_isis_route_count(self, route_count, router_id=None, ip_type=\"ipv4\", lsp_id=None, start_ip_prefix=None, **kwargs):\n        \"\"\"\n        Modifying address count for ISIS protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param router_id: NA for IXIA\n        :param lsp_id: NA for IXIA\n        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                       For IXIA, network_group has to be included in the kwargs as a\n                       mandatory parameter and ports is optional\n                       network_group: ISIS network group name\n                       ports:  port name\n                       prefix_step:  prefix step to be updated\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_isis_route_count(route_count=300,router_id=None, network_group='Network Group 8')\n        \"\"\"\n        self.log.info(\"Setting ISIS route count\")\n        network_group = kwargs.get('network_group')\n        ports = kwargs.get('ports')\n        prefix_step = kwargs.get('prefix_step')\n        if router_id:\n            if \".\" in router_id:\n                router_id = None\n        if not network_group and start_ip_prefix is None and router_id is None and ports is None:\n            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')\n        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix,\n                                        prefix_step=prefix_step,protocol=\"ISIS\", prefix=None, router_id=router_id)\n\n    def get_port_mtu(self, port):\n        \"\"\"\n        Get MTU value for Ether PORT\n\n        :param port: portName, Location or Interface of PORT\\n\n            Example: portName: (str): The virtual port name. Ex: '1/2/9'\\n\n            Example: port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)] , Ex: ['10.34.57.60', '2', '9']\\n\n            Example: location (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'\n        :return: A list of one or more (if sub-interface exists) MTU values for a given port\n\n        :Example: get_port_mtu(\"10.39.60.120/2/9\")\n        \"\"\"\n        self.log.info(\"Getting MTU on the port:%s\" % (port))\n        if type(port) == list:\n            port = ':'.join(port)\n        elif type(port) == str and re.search('\\\\d+.\\\\d+.\\\\d+.\\\\d+/\\\\d+/\\\\d+', port):\n            port = port.replace('/', ':')\n        else:\n            port = self.ixNetwork.Vport.find(Name=port).AssignedTo\n\n        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:\n            for vport in vportList:\n                assignedVport = self.ixNetwork.Vport.find(Name=vport)\n                if assignedVport.AssignedTo == port:\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.Vports[0] == assignedVport.href:\n                            topologyObj = topology.href\n                            for deviceGroup in topology.DeviceGroup.find():\n                                mtuValues = []\n                                for ethernet in deviceGroup.Ethernet.find():\n                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):\n                                        mtuValues.append(ethernet.Mtu.Values)\n                                return [mtu for mtuSubList in mtuValues for mtu in mtuSubList]\n        else:\n            raise IxiaConfigException(\"Port %s is invalid or not configured\" % port)\n\n    def set_port_mtu(self, port, mtu, **kwargs):\n        \"\"\"\n        Change MTU value in port Ethernet configuration\n\n        :param port: portName, Location or Interface of PORT\\n\n            Example:\n               portName: (str): The virtual port name. Ex: '1/2/9' \\n\n               port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)], Ex: ['10.34.57.60', '2', '9']\\n\n               location: (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'\n        :param mtu: (int): User preferred MTU value for Ethernet PORT. (RANGE 68 - 9216)\n        :kwargs_param direction: (str): increment|decrement MTU value.\n        :kwargs_param step: (int): Number of steps to increment/decrement MTU value, default is 0\n        :return: True on success\n\n        :Example: set_port_mtu(portList[0],1300,direction='increment',step=2)\n        \"\"\"\n        self.log.info(\"Setting MTU on the port:%s\" % (port))\n        step = kwargs.get('step', 0)\n        if type(port) == list:\n            port = ':'.join(port)\n        elif type(port) == str and re.search('\\\\d+.\\\\d+.\\\\d+.\\\\d+/\\\\d+/\\\\d+', port):\n            port = port.replace('/', ':')\n        else:\n            port = self.ixNetwork.Vport.find(Name=port).AssignedTo\n\n        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:\n            for vport in vportList:\n                vports = self.ixNetwork.Vport.find(Name=vport)\n                if vports.AssignedTo == port:\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.Vports[0] == vports.href:\n                            topologyObj = topology.href\n                            for deviceGroup in topology.DeviceGroup.find():\n                                for ethernet in deviceGroup.Ethernet.find():\n                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):\n                                        if kwargs:\n                                            if kwargs['direction'].lower() == 'increment':\n                                                ethernet.Mtu.Increment(start_value=mtu, step_value=step)\n                                            if kwargs['direction'].lower() == 'decrement':\n                                                ethernet.Mtu.Decrement(start_value=mtu, step_value=step)\n                                        else:\n                                            ethernet.Mtu.Single(mtu)\n            time.sleep(2)\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        else:\n            raise IxiaConfigException(\"Port %s is invalid or not configured\" % port)\n        return True\n\n    def get_all_traffic_streams(self, getEnabledTrafficItemsOnly=True):\n        \"\"\"\n        Retrieves all traffic items for a given session\n\n        :param getEnabledTrafficItemsOnly: (bool): Retrieve the traffic items which are enabled|disabled.\n                                                    Valid values True or False, default is False.\n        :return: List of one or more traffic item objects in configuration\n\n        :Example: get_all_traffic_streams(getEnabledTrafficItemsOnly=True)\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n        self.log.info(\"Available traffic streams\")\n        trafficStreams = [trafficItem for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Enabled == getEnabledTrafficItemsOnly]\n        return trafficStreams\n\n    def _modify_ipv4_ipv6_address(self,ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed):\n        \"\"\"\n        This function is used internally\n\n        :param ip_config: (str|list): Config IP address value(single/list).\n        :param pattern:(str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter\n        :param ipObj: IP Object to modify the parameters\n        :param gateway_config: (str): Config with gateway address, count, step, seed\n        :param maximum: Maximum IPv4/IPv6 addresses\n        :param step: (str): Increment step value if needed\n        :param gw_step: (str): Increment gateway step value if needed\n        :param direction: (str): Counter direction increment|decrement.\n        :param ngpfEndpoint: IXIA NGPF Endpoints\n        :param mask: IPv4/IPv6 address Mask\n        :param count: IPv4/IPv6 address count\n        :param seed: IPv4/IPv6 seed values\n        \"\"\"\n        if ngpfEndpoint == \"ipv4\":\n            if type(ip_config) == list:\n                ipObj.Address.ValueList(values=ip_config)\n            elif pattern == 'random':\n                ipObj.Address.Random()\n                if gateway_config:\n                    ipObj.GatewayIp.Random()\n            elif pattern == 'repeatableRandomRange':\n                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)\n                if gateway_config:\n                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)\n            elif pattern == 'repeatableRandom':\n                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)\n                if gateway_config:\n                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)\n            elif pattern == 'custom':\n                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)\n                if gateway_config:\n                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)\n            else:\n                if direction.lower() == \"increment\":\n                    ipObj.Address.Increment(start_value=ip_config, step_value=step)\n                    if gateway_config:\n                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)\n                else:\n                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)\n                    if gateway_config:\n                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            self.log.info(\"Device IP Address configured successfully\")\n            return True\n        if ngpfEndpoint == \"ipv6\":\n            if type(ip_config) == list:\n                ipObj.Address.ValueList(values=ip_config)\n            elif pattern == 'random':\n                ipObj.Address.Random()\n                if gateway_config:\n                    ipObj.GatewayIp.Random()\n            elif pattern == 'repeatableRandomRange':\n                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)\n                if gateway_config:\n                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)\n            elif pattern == 'repeatableRandom':\n                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)\n                if gateway_config:\n                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)\n            elif pattern == 'custom':\n                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)\n                if gateway_config:\n                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)\n            else:\n                if direction.lower() == \"increment\":\n                    ipObj.Address.Increment(start_value=ip_config, step_value=step)\n                    if gateway_config:\n                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)\n                else:\n                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)\n                    if gateway_config:\n                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            self.log.info(\"Device IP Address configured successfully\")\n            return True\n\n    def set_device_ip_address(self, router_id, address_family, ip_config, gateway_config=None, advanced_config=None, **kwargs):\n        \"\"\"\n        Modifies IP address configuration for requested routerId and address family if provided\n\n        :param router_id: (str): The router ID IP address.\n        :param address_family: (str) The IP address belongs to IPv4|IPv6\n        :param ip_config: (str|list): Config IP address value(single/list).\n        :param gateway_config: (str): Config with gateway address, count, step, seed\n        :param advanced_config: stack count, repeat, recycle count in Modifier\n        :param kwargs:\n               pattern: (str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter \\n\n               direction: (str): Counter direction increment|decrement. \\n\n               step: (str): Increment step value if needed \\n\n               gw_step: (str): Increment gateway step value if needed \\n\n               prefix: (int): Prefix for IPv4|IPv6 (24 or 64) \\n\n               resolveGateway: (bool): Resolve gateway True|False, default is True. \\n\n               multiplier: (int): Increment Multiplier value if needed\n        :return: True on success\n\n        :Example: set_device_ip_address(router_id ='192.0.0.1', address_family='IPv4', ip_config='120.1.1.1', gateway_config='120.1.1.2', name=\"ipv4\", step='0.0.1.0')\n        \"\"\"\n        self.log.info(\"Setting Device IP Address\")\n        pattern = kwargs.get('pattern','counter')\n        if address_family.lower() == 'ipv4':\n            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')\n            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)\n            gw_step = kwargs.get('gw_step', None)\n            count, seed = kwargs.get('count', None), kwargs.get('seed', None)\n            ngpfEndpoint = 'ipv4'\n\n        if address_family.lower() == 'ipv6':\n            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')\n            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)\n            gw_step = kwargs.get('gw_step', None)\n            count, seed = kwargs.get('count', None), kwargs.get('seed', None)\n            ngpfEndpoint = 'ipv6'\n        protocols = ['Ospfv3', 'BgpIpv4Peer', 'LdpConnectedInterface', 'Ospfv2', 'BgpIpv6Peer','Ldpv6ConnectedInterface']\n        if ngpfEndpoint == 'ipv4':\n            for protocol in protocols:\n                try:\n                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().'+ protocol +'.find()'):\n                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):\n                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction,ngpfEndpoint, mask, count, seed)\n                except:\n                    pass\n        if ngpfEndpoint == 'ipv6':\n            for protocol in protocols:\n                try:\n                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().'+ protocol +'.find()'):\n                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):\n                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed)\n                except:\n                    pass\n\n        return True\n\n\n    def _modify_ethernet_address(self, value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernet_obj):\n        \"\"\"\n        Modify Ethernet mac address\n\n        :param router_id: (str): The router ID IP address.\n        :param value: (str): Mac address for requested router ID.\n        :param value_mode: (str): Mac address pattern.\n        :param step: (str): Increment step value if needed\n        :param repeat_count: (int): Number of times to be repeated\n        :param seed: (int): Random see value for Source MAC address\n        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier\n        :param direction: (str): Counter direction increment|decrement.\n        :param maximum: (str): Max value for repeatableRandomRange\n        :param mask: (str): Mask for repeatableRandom\n        :param ethernetObj: Ethernet Object on which address to be modified\n        :return:True\n        \"\"\"\n        if type(value) == list:\n            ethernetObj.Mac.ValueList(values=value)\n        elif value_mode == 'random':\n            ethernetObj.Mac.Random()\n        elif value_mode == 'repeatableRandomRange':\n            ethernetObj.Mac.RandomRange(min_value=value, max_value=maximum, step_value=step, seed=seed)\n        elif value_mode == 'repeatableRandom':\n            ethernetObj.Mac.RandomMask(fixed_value=value, mask_value=mask, seed=seed, count=repeat_count)\n        elif value_mode == 'custom':\n            ethernetObj.Mac.Custom(start_value=value, step_value=step, increments=None)\n        else:\n            if direction.lower() == \"increment\":\n                ethernetObj.Mac.Increment(start_value=value, step_value=step)\n            else:\n                ethernetObj.Mac.Decrement(start_value=value, step_value=step)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        self.log.info(\"Device MAC Address set successfully\")\n        return True\n\n    def set_device_mac_address(self, router_id, value_mode='counter', value='', step='00:00:00:00:00:01',repeat_count='0', seed=1, advanced_config=None, **kwargs):\n        \"\"\"\n        Modifies mac address configuration for requested routerId if provided\n\n        :param router_id: (str): The router ID IP address.\n        :param value: (str): Mac address for requested router ID.\n        :param value_mode: (str): Mac address pattern.\n        :param step: (str): Increment step value if needed\n        :param repeat_count: (int): Number of times to be repeated\n        :param seed: (int): Random see value for Source MAC address\n        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier\n        :param kwargs:\n               direction: (str): Counter direction increment|decrement. \\n\n               maximum: (str): Max value for repeatableRandomRange \\n\n               mask: (str): Mask for repeatableRandom\n        :return: True on Success\n\n        :Example: set_device_mac_address(router_id='194.0.0.1', value='00:16:01:00:00:20')\n        \"\"\"\n        self.log.info(\"Setting Device MAC Address\")\n        direction, maximum = kwargs.get('direction','increment'), kwargs.get('maximum', None)\n        mask = kwargs.get('mask', None)\n        ethernetNameList = [ethernetObj.Name for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find()]\n        protocols = ['Ospfv2','BgpIpv4Peer','LdpConnectedInterface','Ospfv3','BgpIpv6Peer','Ldpv6ConnectedInterface']\n        for protocol in protocols:\n            try:\n                for ethernetName in ethernetNameList:\n                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv4.find().'+ protocol +'.find()'):\n                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):\n                            if router_id in eval('ethernetObj.Ipv4.find().'+protocol+'.find().LocalRouterID'):\n                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)\n            except:\n                pass\n            try:\n                for ethernetName in ethernetNameList:\n                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv6.find().'+ protocol +'.find()'):\n                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):\n                            if router_id in eval('ethernetObj.Ipv6.find().'+ protocol +'.find().LocalRouterID'):\n                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)\n            except:\n                pass\n        return True\n\n    def _start_stop_protocols(self, protocols, port_list, host_ip_list, action, active, devices, nested_device, nested=False):\n        \"\"\"\n        Function used internally by start_protocol/stop_protocol API'S\n\n        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp'])\n                                Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.\n\n        :param port_list: one or more portNames in list on which device can be started.\n                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']\n                            port: The virtual port name.\n\n        :param host_ip_list: one or more hostip in list of type ipv4 or ipv6.\n                            Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']\n                            host_ip: The source IP address to query for the object.\n        :param action: 'start' or 'stop'\n        :param active: 'True' or 'False'\n        :param devices: Name of the devices in the config\n        :param nested_device: Nested device name to set action\n        :param nested: boolean value to start/stop nested devices\n        \"\"\"\n        classicprotocol = False\n        if isinstance(protocols, str):\n            protocols = protocols.split(\",\")\n        for each_protocol in protocols:\n            if each_protocol in ('lacp', 'lldp', 'dcbx'):\n                classicprotocol = True\n        if action == 'start':\n            self.start_arp()\n        if type(protocols) is dict:\n            protocols = set(protocols)\n        protocolsList = {'isis': 'IsisL3', 'dhcpv4client': 'Dhcpv4client', 'dhcpv6client': 'Dhcpv6client',\n                        'pppoxclient': 'Pppoxclient', 'pppoxserver': 'Pppoxserver', 'mpls': 'Mpls',\n                        'dotonex': 'DotOneX', 'bfdv4interface': 'Bfdv4Interface', 'bgp': 'BgpIpv4Peer',\n                        'dhcpv4server': 'Dhcpv4server', 'igmp': 'IgmpHost', 'rsvp': 'RsvpteLsps',\n                        'rsvpteif': 'Rsvpteif', 'bgpevpn': 'BgpIPv4EvpnEvi', 'bgpv6evpn': 'BgpIPv6EvpnEvi',\n                        'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',\n                        'ldptargetedrouter': \"LdpTargetedRouter\", 'bgpevpnvpws': \"BgpIPv4EvpnVpws\",\n                        'ldpconnectedinterface': 'LdpConnectedInterface', 'ospfv2': 'Ospfv2',\n                        'bfdv6interface': 'Bfdv6Interface', 'bgpv6': 'BgpIpv6Peer', 'dhcpv6server': 'Dhcpv6server',\n                        'ldpbasicrouterv6': 'LdpBasicRouterV6', 'ldpv6connectedinterface': 'Ldpv6ConnectedInterface',\n                        'mld': 'MldHost', 'mldquerier': 'MldQuerier', 'pimv6interface': 'PimV6Interface',\n                        'ospfv3': 'Ospfv3','ipv4':'Ipv4','ipv6':'Ipv6','rocev2':'Rocev2','roce6v2':'Roce6v2'}\n        protocolsListV6 = ['mld', 'ospfv3', 'bfdv6interface', 'ldpbasicrouterv6', 'pimv6interface''dhcpv6client',\n                        'bgpipv6peer', 'dhcpv6server', 'bgpv6','roce6v2']\n        for protocol in protocols:\n            if port_list:\n                if isinstance(port_list, str):\n                    port_list = port_list.split(\",\")\n                port_name_dict = {}\n                for vport in self.ixNetwork.Vport.find():\n                    if vport.AssignedTo.replace(\":\", \"/\") in port_list or vport.Name in port_list:\n                        port_name_dict.update({vport.Name: vport.href})\n                for port_name in port_name_dict.keys():\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.Vports[0] == port_name_dict[port_name]:\n                            topologyObj = topology.href\n                            for ethernet in topology.DeviceGroup.find().Ethernet.find():\n                                if protocol.lower() in protocolsList:\n                                    try:\n                                        for protocol_obj in eval('ethernet.' + protocolsList[protocol.lower()] + '.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):\n                                                eval('ethernet.' + protocolsList[protocol.lower()] + '.find().' + action + '(async_operation=True)')\n                                    except AttributeError:\n                                        pass\n                                    except:\n                                        raise IxiaConfigException(\"Failed to start protocol %s\" % protocol)\n\n                            for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                                if protocol.lower() in protocolsList:\n                                    try:\n                                        for protocolObj in eval('ipv4.' + protocolsList[protocol.lower()] + '.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):\n                                                eval('ipv4.' + protocolsList[\n                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')\n                                    except AttributeError:\n                                        pass\n                                    except:\n                                        raise IxiaConfigException(\"Failed to start protocol %s\" % protocol)\n\n                            for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                                if protocol.lower() in protocolsList:\n                                    try:\n                                        for protocolObj in eval('ipv6.' + protocolsList[protocol.lower()] + '.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):\n                                                eval('ipv6.' + protocolsList[\n                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')\n                                    except AttributeError:\n                                        pass\n                                    except:\n                                        raise IxiaConfigException(\"Failed to start protocol %s\" % protocol)\n\n                            for ipv4_loopback in topology.DeviceGroup.find().Ipv4Loopback.find():\n                                if protocol.lower() in protocolsList:\n                                    try:\n                                        for protocol_obj in eval(\n                                                'ipv4_loopback.' + protocolsList[protocol.lower()] + '.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):\n                                                eval('ipv4_loopback.' + protocolsList[\n                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')\n                                    except AttributeError:\n                                        self.log.error(f'IPv4 Loopback Not Found - {ipv4_loopback.Name}')\n                                    except:\n                                        raise IxiaConfigException(f\"Failed to start protocol - {protocol}\")\n                            for ipv6_loopback in topology.DeviceGroup.find().Ipv6Loopback.find():\n                                if protocol.lower() in protocolsList:\n                                    try:\n                                        for protocol_obj in eval(\n                                                'ipv6_loopback.' + protocolsList[protocol.lower()] + '.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', protocol_obj.href):\n                                                eval('ipv6_loopback.' + protocolsList[\n                                                    protocol.lower()] + '.find().' + action + '(async_operation=True)')\n                                    except AttributeError:\n                                        self.log.error(f'IPv6 Loopback Not Found - {ipv6_loopback.Name}')\n                                    except:\n                                        raise IxiaConfigException(f\"Failed to start protocol - {protocol}\")\n\n            if host_ip_list:\n                protocol = protocol.lower()\n                ipv4_host_ips = [hostIp for hostIp in host_ip_list if \":\" not in hostIp]\n                ipv6_host_ips = [hostIp for hostIp in host_ip_list if \":\" in hostIp]\n                if protocol in protocolsList and protocol not in protocolsListV6:\n                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():\n                        ipindices = []\n                        for ipaddress in ipv4_host_ips:\n                            if ipaddress in ipv4Obj.Address.Values:\n                                ipindices.append((ipv4Obj.Address.Values).index(ipaddress) + 1)\n                        try:\n                            eval('ipv4Obj.' + protocolsList[protocol] + '.find().' + action + '(ipindices)')\n                        except:\n                            pass\n                else:\n                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():\n                        ipv6indices = []\n                        for ipv6address in ipv6_host_ips:\n                            if ipv6address in ipv6Obj.Address.Values:\n                                ipv6indices.append((ipv6Obj.Address.Values).index(ipv6address) + 1)\n                        try:\n                            eval('ipv6Obj.' + protocolsList[protocol] + '.find().' + action + '(ipv6indices)')\n                        except:\n                            pass\n\n            if devices and nested_device is None:\n                deviceNameList = [deviceGroupObj.Name for deviceGroupObj in\n                                self.ixNetwork.Topology.find().DeviceGroup.find()]\n                for each_device in devices:\n                    if each_device in deviceNameList:\n                        each_device = '^' + each_device.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                        protocol = protocol.lower()\n                        if protocol in protocolsList:\n                            device_object = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)\n                            self._start_stop_protocol_action(device_obj=device_object,\n                                                            protocol_name=protocolsList[protocol],\n                                                            protocol_action=action, activate=active)\n                    else:\n                        self.log.warning(f\"Device - {each_device}, not found in the Ixia config\")\n\n            if devices and nested_device:\n                device_name_list = [deviceGroupObj.Name for deviceGroupObj in\n                                    self.ixNetwork.Topology.find().DeviceGroup.find()]\n                for each_device in devices:\n                    if each_device in device_name_list:\n                        device = '^' + each_device.replace('+', r'\\+').replace('*', r'\\*') + '$'\n                        dev_object = self.ixNetwork.Topology.find().DeviceGroup.find(Name = device)\n                        if protocol.lower() in protocolsList:\n                            if dev_object.NetworkGroup.find().DeviceGroup.find():\n                                if dev_object.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):\n                                    device_object = dev_object.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                                elif dev_object.NetworkGroup.find().DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):\n                                    device_object = dev_object.NetworkGroup.find().DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                            elif dev_object.DeviceGroup.find():\n                                if dev_object.DeviceGroup.find(Name='^' + nested_device + '$'):\n                                    device_object = dev_object.DeviceGroup.find(Name='^' + nested_device + '$')\n                                elif dev_object.DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$'):\n                                    device_object = dev_object.DeviceGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                            else:\n                                self.log.error(f'Device Group {nested_device} Not found')\n                            self._start_stop_protocol_action(device_obj=device_object,\n                                                            protocol_name=protocolsList[protocol],\n                                                            protocol_action=action, activate=active)\n                    else:\n                        self.log.warning(f\"Device - {each_device}, not found in the Ixia config\")\n\n            if port_list is None and host_ip_list is None and devices is None and classicprotocol is False:\n                if protocol.lower() in protocolsList:\n                    device_object = self.ixNetwork.Topology.find().DeviceGroup.find()\n                    self._start_stop_protocol_action(device_obj=device_object, protocol_name=protocolsList[protocol],\n                                                    protocol_action=action, activate=active)\n\n                    if nested == True:\n                        try:\n                            device_object = device_object.NetworkGroup.find().DeviceGroup.find()\n                            self._start_stop_protocol_action(device_obj=device_object,\n                                                            protocol_name=protocolsList[protocol],\n                                                            protocol_action=action, activate=active)\n                        except:\n                            device_object = device_object.DeviceGroup.find()\n                            self._start_stop_protocol_action(device_obj=device_object,\n                                                            protocol_name=protocolsList[protocol],\n                                                            protocol_action=action, activate=active)\n\n            if classicprotocol:\n                if protocol.lower() == 'lacp':\n                    try:\n                        eval('self.ixNetwork.Vport.find().Protocols.find().Lacp.' + action + '()')\n                    except:\n                        pass\n                if protocol.lower() == 'lldp' or protocol.lower() == 'dcbx':\n                    try:\n                        eval(\n                            'self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().DcbxEndpoint.find().' + action + '()')\n                    except:\n                        pass\n        return True\n\n    def get_arp_status_on_streams(self):\n        \"\"\"\n        Get ARP status for All streams\n        Ex: get_arp_status_on_streams()\n        :return: arp status for each streams. Ex: {'Traffic Item 1': True, 'Traffic Item 2': False}\n        \"\"\"\n        arp_status = {}\n        trafficitems = self.ixNetwork.Traffic.TrafficItem.find()\n        for trafficitem in trafficitems:\n            self.log.info(f\"Checking ARP status on stream {trafficitem.Name}\")\n            if trafficitem.FlowGroupCount == 0:\n                arp_status[trafficitem.Name] = False\n            else:\n                highlevelstream = trafficitem.HighLevelStream.find()\n                output = highlevelstream.PreviewFlowPackets(0, 1)\n                l3Info = dict(zip(output['arg3'], output['arg4'][0]))\n                destination_mac_address = l3Info.get('Destination MAC Address')\n                if destination_mac_address == 'removePacket[Unresolved]':\n                    arp_status[trafficitem.Name] = False\n                else:\n                    arp_status[trafficitem.Name] = True\n        return arp_status\n\n    def arp_on_object_list(self, object_type=None, object_list=None, action='start'):\n        \"\"\"\n        Start/Stop ARP on specific (ports/devices/streams)\n\n        :param object_type: \"devices\" or \"streams\" or \"ports\"\n        :param object_list: List of Device names or Stream names or Port names\n        :param action: \"start\" or \"stop\"\n        :return: True on success\n        :Examples:\n        tgn.arp_on_object_list(object_type=\"devices\", object_list=[\"Device-1\", \"Device-2\"], action='start')\n        tgn.arp_on_object_list(object_type=\"ports\", object_list=[\"port_1\", \"port_2\"], action='start')\n        \"\"\"\n        if object_type == None or object_list == None:\n            raise IxiaConfigException(\n                'object_type must be ports/devices/streams and object_list cannot be empty')\n\n        elif object_type.lower() == 'devices':\n            device_list = self.get_device_names()\n            for each_object in object_list:\n                if each_object in device_list:\n                    each_object = re.escape(each_object)\n                    device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f'^{each_object}$')\n                    for each_ipv4 in device_obj.Ethernet.find().Ipv4.find():\n                        obj_count = each_ipv4.Count\n                        obj_count_list = list(range(1, obj_count + 1))\n                        if action == 'start':\n                            each_ipv4.SendArp(SessionIndices=obj_count_list)\n                else:\n                    raise IxiaConfigException(f\"{each_object} not found in configuration\")\n\n        elif object_type.lower() == 'ports':\n            vport_list = [vport.Name for vport in self.get_list_ports() if vport]\n\n            for port in object_list:\n                if port in vport_list or self.get_port_name_from_location(port) in vport_list:\n                    if action == 'start':\n                        if not re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', port):\n                            port = re.escape(port)\n                        self.start_arp(ports=port)\n                else:\n                    raise IxiaConfigException(f\"{port} not found in configuration\")\n        else:\n            raise IxiaConfigException(\"object_type must be ports/devices/streams\")\n        return True\n\n    def _start_stop_protocol_action(self, device_obj, protocol_name, protocol_action, activate):\n        \"\"\"\n        This is internal function to start/stop the protocols\n        :param device_obj:Device Object where protocols will be started/stopped\n        :param protocol_name:Protocol to be started/stopped\n        :param protocol_action:Start/Stop\n        :param activate: True or False\n        :return: True on success\n        \"\"\"\n        loopback_protocol_dict = {'BgpIPv4EvpnEvi': 'BgpIpv4Peer', 'BgpIPv6EvpnEvi': 'BgpIpv6Peer',\n                                    'BgpIPv4EvpnVpws': 'BgpIpv4Peer'}\n        try:\n            eval('device_obj' + '.Ethernet.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n        try:\n            eval('device_obj' + '.Ethernet.find().'+'DotOneX.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n        try:\n            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().Active.Single' + '(' + activate + ')')\n            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n\n        try:\n            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().Active.Single' + '(' + activate + ')')\n            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n\n        try:\n            if protocol_name in loopback_protocol_dict.keys():\n                eval('device_obj' + '.Ipv4Loopback.find().' +\n                    loopback_protocol_dict[protocol_name] + '.find().' +\n                    protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n            else:\n                eval('device_obj' + '.Ipv4Loopback.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n\n        try:\n            if protocol_name in loopback_protocol_dict.keys():\n                eval('device_obj' + '.Ipv6Loopback.find().' + loopback_protocol_dict[protocol_name] + '.find().' +\n                    protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n            else:\n                eval('device_obj' + '.Ipv6Loopback.find().' + protocol_name + '.find().' + protocol_action + '(async_operation=True)')\n        except:\n            pass\n        return True\n\n    def start_protocols(self, protocols, port=None, host_ip=None, protocol_only=False, devices=None, **kwargs):\n        \"\"\"\n        To start devices configured with a protocol or a list of protocols\n\n        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']). \\n\n                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.\n        :param port: one or more portNames in list on which device can be started. \\n\n                            Ex: ['1/2/9'] or ['1/2/9','1/2/10'].\n                            port: The virtual port name.\n        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \\n\n                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2'].\n                               host_ip: The source IP address to query for the object.\n        :param protocol_only: NA for Ixia. Added to follow Tgn Vendor Agnostic.\n        :param devices: Name of the devices in the config\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                nested_device: For IXIA nested Device name if nested DG to be started\n        :return: True on success\n\n        :Example: start_protocols(['ospfv2', 'ospfv3'])\n                  start_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])\n                  start_protocols(protocols=[\"rsvp\"],devices=[\"D8_5\"],nested_device=\"D8_5_RSVP\")\n        \"\"\"\n        self.log.info(f\"Starting protocols: {protocols}\")\n        port_list = port\n        host_ip_list = host_ip\n        nested_device = kwargs.get('nested_device', None)\n        nested = kwargs.get('nested', False)\n        return self._start_stop_protocols(protocols, port_list, host_ip_list, \"Start\", \"True\", devices, nested_device, nested)\n\n    def stop_protocols(self, protocols, port=None, host_ip=None, devices=None, **kwargs):\n        \"\"\"\n        To stop devices configured with a protocol or a list of protocols\n\n        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']) \\n\n                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.\n        :param port: one or more portNames in list on which device can be started. \\n\n                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']\n                            port: The virtual port name.\n        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \\n\n                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']\n                               host_ip: The source IP address to query for the object.\n        :param devices: Name of the devices in the config\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                nested_device: nested_device: For IXIA nested Device name if nested DG to be stopped\n\n        :Example: stop_protocols(protocols=['ospfv2', 'ospfv3'], devices=['DG1'])\n                  stop_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])\n                  stop_protocols(protocols=[\"rsvp\"],devices=[\"D8_5\"],nested_device=\"D8_5_RSVP\")\n\n        :return: True on Success,else raises exception\n        \"\"\"\n        self.log.info(f\"Stopping protocols: {protocols}\")\n        port_list = port\n        host_ip_list = host_ip\n        nested_device = kwargs.get('nested_device', None)\n        nested = kwargs.get('nested', False)\n        return self._start_stop_protocols(protocols, port_list, host_ip_list, \"Stop\", \"True\", devices, nested_device, nested)\n\n    def connect_to_session(self, sid=None, **kwargs):\n        \"\"\"\n        Connect to an existing session on the TGN.\n\n        :param sid: The session ID on the Linux API server or Windows Connection Mgr to connect to.\n        :param kwargs: optional\n        :return: True if successful else raises exception\n\n        :Example: connect_to_session(sId=1)\n        \"\"\"\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n        if not sid:\n            self.log.info(f\"Connecting to Session - '{self.session_name}'\")\n        else:\n            self.log.info(f\"Connecting to Session - '{sid}'\")\n        kill_existing = kwargs.get('kill_existing', False)\n        self._new_session(session_name=sid, kill_existing=kill_existing)\n        return True\n\n    def delete_session(self):\n        \"\"\"\n        Deletes the TGN session\n\n        :return: True on success, exception on failure\n\n        :Example: delete_session()\n        \"\"\"\n        if self.tgn_server_type == \"linux\":\n            try:\n                sId = self.session.Id\n                self.session.remove()\n                self.log.info(\"Deleted Session %s\" %sId)\n                return True\n            except:\n                self.log.error(\"Failed to delete the Session\")\n\n    def tgn_disconnect(self, port_list=None):\n        \"\"\"\n        Release the ports and delete the session.\n\n        :param port_list: (list): format = [[(str(chassisIp), str(slotNumber), str(portNumber)]] \\n\n                Example: [ ['192.168.70.10', '1', '1'] ] \\n\n                Example: [ ['192.168.70.10', '1', '1'], ['192.168.70.10', '2', '1'] ]\n        :return: True on success, exception on failure\n\n        :Example: tgn_disconnect(port_list=['Ethernet - 001','Ethernet - 002'])\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info(\"Disconnecting TGN Session\")\n        if port_list:\n            self.release_ports(port_list)\n            results = True\n        else:\n            self.release_ports()\n            results = True\n\n        # If OS is linux, delete the session\n        if self.tgn_server_type == 'linux':\n            self.session.remove()\n            results = True\n        return results\n\n    def _ldp_start_stop(self, port, hostip, action):\n        \"\"\"\n        Function used internally by APIS ldp_start and ldp_stop\n\n        :param port: one or more port names in a list. If 'None', all the ports.\n                Ex: port = ['1/1/2']\n                     port = ['1/1/1', '1/1/2']\n        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address\n                    Ex : hostip = ['1.1.1.1']\n                        hostip = ['1.1.1.1', '2000:0:0:1::1', ...]\n        :param action: 'start' or 'stop'\n        \"\"\"\n        self.log.info('LDP action %s' % (action))\n        if (port and hostip):\n            if type(port) is str:\n                port = port.split(\",\")\n            for portName in port:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n\n                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            ipv4_temp = []\n                            ipv6_temp = []\n                            ipv4Address = []\n                            ipv6Address = []\n                            [ipv4_temp.append(ipv4.Address.Values) for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find()]\n\n                            for ip in ipv4_temp:\n                                for eachIp in ip:\n                                    ipv4Address.append(eachIp)\n\n                            if len(hostip) == len(ipv4Address):\n                                if action == \"Start\":\n                                    for ldp in ipv4.LdpConnectedInterface.find():\n                                        if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                            Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                            eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')\n                                else:\n                                    for ldp in ipv4.LdpBasicRouter.find():\n                                        if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                            Name= ldp.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                            eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')\n                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            [ipv6_temp.append(ipv6.Address.Values) for ipv6 in\n                             topology.DeviceGroup.find().Ethernet.find().Ipv6.find()]\n\n                            for ip in ipv6_temp:\n                                for eachIp in ip:\n                                    ipv6Address.append(eachIp)\n                            if len(hostip) == len(ipv6Address):\n                                for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                                    if action == \"Start\":\n                                        for ldp in ipv6.Ldpv6ConnectedInterface.find():\n                                            if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                                Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                                eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')\n                                    else:\n                                        for ldp in ipv6.LdpBasicRouterV6.find():\n                                            if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                                Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                                eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')\n\n        if (port and hostip is None):\n            if type(port) is str:\n                port = port.split(\",\")\n            for portName in port:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            if action == \"Start\":\n                                for ldp in ipv4.LdpConnectedInterface.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                        Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*',r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                        eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')\n                            else:\n                                for ldp in ipv4.LdpBasicRouter.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                        Name= ldp.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*').replace('(', r'\\(').replace(')', r'\\)')\n                                        eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')\n                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                            if action == \"Start\":\n                                for ldp in ipv6.Ldpv6ConnectedInterface.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                        Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*').replace('(',')', r'\\)')\n                                        eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')\n                            else:\n                                for ldp in ipv6.LdpBasicRouterV6.find():\n                                    if re.match(topologyObj + '/deviceGroup', ldp.href):\n                                        Name = ldp.DescriptiveName.replace('+', r'\\+').replace('*', r'\\*').replace('(',')',r'\\)')\n                                        eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')\n\n        if hostip and port is None:\n            for ipAddress in hostip:\n                if ':' not in ipAddress:\n                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():\n                       if ipAddress in ipv4Obj.Address.Values:\n                            ipIndex = (ipv4Obj.Address.Values).index(ipAddress)+1\n                            if action == \"Start\":\n                                eval('ipv4Obj.LdpConnectedInterface.find().'+action+'(ipIndex)')\n                            else:\n                                eval('ipv4Obj.LdpBasicRouter.find().'+action+'(ipIndex)')\n                            break\n                else:\n                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():\n                        if ipAddress in ipv6Obj.Address.Values:\n                            ipIndex = (ipv6Obj.Address.Values).index(ipAddress) + 1\n                            if action == \"Start\":\n                                eval('ipv6Obj.Ldpv6ConnectedInterface.find().'+action+'(ipIndex)')\n                            else:\n                                eval('ipv6Obj.LdpBasicRouterV6.find().'+action+'(ipIndex)')\n                            break\n        if port is None and hostip is None:\n            if action == \"Start\":\n                try:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpConnectedInterface.find().'+action+'(None)')\n                except:pass\n                try:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ldpv6ConnectedInterface.find().'+action+'(None)')\n                except:pass\n            else:\n                try:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpBasicRouter.find().'+action+'(None)')\n                except:pass\n                try:\n                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().LdpBasicRouterV6.find().'+action+'(None)')\n                except:pass\n\n        return True\n\n    def ldp_start(self, port=None, hostip=None):\n        \"\"\"\n        Starts LDP emulation\n\n        :param port: one or more port names in a list. If 'None', all the ports. \\n\n                    Ex : port = ['1/1/2']\n                    Ex : port = ['1/1/1', '1/1/2']\n        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \\n\n                    Ex : hostip = ['1.1.1.1']\n                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]\n        :return: True. raise exception if False/error\n\n        :Example: ldp_start(hostip=['100.1.0.1','100.1.0.2'])\n        \"\"\"\n\n        return self._ldp_start_stop(port, hostip, \"Start\")\n\n    def ldp_stop(self, port=None, hostip=None):\n        \"\"\"\n        Stops LDP emulation\n\n        :param port: one or more port names in a list. If 'None', all the ports. \\n\n                    Ex : port = ['1/1/2']\n                    Ex : port = ['1/1/1', '1/1/2']\n        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \\n\n                    Ex : hostip = ['1.1.1.1']\n                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]\n        :return: True. raise exception if False/error\n\n        :Example: ldp_stop(hostip=['100.1.0.1','100.1.0.2'])\n        \"\"\"\n\n        return self._ldp_start_stop(port, hostip, \"Stop\")\n\n    def clear_traffic_stats(self):\n        \"\"\"\n        Clears the traffic statistics on the chassis\n\n        :return: True if success, false if error\n\n        :Example: clear_traffic_stats()\n        \"\"\"\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n        #     return\n\n        self.log.info(\"Clearing Stats\")\n        try:\n            self.ixNetwork.ClearPortsAndTrafficStats(Arg1=[\"waitForTrafficStatsRefresh\"])\n        except:\n            pass\n        self.log.info(\"Traffic Stats Cleared\")\n        return True\n\n    def _change_mac_format(self,inputMac):\n        \"\"\"\n        Internal function to change MAC address format\n\n        :param inputMac: MAC Address in any format\n                        EX:'008a.9695.748c'\n        :return: MAC Address in actual format\n                OutputMac: '00:8a:96:95:74:8c'\n        \"\"\"\n        outputMac = netaddr.EUI(inputMac)\n        outputMac.dialect = netaddr.mac_unix_expanded\n        return str(outputMac)\n\n    def change_traffic_mac(self,\n                           traffic_item_name=None,\n                           endpoint_name='EndpointSet-1',\n                           mac_dst_mode=None,\n                           mac_dst='00:00:00:00:00:01',\n                           mac_dst_count=1,\n                           mac_dst_step='00:00:00:00:00:01',\n                           mac_dst_mask='FF:FF:FF:FF:FF:FF',\n                           mac_dst_seed=1,\n                           mac_src_mode=None,\n                           mac_src='00:00:00:00:00:01',\n                           mac_src_count=1,\n                           mac_src_step='00:00:00:00:00:01',\n                           mac_src_mask='FF:FF:FF:FF:FF:FF',\n                           mac_src_seed=1,\n                           eth_header_index=None):\n        \"\"\"\n        API used to change MAC Address on Traffic Item/Stream\n\n        :param traffic_item_name: The traffic item name\n        :param endpoint_name: The endpoint name\n        :param mac_dst_mode: The mac destination mode\n        :param mac_dst: The mac destination address\n        :param mac_dst_count: The mac destination count\n        :param mac_dst_step: The mac destination step\n        :param mac_dst_mask: The mac destination mask\n        :param mac_dst_seed: The mac destination seed\n        :param mac_src_mode: The mac source mode\n        :param mac_src: The mac source address\n        :param mac_src_count: The mac source count\n        :param mac_src_step: The mac source step\n        :param mac_src_mask: The mask source mask\n        :param mac_src_seed: The mask source seed\n        :param eth_header_index: Index of ethernet header\n        :return: True on success else raises exception\n\n        :Example: change_traffic_mac(traffic_item_name=\"Traffic Item 4\")\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        self.log.info(\"Changing Mac Parameters for Traffic Item/Items\")\n        mac_mode_dict = {None: 'singleValue', 'fixed': 'singleValue', 'discovery': 'singleValue', 'increment': 'increment', 'list': 'valueList',\n                         'decrement': 'decrement', 'random': 'nonRepeatableRandom', 'repeatable_random': 'repeatableRandomRange'}\n        mac_updated = False\n        mac_src_list = []\n        mac_dst_list = []\n\n        if isinstance(mac_dst, list):\n            for mac_dst_value in mac_dst:\n                mac_dst_list.append(self._change_mac_format(mac_dst_value))\n            mac_dst = mac_dst_list[0]\n        else:\n            mac_dst = self._change_mac_format(mac_dst)\n            mac_dst_list = [mac_dst]\n        mac_dst_step = self._change_mac_format(mac_dst_step)\n        mac_dst_mask = self._change_mac_format(mac_dst_mask)\n\n        if isinstance(mac_src, list):\n            for mac_src_value in mac_src:\n                mac_src_list.append(self._change_mac_format(mac_src_value))\n            mac_src = mac_src_list[0]\n        else:\n            mac_src = self._change_mac_format(mac_src)\n            mac_src_list = [mac_src]\n        mac_src_step = self._change_mac_format(mac_src_step)\n        mac_src_mask = self._change_mac_format(mac_src_mask)\n\n        if traffic_item_name:\n            self.log.info(f\"Changing MAC Parameters for Traffic Item/Items - {traffic_item_name}\")\n        else:\n            self.log.info(\"Changing MAC Parameters for all available Traffic Item/Items\")\n        if isinstance(traffic_item_name, str):\n            traffic_item_name_list = [traffic_item_name]\n        elif isinstance(traffic_item_name, list):\n            traffic_item_name_list = traffic_item_name\n        else:\n            traffic_item_name_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]\n\n        all_traffic_items = self.ixNetwork.Traffic.TrafficItem.find()\n        all_traffic_names = [ti.Name for ti in all_traffic_items]\n\n        for traffic_name in traffic_item_name_list:\n            if traffic_name not in all_traffic_names:\n                self.log.warning(f\"Traffic item '{traffic_name}' not found.\")\n                continue\n            traffic_stream = re.escape(traffic_name)\n            config_elems = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_stream}$').ConfigElement.find()\n            eth_header_matched = False\n            eth_header_count = 0\n\n            for stack in config_elems.Stack.find():\n                if stack.DisplayName != \"Ethernet II\":\n                    continue\n                eth_header_count += 1\n                if eth_header_index is not None and eth_header_count != eth_header_index:\n                    continue\n\n                eth_header_matched = True\n\n                for field in stack.Field.find():\n                    # Destination MAC\n                    if field.DisplayName == \"Destination MAC Address\":\n                        if hasattr(field, 'Auto'):\n                            field.Auto = False\n                        field.ValueType = mac_mode_dict[mac_dst_mode]\n                        if field.ValueType == 'singleValue':\n                            field.FieldValue = mac_dst\n                        elif field.ValueType in ['increment', 'decrement']:\n                            field.StartValue = mac_dst\n                            field.StepValue = mac_dst_step\n                            field.CountValue = mac_dst_count\n                        elif field.ValueType == 'valueList':\n                            field.ValueList = mac_dst_list\n                        elif field.ValueType == 'repeatableRandomRange':\n                            field.StartValue = mac_dst\n                            field.StepValue = mac_dst_step\n                            field.CountValue = mac_dst_count\n                            field.RandomMask = mac_dst_mask\n                            field.Seed = mac_dst_seed\n                        elif field.ValueType == 'nonRepeatableRandom':\n                            field.CountValue = mac_dst_count\n                            field.RandomMask = mac_dst_mask\n\n                        field.update()\n\n                    # Source MAC\n                    elif field.DisplayName == \"Source MAC Address\":\n                        if hasattr(field, 'Auto'):\n                            field.Auto = False\n\n                        field.ValueType = mac_mode_dict[mac_src_mode]\n                        if field.ValueType == 'singleValue':\n                            field.FieldValue = mac_src\n                        elif field.ValueType in ['increment', 'decrement']:\n                            field.StartValue = mac_src\n                            field.StepValue = mac_src_step\n                            field.CountValue = mac_src_count\n                        elif field.ValueType == 'valueList':\n                            field.ValueList = mac_src_list\n                        elif field.ValueType == 'repeatableRandomRange':\n                            field.StartValue = mac_src\n                            field.StepValue = mac_src_step\n                            field.CountValue = mac_src_count\n                            field.RandomMask = mac_src_mask\n                            field.Seed = mac_src_seed\n                        elif field.ValueType == 'nonRepeatableRandom':\n                            field.CountValue = mac_src_count\n                            field.RandomMask = mac_src_mask\n                        field.update()\n                mac_updated = True\n            if eth_header_index is not None and not eth_header_matched:\n                self.log.warning(f\"Traffic item '{traffic_name}': Ethernet II header index {eth_header_index} \"\n                                 f\"is out of range (only {eth_header_count} Ethernet II headers found).\")\n                continue\n        if mac_updated:\n            self.log.info(\"MAC address update completed successfully.\")\n            return True\n        else:\n            self.log.warning(\"No MAC addresses were updated. traffic items were invalid or skipped.\")\n            return False\n\n    def change_traffic_transmission_mode(self, config, traffic_item_list='all', port='all', **kwargs):\n        \"\"\"\n        Changes the transmission control mode for a given set of traffic items.\n\n        :param config: Dict including the transmission control data to be modified. \\n\n            valid Options:\\n\n            type: auto,continuous,custom,fixedDuration, fixedFrameCount,fixedIterationCount \\n\n            duration: The duration of time (in seconds) for traffic to run for applicable transmission control types \\n\n            extra options (case-sensitive): iterationCount,frameCount,startDelay,startDelayUnits,minGapBytes, burstPacketCount,repeatBurst,interBurstGap,interStreamGap,interBurstGapUnits \\n\n        :param traffic_item_list: List of traffic Items name.\n        :param port: NA for IXIA\n        :param kwargs:\n                    - split_port_rate : (False by default) To be used for even distribution of load across Traffic Items\n        :return: True on success, else reverts the config\n\n        :Example: change_traffic_transmission_mode(config={'type': 'custom', 'interBurstGap': 25, 'burstPacketCount': 25}, traffic_item_list=[\"Traffic Item 3\"])\n        \"\"\"\n\n        self.log.info(\"Changing Traffic Transmission Mode\")\n        split_port_rate = kwargs.get('split_port_rate', False)\n        rate_map_dict = {'fps': 'framesPerSecond', 'bps': 'bitsPerSecond',\n                         'kps': 'kilobitsPerSecond', 'mps': 'megabitsPerSecond', 'percent': 'percentLineRate'}\n        if traffic_item_list and traffic_item_list != 'all':\n            if 'mode' in config.keys():\n                if config['mode'] in ['stream_rate', 'port_rate']:\n                    traffic_rate_dict = {}\n                    if 'load' in config.keys():\n                        if split_port_rate == False:\n                            traffic_rate_dict.update({'rate': config['load']})\n                        else:\n                            src_groups = defaultdict(list)\n                            for item in self.ixNetwork.Traffic.TrafficItem.find():\n                                src_desc = item.EndpointSet.find().SourcesDescription\n                                if src_desc:\n                                    key = (src_desc,)\n                                    src_groups[key].append(item)\n                            total_load = config.get('load')\n                            unit = config.get('load_unit')\n                            for group, ti_list in src_groups.items():\n                                per_ti_load = int(total_load / len(ti_list))\n                                self.log.info(\n                                    f\"Source group {group} has {len(ti_list)} TIs. Per-TI load: {per_ti_load} {unit}\")\n                                for item in ti_list:\n                                    try:\n                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')\n                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)\n                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)\n                                    except Exception as err:\n                                        self.log.error(f\"Failed to set load on TI '{item.Name}': {err}\")\n                    if 'load_unit' in config.keys():\n                        if config['load_unit'] in rate_map_dict.keys():\n                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})\n                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():\n                        self.change_traffic_rate(cfg_dict=traffic_rate_dict, traffic_item_list=traffic_item_list)\n                    if 'duration_mode' in config.keys():\n                        if config['duration_mode'] == 'seconds':\n                            config['type'] = 'fixedDuration'\n                            config['startDelayUnits'] = config['duration_mode']\n                        elif config['duration_mode'] == 'continuous':\n                            config['type'] = 'continuous'\n            for traffic_item in traffic_item_list:\n                traffic_item = re.escape(traffic_item)\n                for transmission_control in self.ixNetwork.Traffic.TrafficItem.find(\n                        Name=f'^{traffic_item}$').ConfigElement.find().TransmissionControl:\n                    for key in config:\n                        if 'interBurstGap' in key:\n                            setattr(transmission_control, 'EnableInterBurstGap', True)\n                        try:\n                            setattr(transmission_control, key[0].upper() + key[1:], config[key])\n                        except:\n                            pass\n        else:\n            if 'mode' in config.keys():\n                if config['mode'] in ['stream_rate', 'port_rate']:\n                    traffic_rate_dict = {}\n                    if 'load' in config.keys():\n                        if split_port_rate == False:\n                            traffic_rate_dict.update({'rate': config['load']})\n                        else:\n                            src_groups = defaultdict(list)\n                            for item in self.ixNetwork.Traffic.TrafficItem.find():\n                                src_desc = item.EndpointSet.find().SourcesDescription\n                                if src_desc:\n                                    key = (src_desc,)\n                                    src_groups[key].append(item)\n                            total_load = config.get('load')\n                            unit = config.get('load_unit')\n                            for group, ti_list in src_groups.items():\n\n                                per_ti_load = int(total_load / len(ti_list))\n                                self.log.info(f\"Port {group} has {len(ti_list)} TIs. Per-TI load: {per_ti_load} {unit}\")\n                                for item in ti_list:\n                                    try:\n                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')\n\n                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)\n                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)\n                                    except Exception as err:\n                                        self.log.error(f\"Failed to set load on TI '{item.Name}': {err}\")\n                    if 'load_unit' in config.keys():\n                        if config['load_unit'] in rate_map_dict.keys():\n                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})\n                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():\n                        self.change_traffic_rate(cfg_dict=traffic_rate_dict)\n                    if 'duration_mode' in config.keys():\n                        if config['duration_mode'] == 'seconds':\n                            config['type'] = 'fixedDuration'\n                            config['startDelayUnits'] = config['duration_mode']\n                        elif config['duration_mode'] == 'continuous':\n                            config['type'] = 'continuous'\n            for transmission_control in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().TransmissionControl:\n                for key in config:\n                    if 'interBurstGap' in key:\n                        setattr(transmission_control, 'EnableInterBurstGap', True)\n                    try:\n                        setattr(transmission_control, key[0].upper() + key[1:], config[key])\n                    except:\n                        pass\n        self.log.info(\"Traffic Transmission mode updated in Traffic Items\")\n        return True\n\n    def _igmp_mld_multicast(self, vportList, ipVersion, HostObj,srcObj, groupObj, proto, action, state,\n                             igmp_mld_mcastList, hostIpList=None, versionType=None, groupDict=None, protocolType='mld'):\n        \"\"\"\n        Function used internally by APIs igmp_join_leave,mld_join_leave\n\n        :param vportList: List of Vports\n        :param ipVersion: IP version , Ex:IPv4/IPv6\n        :param HostObj: Host Object\n        :param srcObj: Source Object\n        :param groupObj: Group Object\n        :param proto: Protocol\n        :param action: Action\n        :param state: State\n        :param igmp_mld_mcastList: IGMP MLD Multicast\n        :param hostIpList: Host IP List\n        :param versionType: IGMP Version type.\n        :param groupDict: IGMP Group value\n        :param protocolType: Protocol Type\n        \"\"\"\n\n        for vport in vportList:\n            vport = vport.replace(\"(\", r\"\\(\").replace(\")\", r\"\\)\")\n            if self.ixNetwork.Vport.find(Name=vport + r'\\s'):\n                vports = self.ixNetwork.Vport.find(Name=vport + r'\\s')\n            else:\n                vports = self.ixNetwork.Vport.find(Name=vport)\n            for topology in self.ixNetwork.Topology.find():\n                if vports.href in topology.Vports:\n                    portIndex = topology.Vports.index(vports.href)\n                    for deviceGroup in topology.DeviceGroup.find():\n                        multiplier = deviceGroup.Multiplier\n                        mcastList = {'igmp_mld_host_obj': '', 'action_list': '', 'new_active_state': '', 'port_ips': '', 'selected_index': '', 'selected_info': ''}\n                        if eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()'):\n                            groupList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()')\n                            if groupList.Status == \"notStarted\":\n                                eval('groupList.' + proto +'StartHost()')\n                                time.sleep(10)\n                                eval('groupList.' + groupObj + '.' + proto + 'Leave' + 'Group(None)')\n                                time.sleep(10)\n                            else:\n                                pass\n\n                            groupRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges\n                            groupRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges\n\n                            sourceRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')\n                            sourceRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')\n\n                            if hostIpList:\n                                ipAddressList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().Address.Values')\n                                for ip in hostIpList:\n                                    if ip in ipAddressList:\n                                        ipIndex = ipAddressList.index(ip)\n                                        ipGroupRangeStartIndex = ipIndex * groupList.NoOfGrpRanges + 1\n                                        ipGroupRangeEndIndex = (ipIndex + 1) * groupList.NoOfGrpRanges\n                                        if ipGroupRangeStartIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1):\n                                            groupRange = str(ipGroupRangeStartIndex)+\"-\"+str(ipGroupRangeEndIndex)\n                                            eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find().' + groupObj\n                                                 + '.' + proto + action + 'Group(SessionIndices=groupRange)')\n\n                            elif groupDict:\n                                for group in groupDict:\n                                    mcastGroupsList = eval('groupList.' + groupObj + '.StartMcastAddr.Values')\n                                    if ipVersion.lower() == \"ipv4\":\n                                        sourcesList = eval('groupList.' + groupObj +'.IgmpUcastIPv4SourceList.StartUcastAddr.Values')\n                                    else:\n                                        sourcesList = eval('groupList.' + groupObj +'.MldUcastIPv6SourceList.StartUcastAddr.Values')\n\n                                    mcastGroupsIndices = [index + 1 for index in range(len(mcastGroupsList)) if group ==\n                                                          mcastGroupsList[index] and index in range(groupRangeStartIndex, groupRangeEndIndex)]\n\n                                    #version and group combination\n                                    versionTypeValues = groupList.VersionType.Values\n                                    indices = [index + 1 for index, version in enumerate(versionTypeValues) if version == versionType]\n                                    groupRanges = eval('groupList.NoOfGrpRanges')\n                                    joinLeaveList = []\n                                    for index in indices:\n                                        endIndex = index * groupRanges\n                                        startIndex = endIndex - groupRanges\n                                        GroupIndexList = [index for index in range(endIndex, startIndex, -1)]\n                                        GroupIndexList = GroupIndexList[::-1]\n                                        joinLeaveList.append(GroupIndexList)\n                                    joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index\n                                                     if joinIndex in range(groupRangeStartIndex + 1, groupRangeEndIndex + 1)]\n\n                                    mcastGroupSourceIndices = list(set(joinLeaveList).intersection(mcastGroupsIndices))\n\n                                    if mcastGroupSourceIndices != []:\n                                        if '*' in groupDict[group]:\n                                            eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')\n                                        else:\n                                            sourcesListindices = []\n                                            for source in groupDict[group]:\n                                                sourcesListindices.append([index + 1 for index in range(len(sourcesList)) if source ==\n                                                                           sourcesList[index] and index in range(sourceRangeStartIndex, sourceRangeEndIndex)])\n\n                                            sourcesListindices = [ele for subele in sourcesListindices for ele in subele]\n\n                                            sources = eval('groupList.' + groupObj + '.NoOfSrcRanges')\n                                            mcastGroupIndex = mcastGroupsIndices[0]\n                                            srcRangeStartIndex = (mcastGroupIndex - 1) * sources + 1\n                                            srcRangeEndIndex = (mcastGroupIndex) * sources + 1\n                                            sourcesListindices = [sourceIndex for sourceIndex in sourcesListindices\n                                                                  if sourceIndex in range(srcRangeStartIndex, srcRangeEndIndex)]\n\n                                            if action == \"Join\":\n                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')\n                                                sourceRange = str(srcRangeStartIndex) + \"-\" + str(srcRangeEndIndex-1)\n                                                eval('groupList.' + groupObj + '.' + srcObj + '.' + proto + 'LeaveSource(SessionIndices=sourceRange)')\n\n                                            eval('groupList.' + groupObj + '.' + srcObj + '.'+ proto + action + 'Source(SessionIndices=sourcesListindices)')\n\n                                            time.sleep(2)\n                                            if ipVersion.lower() == \"ipv4\":\n                                                stateList = eval('groupList.' + groupObj + '.IgmpUcastIPv4SourceList.State')\n                                            else:\n                                                stateList = eval('groupList.' + groupObj + '.MldUcastIPv6SourceList.State')\n\n                                            stateList = stateList[(mcastGroupIndex - 1)*sources:(mcastGroupIndex)*sources]\n                                            if len(set(stateList)) == 1:\n                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')\n\n                            elif versionType:\n                                versionTypeValues = groupList.VersionType.Values\n                                indices = [index+1 for index, version in enumerate(versionTypeValues) if version == versionType]\n                                groupRanges = eval('groupList.NoOfGrpRanges')\n                                joinLeaveList = []\n                                for index in indices:\n                                    endIndex = index * groupRanges\n                                    startIndex = endIndex - groupRanges\n                                    GroupIndexList = [index for index in range(endIndex, startIndex, -1)]\n                                    GroupIndexList = GroupIndexList[::-1]\n                                    joinLeaveList.append(GroupIndexList)\n                                joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index\n                                                 if joinIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1)]\n                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(joinLeaveList)')\n                            else:\n                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(None)')\n\n                        igmp_mld_mcastList.append(mcastList)\n\n    def _igmp_mld_join_leave(self, protocol, port, action, version, hostIp, groups):\n        \"\"\"\n        Function used internally by APIs igmp_join_leave,mld_join_leave\n\n        :param protocol: Protocol Type\n        :param port: IXIA Port\n        :param action: Action , Ex: Join/Leave\n        :param version: IGMP version\n        :param hostIp: Host IP\n        :param groups: IGMP Groups\n        \"\"\"\n\n        if protocol.lower() == 'mld':\n            HostObj = \"MldHost\"\n            ipVersion = \"Ipv6\"\n            groupObj = \"MldMcastIPv6GroupList\"\n            proto = \"Mld\"\n            srcObj = \"MldUcastIPv6SourceList\"\n        else :\n            HostObj = \"IgmpHost\"\n            ipVersion =\"Ipv4\"\n            groupObj = \"IgmpMcastIPv4GroupList\"\n            proto = \"Igmp\"\n            srcObj = \"IgmpUcastIPv4SourceList\"\n        if action.lower() == \"leave\":\n            action = \"Leave\"\n            state = \"notJoined\"\n        else:\n            action = \"Join\"\n            state = \"joined\"\n        igmp_mld_mcastList = []\n\n        if version == 'v1':\n            version = \"version1\"\n        elif version == 'v2':\n            version = \"version2\"\n        elif version == 'v3':\n            version = \"version3\"\n        else:\n            if protocol.lower() == 'mld':\n                version = \"version1\"\n            else:\n                version = \"version2\"\n\n        if port == None and hostIp == None and groups == None and version == None:\n            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,\n                                                        action, state, igmp_mld_mcastList)\n\n        elif port:\n            if type(port) is str:\n                port = port.split(\",\")\n            vportNameList = [vport.Name.split(\"//\")[0].rstrip() for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in port if portName in vportNameList]\n            if groups:\n                groupsOnly = list(set([group[1] for group in groups]))\n                groupDict = {}\n                for groupOnly in groupsOnly:\n                    groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]\n                self._igmp_mld_multicast(portNameList, ipVersion, HostObj,srcObj, groupObj, proto,\n                                         action, state, igmp_mld_mcastList,hostIpList=hostIp,\n                                         versionType=version,groupDict=groupDict, protocolType=protocol)\n            else:\n                self._igmp_mld_multicast(portNameList, ipVersion, HostObj, srcObj, groupObj, proto,\n                                         action, state, igmp_mld_mcastList, hostIpList=hostIp,\n                                         versionType=version)\n\n        elif hostIp:\n            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,\n                                                        action, state, igmp_mld_mcastList, hostIpList=hostIp)\n\n        elif groups:\n            groupsOnly = list(set([group[1] for group in groups]))\n            groupDict = {}\n            for groupOnly in groupsOnly:\n                groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]\n            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,\n                                     action, state, igmp_mld_mcastList, groupDict=groupDict, protocolType=protocol, versionType=version)\n\n        elif version:\n            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,\n                                                        action, state, igmp_mld_mcastList, versionType=version)\n\n        return igmp_mld_mcastList\n\n    def igmp_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):\n        \"\"\"\n        Igmp join or leave for multicast groups\n\n        :param port: list of port name. E.g. ['egress1', 'egress2']\n        :param action: \"join\" or \"leave\". Default value is \"join\"\n        :param version: CHOICES 'v1', 'v2', 'v3'\n        :param hostIp: list of host ip. E.g. ['1.1.1.1', '1.2.1.1']\n        :param groups: list of ipv4 multicast groups.\n\n        :Example: igmp_join_leave(port=[\"Ethernet - 001\", \"Ethernet - 002\"], hostIp=[\"105.1.1.2\",\"105.1.2.2\"],action='join')\n        \"\"\"\n        self.log.info('igmp %s' % action)\n        return self._igmp_mld_join_leave('igmp', port, action, version, hostIp, groups)\n\n\n    def _igmp_mld_control(self, port, hostip, protocol, action):\n        \"\"\"\n        Function used internally by APIS igmp_stop,igmp_start,mld_start,mld_stop\n\n        :param port: Port\n        :param hostip: Host IP\n        :param protocol: Protocol\n        :param action: Action , Ex : start/stop\n        \"\"\"\n        if protocol.lower() == 'mld':\n            HostObj = \"MldHost\"\n            ipVersion = \"Ipv6\"\n        else :\n            HostObj = \"IgmpHost\"\n            ipVersion =\"Ipv4\"\n        if port == None and hostip == None:\n            for host in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find().'+HostObj+'.find()'):\n                eval('host.' + action + '(None)')\n        if port:\n            for eachPort in port:\n                assignedPort = eachPort.replace('/', ':')\n                vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n                if assignedPort in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:\n                    for vport in vportList:\n                        assignedVport = self.ixNetwork.Vport.find(Name=vport)\n                        if assignedVport.AssignedTo == assignedPort:\n                            for topology in self.ixNetwork.Topology.find():\n                                if topology.Vports[0] == assignedVport.href:\n                                    topologyObj = topology.href\n                                    for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()'):\n                                        for hostObj in eval('ipObj.'+HostObj+'.find()'):\n                                            if re.match(topologyObj + '/deviceGroup', hostObj.href):\n                                                eval('ipObj.'+HostObj+'.find(DescriptiveName=hostObj.DescriptiveName).'+action +'(None)')\n                else:\n                    raise IxiaConfigException(\"Port %s is invalid or not configured\"%assignedPort)\n\n        if hostip:\n            for ip in hostip:\n                ipNameList = [address.Name for address in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()') if address]\n                for ipName in ipNameList:\n                    address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ ipVersion +'.find(Name=ipName).Address')\n                    if ip in address.Values:\n                        ipIndex = address.Values.index(ip) + 1\n                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find(Name=ipName).'+HostObj+'.find().'+action+'(ipIndex)')\n        return True\n\n    def igmp_start(self,port=None,hostip=None):\n        \"\"\"\n        To  start igmp emulation\n\n        :param port: List of ports. If 'None', all the ports\n        :param hostip: List of hostip. If 'None' all the igmp hosts\n        :return: raise exception if False/error\n\n        :Example: igmp_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])\n        \"\"\"\n        self.log.info(\"Starting IGMP\")\n        return self._igmp_mld_control(port, hostip, 'igmp', 'Start')\n\n    def igmp_stop(self,port=None,hostip=None):\n        \"\"\"\n        To  stop igmp emulation\n\n        :param port: List of ports. If 'None', all the ports\n        :param hostip: List of hostip. If 'None' all the igmp hosts\n        :return: raise exception if False/error\n\n        :Example: igmp_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])\n        \"\"\"\n        self.log.info(\"Stopping IGMP\")\n        return self._igmp_mld_control(port, hostip, 'igmp', 'Stop')\n\n    def mld_start(self,port=None,hostIp=None):\n        \"\"\"\n        To  start mld emulation\n\n        :param port: List of ports. If 'None', all the ports\n        :param hostIp: List of hostip. If 'None' all the mld hosts\n        :return: raise exception if False/error\n\n        :Example: mld_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])\n        \"\"\"\n        self.log.info(\"Starting MLD\")\n        return self._igmp_mld_control(port, hostIp, 'mld', 'Start')\n\n    def mld_stop(self,port=None,hostIp=None):\n        \"\"\"\n        To  stop mld emulation\n\n        :param port: List of ports. If 'None', all the ports\n        :param hostIp: List of hostip. If 'None' all the igmp hosts\n        :return: raise exception if False/error\n\n        :Example: mld_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])\n        \"\"\"\n        self.log.info(\"Stopping MLD\")\n        return self._igmp_mld_control(port, hostIp, 'mld', 'Stop')\n\n    def mld_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):\n        \"\"\"\n        Mld join or leave for multicast groups\n\n        :param port: list of port name. E.g. ['egress1', 'egress2']\n        :param action: \"join\" or \"leave\". Default value is \"join\"\n        :param version: CHOICES 'v1', 'v2'\n        :param hostIp: list of host ip. E.g. ['1001::1', '1002:2']\n        :param groups: list of ipv6 multicast groups.\n\n        :Example: mld_join_leave(action='join') \\n\n                  mld_join_leave(action='leave')\n        \"\"\"\n        self.log.info('mld %s' % action)\n        return self._igmp_mld_join_leave('mld', port, action, version, hostIp, groups)\n\n    def _pim_stop_start_control(self, port, mode, af, neighbor_ip, groups, action):\n        \"\"\"\n        Function used internally by APIs pim_start,pim_stop\n\n        :param port: list of port name. E.g. ['egress1', 'egress2']\n        :param mode: PIM Mode , Ex: sm/ssm\n        :param af: ipv4,ipv6\n        :param neighbor_ip: PIM neighbor ip\n        :param groups: list of ipv6 multicast groups.\n        :param action: \"start\" or \"stop\". Default value is \"start\"\n        \"\"\"\n        self.log.info('PIM {}'.format(action))\n\n        if action.lower() == \"start\":\n            action = 'Start'\n        elif action.lower() == \"stop\":\n            action = \"Stop\"\n\n        if af.lower() == \"ipv4\":\n            af = \"Ipv4\"\n            pimObj = \"PimV4Interface\"\n            joinPruneObj = \"PimV4JoinPruneList\"\n            groupAddress = \"GroupV4Address\"\n        elif af.lower() == \"ipv6\":\n            af = \"Ipv6\"\n            pimObj = \"PimV6Interface\"\n            joinPruneObj = \"PimV6JoinPruneList\"\n            groupAddress = \"GroupV6Address\"\n        try:\n            if port == None and neighbor_ip == None and groups == None and mode == None:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().'+action+'(None)')\n\n            if port:\n                for portName in port:\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                            eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().' + action + '(None)')\n\n            if neighbor_ip:\n                for ip in neighbor_ip:\n                    ipNameList = [address.Name for address in\n                                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find()') if address]\n                    for ipName in ipNameList:\n                        address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).Address')\n                        if ip in address.Values:\n                            ipIndex = address.Values.index(ip) + 1\n                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).'+pimObj+'.find().'+action+'(ipIndex)')\n\n            if mode:\n                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+pimObj+'.find()'):\n                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')\n                    if mode.lower() == \"sm\":\n                        mode =\"startogroup\"\n                    elif mode.lower() == \"ssm\":\n                        mode = \"sourcetogroup\"\n                    indices = [index for index in range(0,len(rangeTypeList)) if rangeTypeList[index] == mode]\n                    for index in indices:\n                        indexVal = index + 1\n                        eval('pimInterface.' + action + '(indexVal)')\n            if groups:\n                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+ pimObj + '.find()'):\n                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')\n                    mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')\n                    for rangeType in rangeTypeList:\n                        for group in groups:\n                            if \"*\" in group:\n                                if rangeType == \"startogroup\":\n                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]\n                                    for index in indices:\n                                        indexVal = index + 1\n                                        eval('pimInterface.'+action+'(indexVal)')\n                            else:\n                                if rangeType == \"sourcetogroup\":\n                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]\n                                    for index in indices:\n                                        indexVal = index + 1\n                                        eval('pimInterface.'+ action + '(indexVal)')\n            self.log.info('PIM {} action Success'.format(action))\n        except:\n            msg = 'PIM {} failed: no entry is matched'.format(action)\n            self.log.error(msg)\n            raise CafyException.TgenConfigMissingError(msg)\n        return True\n\n    def pim_start(self, port=None, mode=None, af=\"ipv4\", neighbor_ip=None, groups=None):\n        \"\"\"\n        To start the PIM\n\n        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports\n        :param mode: List/String sm or ssm. If None, both modes\n        :param af: String ipv4 or ipv6\n        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.\n            If None, all the neighbors\n        :param groups: List of groups. Apply the action to these groups only. If None, all the groups\n            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])\n        :return: raise exception if there is an error\n\n        :Example: pim_start(port=\"Ethernet - 001\", mode=\"sm\")\n        \"\"\"\n        self.log.info(\"Starting PIM\")\n        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='start')\n\n    def pim_stop(self, port=None, mode=None, af=\"ipv4\", neighbor_ip=None, groups=None):\n        \"\"\"\n        To stop the PIM\n\n        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports\n        :param mode: List/String sm or ssm. If None, both modes\n        :param af: String ipv4 or ipv6\n        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.\n            If None, all the neighbors\n        :param groups: List of groups. Apply the action to these groups only. If None, all the groups\n            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])\n        :return: raise exception if there is an error\n\n        :Example: pim_stop(port=\"Ethernet - 001\", mode=\"sm\")\n        \"\"\"\n        self.log.info(\"Stopping PIM\")\n        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='stop')\n\n    def pim_join_prune(\n            self,\n            port=None,\n            action='join',\n            mode=None,\n            af='ipv4',\n            neighborIp=None,\n            groups=None):\n        \"\"\"\n        Send Join/Prune for the specified sparse mode groups.\n\n        :param port: The name string/list of the port (e.g 'MyPort1')\n            port handle (e.g <slotID>/<portID>\n            interface name from topologyfile\n            (e.g <chassisIP>/<slotID>/<portID>)\n        :param action:  Join or Prune\n        :param mode: PIM Mode , Ex : 'sm','ssm'\n        :param af: ipv4 or ipv6\n        :param neighborIp: Apply the action to device with this neighbor address only.\n        :param groups: Apply the action to these groups only. (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])\n\n        :Example:\n            pim_join_prune(\"pim_port_1\",\"join\",\"ssm\",\"ipv4\",\"10.1.1.1\")\n            pim_join_prune(\"pim_port_1\",\"join\",\"ssm\",\"ipv4\",\"10.1.1.1\",groups=[[\"*\",\"232.0.0.1\"]])\n            pim_join_prune(\"pim_port_1\",\"prune\",\"ssm\",\"ipv4\",\"10.1.1.1\",groups=[[\"*\",\"232.0.0.1\"]])\n            pim_join_prune(\"pim_port_1\",\"join\",\"ssm\",\"ipv4\",\"10.1.1.1\",groups=[[\"200.200.200.200\",\"232.0.0.1\"]])\n            pim_join_prune(\"pim_port_1\",\"prune\",\"sm\",\"ipv6\")\n            pim_join_prune(\"pim_port_1\",\"join\",\"sm\",\"ipv6\",\"10::1\",groups=[[\"*\",\"ff1e::1\"]])\n            pim_join_prune(\"pim_port_1\",\"join\",\"sm\",\"ipv6\",\"10::2\",groups=[[\"*\",\"ff1e::1\"]])\n        \"\"\"\n        self.log.info('PIM action: %s' % (action))\n        if action.lower() == \"leave\" or action.lower() == 'prune':\n            action = 'Leave'\n        elif action.lower() == \"join\":\n            action = \"Join\"\n\n        if af.lower() == \"ipv4\":\n            af = \"Ipv4\"\n            HostObj = \"PimV4Interface\"\n            joinPruneObj=\"PimV4JoinPruneList\"\n            groupAddress = \"GroupV4Address\"\n            sourceAddress = \"SourceV4Address\"\n        elif af.lower() == \"ipv6\":\n            af = \"Ipv6\"\n            HostObj = \"PimV6Interface\"\n            joinPruneObj = \"PimV6JoinPruneList\"\n            groupAddress = \"GroupV6Address\"\n            sourceAddress = \"SourceV6Address\"\n\n        if port:\n            if isinstance(port, str):\n                ports = [port]\n            else:\n                ports = port\n        else:\n            ports = [vport.Name for vport in self.ixNetwork.Vport.find()]\n\n        for port in ports:\n            port = port.replace(\"(\", r\"\\(\").replace(\")\", r\"\\)\")\n            vports = self.ixNetwork.Vport.find(Name=port)\n            for topology in self.ixNetwork.Topology.find():\n                if topology.Vports[0] == vports.href:\n                    if groups:\n                        for pimInterface in eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):\n                            mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')\n                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')\n                            for group in groups:\n                                if mode == 'ssm':\n                                    sourceList = eval('pimInterface.' + joinPruneObj + '.' + sourceAddress + '.Values')\n                                    indices = [index + 1 for index in range(0, len(mcastIpList)) and\n                                               range(0,len(sourceList)) if mcastIpList[index] == group[1] and\n                                               sourceList[index] == group[0] and rangeTypeList[index] == \"sourcetogroup\"]\n                                else:\n                                    indices = [index + 1 for index in range(0, len(mcastIpList)) if\n                                               mcastIpList[index] == group[1] and rangeTypeList[index] == \"startogroup\"]\n                                eval('pimInterface.' + joinPruneObj + '.' + action + '(indices)')\n                    elif neighborIp:\n                        if isinstance(neighborIp, str):\n                            neighborIpList = [neighborIp]\n                        else:\n                            neighborIpList = neighborIp\n                        for neighborIp in neighborIpList:\n                            for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find()'):\n                                addressValues = ipObj.Address.Values\n                                if neighborIp in addressValues:\n                                    ipIndex = addressValues.index(neighborIp) + 1\n                                    eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipObj.Name).'+HostObj+'.find().'+joinPruneObj+'.'+action+'([ipIndex] )')\n                    else:\n                        for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):\n                            indexcount = pimInterface.Count\n                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')\n                            if mode == 'ssm':\n                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == \"sourcetogroup\"]\n                            else:\n                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == \"startogroup\"]\n                            eval('pimInterface.' + joinPruneObj + '.' + action + '(indexList)')\n        return True\n\n    def _get_port_name_list(self, ports):\n        \"\"\"\n        Function used internally by APIs\n\n        :param ports: List of ports\n        :return: port list\n        \"\"\"\n        portList = []\n        for port in ports:\n            if '.' in port and '/' in port:\n                vportObj = self.ixNetwork.Vport.find(AssignedTo='^' + port.replace('/', ':') + '$')\n                portList.append(vportObj.Name)\n            elif '/' in port:\n                assignedList = [vport.AssignedTo for vport in self.ixNetwork.Vport.find()]\n                for assigned in assignedList:\n                    if re.search(':' + port.replace('/', ':') + '$', assigned):\n                        portList.append(self.ixNetwork.Vport.find(AssignedTo='^' + assigned + '$').Name)\n            else:\n                portList.append(port)\n        return portList\n\n    def start_arp(self, ports=None, **kwargs):\n        \"\"\"\n        Send arp based on port list, In NGPF ARP is default once IPV4 stack is up, so no need to start_arp again\n\n        :param ports: list of port name or port handle or interface name from Json file.Default is None for all ports\n        :return: True\n\n        :Example: start_arp()\n                  start_arp(ports = ['10.85.99.38/7/17', '10.85.99.38/7/19'])\n                  start_arp(ports = '10.85.99.38/7/17')\n        \"\"\"\n        if ports:\n            if type(ports) == str:\n                ports = [ports]\n            for portname in ports:\n                if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', portname)):\n                    portname = portname.replace(\"/\", \":\")\n                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + portname + '$')\n                else:\n                    vport = self.ixNetwork.Vport.find(Name='^' + portname + '$')\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == vport.href:\n                        try:\n                            for ipv4Obj in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                                objCount = ipv4Obj.Count\n                                objCountList = [device for device in range(1, objCount + 1)]\n                                ipv4Obj.SendArp(SessionIndices=objCountList)\n                        except:\n                            pass\n                        try:\n                            for ipv6Obj in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():\n                                objCount = ipv6Obj.Count\n                                objCountList = [device for device in range(1, objCount + 1)]\n                                ipv6Obj.SendNs(SessionIndices=objCountList)\n                        except:\n                            pass\n        else:\n            topology = self.ixNetwork.Topology.find()\n            if topology:\n                with BatchFind(topology) as ipv4_list:\n                    self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find()\n                try:\n                    ipv4_obj_list = getattr(ipv4_list.results, 'ipv4')\n                except:\n                    ipv4_obj_list = []\n                if ipv4_obj_list:\n                    threads_arp = []\n                    for ipv4_obj in ipv4_obj_list:\n                        try:\n                            thread_arp = threading.Thread(target=self._start_arp_ns, args=(ipv4_obj, 'ipv4'))\n                            thread_arp.start()\n                            threads_arp.append(thread_arp)\n                        except:\n                            pass\n                    for thread_arp in threads_arp:\n                        thread_arp.join()\n                else:\n                    self.log.warning('IPv4 block is not configured')\n                with BatchFind(topology) as ipv6_list:\n                    self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find()\n                try:\n                    ipv6_obj_list = getattr(ipv6_list.results, 'ipv6')\n                except:\n                    ipv6_obj_list = []\n                if ipv6_obj_list:\n                    threads_ns = []\n                    for ipv6_obj in ipv6_obj_list:\n                        try:\n                            thread_ns = threading.Thread(target=self._start_arp_ns, args=(ipv6_obj, 'ipv6'))\n                            thread_ns.start()\n                            threads_ns.append(thread_ns)\n                        except:\n                            pass\n                    for thread_ns in threads_ns:\n                        thread_ns.join()\n                else:\n                    self.log.warning('IPv6 block is not configured')\n            else:\n                self.log.warning('Topology not found')\n        return True\n\n    def _start_arp_ns(self, ip_obj, ip_type):\n        \"\"\"\n        Internal function to start_arp\n\n        :param ip_obj: IP Object where Arp/Ns to be started\n        :param ip_type: IP type for IPv4/IPv6\n        :return: True if successful\n        \"\"\"\n        obj_count = ip_obj.Count\n        obj_count_list = list(range(1, obj_count + 1))\n        if ip_type == 'ipv4':\n            try:\n                ip_obj.SendArp(SessionIndices=obj_count_list)\n            except:\n                pass\n        else:\n            try:\n                ip_obj.SendNs(SessionIndices=obj_count_list)\n            except:\n                pass\n        return True\n\n    def send_ping(self, src_ip_address, dest_ip_address, port=None, ip_version=\"ipv4\"):\n        \"\"\"\n        Send ping from src_ip_address to dest_ip_address\n\n        :param src_ip_address: string demonstrating the source IP address for ping\n        :param dest_ip_address: string demonstrating the destination IP address for ping\n        :param port: String showing the port through which the port is sent out in IXIA, if None, the port corresponding to the source IP address is extracted dynamically\n        :param ip_version: String representing the IP version, default will be IPv4\n        :return: True if the ping is successful, False otherwise\n\n        :Example: send_ping(src_ip_address='103.1.2.2',dest_ip_address='103.1.2.1')\n        \"\"\"\n        self.log.info(\"Sending ping for ip: %s\" % dest_ip_address)\n        pingStatus = False\n        if ip_version.lower() == 'ipv4':\n            ipVersion = \"Ipv4\"\n        elif ip_version.lower() == 'ipv6':\n            ipVersion = \"Ipv6\"\n\n        if port:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            if port in vportNameList:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:\n                        for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):\n                            ipAddressList = ipObj.Address.Values\n                            if src_ip_address in ipAddressList:\n                                index = ipAddressList.index(src_ip_address) + 1\n                                pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')\n                                if pingStatus ==[]:\n                                    raise IxiaOperationException(\"Not able to ping, DeviceGroup not started\")\n                                else:\n                                    pingStatus = pingStatus[0]['arg2']\n        else:\n            for ipObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):\n                ipAddressList = ipObj.Address.Values\n                if src_ip_address in ipAddressList:\n                    index = ipAddressList.index(src_ip_address) + 1\n                    pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')\n                    if pingStatus == []:\n                        raise IxiaOperationException(\"Not able to ping, DeviceGroup not started\")\n                    else:\n                        pingStatus = pingStatus[0]['arg2']\n        if (pingStatus==True):\n            self.log.info(\"Ping success for:%s\"  % dest_ip_address)\n        else:\n            self.log.info(\"Ping fail for:%s\" % dest_ip_address)\n        return pingStatus\n\n    def _verifyDhcpClientBind(self, deviceGroupName=None, protocol=None, **kwargs):\n        \"\"\"\n        Function used internally by API verify_dhcp_client_bind, get_dhcp_client_bound_count\n\n        :param deviceGroupName: Device Group Name\n        :param protocol: Protocol , Ex: IPv4/IPv6\n        :param kwargs: optional arguments\n        \"\"\"\n        portName = kwargs.get('portName', None)\n        if protocol == None:\n            protocols = ['ipv4', 'ipv6']\n        else:\n            protocols = [protocol]\n        boundCount = 0\n        idleBoundDict = {}\n        ibList = []\n        for protocol in protocols:\n            if portName and deviceGroupName is None:\n                # Get all deviceGroups configured with Port\n                vportHref = self.ixNetwork.Vport.find(Name=portName).href\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Ports[0] == vportHref:\n                        deviceList = [deviceGroupName.Name for deviceGroupName in topology.DeviceGroup.find() if deviceGroupName]\n            elif deviceGroupName == None:\n                # Get all deviceGroups in all topology lists\n                deviceList = [deviceGroupName.Name for deviceGroupName in self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]\n            else:\n                deviceList = [deviceGroupName]\n            for eachDevice in deviceList:\n                ethObjList = self.ixNetwork.Topology.find().DeviceGroup.find(DescriptiveName=eachDevice).Ethernet.find()\n                for ethObj in ethObjList:\n                    idleDhcpDict = {}\n                    boundDhcpDict = {}\n                    if protocol == 'ipv6':\n                        # raise an exception if no DHCPv6 client\n                        try:\n                            for dhcpObjName in ethObj.Dhcpv6client.find():\n                                dhcpName = dhcpObjName.Name\n                                dhcpClientObjDeviceCount = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).Count\n                                discoveredAddressList = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).DiscoveredAddresses\n                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]\n                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]\n                                boundCount += len(boundList)\n                                if idleList:\n                                    idleDhcpDict[dhcpName] = idleList\n                                    ibList.append([\"Idle\", eachDevice, idleDhcpDict])\n                                if boundList:\n                                    boundDhcpDict[dhcpName] = boundList\n                                    ibList.append([\"Bound\", eachDevice, boundDhcpDict])\n                        except:\n                            raise IxiaConfigException(\"no dhcpv6 client found\")\n                    else:\n                        try:\n                            for dhcpObjName in ethObj.Dhcpv4client.find():\n                                dhcpName =  dhcpObjName.Name\n                                dhcpClientObjDeviceCount = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).Count\n                                discoveredAddressList = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).DiscoveredAddresses\n                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]\n                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]\n                                if idleList:\n                                    idleDhcpDict[dhcpName] = idleList\n                                    ibList.append([\"Idle\", eachDevice, idleDhcpDict])\n                                if boundList:\n                                    boundDhcpDict[dhcpName] = boundList\n                                    ibList.append([\"Bound\", eachDevice, boundDhcpDict])\n                                boundCount += len(boundList)\n                        except:\n                            raise IxiaConfigException(\"ERROR: No DHCP V4 Client Found\")\n        self.log.info(boundCount)\n        idleBoundDict['Idle'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Idle', ibList)}\n        idleBoundDict['Bound'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Bound', ibList)}\n        idleBoundDict['boundCount'] = boundCount\n        return idleBoundDict\n\n    def verify_dhcp_client_bind(self, device, protocol, **kwargs):\n        \"\"\"\n        DHCP client bind verifier - check if client received IP from the server.\n        :param device: (str): Device Group name, If none passed check for all device group names\n        :param protocol: (str): ipv4/ipv6, If none passed check for both ipv4 and ipv6\n        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')\n        :param expected_blockstate: 'IDLE'/'BOUND'\n        :return: Idle and Bound items of deviceGroup in dictionary format. Return Exception when device is not present in config\n\n        :Example: verify_dhcp_client_bind(device=\"Device Group 23\")\n        \"\"\"\n        try:\n            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').Ethernet.find()\n        except:\n            raise IxiaOperationException(\"Device Group not Found\")\n        if protocol.lower() == \"ipv4\":\n            discoveredAddressList = deviceObj.Dhcpv4client.find().DiscoveredAddresses\n        elif protocol.lower() == \"ipv6\":\n            discoveredAddressList = deviceObj.Dhcpv6client.find().DiscoveredAddresses\n        idleList = [client for client in discoveredAddressList if '[Unresolved]' in client]\n        if idleList:\n            actual_blockstate = \"IDLE\"\n        else:\n            actual_blockstate = \"BOUND\"\n        expected_blockstate = kwargs.get('expected_blockstate', None)\n        if expected_blockstate:\n            if expected_blockstate.upper() == actual_blockstate:\n                log.info('Blockstate of client %s is %s as expected (%s)' \\\n                         % (device, actual_blockstate, expected_blockstate))\n            else:\n                err_msg = \"Blockstate of client %s is %s. NOT as expected (%s)\" \\\n                          % (device, actual_blockstate, expected_blockstate)\n                raise CafyException.VerificationError(err_msg)\n        return actual_blockstate\n\n    def get_dhcp_client_bound_count(self, device=None, protocol=None, **kwargs):\n        \"\"\"\"\n        To retrieve number of DHCP sessions currently bound to the interface/device\n\n        :param device: Device Group name, If none passed check for all device group names\n        :param protocol: ipv4/ipv6, If none passed check for both ipv4 and ipv6\n        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')\n        :return: Number of sessions Bound. Return Exception when device is not present in config\n\n        :Example: get_dhcp_client_bound_count()\n        \"\"\"\n        self.log.info(\"Getting DHCP Client Bound Count\")\n        if 'port_name' in kwargs:\n            kwargs['portName'] = kwargs['port_name']\n        boundDict = self._verifyDhcpClientBind(deviceGroupName=device, protocol=protocol, **kwargs)\n        return boundDict['boundCount'],boundDict['boundCount']\n\n    def verify_arp(self,ports=(), ip_type='ipv4'):\n        \"\"\"\n        This method requires:  _device_group_protocolstack_ngpf()\n        It will verify for ARP session resolvement on\n        every Device Group including inner Device Groups.\n\n        How it works?\n        Each device group has a list of $sessionStatus: up, down or notStarted.\n        If the deviceGroup has sessionStatus as \"up\", then ARP will be verified.\n        It also has a list of $resolved_gateway_mac: MacAddress or removePacket\n        [Unresolved]\n        These two $sessionStatus and $resolved_gateway_mac lists are aligned.\n        If lindex 0 on $sessionSatus is up, then $resolved_gateway_mac on index 0 expects\n        to have a mac address.  Not removePacket[Unresolved].\n        If not, then arp is not resolved.\n\n        :param ports: port or list of ports\n        :param ip_type: default is ipv4\n        :return: 0 if ARP passes, 1 if device group is not started\n                Returns a list of unresolved ARPs (src ip)\n\n        :Example: verify_arp()\n        \"\"\"\n\n        self.log.info(\"Arp Verification on All interfaces\")\n        unresolvedArpList = []\n        gatewayIpList = []\n        timeout = 25\n        start_flag = 0\n        for deviceGroupObj in (self.ixNetwork.Topology.find().DeviceGroup.find()):\n            for counter in range(1, 30):\n                if deviceGroupObj.Status in ['started', 'mixed']:\n                    start_flag = 1\n                    break\n                elif (counter >= timeout and deviceGroupObj.Status not in ['started', 'mixed']):\n                    raise IxiaConfigException('\\nDevice Group failed to come up: {0}.'.format(deviceGroupObj.href))\n        if (ip_type.lower() == 'ipv6'):\n            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find()):\n                for index, eachState in enumerate(ipObj.SessionStatus):\n                    if eachState != \"up\":\n                        unresolvedArpList.append(ipObj.Address.Values[index])\n                        gatewayIpList.append(ipObj.GatewayIp.Values[index])\n            try:\n                for ipObj in ([x for x in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv6.find() if x]):\n                    for index, eachState in enumerate(ipObj.SessionStatus):\n                        if eachState != \"up\":\n                            unresolvedArpList.append(ipObj.Address.Values[index])\n                            gatewayIpList.append(ipObj.GatewayIp.Values[index])\n            except:\n                pass\n        else:\n            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):\n                for index, eachState in enumerate(ipObj.SessionStatus):\n                    if eachState != \"up\":\n                        unresolvedArpList.append(ipObj.Address.Values[index])\n                        gatewayIpList.append(ipObj.GatewayIp.Values[index])\n            try:\n                for ipObj in (\n                        self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):\n                    for index, eachState in enumerate(ipObj.SessionStatus):\n                        if eachState != \"up\":\n                            unresolvedArpList.append(ipObj.Address.Values[index])\n                            gatewayIpList.append(ipObj.GatewayIp.Values[index])\n            except:\n                pass\n        if unresolvedArpList == [] and start_flag == 1:\n            self.log.info(f'\\t{ip_type} - ARP is resolved')\n            return 0\n        if unresolvedArpList != [] and start_flag == 0:\n            self.log.info('Device Group not started')\n            return 1\n        if unresolvedArpList != [] and start_flag == 1:\n            raise IxiaConfigException(\"\\nFailed to resolve ARP: srcIp: {0} gateway: {1}\".format(unresolvedArpList, gatewayIpList))\n        return unresolvedArpList\n\n    def neighbor_discovery(self, *args):\n        \"\"\"\n        neighbor discovery for IPv6\n\n        :Example: neighbor_discovery()\n        \"\"\"\n        if len(args):\n            self.log.debug(\"unused options %s\" % args)\n        self.verify_arp(ip_type='ipv6')\n\n    def change_traffic_frame_size(self, cfg_dict, traffic_item_list=None, **kwargs):\n        \"\"\"\n        This API is used for changing traffic item frame size.\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :param cfg_dict: Dict including the data need to be modified\\n\n                type: auto, fixed, increment, random, weightedPairs, presetDistribution,\n                quadGaussian\\n\n                fixedSize: frame size for type of fixed\\n\n                more options see: <IP of IxNetwork>:25445/api/v1/meta\n        :param kwargs :\n                dynamic_frame_size : True/False dynamic frame size , Frame size to be set on the fly\n                                    supported frame type is \"fixed\" and \"random\n        :return: True or Exception\n\n        :Example: change_traffic_frame_size(cfg_dict={'type': 'presetDistribution', 'presetDistribution': 'cisco'})\n                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'random','fixedSize': '10'})\n                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'fixed', 'fixedSize': '100'},traffic_item_list=['Traffic ipv4'])\n        \"\"\"\n        self.log.info(\"Changing Traffic Frame Size\")\n        if traffic_item_list is None:\n            traffic_item_list = self.get_traffic_items()\n        frame_size_dict = {'type': 'Type', 'fixedSize': 'FixedSize', 'incrementFrom': 'IncrementFrom',\n                         'incrementTo': 'IncrementTo', 'incrementStep': 'IncrementStep',\n                         'presetDistribution': 'PresetDistribution', 'weightedPairs': 'WeightedPairs',\n                         'randomMax': 'RandomMax', 'randomMin': 'RandomMin',\n                         'weightedRangePairs': 'WeightedRangePairs'}\n\n        for traffic_name in traffic_item_list:\n            traffic_name = '^' + traffic_name.replace('+', r'\\+').replace('*', r'\\*') + '$'\n            if kwargs.get('dynamic_frame_size'):\n                for trafficitemname in self.ixNetwork.Traffic.DynamicFrameSize.find(TrafficItemName=traffic_name):\n                    for key in cfg_dict:\n                        setattr(trafficitemname, frame_size_dict[key], cfg_dict[key])\n            else:\n                if 'weightedPairs' in cfg_dict.keys():\n                    if ':' in str(cfg_dict['weightedPairs'][0]):\n                        wp_tmp = []\n                        for i in cfg_dict['weightedPairs']:\n                            wp_tmp.append(int(i.split(':')[0]))\n                            wp_tmp.append(int(i.split(':')[1]))\n                        cfg_dict['weightedPairs'] = wp_tmp\n\n                for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name):\n                    Streams = traffic.ConfigElement.find()\n                    for Stream in Streams:\n                        for frameSize in Stream.FrameSize:\n                            for key in cfg_dict:\n                                setattr(frameSize, frame_size_dict[key], cfg_dict[key])\n        self.log.info(\"Frame Size in Traffic Items Updated\")\n        return True\n\n    def change_traffic_rate(self, cfg_dict, traffic_item_list=None, **kwargs):\n        \"\"\"\n        Changes the rate of traffic.\n\n        :param cfg_dict: Dict including the data need to be modified\n                   type: 'bitsPerSecond','kilobitsPerSecond','megabitsPerSecond','framesPerSecond','percentLineRate'\n                   rate: The rate at which packet is transmitted.\n                Example: percent Line Rate: cfg_dict = {'type':'percentLineRate','rate':25.0}\n                         frame Per Second: cfg_dict = {'type':'framesPerSecond','rate':200000.0}\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :param kwargs :\n                dynamic_traffic_rate : True/False dynamic traffic rate to be set on the fly\n        :return: True on success else raises exception.\n\n        :Example:\n            change_traffic_rate(cfg_dict={'type': 'megabitsPerSecond', 'rate': 20}, traffic_item_list=['Traffic Item 1'])\\n\n            change_traffic_rate(cfg_dict = {'type':'framesPerSecond','rate':200.0})\n            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type':'percentLineRate','rate':10},\n            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type': 'megabitsPerSecond', 'rate': 20})\n        \"\"\"\n        self.log.info(\"Changing Traffic Rate\")\n\n        if traffic_item_list is None:\n            traffic_item_list = self.get_traffic_items()\n        rateTypeDict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',\n                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',\n                        'percentLineRate': 'lineRate'}\n\n        for traffic_name in traffic_item_list:\n            traffic_name_modified = re.escape(traffic_name)\n            traffic_name_modified = f'^{traffic_name_modified}$'\n\n            if cfg_dict.get('type') in rateTypeDict.keys():\n                if kwargs.get('dynamic_traffic_rate'):\n                    if self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name_modified):\n                        for trafficitemname in self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name_modified):\n                            if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:\n                                trafficitemname.RateType = 'bitsPerSecond'\n                                trafficitemname.BitRateUnitsType = rateTypeDict[cfg_dict['type']]\n                            else:\n                                trafficitemname.RateType = cfg_dict['type']\n                            trafficitemname.Rate = cfg_dict.get('rate', None)\n                            self.log.info(f\"Traffic Rate updated for Traffic item '{traffic_name}'\")\n                    else:\n                        self.log.error(f\"Traffic Item '{traffic_name}' not found in config\")\n                else:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name_modified):\n                        for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name_modified):\n                            streams = traffic.ConfigElement.find()\n                            for each_stream in streams:\n                                for frame_rate in each_stream.FrameRate:\n                                    if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:\n                                        frame_rate.Type = 'bitsPerSecond'\n                                        frame_rate.BitRateUnitsType = rateTypeDict[cfg_dict['type']]\n                                    else:\n                                        frame_rate.Type = cfg_dict['type']\n                                    frame_rate.Rate = cfg_dict.get('rate', None)\n                            self.log.info(f\"Traffic Rate updated for Traffic item '{traffic_name}'\")\n                    else:\n                        self.log.error(f\"Traffic Item '{traffic_name}' not found in config\")\n            else:\n                log.error('Unknown/Unsupported rate type.')\n                raise CafyException.InvalidValueError('Unknown/Unsupported rate type provided in change_traffic_rate')\n        return True\n\n    def set_traffic_mpls_exp_bits(self, exp_value, traffic_item_list=None):\n        \"\"\"\n        Sets the MPLS headers Experimental Bits (bits) field to the specified value\n\n        :param exp_value: The exp bit field value to be used. Accepted values are 0-7\n            e.g. exp_bit_value=4 or [1,4,6]\n        :param traffic_item_list: A list of streamblocks to be modified. If None,\n            set exp_bit_value for all streamblocks.\n        :return: True if no exceptions were thrown\n\n        :Example: set_traffic_mpls_exp_bits(exp_value = 1, traffic_item_list=[\"Traffic Item 2\"])\n                  set_traffic_mpls_exp_bits(exp_value = [1,2,3], traffic_item_list=[\"Traffic Item 2\"])\n        \"\"\"\n        self.log.info(\"Setting MPLS EXP Bits in Traffic Item/Items\")\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():\n                    try:\n                        if type(exp_value) is not list:\n                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')\n                            fieldValue.ValueType = 'singleValue'\n                            fieldValue.SingleValue = exp_value\n                        if type(exp_value) is list:\n                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')\n                            fieldValue.ValueType = 'valueList'\n                            fieldValue.ValueList = exp_value\n                    except:\n                        pass\n        else:\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                try:\n                    if type(exp_value) is not list:\n                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')\n                        fieldValue.ValueType = 'singleValue'\n                        fieldValue.SingleValue = exp_value\n                    if type(exp_value) is list:\n                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')\n                        fieldValue.ValueType = 'valueList'\n                        fieldValue.ValueList = exp_value\n                except:\n                    pass\n        return True\n\n    def get_traffic_mpls_exp_bits(self, traffic_item_list=None):\n        \"\"\"\n        Gets the value of the MPLS headers exp field for the specified traffic items\n\n        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.\n        :return: A list of results containing the exp field value for the specified streams\n\n        :Example: get_traffic_mpls_exp_bits(traffic_item_list=[\"Traffic Item 2\"])\n        \"\"\"\n\n        self.log.info(\"Getting MPLS EXP Bits For Traffic Items\")\n        results = []\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                try:\n                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(\n                        StackTypeId='mpls').Field.find(Name='mpls_exp'):\n                        results.append(fieldValue.SingleValue)\n                except:\n                    self.log.info(\"MPLS Stack Not Available in %s\" % trafficName)\n                    raise IxiaOperationException(\"MPLS Stack Not Available in %s\" % trafficName)\n        else:\n            try:\n                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(\n                            StackTypeId='mpls').Field.find(Name='mpls_exp'):\n                    results.append(fieldValue.SingleValue)\n            except:pass\n        return results\n\n    def change_vlan_priority(self, device_name, vlan_number, priority=7):\n        \"\"\"\n        Change VLAN priority on a device group\n\n        :param device_name: Name of device group on which VLAN Priority need to be changed\n        :param vlan_number:  VLAN Number on which priority needs to be changed.\n        :param priority: Range 0 to 7. Default is 7\n\n        :Example: change_vlan_priority(device_name='Device Group 13' , vlan_number=10, priority=4)\n        \"\"\"\n        self.log.info(\"Changing VLAN Priority for Vlan {0} in {1}\".format(vlan_number,device_name))\n        try:\n            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values\n        except:\n            raise IxiaOperationException(\"Device Group not Found\")\n        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().Priority.Values\n        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]\n        if indexList:\n            for index in indexList:\n                priorityList.pop(index)\n                priorityList.insert(index, str(priority))\n\n            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():\n                vlan.Priority.ValueList(values=priorityList)\n            self.log.info(\"VLAN Priority Changed for Vlan {0} in {1}\".format(vlan_number,device_name))\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        else:\n            raise IxiaConfigException(\"VLAN Number not Found\")\n\n    def change_traffic_flow_tracking(self, cfg_dict, traffic_item_list=None, **kwargs):\n        \"\"\"\n        This API is used for changing traffic item flow tracking.\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :param cfg_dict: Dict including the data need to be modified\\n\n                trackBy: []\\n\n                availableTrackBy: ['customOverride', 'sourceDestValuePair0',\n                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',\n                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',\n                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',\n                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',\n                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',\n                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',\n                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']\\n\n                more options see: <IP of IxNetwork>:25445/api/v1/meta\n\n        :Example: change_traffic_flow_tracking(cfg_dict = {'trackBy':['ipv4SourceIp0','sourcePort0']},traffic_item_list =['Traffic Item 2'])\n        \"\"\"\n\n        self.log.info(\"Changing Traffic Flow Tracking\")\n        ipv4_precedence_full_mesh = kwargs.get(\"ipv4_precedence_full_mesh\", False)\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():\n                    tracking.TrackBy = cfg_dict['trackBy']\n                if ipv4_precedence_full_mesh:\n                    self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find().Field.find(DisplayName='Precedence')\\\n                        .FullMesh = ipv4_precedence_full_mesh\n        else:\n            for traffic in self.ixNetwork.Traffic.TrafficItem.find():\n                for tracking in traffic.Tracking.find():\n                    tracking.TrackBy = cfg_dict['trackBy']\n\n        self.log.info(\"Flow Tracking Updated for Traffic Items\")\n\n    def change_traffic_egress_tracking(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        This API is used for changing traffic item egress tracking.\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :param cfg_dict: Dict including the data need to be modified\\n\n                enabled: True or False\n\n                availableEncapsulations: ['Any: Use Custom Settings', 'Ethernet',\n                'LLC/Snap Routed Protocol', 'LLC Encapsulated PPP',\n                'LLC Bridged Ethernet/802.3', 'LLC Bridged Ethernet/802.3 no FCS',\n                'VC Multiplexed PPP', 'VC Mux Routed Protocol',\n                'VC Mux Bridged Ethernet/802.3', 'VC Mux Bridged Ethernet/802.3 no FCS',\n                'PPP', 'CISCO HDLC', 'Frame Relay', 'Cisco Frame Relay']\n\n                availableOffsets: ['Outer VLAN Priority (3 bits)', 'Outer VLAN ID (4 bits)',\n                'Outer VLAN ID (6 bits)', 'Outer VLAN ID (8 bits)',\n                'Outer VLAN ID (10 bits)', 'Outer VLAN ID (12 bits)',\n                'Inner VLAN Priority (3 bits)', 'Inner VLAN ID (4 bits)',\n                'Inner VLAN ID (6 bits)', 'Inner VLAN ID (8 bits)',\n                'Inner VLAN ID (10 bits)', 'Inner VLAN ID (12 bits)',\n                'VNTag Direction Bit (1 bit)', 'VNTag Pointer Bit (1 bit)',\n                'VNTag Looped Bit (1 bit)', 'MPLS Exp (3 bits)',\n                'IPv4 TOS Precedence (3 bits)', 'IPv4 DSCP (6 bits)',\n                'IPv6 Traffic Class (8 bits)', 'IPv6 Traffic Class Bits 0-2 (3 bits)',\n                'IPv6 Traffic Class Bits 0-5 (6 bits) ']\n\n        :Example: change_traffic_egress_tracking(cfg_dict={'enabled': True, 'encapsulation': 'Ethernet'})\n        \"\"\"\n        self.log.info(\"Changing Traffic Egress Tracking\")\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():\n                    tracking.Egress.Enabled = cfg_dict.get('enabled', True)\n                    tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)\n                    tracking.Egress.Offset = cfg_dict.get('offset', None)\n        else:\n            for tracking in self.ixNetwork.Traffic.TrafficItem.find().Tracking.find():\n                tracking.Egress.Enabled = cfg_dict.get('enabled', True)\n                tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)\n                tracking.Egress.Offset = cfg_dict.get('offset', None)\n        self.log.info(\"Egress Tracking Updated for Traffic Items\")\n\n    def get_port_name_from_location(self, location):\n        \"\"\"\n        Get name of port in config based on location\n\n        :param location: port (str) location in chassis/card/port format.\n         Ex: location=\"172.29.126.16/5/7\"\n        :return: Name of the port\n\n        :Example: get_port_name_from_location(location = \"172.29.126.16/5/7\")\n        \"\"\"\n        self.log.info(\"Getting Port Name from Location\")\n        for vport in self.ixNetwork.Vport.find():\n            locationUpdated = location.replace(\"/\", \":\")\n            if vport.AssignedTo == locationUpdated:\n                return vport.Name\n\n        raise IxiaConfigException(\"No Port found for location : '%s' \" % location)\n\n    def set_chassis_mode(self, **kwargs):\n        \"\"\"\n        Designates a chassis with a given IP as either the primary or a secondary for a given IXIA config\n\n        :kwargs :\n                :param primary: Primary Chassis IP\n                :param secondary: secondary Chassis IP\n        :return: True if successful\n        :Example: set_chassis_mode()\n                set_chassis_mode(primary='172.21.179.238',secondary='172.21.179.239')\n        \"\"\"\n        self.log.info(\"Setting Chassis Mode\")\n        primary_ip = kwargs.get('primary', None)\n        secondary_ip_list = kwargs.get('secondary', None)\n        if isinstance(secondary_ip_list, str):\n            secondary_ip_list = [secondary_ip_list]\n        if primary_ip and secondary_ip_list:\n            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find()]\n            if primary_ip not in connected_chassis_list:\n                self.connect_to_chassis([primary_ip])\n            primary_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + primary_ip + '$')\n            if primary_obj:\n                for secondary_ip in secondary_ip_list:\n                    if secondary_ip not in connected_chassis_list:\n                        self.connect_to_chassis([secondary_ip])\n                    secondary_obj = self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + secondary_ip + '$')\n                    if secondary_obj:\n                        if not secondary_obj.IsPrimary:\n                            secondary_obj.PrimaryChassis = primary_ip\n                            self.log.info(f'Added Primary chassis ip {primary_ip} to Secondary chassis {secondary_ip}')\n                    else:\n                        self.log.warning(f'Secondary chassis {secondary_ip} not present in config')\n            else:\n                self.log.warning(f'Primary chassis {primary_ip} not present in config')\n        else:\n            for chassis in self.ixNetwork.AvailableHardware.Chassis.find():\n                if chassis.Ip == self.chassis_ip:\n                    chassis.IsMaster = True\n                else:\n                    chassis.IsMaster = False\n                    chassis.MasterChassis = self.chassis_ip\n        return True\n\n    def _bgp_neighbor_control(self, bgp_peer_name_list, local_ip_list, ip_type, action):\n        \"\"\"\n        Function used internally by APIs bgp_start and bgp_stop\n\n        :param bgp_peer_name_list: BGP Peer Name list\n        :param local_ip_list: BGP Local IP list\n        :param ip_type: IP type , IPv4/IPv6\n        :param action: Action, \"start/stop\"\n        \"\"\"\n        self.log.info(\"BGP action {}\".format(action))\n        if ip_type not in ['ipv4', 'v4', 'ipv6', 'v6']:\n            msg = 'ip_type %s can only be ipv4 or ipv6' % ip_type\n            raise IxiaOperationException(msg)\n        for bgpPeerName in bgp_peer_name_list:\n            bgpPeerName = '^' + bgpPeerName.replace('+', r'\\+').replace('*', r'\\*') + '$'\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(Name=\"' + bgpPeerName + '\").' + action + '(None)')\n            except:\n                pass\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(Name=\"' + bgpPeerName + '\").' + action + '(None)')\n            except:\n                pass\n        for localIp in local_ip_list:\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(LocalIpv4Ver2=\"' + localIp + '\").' + action + '(None)')\n            except:\n                pass\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(LocalIpv6Ver2=\"' + localIp + '\").' + action + '(None)')\n            except:\n                pass\n        if bgp_peer_name_list == [] and local_ip_list == []:\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find().' + action + '(None)')\n            except:\n                pass\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find().' + action + '(None)')\n            except:\n                pass\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find().BgpIpv4Peer.find().' + action + '(None)')\n            except:\n                pass\n            try:\n                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find().BgpIpv6Peer.find().' + action + '(None)')\n            except:\n                pass\n        return True\n\n    def bgp_start(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):\n        \"\"\"\n        Start bgp emulation\n\n        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type\n        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.\n        :param ip_type: ipv4 or ipv6, default set to ipv4\n        :return: raise exception if False/error\n\n        :Example: bgp_start(bgp_peer_name_list=[\"BGP Peer 1\",\"BGP Peer 2\"], local_ip_list=[\"103.1.1.2\",\"103.1.1.1\"])\n        \"\"\"\n        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action=\"Start\")\n\n    def bgp_stop(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):\n        \"\"\"\n        Stop bgp emulation\n\n        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type\n        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.\n        :param ip_type: ipv4 or ipv6, default set to ipv4\n        :return: raise exception if False/error\n\n        :Example: bgp_stop(bgp_peer_name_list=[\"BGP Peer 1\",\"BGP Peer 2\"], local_ip_list=[\"103.1.1.2\",\"103.1.1.1\"])\n        \"\"\"\n        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action=\"Stop\")\n\n    def link_up_down(self, port, action='up'):\n        \"\"\"\n        Flap a port Up and Down\n\n        :param port: list of port names\\n\n                Example : port = ['10.30.20.140/1/5','10.30.20.140/1/6']\\n\n                Example : port = ['Ethernet 01' , Ethernet 02']\n        :param action: CHOICES up, down\n        :return: True\n\n        :Example: link_up_down(port=[\"Ethernet - 001\", \"Ethernet - 002\"], action='down')\n        \"\"\"\n        self.log.info(\"Simulation Link :%s\" % (action))\n        action = action.lower()\n        for eachPort in port:\n            if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', eachPort)):\n                eachPort = eachPort.replace(\"/\", \":\")\n                for vport in self.ixNetwork.Vport.find(AssignedTo = eachPort):\n                    vport.LinkUpDn(action)\n                    time.sleep(30)\n                for vport in self.ixNetwork.Vport.find(AssignedTo=eachPort):\n                    if vport.State != action:\n                        msg = 'Port \"%s\" Link \"%s\" Simulatin not Successful' % (eachPort, action)\n                        self.log.info(msg)\n\n            else:\n                for vport in self.ixNetwork.Vport.find(Name=eachPort):\n                    vport.LinkUpDn(action)\n                    time.sleep(30)\n                for vport in self.ixNetwork.Vport.find(Name=eachPort):\n                    if vport.State != action:\n                        msg = 'Port \"%s\" Link \"%s\" Simulation Failed' % (eachPort,action)\n                        self.log.info(msg)\n        return True\n\n    def release_ports(self, port_list=None):\n        \"\"\"\n        Release ports\n\n        :param port_list: list of port names\\n\n               port_list can be port_list = ['10.30.20.140/1/5','10.30.20.140/1/6']\n               port_list = ['Ethernet 01' , Ethernet 02']\\n\n               port_list = [[ixChassisIp, 1, 2], [ixChassisIp, 1, 3], ...]\n        :return: True\n\n        :Example: release_ports(port_list=['10.30.20.140/1/5','10.30.20.140/1/6'])\n        \"\"\"\n        self.log.info(\"Releasing Ports\")\n        if port_list is None:\n            try:\n                ports = self.ixNetwork.Vport.find()\n                ports.ResetPortCpuAndFactoryDefault()\n                time.sleep(5)\n                ports.ReleasePort()\n            except:\n                pass\n        else:\n            vportNames = []\n            for port in port_list:\n                regexString = ''\n                if isinstance(port, list):\n                    # Construct the regex string format = '(1.1.1.1:2:3)'\n                    regexString = regexString + '(' + str(port[0]) + ':' + str(port[1]) + ':' + str(port[2]) + ')'\n                elif isinstance(port, str):\n                    if '.' in port:\n                        regexString = port.replace('/',':')\n                    else:\n                        try:\n                            regexString = self.ixNetwork.Vport.find(Name=port).AssignedTo\n                        except:\n                            raise IxiaConfigException(\"Port not configured or Failed to release\")\n                vport = self.ixNetwork.Vport.find(AssignedTo=regexString)\n                if vport:\n                    vportNames.append(vport.Name)\n                    self.log.info('\\nReleasing port: {0}:{1}'.format(port, vport.href))\n                    vport.ResetPortCpuAndFactoryDefault()\n                    time.sleep(5)\n                    vport.ReleasePort()\n                    time.sleep(5)\n            for vport in self.ixNetwork.Vport.find():\n                if vport.ConnectionStatus != 'Port Released':\n                    msg = 'Release Port \"%s\" not Successful' % (vport.Name)\n                    raise IxiaOperationException(msg)\n        return True\n\n    def verify_arp_status(self, ipType='ipv4', device=None, **kwargs):\n        \"\"\"\n        verifies the ARP status of all device groups on the TGN session\n\n        :param ipType: IP type , ipv4/ipv6\n        :param device: Device Group name\n        :return: True or Exception\n\n        :Example: verify_arp_status(ipType='ipv6', device='Device Group 3')\n        \"\"\"\n        # if StubitUtil.is_stubit_playback():\n        #     log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n        #     return\n        scale_traffic = kwargs.get(\"scale_traffic\",False)\n\n        self.log.info(\"Verification of Arp Started\")\n        if isinstance(device, str):\n            device = [device]\n        unresolved_arp_list = []\n        gateway_ip_list = []\n        timeout = 20\n        result = True\n        ip_type = ipType\n\n        if device:\n            device_obj_list = list(map(lambda device_obj: device_obj if device_obj.Name in device else None,\n                                    self.ixNetwork.Topology.find().DeviceGroup.find()))\n            device_obj_list = list(filter(None, device_obj_list))\n        else:\n            topology = self.ixNetwork.Topology.find()\n            if topology:\n                with BatchFind(topology) as device_group:\n                    self.ixNetwork.Topology.find().DeviceGroup.find()\n                device_obj_list = getattr(device_group.results, 'deviceGroup')\n            else:\n                self.log.warning('Topology not found in the config')\n                return result\n\n        if device_obj_list:\n            for device_obj in device_obj_list:\n                for counter in range(0, timeout, 2):\n                    if device_obj.Status == 'notStarted':\n                        msg = f'\\n Device Group {device_obj.Name} is not started'\n                        self.log.warning(msg)\n                    if counter < timeout and device_obj.Status == 'starting':\n                        time.sleep(2)\n                        continue\n                    if counter < timeout and device_obj.Status in ['started', 'mixed']:\n                        break\n                    if counter == timeout and device_obj.Status not in ['started', 'mixed']:\n                        msg = f'\\n Device Group failed to come up: {device_obj.Name}'\n                        raise IxiaOperationException(msg)\n\n            for device_obj in device_obj_list:\n                unresolved_mac = False\n                with BatchFind(device_obj) as ip_obj_list:\n                    eval('device_obj.Ethernet.find().' + ip_type[0].upper() + ip_type[1:] + '.' + 'find()')\n                if device_obj.Status == 'notStarted':\n                    self.log.info(f'Device {device_obj.Name} is not started')\n                else:\n                    try:\n                        ip_obj_list = getattr(ip_obj_list.results, ip_type)\n                    except:\n                        ip_obj_list = []\n                        self.log.info(f'{ip_type} block is not configured in device {device_obj.Name}')\n\n                    for ip_obj in ip_obj_list:\n                        if scale_traffic == True:\n                            count = 0\n                            session_info = ip_obj.SessionInfo\n                            for not_started in session_info:\n                                if not_started == \"resolveMacFailed\":\n                                    count = count + 1\n                            if count > 1:\n                                self.log.warning(f\"[{device_obj.Name}] Found {count} count of IPs that have the MAC Resolution failed\")\n                            elif count < 1:\n                                self.log.info(f\"[{device_obj.Name}] ARP Verification passed for scale traffic\")\n                        else:\n                            for index, each_state in enumerate(ip_obj.SessionStatus):\n                                if each_state != \"up\":\n                                    unresolved_arp_list.append(ip_obj.Address.Values[index])\n                                    gateway_ip_list.append(ip_obj.GatewayIp.Values[index])\n                                    unresolved_mac = True\n                        if unresolved_mac:\n                            self.log.info(f'Arp Verification Failed for {ip_type} in - \"{device_obj.Name}\"')\n                        else:\n                            msg = f'\\n Device Group \"{device}\" not found'\n                            raise IxiaOperationException(msg)\n                        \n\n            if unresolved_arp_list:\n                self.log.info(f\"\\n Failed to Resolve ARP: srcIp: {unresolved_arp_list} gateway: {gateway_ip_list}\")\n                result = False\n\n            if result:\n                self.log.info(f'Arp Verification Successful for {ip_type}')\n            return result\n\n\n    def start_arp_and_verify(self,**kwargs):\n        \"\"\"\n        starts the ARP and verifies the ARP status\n\n        :return: true if successful else false if verify fails or exception in case error occurs\n\n        :Example: start_arp_and_verify()\n        \"\"\"\n        result_list = []\n        scale_config = kwargs.get(\"scale_config\",True)\n        topology = self.ixNetwork.Topology.find()\n        with BatchFind(topology) as device_group:\n            topology.DeviceGroup.find()\n\n        device_obj_list = getattr(device_group.results, \"deviceGroup\")\n        try:\n            for device_obj in device_obj_list:\n                self.log.info(f'Starting Arp on: {device_obj.Name}')\n                if device_obj.Ethernet.find().Ipv4.find():\n                    for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():\n                        obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))\n                        ipv4_obj.SendArp(SessionIndices=obj_count_list)\n                        result_list.append(self.verify_arp_status1(device=device_obj.Name, scale_config = True))\n                else:\n                    self.log.info(f'IPv4 block not found in {device_obj.Name}')\n        except:\n            self.log.error(f'Device Group {device_obj.Name} is not started')\n\n        if not False in result_list:\n            result = True\n        else:\n            result = False\n        return result\n\n    def bgp_ngp_flap(self, bgp_peer_name_list, action='True', up_time_in_sec=0, down_time_in_sec=0):\n        \"\"\"\n        Enable/disable flapping on all the BGP interfaces.\n\n        :param bgp_peer_name_list: BGP peer name List\n        :param action: string format. Not boolean\n               'True' = enable BGP flap\n               'False' = disable BGP flap\n        :param up_time_in_sec: Up Time In Seconds.\n        :param down_time_in_sec: Down Time In Seconds.\n        :return: True on success else raise exception.\n\n        :Example: bgp_ngp_flap(bgp_peer_name_list=[\"BGP Peer 1\",\"BGP Peer 2\"])\n        \"\"\"\n\n        self.log.info('BGP Neighbor Flapping for %s' % bgp_peer_name_list)\n        if not type(bgp_peer_name_list) == list:\n            msg = 'bgp_peer_name_list type can not be %s. It should be a list' \\\n                        % type(bgp_peer_name_list)\n            raise IxiaConfigException(msg)\n        for bgpPeerName in bgp_peer_name_list:\n            for version in ['v4', 'v6']:\n                try:\n                    peerNameList = [bgpObj.Name for bgpObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find()')]\n                except:\n                    pass\n                for peerName in peerNameList:\n                    if peerName == bgpPeerName:\n                        peerName = '^' + bgpPeerName + '$'\n                        if '+' or '*' in peerName:\n                            peerName = peerName.replace('+', r'\\+').replace('*', r'\\*')\n                        try:\n                            for bgpPeerObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find(DescriptiveName=peerName)'):\n                                bgpPeerObj.Flap.Single(action)\n                                bgpPeerObj.UptimeInSec.Single(up_time_in_sec)\n                                bgpPeerObj.DowntimeInSec.Single(down_time_in_sec)\n                        except:\n                            pass\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def igmp_active_deactive(self, **kwargs):\n        \"\"\"\n        Igmp active or deactive for multicast groups\n\n        :param kwargs: optional arguments\n\n        :Example: igmp_active_deactive(port=[\"Ethernet - 001\", \"Ethernet - 002\"], hostIp=[\"105.1.1.2\",\"105.1.2.2\"],action=False)\n        \"\"\"\n        kwargs['ports'] = kwargs.get('ports', None)\n        kwargs['hostIp'] = kwargs.get('hostIp', None)\n        kwargs['groups'] = kwargs.get('groups', None)\n        kwargs['action'] = kwargs.get('action', True)\n\n        if ('ports' in kwargs and kwargs['ports'] == None) and ('hostIp' in kwargs and kwargs['hostIp'] == None ) \\\n                and ('groups' in kwargs and kwargs['groups'] == None):\n           for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.\\\n                   find().IgmpMcastIPv4GroupList:\n               igmpMcastObj.Active.Single(str(kwargs['action']).lower())\n\n        if 'ports' in kwargs and kwargs['ports'] is not None:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in kwargs['ports'] if portName in vportNameList]\n            for portName in portNameList:\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        for ipv4 in topologyObj.DeviceGroup.find().Ethernet.find().Ipv4.find():\n                            for igmpHost in ipv4.IgmpHost.find():\n                                if re.match(topologyObj + '/deviceGroup', igmpHost.href):\n                                    for igmpObj in ipv4.IgmpHost.find(DescriptiveName=igmpHost.DescriptiveName).IgmpMcastIPv4GroupList:\n                                        igmpObj.Active.Single(str(kwargs['action']).lower())\n\n        if 'hostIp' in kwargs and kwargs['hostIp'] is not None:\n            for ip in kwargs['hostIp']:\n                ipNameList = [address.Name for address in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find() if address]\n                for ipName in ipNameList:\n                    address = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).Address\n                    if ip in address.Values:\n                        ipIndex = address.Values.index(ip)\n                        valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active.Values\n                        valuesList[ipIndex] = str(kwargs['action']).lower()\n                        igmpMcastObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active\n                        igmpMcastObj.ValueList(values=valuesList)\n\n        if 'groups' in kwargs and kwargs['groups'] is not None:\n            for igmpMcast in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList:\n                multicastIpList = igmpMcast.StartMcastAddr.Values\n                for group in kwargs['groups']:\n                    if group[1] in multicastIpList:\n                        indices = [index for index in range(0, len(multicastIpList)) if multicastIpList[index] == group[1]]\n                        for index in indices:\n                            valuesList = igmpMcast.Active.Values\n                            valuesList[index] = str(kwargs['action']).lower()\n                            igmpMcastObj = igmpMcast.Active\n                            igmpUcastObj = igmpMcast.IgmpUcastIPv4SourceList.Active\n                            if \"*\" in group:\n                                igmpMcastObj.ValueList(values=valuesList)\n                            else:\n                                igmpMcastObj.ValueList(values=valuesList)\n                                igmpUcastObj.ValueList(values=valuesList)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n    def _update_bgp_flap_values(self,bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime):\n        \"\"\"\n        Internal API used by bgp_routes_flap\n\n        :param bgpRoutePropertyObj: bgpRoutePropertyObj\n        :param ipv4PrefixPoolObj: ipv4PrefixPoolObj\n        :param address: address\n        :param action: action\n        :param uptime: uptime\n        :param downtime: downtime\n        :return:\n        \"\"\"\n        if address in ipv4PrefixPoolObj.NetworkAddress.Values:\n            addressIndex = (ipv4PrefixPoolObj.NetworkAddress.Values).index(address)\n            enableFlappingValues = bgpRoutePropertyObj.EnableFlapping.Values\n            enableFlappingValues[addressIndex] = str(action).lower()\n            bgpRoutePropertyObj.EnableFlapping.ValueList(enableFlappingValues)\n            UptimeValues = bgpRoutePropertyObj.Uptime.Values\n            UptimeValues[addressIndex] = uptime\n            bgpRoutePropertyObj.Uptime.ValueList(UptimeValues)\n            DowntimeValues = bgpRoutePropertyObj.Downtime.Values\n            DowntimeValues[addressIndex] = downtime\n            bgpRoutePropertyObj.Downtime.ValueList(DowntimeValues)\n\n    def bgp_routes_flap(self, port_list=None, IP_type='ipv4', action='False', uptime=0, downtime=0, address_list=None, **kwargs):\n        \"\"\"\n        Enable/disable BGP routes flapping based on port_list and last_address_list\n\n        :param port_list: list of port name. Default is None\n        :param IP_type: 'ipv4' or 'ipv6'\n        :param action: 'true' or 'false'\n        :param uptime: uptime in seconds. Default is 0\n        :param downtime: downtime in seconds. Default is 0\n        :param address_list: list for start network address. Default is None\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                       For IXIA, device_list list of devices\n        :return: True on success else raises exception\n\n        :Example: bgp_routes_flap(port_list=['Ethernet - 001'],action='true',uptime=0,downtime=0)\n                  bgp_routes_flap(port_list=[\"Ethernet - 002\"], IP_type='ipv6', action='True', address_list=[\"1001::1\"])\n                  bgp_routes_flap(device_list=[\"Device 1\"],address_list=[\"10.1.1.1\"], IP_type='ipv4', action='True', uptime=5, downtime=5)\n        \"\"\"\n        self.log.info('BGP Route Flapping')\n        device_list = kwargs.get('device_list',None)\n        if (device_list and address_list and port_list == None) or (device_list and port_list and address_list):\n            for device in device_list:\n                for address in address_list:\n                    if IP_type.lower() == \"ipv4\":\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():\n                            for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():\n                                if ipv4PrefixPoolObj.BgpIPRouteProperty.find():\n                                    bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()\n                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime)\n                    if IP_type.lower() == \"ipv6\":\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():\n                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():\n                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():\n                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()\n                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv6PrefixPoolObj,address,action,uptime,downtime)\n                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():\n                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()\n                                    self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)\n        if (device_list and address_list == None and port_list == None):\n            for device in device_list:\n                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').NetworkGroup.find():\n                        if IP_type.lower() == \"ipv4\":\n                            for bgpIpRoute in networkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                                bgpIpRoute.EnableFlapping.Single(str(action).lower())\n                                bgpIpRoute.Uptime.Single(uptime)\n                                bgpIpRoute.Downtime.Single(downtime)\n                        if IP_type.lower() == \"ipv6\":\n                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():\n                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():\n                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()\n                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():\n                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()\n                                bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())\n                                bgpRoutePropertyObj.Uptime.Single(uptime)\n                                bgpRoutePropertyObj.Downtime.Single(downtime)\n        if (device_list == None and port_list and address_list) or (device_list == None and port_list == None and address_list):\n            for address in address_list:\n                if IP_type.lower() == \"ipv4\":\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                        for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():\n                            if ipv4PrefixPoolObj.BgpIPRouteProperty.find():\n                                bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()\n                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv4PrefixPoolObj, address, action, uptime, downtime)\n                if IP_type.lower() == \"ipv6\":\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                        for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():\n                            if ipv6PrefixPoolObj.BgpIPRouteProperty.find():\n                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()\n                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)\n                            if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():\n                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()\n                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)\n        if (port_list and device_list == None and address_list == None):\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            portNameList = [portName for portName in port_list if portName in vportNameList]\n            for portName in portNameList:\n                portName = '^' + portName.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n                for topology in self.ixNetwork.Topology.find():\n                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                        topologyObj = topology.href\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                            if IP_type.lower() == \"ipv4\":\n                                for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():\n                                    if ipv4PrefixPoolObj.BgpIPRouteProperty.find():\n                                        bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()\n                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):\n                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())\n                                            bgpRoutePropertyObj.Uptime.Single(uptime)\n                                            bgpRoutePropertyObj.Downtime.Single(downtime)\n                            else:\n                                for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():\n                                    if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():\n                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()\n                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):\n                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())\n                                            bgpRoutePropertyObj.Uptime.Single(uptime)\n                                            bgpRoutePropertyObj.Downtime.Single(downtime)\n                                    if ipv6PrefixPoolObj.BgpIPRouteProperty.find():\n                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()\n                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):\n                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())\n                                            bgpRoutePropertyObj.Uptime.Single(uptime)\n                                            bgpRoutePropertyObj.Downtime.Single(downtime)\n        if (port_list == None and address_list== None and device_list ==None):\n            for device in self.ixNetwork.Topology.find().DeviceGroup.find():\n                for group in device.find().NetworkGroup.find():\n                    if IP_type.lower() == 'ipv4':\n                        try:\n                            for bgpIpRoute in group.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                                bgpIpRoute.EnableFlapping.Single(str(action).lower())\n                                bgpIpRoute.Uptime.Single(uptime)\n                                bgpIpRoute.Downtime.Single(downtime)\n                        except:\n                            pass\n                    if IP_type.lower() == \"ipv6\":\n                        try:\n                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():\n                                bgpIpRoute.EnableFlapping.Single(str(action).lower())\n                                bgpIpRoute.Uptime.Single(uptime)\n                                bgpIpRoute.Downtime.Single(downtime)\n                        except:\n                            pass\n                        try:\n                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():\n                                bgpIpRoute.EnableFlapping.Single(str(action).lower())\n                                bgpIpRoute.Uptime.Single(uptime)\n                                bgpIpRoute.Downtime.Single(downtime)\n                        except:\n                            pass\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def _get_dict_traffic_streams(self):\n        \"\"\"\n        Get traffic streams mapped to streamblock\n\n        :return: Dictionary of traffic streams\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        dictTrafficStreams = {}\n        streamblockList = self.get_all_traffic_streams()\n        for stream in streamblockList:\n            streamblockName = stream.Name\n            dictTrafficStreams[streamblockName] = stream\n        return dictTrafficStreams\n\n    def set_stream_mpls_label(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Sets the MPLS label field to the specified value\n\n        :param cfg_dict: The exp bit field value to be used.\n        :param mpls_label_index: Mpls label index , default value is 0.\n        :param traffic_item_list: A list of streamblocks to be modified. If None,\n                set mplsbit for all streamblocks.\n        :return: True if no exceptions were thrown\n\n        :Example: set_stream_mpls_label(cfg_dict = {'valueType':'singleValue', 'value' : 20})\n                  set_stream_mpls_label1(cfg_dict = {'valueType':'singleValue', 'value' : 20, 'mpls_label_index': 0 }, traffic_item_list= ['Traffic Item 1'])\n        \"\"\"\n        self.log.info(\"Setting MPLS label for Traffic Items\")\n        if not 'mpls_label_index' in cfg_dict is None:\n            cfg_dict['mpls_label_index'] = 0\n        if traffic_item_list is None:\n            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]\n        for trafficName in traffic_item_list:\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():\n                try:\n                    fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='label_value')\n                    for index in range(len(fieldValue)):\n                        if index == cfg_dict['mpls_label_index']:\n                            try:\n                                if cfg_dict['valueType'].lower() in ['increment', 'decrement']:\n                                    fieldValue[index].ValueType = cfg_dict['valueType'].lower()\n                                    fieldValue[index].StepValue = 1\n                                    fieldValue[index].StartValue = cfg_dict['value']\n                                else:\n                                    fieldValue[index].ValueType = cfg_dict['valueType']\n                                    fieldValue[index].SingleValue = cfg_dict['value']\n                                result = True\n\n                            except:\n                                result = False\n                except:\n                    result = False\n        return result\n\n    def get_stream_mpls_label(self, traffic_item_list=None):\n        \"\"\"\n        Gets the value of the MPLS headers exp field for the specified traffic items\n\n        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.\n        :return: A list of results containing the exp field value for the specified streams\n\n        :Example: get_stream_mpls_label()\n        \"\"\"\n        self.log.info(\"Getting MPLS EXP Bits For Traffic Items\")\n        results = []\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                try:\n                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(\n                        StackTypeId='mpls').Field.find(Name='mpls_exp'):\n                        results.append(fieldValue.SingleValue)\n                except:\n                    self.log.info(\"MPLS Stack Not Available in %s\" % trafficName)\n                    raise IxiaOperationException(\"MPLS Stack Not Available in %s\" % trafficName)\n        else:\n            try:\n                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(\n                            StackTypeId='mpls').Field.find(Name='mpls_exp'):\n                    results.append(fieldValue.SingleValue)\n            except:pass\n        return results\n\n    def get_traffic_transmission_mode(self, traffic_item_list=None, port='all'):\n        \"\"\"\n        Returns the traffic transmission mode with respective values configured\n\n        :param traffic_item_list: List of traffic items\n        :param port: port on which traffic is generated\n        :return: Dictionary of the traffic transmission mode configured\n\n        :Example: get_traffic_transmission_mode()\n        \"\"\"\n        self.log.info(\"Getting Traffic Transmission Mode\")\n        result = {}\n        if traffic_item_list:\n            for trafficName in traffic_item_list:\n                result[trafficName] = self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).TransmitMode\n        else:\n            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():\n                result[trafficItem.Name] = trafficItem.TransmitMode\n        return result\n\n    def _get_route_count(self, poolHandle, routeCount, prefixIp=None):\n        \"\"\"\n        Get Route count based on Protocol handle.\n\n        :param poolHandle: network pool handle\n        :param routeCount: routecount\n        :param prefixIp: Ip prefix value as reference\n        :return:\n        \"\"\"\n        if prefixIp:\n            try:\n                # This block for 9.0 version\n                ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)\n                routeCount = (poolHandle.NumberOfAddressesAsy.Values)[ipPrefixIndex]\n            except:\n                # This block for 8.50 version\n                routeCount = poolHandle.NumberOfAddresses\n                pass\n        else:\n            try:\n                # This block for 9.0 version\n                addressCountList = poolHandle.NumberOfAddressesAsy.Values\n                routeCount = int(addressCountList[0]) + routeCount\n            except:\n                # This block for 8.50 version\n                addressCount = poolHandle.NumberOfAddresses\n                routeCount = routeCount + addressCount\n                pass\n        return routeCount\n\n    def _get_isis_ospf_route_count(self, network_group, ports, ip_type, start_ip_prefix, protocol, router_id):\n        \"\"\"\n        getting address count for protocols.\n        :param network_group: Network Group for which Route Count should be modified\n        :param ports: Ports\n        :param ip_type: ipv4 or ipv6\n        :param start_ip_prefix: ipv4/ipv6 perfix ip\n        :param protocol: ISIS/OSPF\n        :param router_id: router ID\n        :return: result\n        \"\"\"\n        route_count = 0\n        protocol_status = False\n        deviceGroupName = None\n        if (network_group and start_ip_prefix and router_id) or (\n                network_group is None and start_ip_prefix and router_id):\n            networkGroupNameList = []\n            if \".\" in router_id and protocol.lower() != 'isis':\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                            deviceGroupName = deviceGroupObj.Name\n                            break\n                try:\n                    if deviceGroupName:\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                            if network_group:\n                                if network_group in networkGroup.Name:\n                                    networkGroupNameList.append(networkGroup.Name)\n                                    break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            if \".\" not in router_id and protocol.lower() == 'isis':\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.Name == router_id:\n                        deviceGroupName = router_id\n                try:\n                    if deviceGroupName:\n                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                            if network_group:\n                                if network_group in networkGroup.Name:\n                                    networkGroupNameList.append(networkGroup.Name)\n                                    break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            else:\n                try:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():\n                        if network_group:\n                            if network_group in networkGroup.Name:\n                                networkGroupNameList.append(networkGroup.Name)\n                                break\n                            else:\n                                networkGroupNameList.append(networkGroup.Name)\n                except:\n                    pass\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    protocol_status = True\n                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)\n                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.OspfRouteProperty.find():\n                                    protocol_status = True\n                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)\n                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                    if ip_type.lower() == \"ipv6\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                        protocol_status = True\n                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)\n                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.Ospfv3RouteProperty.find():\n                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:\n                                        protocol_status = True\n                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)\n                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                        raise IxiaConfigException(\"Passed Invalid Ip %s\" % start_ip_prefix)\n            else:\n                raise IxiaConfigException(\"Router Id not found on this '%s' Network Group\" % network_group)\n\n        if (network_group and start_ip_prefix is None and ports is None and router_id) or (\n                network_group is None and start_ip_prefix is None and router_id):\n            if \".\" in router_id:\n                if protocol == \"ISIS\":\n                    raise IxiaConfigException(\"ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')\")\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                            deviceGroupName = deviceGroupObj.Name\n                            break\n                networkGroupNameList = []\n                if network_group and router_id:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                        if network_group in networkGroup.Name:\n                            networkGroupNameList.append(networkGroup.Name)\n                            # networkGroupNameList = networkGroupNameList\n                if network_group is None and router_id:\n                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]\n\n            else:\n                networkGroupNameList = []\n                if network_group and router_id:\n                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():\n                        if network_group in networkGroup.Name:\n                            networkGroupNameList.append(networkGroup.Name)\n                if network_group is None and router_id:\n                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                                Name='^' + router_id + '$').NetworkGroup.find()]\n\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    protocol_status = True\n                                    route_count = self._get_route_count(networkGroupObj,route_count)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.OspfRouteProperty.find():\n                                    protocol_status = True\n                                    route_count = self._get_route_count(networkGroupObj,route_count)\n                    if ip_type.lower() == \"ipv6\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():\n                            if protocol == \"ISIS\":\n                                if networkGroupObj.IsisL3RouteProperty.find():\n                                    protocol_status = True\n                                    route_count = self._get_route_count(networkGroupObj,route_count)\n                            if protocol == \"OSPF\":\n                                if networkGroupObj.Ospfv3RouteProperty.find():\n                                    protocol_status = True\n                                    route_count = self._get_route_count(networkGroupObj,route_count)\n            else:\n                raise IxiaConfigException(\"Router Id not found on this '%s' Network Group\" % network_group)\n\n        if network_group and ports is None and start_ip_prefix is None and router_id is None:\n            networkGroupNameList = []\n            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                for networkGroupObj in deviceGroupObj.NetworkGroup.find():\n                    if network_group in networkGroupObj.Name:\n                        networkGroupNameList.append(networkGroupObj.Name)\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):\n                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if ipv4PoolObj.IsisL3RouteProperty.find():\n                                        protocol_status = True\n                                        route_count = self._get_route_count(ipv4PoolObj,route_count)\n                                if protocol == \"OSPF\":\n                                    if ipv4PoolObj.OspfRouteProperty.find():\n                                        protocol_status = True\n                                        route_count = self._get_route_count(ipv4PoolObj,route_count)\n                    else:\n                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):\n                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if ipv6PoolObj.IsisL3RouteProperty.find():\n                                        protocol_status = True\n                                        route_count = self._get_route_count(ipv6PoolObj,route_count)\n                                if protocol == \"OSPF\":\n                                    if ipv6PoolObj.Ospfv3RouteProperty.find():\n                                        protocol_status = True\n                                        route_count = self._get_route_count(ipv6PoolObj,route_count)\n            else:\n                raise IxiaConfigException(\"Network group name '%s' not found for Ip version '%s'\" % (network_group,ip_type))\n        if ports:\n            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]\n            for port in ports:\n                if port in vportNameList:\n                    for topologyObj in self.ixNetwork.Topology.find():\n                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:\n                            if ip_type.lower() == \"ipv4\":\n                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():\n                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():\n                                        if protocol == \"ISIS\":\n                                            if ipv4PoolObj.IsisL3RouteProperty.find():\n                                                protocol_status = True\n                                                route_count = self._get_route_count(ipv4PoolObj,route_count)\n                                        if protocol == \"OSPF\":\n                                            if ipv4PoolObj.OspfRouteProperty.find():\n                                                protocol_status = True\n                                                route_count = self._get_route_count(ipv4PoolObj,route_count)\n                            else:\n                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():\n                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():\n                                        if protocol == \"ISIS\":\n                                            if ipv6PoolObj.IsisL3RouteProperty.find():\n                                                protocol_status = True\n                                                route_count = self._get_route_count(ipv6PoolObj,route_count)\n                                        if protocol == \"OSPF\":\n                                            if ipv6PoolObj.Ospfv3RouteProperty.find():\n                                                protocol_status = True\n                                                route_count = self._get_route_count(ipv6PoolObj,route_count)\n        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (\n                start_ip_prefix and network_group and ports is None and router_id is None):\n            networkGroupNameList = []\n            if network_group and start_ip_prefix:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if\n                                        network_group in networkObj.Name]\n                # This condition for compact version\n                if networkGroupNameList == []:\n                    networkGroupNameList = [networkObj.Name for networkObj in\n                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]\n\n            if start_ip_prefix and network_group is None:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]\n            if networkGroupNameList:\n                for networkGroupName in networkGroupNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        try:\n                            for network_group_obj in networkObj.Ipv4PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if network_group_obj.IsisL3RouteProperty.find():\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                                if protocol == \"OSPF\":\n                                    if network_group_obj.OspfRouteProperty.find():\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                        except:\n                            pass\n                    else:\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')\n                        try:\n                            for network_group_obj in networkObj.Ipv6PrefixPools.find():\n                                if protocol == \"ISIS\":\n                                    if network_group_obj.IsisL3RouteProperty.find():\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                                if protocol == \"OSPF\":\n                                    if network_group_obj.Ospfv3RouteProperty.find():\n                                        protocol_status = True\n                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:\n                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)\n                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:\n                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')\n                        except:\n                            pass\n        if protocol_status and route_count != 0:\n            return route_count\n        else:\n            raise IxiaConfigException(\"%s protocol not configured or Configuration issue.\" % protocol)\n\n    def get_isis_route_count(self,router_id=None, ip_type=\"ipv4\", lsp_id=None, start_ip_prefix=None, **kwargs):\n        \"\"\"\n        Get the route count for ISIS protocol.\n\n        :param router_id: It's mandatory value for spirent and represents the Router ID of the router.\n        :param ip_type: String demonstrating the IP version\n        :param lsp_id: It's optional value specific to Spirent and represents the LSP Name.\n        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                        For IXIA, network_group has to be included in the kwargs\n                        as a mandatory parameter and ports is optional\n        :return: route count value/dictionary.\n\n        :Example: get_isis_route_count(network_group='Network Group 8',ip_type=\"ipv4\")\n        \"\"\"\n        self.log.info(\"Getting ISIS Route Count\")\n        ports = kwargs.get('ports', None)\n        network_group = kwargs.get('network_group', None)\n        if router_id:\n            if \".\" in router_id:\n                router_id = None\n        if not network_group and start_ip_prefix is None and router_id is None and ports is None:\n            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')\n        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol=\"ISIS\",router_id=router_id)\n        return routeCount\n\n    def get_ospf_route_count(self, router_id, ip_type=\"ipv4\", lsa_id=None, start_ip_prefix=None, **kwargs):\n        \"\"\"\n        Get the route count for OSPF protocol.\n\n        :param router_id: It's mandatory value and represents the Router ID of the router.\n        :param ip_type: String demonstrating the IP version\n        :param lsa_id: It's optional value specific to Spirent and represents the LSA Name.\n        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                        For IXIA, network_group has to be included in the kwargs\n                        as a mandatory parameter and ports is optional\n        :return: route count value/dictionary.\n\n        :Example: get_ospf_route_count(router_id=\"192.0.0.1\",ip_type=\"ipv6\",network_group='Network Group 2'))\n        \"\"\"\n        self.log.info(\"Getting OSPF Route Count\")\n        ports = kwargs.get('ports')\n        network_group = kwargs.get('network_group', None)\n        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol=\"OSPF\",router_id=router_id)\n        return routeCount\n\n    def verify_dhcp_client_bound_count(self, client_dict):\n        \"\"\"\n        To verify number of DHCP sessions currently bound to the interface/device\n\n        :param client_dict: {'device1':{'protocol': 'ipv4', 'total_bound_count':'100', 'current_bound_count':'10'}}\n        :return: True if successful\n\n        :Example: verify_dhcp_client_bound_count(client_dict={'Device Group 23':{'protocol': 'ipv4', 'total_bound_count':10, 'current_bound_count':10}})\n        \"\"\"\n        self.log.info(\"Verifying DHCP Client Bound Count\")\n        error_flag = False\n        err_msg = \"\"\n        for device in client_dict:\n            protocol = client_dict[device]['protocol']\n            totalBoundCount, currentBoundCount = self.get_dhcp_client_bound_count(device, protocol)\n\n            expectedTotalBoundCount = client_dict[device]['total_bound_count']\n            expectedCurrentBoundCount = client_dict[device]['current_bound_count']\n\n            if totalBoundCount == expectedTotalBoundCount and \\\n                    currentBoundCount == expectedCurrentBoundCount:\n                log.info('Actual and expected bound count for client/device %s match' % device)\n            else:\n                error_flag = True\n                err_msg += 'For device %s:\\n' % device\n                err_msg += 'Actual values: (totalBoundCount)=%s, (currentBoundCount)=%s \\n' \\\n                           % (totalBoundCount, currentBoundCount)\n                err_msg += 'Expected values: (totalBoundCount)=%s, (currentBoundCount)=%s\\n\\n' \\\n                           % (expectedTotalBoundCount, expectedCurrentBoundCount)\n\n        if error_flag:\n            raise CafyException.VerificationError(err_msg)\n\n        return True\n\n    def ospf_start(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):\n        \"\"\"\n        To start OSPFv2/OSPFv3 emulation\n\n        :param version: Version\n        :param port: List of ports. If 'None', all the ports\n        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts\n        :param devices: Name of the devices in the config\n        :return: True on success. raise exception if False/error\n\n        :Example: ospf_start(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])\n        \"\"\"\n        self.log = CafyLog('Starting OSPF protocol')\n        action = 'Start'\n        protocol = []\n        if version.lower() not in ('v2', 'v3'):\n            CafyException.InvalidValueError('%s not a valid OSPF version' % version)\n        protocol.append('ospf' + version)\n        nested_device = kwargs.get('nested_device', None)\n        self._start_stop_protocols(protocol, port, host_ip, \"Start\", \"True\", devices, nested_device)\n        return True\n\n    def ospf_stop(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):\n        \"\"\"\n        To start OSPFv2/OSPFv3 emulation\n\n        :param version: Version\n        :param port: List of ports. If 'None', all the ports\n        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts\n        :param devices: Name of the devices in the config\n        :return: True on success. raise exception if False/error\n\n        :Example: ospf_stop(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])\n        \"\"\"\n        self.log = CafyLog('Starting OSPF protocol')\n        action = 'Stop'\n        protocol = []\n        if version.lower() not in ('v2', 'v3'):\n            CafyException.InvalidValueError('%s not a valid OSPF version' % version)\n        protocol.append('ospf' + version)\n        nested_device = kwargs.get('nested_device', None)\n        self._start_stop_protocols(protocol, port, host_ip, \"Stop\", \"False\", devices, nested_device)\n        return True\n    \n    def _igmp_configure(self, igmp_group_start, count, step, prefix, group_name=None, match_all=True, **kwargs):\n        \"\"\"\n        Function used internally by API \"config_multicast_group\"\n\n        :param group_name: Device group name (optional)\n        :param igmp_group_start: IGMP host start address\n        :param count: Group address count\n        :param step: Group address increment\n        :param prefix: IGMP Prefix\n        :param match_all: If True, match exact group name\n                        If False, match names like \"<group_name> 1\", \"<group_name> 2\", etc.\n                        (not ones like \"<group_name>_VRF\")\n        \"\"\"\n        result = False\n        value_type = kwargs.get('value_type', 'increment')\n        no_group_ranges = kwargs.get('no_group_ranges', 1)\n        custom_count = kwargs.get('custom_count', 1)\n        custom_step = kwargs.get('custom_step', step)\n\n        if group_name:\n            self.log.info(f\"Configuring IGMP host : {group_name}\")\n            if match_all == False:\n                # exact match\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=f\"^{re.escape(group_name)}$\")\n            elif match_all == True:\n                # partial match numeric suffix\n                all_hosts = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find()\n                pattern = re.compile(rf\"^{re.escape(group_name)}(\\s*\\d+)?$\", re.IGNORECASE)\n                device_objs = [igmp for igmp in all_hosts if pattern.match(igmp.Name or \"\")]\n        elif 'device_name' in kwargs:\n            device_objs = self.ixNetwork.Topology.find() \\\n                .DeviceGroup.find(Name=kwargs['device_name']).Ethernet.find().Ipv4.find().IgmpHost.find()\n            \n        for igmp_host_obj in device_objs:\n            if 'device' not in kwargs:\n                if igmp_group_start and step:\n                    igmp_host_obj.NoOfGrpRanges = no_group_ranges\n                    if value_type.lower() == 'custom':\n                        igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Custom(\n                            start_value=igmp_group_start,\n                            step_value=step,\n                            increments=[(custom_step, custom_count, [])]\n                        )\n                    else:\n                        igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Increment(\n                            start_value=igmp_group_start,\n                            step_value=step\n                        )\n                elif igmp_group_start and not step:\n                    igmp_host_obj.IgmpMcastIPv4GroupList.StartMcastAddr.Single(igmp_group_start)\n\n            if 'device' in kwargs:\n                device_id = kwargs['device']\n                if count:\n                    mcast_grp_list = igmp_host_obj.IgmpMcastIPv4GroupList\n                    group_count_list = mcast_grp_list.McastAddrCnt.Values\n                    group_count_list[device_id - 1] = count\n                    mcast_grp_list.McastAddrCnt.ValueList(group_count_list)\n                if igmp_group_start:\n                    mcast_start_list = igmp_host_obj.IgmpMcastIPv4GroupList\n                    start_addr_list = mcast_start_list.StartMcastAddr.Values\n                    start_addr_list[device_id - 1] = igmp_group_start\n                    mcast_start_list.StartMcastAddr.ValueList(start_addr_list)\n            else:\n                igmp_host_obj.IgmpMcastIPv4GroupList.McastAddrCnt.Single(count)\n\n            if 'igmp_version' in kwargs:\n                igmp_host_obj.VersionType.Single(kwargs['igmp_version'])\n\n            result = True\n\n        if result:\n            self.log.info(\"Multicast group successfully configured\")\n            return result\n        else:\n            raise IxiaConfigException(f\"Passed invalid group name {group_name}\")\n\n    def _mld_configure(self, mld_group_start, count, step, prefix, group_name=None, match_all1=True, **kwargs):\n        \"\"\"\n        Function used internally by API \"config_multicast_group\"\n\n        :param group_name: MLD host group name (optional)\n        :param mld_group_start: MLD host start address\n        :param count: Group address count\n        :param step: Group address increment\n        :param prefix: 128 for IPv6\n        :param match_all1: If True, match exact group name\n                        If False, match names like \"<group_name> 1\", \"<group_name> 2\", etc.\n                        (not ones like \"<group_name>_VRF\")\n        \"\"\"\n        result = False\n        value_type = kwargs.get('value_type', 'increment')\n        no_group_ranges = kwargs.get('no_group_ranges', 1)\n        custom_count = kwargs.get('custom_count', 1)\n        custom_step = kwargs.get('custom_step', step)\n\n        if group_name:\n            self.log.info(f\"Configuring MLD host : {group_name}\")\n            if match_all1 is False:\n                # exact match\n                device_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=f\"^{re.escape(group_name)}$\")\n            else:\n                # partial match with optional numeric suffix\n                all_hosts = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find()\n                pattern = re.compile(rf\"^{re.escape(group_name)}(\\s*\\d+)?$\", re.IGNORECASE)\n                device_objs = [mld for mld in all_hosts if pattern.match(mld.Name or \"\")]\n        elif 'device_name' in kwargs:\n            device_objs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=kwargs['device_name']).Ethernet.find().Ipv6.find().MldHost.find()\n        else:\n            device_objs = []\n\n        for mld_host_obj in device_objs:\n            if 'device' not in kwargs:\n                if mld_group_start and step:\n                    mld_host_obj.NoOfGrpRanges = no_group_ranges\n                    if value_type.lower() == 'custom':\n                        mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Custom(\n                            start_value=mld_group_start,\n                            step_value=step,\n                            increments=[(custom_step, custom_count, [])]\n                        )\n                    else:\n                        mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Increment(\n                            start_value=mld_group_start,\n                            step_value=step\n                        )\n                elif mld_group_start and not step:\n                    mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Single(mld_group_start)\n\n            if 'device' in kwargs:\n                device_id = kwargs['device']\n                if count:\n                    mcast_grp_list = mld_host_obj.MldMcastIPv6GroupList\n                    group_count_list = mcast_grp_list.McastAddrCnt.Values\n                    group_count_list[device_id - 1] = count\n                    mcast_grp_list.McastAddrCnt.ValueList(group_count_list)\n                if mld_group_start:\n                    start_addr_list = mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.Values\n                    start_addr_list[device_id - 1] = mld_group_start\n                    mld_host_obj.MldMcastIPv6GroupList.StartMcastAddr.ValueList(start_addr_list)\n            else:\n                mld_host_obj.MldMcastIPv6GroupList.McastAddrCnt.Single(count)\n\n            if 'mld_version' in kwargs:\n                mld_host_obj.VersionType.Single(kwargs['mld_version'])\n\n            result = True\n        if result:\n            self.log.info(\"MLD multicast group successfully configured\")\n            return result\n        else:\n            raise IxiaConfigException(f\"Passed invalid group name {group_name}\")\n\n    def _pimv4_configure(self, group_name, pimv4_group_start, count, step, prefix, match_all1=True, **kwargs):\n        \"\"\"\n        Function used internally by API \"config_multicast_group\"\n\n        :param group_name:Device group name\n        :param ip_version: IP Version\n        :param pimv4_group_start:pimv4 host start address\n        :param count: group address count\n        :param step: group address increment\n        :param prefix: PIMv4 Prefix\n        \"\"\"\n        result = False\n        self.log.info(f\"Configuring PIMv4 group : {group_name}\")\n\n        if match_all1 is False:\n            # exact match\n            pim_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find(Name=f\"^{re.escape(group_name)}$\")\n        else:\n            # partial match numeric suffix only\n            all_pims = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find()\n            pattern = re.compile(rf\"^{re.escape(group_name)}(\\s*\\d+)?$\", re.IGNORECASE)\n            pim_objs = [pim for pim in all_pims if pattern.match(pim.Name or \"\")]\n\n        for pimv4Obj in pim_objs:\n            if 'device' not in kwargs:\n                if pimv4_group_start and step:\n                    pimv4Obj.PimV4JoinPruneList.GroupV4Address.Increment(\n                        start_value=pimv4_group_start, step_value=step)\n                elif pimv4_group_start and not step:\n                    pimv4Obj.PimV4JoinPruneList.GroupV4Address.Single(pimv4_group_start)\n\n            if 'device' in kwargs:\n                device_id = kwargs['device']\n                if count:\n                    mcastGrpList = pimv4Obj.PimV4JoinPruneList\n                    group_count_list = mcastGrpList.GroupAddressCount.Values\n                    group_count_list[device_id - 1] = count\n                    mcastGrpList.GroupAddressCount.ValueList(group_count_list)\n                if pimv4_group_start:\n                    group_start_list = mcastGrpList.GroupV4Address.Values\n                    group_start_list[device_id - 1] = pimv4_group_start\n                    mcastGrpList.GroupV4Address.ValueList(group_start_list)\n            else:\n                pimv4Obj.PimV4JoinPruneList.GroupAddressCount.Single(count)\n\n            result = True\n\n        if result:\n            self.log.info(\"PIMv4 multicast group successfully configured\")\n            return result\n        else:\n            raise IxiaConfigException(f\"Passed invalid group name {group_name}\")\n\n    def _pimv6_configure(self, group_name, pimv6_group_start, count, step, prefix, match_all1=True, **kwargs):\n        \"\"\"\n        Function used internally by API \"config_multicast_group\"\n\n        :param group_name:Device group name\n        :param ip_version: IP Version\n        :param pimv4_group_start:pimv4 host start address\n        :param count: group address count\n        :param step: group address increment\n        :param prefix: PIMv4 Prefix\n        \"\"\"\n        result = False\n        self.log.info(f\"Configuring PIMv6 group : {group_name}\")\n\n        if match_all1 is False:\n            # exact match\n            pim_objs = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find(Name=f\"^{re.escape(group_name)}$\")\n        else:\n            # partial match numeric suffix only\n            all_pims = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find()\n            pattern = re.compile(rf\"^{re.escape(group_name)}(\\s*\\d+)?$\", re.IGNORECASE)\n            pim_objs = [pim for pim in all_pims if pattern.match(pim.Name or \"\")]\n\n        for pimv6Obj in pim_objs:\n            if 'device' not in kwargs:\n                if pimv6_group_start and step:\n                    pimv6Obj.PimV6JoinPruneList.GroupV6Address.Increment(\n                        start_value=pimv6_group_start, step_value=step)\n                elif pimv6_group_start and not step:\n                    pimv6Obj.PimV6JoinPruneList.GroupV6Address.Single(pimv6_group_start)\n\n            if 'device' in kwargs:\n                device_id = kwargs['device']\n                if count:\n                    mcastGrpList = pimv6Obj.PimV6JoinPruneList\n                    group_count_list = mcastGrpList.GroupAddressCount.Values\n                    group_count_list[device_id - 1] = count\n                    mcastGrpList.GroupAddressCount.ValueList(group_count_list)\n                if pimv6_group_start:\n                    group_start_list = mcastGrpList.GroupV6Address.Values\n                    group_start_list[device_id - 1] = pimv6_group_start\n                    mcastGrpList.GroupV6Address.ValueList(group_start_list)\n            else:\n                pimv6Obj.PimV6JoinPruneList.GroupAddressCount.Single(count)\n\n            result = True\n\n        if result:\n            self.log.info(\"PIMv6 multicast group successfully configured\")\n            return result\n        else:\n            raise IxiaConfigException(f\"Passed invalid group name {group_name}\")\n\n    def config_multicast_group(self, ip_version, start_ip='', count='', step='',\n                               prefix='', group_name=None, **kwargs):\n        \"\"\"\n        Config ipv4/ipv6 multi cast group\n\n        :param group_name: igmp group name\n        :param ip_version: IP version of multicast group\n        :param start_ip: Starting IP address of the group\n        :param count: Number of Groups\n        :param step: Increment step in case of more that one group\n        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)\n        :param kwargs :\n                protocol: Multicast protocol to config Ex igmp/mld/pimv4/pimv6\n        :return: True on Success\n\n        :Example: config_multicast_group('ipv6',group_name='MLD Host 2',start_ip='ff03::2', count='13',mld_version='version1')\n        \"\"\"\n        self.log.info(\"Configuring Multicast Group\")\n        match_all = kwargs.get(\"match_all\",True)\n        device_name = kwargs.get('device_name')\n        if group_name is None and device_name is None:\n            raise IxiaOperationException(\"Multicast group name or device name not provided by user\")\n        if ip_version not in ('ipv4', 'ipv6'):\n            raise IxiaOperationException(\"Invalid Ip version\")\n        if ip_version.lower() == 'ipv4':\n            protocol = kwargs.get('protocol', 'igmp')\n            if protocol.lower() == 'igmp':\n                self._igmp_configure(start_ip, count, step, prefix, group_name ,match_all = match_all,**kwargs)\n            if protocol.lower() == 'pimv4':\n                self._pimv4_configure(group_name, start_ip, count, step, prefix,match_all1 = match_all, **kwargs)\n\n        if ip_version.lower() == 'ipv6':\n            protocol = kwargs.get('protocol', 'mld')\n            if protocol.lower() == 'mld':\n                self._mld_configure(start_ip, count, step, prefix,group_name,match_all1 = match_all, **kwargs)\n            if protocol.lower() == 'pimv6':\n                self._pimv6_configure(group_name, start_ip, count, step, prefix,match_all1 = match_all, **kwargs)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def ldp_neighbor_flap(self, ldp_peer_name_list, action='True'):\n        \"\"\"\n        Enable/disable LDP on interfaces and also starts/stops LDP protocol\n        Flapping LDP router and LDP connected Interface\n\n        :param ldp_peer_name_list: LDP device name List\n        :param action: string format. Not boolean\n                       'True' = enable LDP flap\n                       'False' = disable LDP flap\n        :return: True on success else raise exception.\n\n        :Example: ldp_neighbor_flap(['Device 1','Device 2'],action='false')\n        \"\"\"\n        self.log.info(\"Performing LDP neighbor flap\")\n        if not isinstance(ldp_peer_name_list, list):\n            msg = 'ldpPeerNameList type can not be %s. It should be a list' \\\n                  % type(ldp_peer_name_list)\n            raise TypeError(msg)\n        if action.lower() == 'true':\n            protocolAction = 'Start'\n        else:\n            protocolAction = 'Stop'\n        for ldpRouter in ldp_peer_name_list:\n            try:\n                for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=ldpRouter):\n                    if deviceObj.LdpBasicRouter.find():\n                        ldpv4Obj = deviceObj.LdpBasicRouter.find()\n                        ldpv4Obj.Active.Single(action.lower())\n                        eval('ldpv4Obj.find().' + protocolAction + '()')\n                    if deviceObj.LdpBasicRouterV6.find():\n                        ldpv6Obj = deviceObj.LdpBasicRouterV6.find()\n                        ldpv6Obj.Active.Single(action.lower())\n                        eval('ldpv6Obj.find().' + protocolAction + '()')\n                    if deviceObj.Ethernet.find().Ipv4.find():\n                        ipv4Obj = deviceObj.Ethernet.find().Ipv4.find()\n                        if ipv4Obj.find().LdpBasicRouter.find():\n                            eval('ipv4Obj.find().LdpBasicRouter.find().Active.Single(action.lower())')\n                            eval('ipv4Obj.find().LdpBasicRouter.find().' + protocolAction + '()')\n                        if ipv4Obj.find().LdpConnectedInterface.find():\n                            eval('ipv4Obj.find().LdpConnectedInterface.find().Active.Single(action.lower())')\n                            eval('ipv4Obj.find().LdpConnectedInterface.find().' + protocolAction + '()')\n                    if deviceObj.Ethernet.find().Ipv6.find():\n                        ipv6Obj = deviceObj.Ethernet.find().Ipv6.find()\n                        if ipv6Obj.find().LdpBasicRouterV6.find():\n                            eval('ipv6Obj.find().LdpBasicRouterV6.find().Active.Single(action.lower())')\n                            eval('ipv6Obj.find().LdpBasicRouterV6.find().' + protocolAction + '()')\n                        if ipv6Obj.find().Ldpv6ConnectedInterface.find():\n                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().Active.Single(action.lower())')\n                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().' + protocolAction + '()')\n            except:\n                raise IxiaOperationException(\"LDP flap failed\")\n        try:\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        except:\n            pass\n        return True\n\n    def start_arp_on_streams(self, ports=()):\n        \"\"\"\n        Starts ARP on all the streams under specified ports\n\n        :param ports: port or list of ports Default all ports\n        :return: True on success\n        :Example: start_arp_on_streams()\n        \"\"\"\n        self.log.info(\"Starting ARP at stream level\")\n        traffic_items_port_dict = {}\n        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):\n                with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')\n                traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n                for traffic_item in traffic_item_list:\n                    stream_list = traffic_item.HighLevelStream.find()\n                    for count, stream in enumerate(stream_list):\n                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n                is_traffic_item = True\n            else:\n                self.log.warning('No Raw Traffic Streams in the configuration')\n                return False\n        else:\n            with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                self.ixNetwork.Traffic.TrafficItem.find()\n            is_traffic_item = False\n            traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n            for traffic_item in traffic_item_list:\n                stream_list = traffic_item.HighLevelStream.find()\n                for count, stream in enumerate(stream_list):\n                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n\n        vport_dest_mac_dict = {}\n        vports = [vport.href for vport in self.ixNetwork.Vport.find()]\n\n        for vport in vports:\n            dest_gateway_mac = []\n            for topology in self.ixNetwork.Topology.find():\n                if topology.Ports[0] == vport:\n                    try:\n                        ipv4_block = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()\n                        for each_ipv4_block in ipv4_block:\n                            each_ipv4_block_mac = list(\n                                filter(lambda ipv4_mac: None if ipv4_mac == 'removePacket[Unresolved]' else ipv4_mac,\n                                       each_ipv4_block.ResolvedGatewayMac))\n                            dest_gateway_mac.extend(each_ipv4_block_mac)\n\n                        ipv6_block = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()\n                        for each_ipv6_block in ipv6_block:\n                            each_ipv6_block_mac = list(\n                                filter(lambda ipv6_mac: None if ipv6_mac == 'removePacket[Unresolved]' else ipv6_mac,\n                                       each_ipv6_block.ResolvedGatewayMac))\n                            dest_gateway_mac.extend(each_ipv6_block_mac)\n                    except:\n                        self.log.warning('Mac address collection failed')\n            if dest_gateway_mac:\n                vport_dest_mac_dict[vport] = dest_gateway_mac[0]\n\n        if vport_dest_mac_dict:\n            traffic_name_mac_mapping = {}\n            for traffic_item_name in traffic_items_port_dict:\n                try:\n                    for flow in traffic_items_port_dict[traffic_item_name]:\n                        traffic_name_mac_mapping.setdefault(traffic_item_name, []).append(vport_dest_mac_dict[flow])\n                except:\n                    pass\n            try:\n                if is_traffic_item:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').ConfigElement.find()\n                            for count, config_element in enumerate(config_element_list):\n                                if config_element.Stack.find(DisplayName='Ethernet II'):\n                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        existing_mac = None\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,\n                                                                                                         'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field,\n                                                                                                        'SingleValue',\n                                                                                                        None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                            skip = True\n                                        else:\n                                            try:\n                                                ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')\n                                                ipv4_field = None\n                                                if ipv4_stackobj and ipv4_stackobj.href:\n                                                    ipv4_field = ipv4_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')\n                                                ipv6_field = None\n                                                if ipv6_stackobj and ipv6_stackobj.href:\n                                                    ipv6_field = ipv6_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                for ip_field in [ipv4_field, ipv6_field]:\n                                                    if ip_field and ip_field.StartValue:\n                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:\n                                                            skip = True\n                                            except Exception:\n                                                pass\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})\")\n                                            continue\n\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n                else:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').HighLevelStream.find()\n                            for count, high_stream in enumerate(high_stream_list):\n                                if high_stream.Stack.find(DisplayName='Ethernet II'):\n                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,\n                                                                                                         'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field,\n                                                                                                        'SingleValue',\n                                                                                                        None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                            skip = True\n                                        else:\n                                            try:\n\n                                                ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')\n                                                ipv4_field = None\n                                                if ipv4_stackobj and ipv4_stackobj.href:\n                                                    ipv4_field = ipv4_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')\n                                                ipv6_field = None\n                                                if ipv6_stackobj and ipv6_stackobj.href:\n                                                    ipv6_field = ipv6_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                for ip_field in [ipv4_field, ipv6_field]:\n                                                    if ip_field and ip_field.StartValue:\n                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:\n                                                            skip = True\n                                            except Exception:\n                                                pass\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac}) \")\n                                            continue\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n            except Exception as err_msg:\n                self.log.error(f'MAC Update failed in Traffic streams {err_msg}')\n                return False\n            self.log.info('Starting ARP on Streams is done')\n            return True\n        else:\n            self.log.error(\"Ip stack is down\")\n            return False\n\n    def get_port_traffic_streams(self, port):\n        \"\"\"\n        Get Traffic stream list with respect to port\n\n        :param port: Port(source) under which streams are created\n        :return: Stream list for the given port\n\n        :Example: get_port_traffic_streams('10.39.65.156/2/1')\n        \"\"\"\n        self.log.info(\"Getting Traffic Streams based on Port\")\n        trafficItemsPortDict = {}\n        streamList = []\n        if port:\n            for vport in self.ixNetwork.Vport.find():\n                if vport.AssignedTo.replace(\":\", \"/\") == port:\n                    port = vport.Name\n        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():\n                if trafficItem.FlowGroupCount > 0:\n                    trafficItemsPortDict[trafficItem.Name] = trafficItem.HighLevelStream.find()[0].TxPortId\n                else:\n                    streamList.append(trafficItem.Name)\n        else:\n            for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():\n                trafficItemsPortDict[quickFlow.Name] = quickFlow.TxPortId\n\n        portHref = self.ixNetwork.Vport.find(Name=port).href\n        for traffic in trafficItemsPortDict:\n            if trafficItemsPortDict[traffic] == portHref:\n                streamList.append(traffic)\n        if not streamList:\n            self.log.warning(f\"No Traffic Streams found on {port}\")\n        self.log.info(streamList)\n        return streamList\n\n    def get_multicast_group(self, ip_version, group_name):\n        \"\"\"\n        Get Multicast's group network block config\n\n        :param ip_version: IP version of multi-cast group\n        :param group_name: Multicast's group name\n        :return: Network block config in Multicast group\n\n        :Example: get_multicast_group('ipv4','IGMP Host 2')\n        \"\"\"\n        self.log.info(\"Getting Multicast Group\")\n        if ip_version not in ('ipv4', 'ipv6'):\n            raise IxiaOperationException(\"Invalid ip version\")\n        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}\n\n        groupConfig = {}\n        try:\n            if ip_version.lower() == 'ipv4':\n                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)\n                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.StartMcastAddr\n                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrIncr\n                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrCnt\n            else:\n                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)\n                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.StartMcastAddr\n                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrIncr\n                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrCnt\n        except:\n            raise IxiaOperationException(\"%s not configured on %s' %(protocol.upper(), device)\")\n\n        return groupConfig\n\n    def add_stream_header(self, traffic_item, headerType, headerName):\n        \"\"\"\n        Add specific header to a trafficItem/stream\n\n        :param traffic_item: Stream name for which header should be configured\n        :param headerType: Type of header\n                           Example: \"DHCP\", \"MPLS\"\n        :param headerName: Header name which should be configured\n                           Example: \"DhcpClientMsg\", \"DhcpServerMsg\"\n                                    \"icmp0\"   - ICMP Msg Types: 0,8,13,14,15,16\n                                    \"icmp3\"   - ICMP Msg Types: 3,4,5,11,12\n                                    \"icmp9\"   - ICMP Msg Type: 9\n                                    \"icmpv6\"  - ICMPV6, \"igmv1\" - IGMPv1, \"igmpv2\" - IGMPv2\n                                    \"igmpv3q\" - IGMPv3 Membership Query\n                                    \"igmpv3r\" - IGMPv3 Membership Report\n        :return: True if header is configured else raise exception\n\n        :Example: add_stream_header('Traffic Item 2','ICMP', 'icmp3')\n                  add_stream_header('Traffic Item 1','MPLS','mpls')\n                  add_stream_header('Traffic Item 2','IGMP', 'igmpv2')\n        \"\"\"\n        self.log.info(\"Adding Stream Header\")\n        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)\n        # add all supported header types and corresponding layer info to headerToLayerMapping dict\n        # headerToLayerMapping = {'DHCP':'L5','IPV4':'L3','IPV6':'L3','TCP':'L4','UDP':'L4','ICMP':'L3'}\n        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)\n        configElement = trafficItem.ConfigElement.find()[0]\n        stackIndex = configElement.find().Stack.find().index\n        stackTop = configElement.Stack.find()[stackIndex - 1]\n        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')\n        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')\n        tcpStack = configElement.Stack.find(StackTypeId='^tcp$')\n        udpStack = configElement.Stack.find(StackTypeId='^udp$')\n        ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')\n        ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')\n        if not streamObj:\n            raise IxiaConfigException(\"stream not found\")\n        try:\n            if headerType.upper() == 'IPV4':\n                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\n                configElement.Stack.read(stackTop.AppendProtocol(ipv4Template))\n            elif headerType.upper() == 'IPV6':\n                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                configElement.Stack.read(stackTop.AppendProtocol(ipv6Template))\n            elif headerType.upper() == 'DHCP' and not configElement.Stack.find(StackTypeId='^dhcp$'):\n                dhcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^dhcp$\")\n                if tcpStack:\n                    configElement.Stack.read(tcpStack.AppendProtocol(dhcpTemplate))\n                elif udpStack:\n                    configElement.Stack.read(udpStack.AppendProtocol(dhcpTemplate))\n                else:\n                    configElement.Stack.read(ipv4Stack.AppendProtocol(dhcpTemplate))\n                if re.search('dhcpserver', headerName, re.IGNORECASE):\n                    configElement.Stack.find(DisplayName='DHCP').Field.find(\n                        DisplayName='Message op code').FieldValue = 'BOOTREPLY'\n                if re.search('dhcpclient', headerName, re.IGNORECASE):\n                    configElement.Stack.find(DisplayName='DHCP').Field.find(\n                        DisplayName='Message op code').FieldValue = 'BOOTREQUEST'\n            elif headerType.upper() == 'IGMP':\n                igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^igmp$\")\n                if headerName.upper() == 'IGMPV1':\n                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^igmpv1$\")\n                if headerName.upper() == 'IGMPV2':\n                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^igmpv2$\")\n                if headerName.upper() == 'IGMPV3R':\n                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^igmpv3MembershipReport$\")\n                if headerName.upper() == 'IGMPV3Q':\n                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^igmpv3MembershipQuery$\")\n                configElement.Stack.read(stackTop.AppendProtocol(igmpTemplate))\n            elif headerType.upper() == 'ICMP':\n                icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmp$\")\n                if headerName.upper() == 'ICMP3':\n                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmpv1$\")\n                if headerName.upper() == 'ICMP0':\n                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmpv2$\")\n                if headerName.upper() == 'ICMP9':\n                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmpv9$\")\n                if headerName.upper() == 'ICMPV6':\n                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmpv6$\")\n                configElement.Stack.read(stackTop.AppendProtocol(icmpTemplate))\n            elif headerType.upper() == 'MPLS':\n                mplsTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^mpls$\")\n                configElement.Stack.read(stackTop.AppendProtocol(mplsTemplate))\n            elif headerType.upper() == \"OSPFV2\" and not configElement.Stack.find(StackTypeId='^ospfv2$'):\n                if re.search('ospfv2 Hello Packet', headerName, re.IGNORECASE):\n                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ospfv2Hello$\")\n                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))\n            elif headerType.upper() == \"OSPFV3\" and not configElement.Stack.find(StackTypeId='^ospfv3$'):\n                if re.search('ospfv3 Hello', headerName, re.IGNORECASE):\n                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"ospfv3Hello\")\n                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))\n            elif headerType.upper() == \"CUSTOM\" and not configElement.Stack.find(StackTypeId='^custom$'):\n                if re.search('Custom', headerName, re.IGNORECASE):\n                    customTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^custom$\")\n                    configElement.Stack.read(stackTop.AppendProtocol(customTemplate))\n            elif headerType.upper() == 'VLAN':\n                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                configElement.Stack.read(stackTop.AppendProtocol(vlanTemplate))\n            elif headerType.upper() == 'IPV6FRAGMENT':\n                ipv6FragmentTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6Fragment$\")\n                configElement.Stack.read(stackTop.AppendProtocol(ipv6FragmentTemplate))\n            elif headerType.upper() == 'GRE':\n                greTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^gre$\")\n                configElement.Stack.read(stackTop.AppendProtocol(greTemplate))\n            elif headerType.upper() == 'L2TP':\n                l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^l2tpv3$\")\n                if headerName.upper() == 'L2TPV3IPC':\n                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^l2TPv3ControlIP$\")\n                if headerName.upper() == 'L2TPV3IPD':\n                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^l2TPv3DataIP$\")\n                if headerName.upper() == 'L2TPV3UDPC':\n                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^l2TPv3ControlUDP$\")\n                if headerName.upper() == 'L2TPV3UDPD':\n                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^l2TPv3DataUDP$\")\n                configElement.Stack.read(stackTop.AppendProtocol(l2tpv3Template))\n            elif headerType.upper() == 'IPV6ROUTE':\n                ipv6RoutingTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6Routing$\")\n                configElement.Stack.read(stackTop.AppendProtocol(ipv6RoutingTemplate))\n            elif headerType.upper() == 'IPV6AUTH':\n                ipv6AuthTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6Authentication$\")\n                configElement.Stack.read(stackTop.AppendProtocol(ipv6AuthTemplate))\n            else:\n                protocolTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId='^' + headerType.lower() + '$')\n                configElement.Stack.read(stackTop.AppendProtocol(protocolTemplate))\n        except:\n            raise IxiaConfigException(\"Adding header failed\")\n        return True\n\n    def add_multicast_group(self, ip_version, group_name='', start_ip='', count='', step='',\n                            prefix='', **kwargs):\n        \"\"\"\n        Create ipv4/ipv6 multi cast group\n\n        :param ip_version: IP version of multicast group\n        :param group_name: User defined group name\n        :param start_ip: Starting IP address of the group\n        :param count: Number of Groups\n        :param step: Increment step in case of more that one group\n        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)\n        :param group_name: User defined group name\n        :return: Unique Group name\n\n        :Example: add_multicast_group('ipv4',group_name='IGMP Host 1',start_ip='227.0.0.0', count='13',igmp_version='version2',deviceName='Device Group 13')\n        \"\"\"\n        self.log.info(\"Adding Multicast Group\")\n        deviceName = kwargs.get('deviceName')\n        igmp_version = kwargs.get('igmp_version','version3')\n        mld_version = kwargs.get('mld_version','version2')\n        if not deviceName:\n            raise IxiaOperationException(\"Device name is must for IXIA\")\n        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+deviceName+'$').Stop\n        if ip_version not in ('ipv4', 'ipv6'):\n            raise IxiaOperationException(\"Invalid Ip version\")\n        if not group_name:\n            group_name = ip_version + 'group'\n        if ip_version.lower() == 'ipv4':\n            try:\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name='^'+deviceName+'$').Ethernet.find().Ipv4.find().IgmpHost.add(Name=group_name)\n                if start_ip or count or step:\n                    self.config_multicast_group('ipv4', group_name=group_name, start_ip=start_ip, count=count,igmp_version=igmp_version)\n            except:\n                raise IxiaOperationException(\"Not able to configure igmp multicast group\")\n        if ip_version.lower() == 'ipv6':\n            try:\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name='^'+deviceName+'$').Ethernet.find().Ipv6.find().MldHost.add(Name=group_name)\n                if start_ip or count or step:\n                    self.config_multicast_group('ipv6', group_name=group_name, start_ip=start_ip, count=count,mld_version=mld_version)\n            except:\n                raise IxiaOperationException(\"Not able to configure mld multicast group\")\n        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceName + '$').Start\n        return group_name\n\n    def get_stream_header(self, traffic_items='all'):\n        \"\"\"\n        Get the dictionary of headers configured for a stream\n\n        :param traffic_items: List of stream names whose headers should be retrieved\n        :return: Dictionary of Stream headers\n\n        :Example: get_stream_header(['Traffic Item 4'])\n        \"\"\"\n        streamList = self.ixNetwork.Traffic.TrafficItem.find()\n        if traffic_items != 'all':\n            if type(traffic_items) not in (list, tuple):\n                traffic_items = [traffic_items]\n        result = {}\n        for streamName in traffic_items:\n            streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=streamName)\n            headers = streamObj.ConfigElement.find().Stack.find()\n            update_headers = []\n            for header in headers:\n                update_headers.append(header.DisplayName)\n            for headerName in update_headers:\n                fields = streamObj.ConfigElement.find().Stack.find(DisplayName=headerName).Field.find()\n                fieldNames = re.findall('DisplayName: (.*)', str(fields))\n                fieldValues = re.findall('FieldValue: (.*)', str(fields))\n                result[headerName] = list(zip(fieldNames, fieldValues))\n        return result\n\n    def config_igmp_group_member(self, router_id , mcast_group_config, mcast_source_config, **kwargs):\n        \"\"\"\n        Allows user to change source count/list for device configured with IGMP_V3 and\n        group count/list for device configured with IGMP_V2 or IGMP_V3\n\n        :param router_id: NA for IXIA\n        :param mcast_group_config: Dictionary with Group count/list info\n        :param mcast_source_config: Dictionary with Source count/list info\n        :param kwargs: optional\n        :return: True on Success\n\n        :Example: config_igmp_group_member(\"192.0.0.1\",{'count':'2'},{'count':'2'},device_name ='Device Group 27')\n        \"\"\"\n        deviceName = kwargs.get(\"device_name\",None)\n        if deviceName is None:\n            raise IxiaOperationException(\"Device Group Name Mandatory for IXIA\")\n        self.log.info(\"Configuring multicast group {0}\".format(deviceName))\n        try:\n            self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'igmp')\n        except:\n            raise IxiaOperationException(\"igmp host not configured for the device group provided\")\n\n        return True\n\n    def config_mld_group_member(self, router_id, mcast_group_config, mcast_source_config, **kwargs):\n        \"\"\"\n        Allows user to change source count/list for device configured with IGMP_V3 and\n        group count/list for device configured with IGMP_V2 or IGMP_V3\n\n        :param router_id: NA for IXIA\n        :param mcast_group_config: Dictionary with Group count/list info\n        :param mcast_source_config: Dictionary with Source count/list info\n        :param kwargs: device_name - Mandatory for IXIA\n        :return: True on Success\n\n        :Example: config_mld_group_member(\"192.0.0.1\",{'count':'3'},{'count':'3'},device_name= 'Device Group 7')\n        \"\"\"\n        deviceName = kwargs.get(\"device_name\",None)\n        if deviceName is None:\n            raise IxiaOperationException(\"Device Group Name Mandatory for IXIA\")\n        self.log.info(\"Configuring multicast group {0}\".format(deviceName))\n        try:\n            self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()\n        except:\n            raise IxiaOperationException(\"igmp host not configured for the device group provided\")\n        self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'mld')\n\n        return True\n\n    def _config_group_member(self, device_name, mcast_group_config, mcast_source_config, protocol):\n        \"\"\"\n        config Source & Group multi-cast config for IGMP or MLD on a device.\n\n        :param device_name: device name of the host configured with multicast group\n        :param mcast_group_config: Dictionary with Group count/list info\n        :param mcast_source_config: Dictionary with Source count/list info\n        :param protocol: IGMP or MLD\n        :return: Group and Source config for IGMP/MLD\n        \"\"\"\n        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)\n        if not device_name:\n            self.log.info('No matching device found with device name: %s' % device_name)\n        if protocol not in ('igmp', 'mld'):\n            raise IxiaOperationException(\"Invalid protocol\")\n        for key, groupCount in mcast_group_config.items():\n            self._config_group(device_name, groupCount, protocol)\n        for key, sourceCount in mcast_source_config.items():\n            self._config_source(device_name, sourceCount, protocol)\n\n    def _config_group(self, device_name, group_count, protocol):\n        \"\"\"\n        Function used internally by other API's\n\n        :param device_name: Device Group Name\n        :param group_count: Device Group count\n        :param protocol: Protocol . Ex : IGMP/MLD\n        \"\"\"\n        if protocol == 'igmp':\n            version = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType\n            if version == 'version2' or version == 'version3':\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Single(group_count)\n            else:\n                raise IxiaOperationException(\"Invalid version\")\n\n        elif protocol == 'mld':\n            version = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType\n            if version == 'version1' or version == 'version2':\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Single(\n                    group_count)\n            else:\n                raise IxiaOperationException(\"Invalid mld version\")\n        else:\n            raise IxiaOperationException(\"Not able to configure group member\")\n        return True\n    def _config_source(self, device_name, source_count, protocol):\n        \"\"\"\n        Function used internally by other API's\n\n        :param device_name: Device Group Name\n        :param source_count: Source count\n        :param protocol: Protocol , Ex: 'igmp','mld'\n        \"\"\"\n        if protocol == 'igmp':\n            version = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType\n            if version == 'version3':\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt.Single(source_count)\n        elif protocol == 'mld':\n            version = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType\n            if version == 'version1':\n                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt.Single(source_count)\n        else:\n            raise IxiaOperationException(\"Not able to configure group member\")\n\n        return True\n\n    def get_stream_frame(self, stream_name, header, fields=()):\n        \"\"\"\n        Get header field value of specific stream frame\n\n        :param stream_name: stream on which header is configured\n        :param header: name of the header configured\n        :param fields: field or list of fields in the header for which value should be returned\n        :return: Dictionary of requested fields and values in the given header.\n\n        :Example: get_stream_frame('Traffic Item 1', 'IP', fields=['Version','Source Address','Destination Address','Flags'])\n        \"\"\"\n        self.log.info(\"Getting Stream Frame\")\n        field_value_dict ={}\n        ipv4_map_dict = {'checksum': 'checksum', 'destAddr': 'dest_ip', 'fragOffset': 'fragment_offset',\n                        'totalLength': 'total_len', 'protocol': 'protocol', 'sourceAddr': 'source_ip',\n                        'identification': 'identification', 'ttl': 'ttl', 'version': 'version'}\n        ipv6_map_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit', 'flowLabel': 'flowLabel',\n                        'sourceAddr': 'source_ip', 'trafficClass': 'trafficClass', 'version': 'version',\n                        'destAddr': 'dest_ip', 'nextHeader': 'nextHeader'}\n        udp_map_dict = {'sourcePort': 'udp_src_prt', 'destPort': 'udp_dst_prt'}\n        tcp_map_dict = {'urgBit': 'u_bit', 'protocolType': 'protocol', 'synBit': 's_bit', 'rstBit': 'r_bit',\n                        'cwrBit': 'c_bit', 'pshBit': 'p_bit', 'ackBit': 'a_bit', 'finBit': 'f_bit', 'ecnBit': 'e_bit',\n                        'ackNum': 'ack_num', 'reserved': 'reserved', 'seq_num': 'seqNum', 'offset': 'data_offset',\n                        'sourcePort': 'tcp_src_prt', 'destPort': 'tcp_dst_prt', 'window': 'tcp_window',\n                        'checksum': 'tcp_checksum', 'urgentPtr': 'urgent_ptr'}\n        ethernet_map_dict = {'dstMac': 'destinationAddress', 'etherType': 'ether_type', 'srcMac': 'sourceAddress'}\n        regex_dict = {'ipv4': ipv4_map_dict,'ipv6':ipv6_map_dict,'udp':udp_map_dict,'tcp':tcp_map_dict,'ethernet':ethernet_map_dict}\n\n        key_map = {'valueType': 'ValueType', 'value': 'FieldValue', 'step': 'StepValue', 'count': 'CountValue'}\n        result = {}\n        stream_name = re.escape(stream_name)\n        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{stream_name}$')\n        if not streamObj:\n            raise IxiaConfigException(\"stream not found\")\n\n        if header in regex_dict.keys():\n            field_value_dict = regex_dict[header]\n        else:\n            raise IxiaConfigException(f'Invalid header name {header}')\n\n        header_handle = streamObj.ConfigElement.find().Stack.find(StackTypeId=f'{header.lower()}')\n        if not header_handle:\n            raise IxiaConfigException(\"header not found\")\n\n        for header_field in fields:\n            if header_field in field_value_dict:\n                for key in key_map:\n                    result.update({key:eval('headerHandle.Field.find(Name=field_value_dict[headerField]).'+key_map[key])})\n            else:\n                self.log.info(f'Invalid header field for header {header}')\n        return result\n\n    def rsvp_te_stop(self, port=None, host_ip=None):\n        \"\"\"\n        RSVP TE Stop\n\n        :param port: List of ports. If 'None', all the ports\n        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts\n        :return: True. raise exception if False/error\n\n        :Example: rsvp_te_stop()\n        \"\"\"\n        self.log = CafyLog('Stopping rsvpte protocol')\n        action = 'Stop'\n        protocol = ['rsvp','rsvptelf']\n        return self._start_stop_protocols(protocol, port, host_ip, action)\n\n    def rsvp_te_start(self, port=None, host_ip=None):\n        \"\"\"\n        RSVP TE Start\n\n        :param port: List of ports. If 'None', all the ports\n        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts\n        :return: True. raise exception if False/error\n\n        :Example: rsvp_te_start()\n        \"\"\"\n        self.log = CafyLog('Stopping rsvpte protocol')\n        action = 'Start'\n        protocol = ['rsvp','rsvptelf']\n        return self._start_stop_protocols(protocol, port, host_ip, action)\n\n    def delete_stream_header(self, traffic_item, headerType, headerName, **kwargs):\n        \"\"\"\n        Delete specific header from a stream\n\n        :param traffic_item: Stream name for which header should be deleted\n        :param headerType: Type of header\\n\n                           Example: \"DHCP\"\n        :param headerName: Header name which should be configured\\n\n                           Example: \"DhcpClientMsg\", \"DhcpServerMsg\"\n                           \"icmp0\"   - ICMP Msg Types: 0,8,13,14,15,16\n                           \"icmp3\"   - ICMP Msg Types: 3,4,5,11,12\n                           \"icmp9\"   - ICMP Msg Type: 9\n                           \"icmpv6\"  - ICMPV6\n        :return: True if header is deleted else raise exception\n\n        :Example: tgnObj.delete_stream_header('Traffic Item 12','L2TP',headerName='L2TPV3IPD')\n                  tgnObj.delete_stream_header('Traffic Item 1','IPv6')\n                  tgnObj.delete_stream_header('Traffic Item 1','gre',header_index=1)\n                  tgnObj.delete_stream_header('Traffic Item 1','icmp','icmp3')\n        \"\"\"\n        self.log.info('Deleting Stream Header')\n        headerIndex = kwargs.get('headerIndex', 1)\n        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$')\n        if not trafficItem:\n            raise IxiaConfigException(\"{} is not found\".format(traffic_item))\n        try:\n            configElement = trafficItem.ConfigElement.find()[0]\n            headerObj = None\n            if headerType.upper() == 'IPV6':\n                headerObj = configElement.Stack.find(StackTypeId='^ipv6$')[headerIndex - 1]\n            elif headerType.upper() == 'IPV6ROUTE':\n                headerObj = configElement.Stack.find(StackTypeId='^ipv6Routing$')[headerIndex - 1]\n            elif headerType.upper() == 'IPV6AUTH':\n                headerObj = configElement.Stack.find(StackTypeId='^ipv6Authentication$')[headerIndex - 1]\n            elif headerType.upper() == 'GRE':\n                headerObj = configElement.Stack.find(StackTypeId='^gre$')[headerIndex - 1]\n            elif headerType.upper() == 'L2TP':\n                if headerName.upper() == 'L2TPV3IPC':\n                    headerObj = configElement.Stack.find(StackTypeId=\"^l2TPv3ControlIP$\")[headerIndex - 1]\n                elif headerName.upper() == 'L2TPV3IPD':\n                    headerObj = configElement.Stack.find(StackTypeId=\"^l2TPv3DataIP$\")[headerIndex - 1]\n                elif headerName.upper() == 'L2TPV3UDPC':\n                    headerObj = configElement.Stack.find(StackTypeId=\"^l2TPv3ControlUDP$\")[headerIndex - 1]\n                elif headerName.upper() == 'L2TPV3UDPD':\n                    headerObj = configElement.Stack.find(StackTypeId=\"^l2TPv3DataUDP$\")[headerIndex - 1]\n                else:\n                    self.log.error('Incorrect L2TP header name')\n            elif headerType.upper() == 'IPV6FRAGMENT':\n                headerObj = configElement.Stack.find(StackTypeId='^ipv6Fragment$')[headerIndex - 1]\n            elif headerType.upper() == 'ICMP':\n                if headerName.upper() == 'ICMP3':\n                    headerObj = configElement.Stack.find(StackTypeId='^icmpv1$')[headerIndex - 1]\n                if headerName.upper() == 'ICMP0':\n                    headerObj = configElement.Stack.find(StackTypeId='^icmpv2$')[headerIndex - 1]\n                if headerName.upper() == 'ICMP9':\n                    headerObj = configElement.Stack.find(StackTypeId='^icmpv9$')[headerIndex - 1]\n                if headerName.upper() == 'ICMPV6':\n                    headerObj = configElement.Stack.find(StackTypeId='^icmpv6$')[headerIndex - 1]\n            else:\n                headerObj = configElement.Stack.find(StackTypeId='^' + headerType.lower() + '$')[headerIndex - 1]\n            if headerObj:\n                headerObj.Remove()\n                self.log.info('Stream header {} deleted successfully'.format(headerType))\n            else:\n                self.log.error('Stream header deletion failed')\n        except:\n            self.log.error('{} Header is not found in traffic stream {}'.format(headerType, traffic_item))\n        return True\n\n    def get_stream_dhcp_client_mac(self, stream_name):\n        \"\"\"\n        get the mac_addr of dhcpclientmsg\n\n        :param stream_name: stream on which dhcpclientmsg is configured\n        :return: mac_addr of dhcpclientmsg\n\n        :Example: get_stream_dhcp_client_mac('Traffic Item 4')\n        \"\"\"\n        self.log.info(\"Getting Stream DHCP Client MAC\")\n        clientMac = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(\n            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue\n        clientMac = ':'.join(format(s, '02x') for s in bytes.fromhex(clientMac))\n        return clientMac\n\n    def get_sessions(self):\n        \"\"\"\n        Get sessions on the server\n\n        :return: list of sessions on the server\n\n        :Example: get_sessions()\n        \"\"\"\n        sessions = []\n        if self.tgn_server_type == \"linux\":\n            for eachSession in self.test_platform.Sessions.find():\n                sessions.append(eachSession.Name)\n            self.log.info(\"Existing Sessions on Ixia Lab server '%s' : %s\" %(self.server_ip,sessions))\n\n        if self.tgn_server_type == 'windows':\n            self.log.warning(\"Get Sessions is Not Supported on Ixia Windows Lab Server\")\n\n        return sessions\n\n    def delete_session_by_name(self, session_name, end_tcsession=True):\n        \"\"\"\n        Deletes the TGN session\n\n        :param session_name: Session name to be deleted\n        :param end_tcsession: NA for IXIA\n        :return: True on success, exception on failure\n\n        :Example: delete_session_by_name(\"session1\")\n        \"\"\"\n        if self.tgn_server_type == \"linux\":\n            if self.test_platform.Sessions.find(Name=session_name):\n                if self.test_platform.Sessions.find(Name=session_name).State == 'ACTIVE':\n                    self.test_platform.Sessions.find(Name=session_name).remove()\n                    self.log.info(\"Deleted Session - '%s'\" % session_name)\n                    return True\n            else:\n                self.log.error(\"Session - '%s' Not Found\" % session_name)\n                return False\n\n        if self.tgn_server_type == 'windows':\n            self.log.warning(\"Sessions Delete is Not Supported in Ixia Windows Lab Server\")\n            return False\n\n    def get_igmp_group_member(self, router_id, **kwargs):\n        \"\"\"\n        API to get Source & Group multi-cast config for IGMP on a device.\n\n        :param router_id: IGMP Router ID:\n        :param device_name: device group name\n        :return: Group and Source config for IGMP\n\n        :Example: get_igmp_group_member('1.1.1.1',device_name='Device Group 13')\n        \"\"\"\n        deviceName = kwargs.get('device_name')\n\n        return self._get_group_member(deviceName, router_id, 'igmp', )\n\n    def get_mld_group_member(self, router_id, **kwargs):\n        \"\"\"\n        API to get Source & Group multi-cast config for MLD on a device.\n\n        :param router_id: IGMP Router ID\n        :param device_name: device group name\n        :return: Group and Source config for MLD\n\n        :Example: get_mld_group_member('1.1.1.1',device_name='Device Group 16')\n        \"\"\"\n        deviceName = kwargs.get('device_name')\n        return self._get_group_member(deviceName, router_id, 'mld')\n\n    def _get_group_member(self, deviceName, router_id, protocol):\n        \"\"\"\n        Get Source & Group multi-cast config for IGMP or MLD on a device.\n\n        :param deviceName: device group name\n        :param router_id: Router ID of a device\n        :param protocol: IGMP or MLD\n        :return: Group and Source config for IGMP/MLD\n        \"\"\"\n        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName)\n        if not deviceName:\n            self.log.info('No matching device found with device name: %s' % deviceName)\n            raise IxiaOperationException(\"Invalid Ip version\")\n        if protocol not in ('igmp', 'mld'):\n            raise IxiaOperationException(\"Invalid protocol\")\n        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}\n\n        key_map = {'StartIpList': 'start_ip', 'AddrIncrement': 'step', 'NetworkCount': 'count'}\n        try:\n            if protocol.lower() == 'igmp':\n                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find()\n            else:\n                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()\n        except:\n            self.log.info('%s not configured on %s' % (protocol.upper(), device))\n            raise IxiaOperationException(\"%s not configured on %s' %(protocol.upper(), device)\")\n        groupConfig = self._get_group_config(deviceName, protocol)\n        groupConfig = updateKey(groupConfig, key_map)\n        mcastConfig = {'group': groupConfig}\n        sourceConfig = self._get_source_config(deviceName, protocol)\n        sourceConfig = updateKey(sourceConfig, key_map)\n        mcastConfig['source'] = sourceConfig\n        return mcastConfig\n\n    def _get_group_config(self, deviceName, protocol):\n        \"\"\"\n        Function used internally by other API's\n\n        :param deviceName: device group name\n        :param protocol: Protocol , Ex: 'igmp'\n        \"\"\"\n        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}\n        if protocol == 'igmp':\n            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr\n            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrIncr\n            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt\n        else:\n            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr\n            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrIncr\n            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt\n        return keyMap\n\n    def _get_source_config(self, deviceName, protocol):\n        \"\"\"\n        Function used internally by other API's\n\n        :param deviceName: device group name\n        :param protocol: Protocol , Ex: 'igmp'\n        \"\"\"\n        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}\n        if protocol == 'igmp':\n            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr\n            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastAddrIncr\n            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt\n        else:\n            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr\n            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastAddrIncr\n            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt\n        return keyMap\n\n    def reserve_ports(self, ports=None):\n        \"\"\"\n        Reserve all or user specified ports\n\n        :param ports: ports to be reserved (Default: all ports)\n        :return: True on success\n\n        :Example: reserve_ports()\n        \"\"\"\n        update_portname = True\n        if ports:\n            for port in ports:\n                port_modified = port.split('/')\n                #To be checked\n                if len(port_modified) < 3:\n                    port_modified.insert(1,'1')\n                ports[ports.index(port)] = port_modified\n            try:\n                self._assign_ports(ports, update_portname)\n            except Exception as err:\n                self.log.error('Failed to reserve ports')\n                raise IxiaOperationException(err)\n        return True\n\n    def start_arp_on_ports(self, ports=None):\n        '''\n        Send arp based on port list\n\n        :param ports: list of port name or port handle or interface name from Json file.\n                      Default is None for all ports\n        :return: True\n\n        :Example: start_arp_on_ports()\n        '''\n\n        return self.start_arp()\n\n    def start_arp_on_devices(self, ports=None):\n        '''\n        Send arp based on port list\n\n        :param ports: list of port name or port handle or interface name from Json file.\n                      Default is None for all ports\n        :return: True\n\n        :Example: start_arp_on_devices()\n        '''\n\n        return self.start_arp()\n\n    def start_arp_on_objects(self,  objects=None, type='all'):\n        '''\n        Send arp based on port list\n\n        :param objects: NA for IXIA\n        :param type: NA for IXIA\n        :return: True\n\n        :Example: start_arp_on_objects()\n        '''\n\n        return self.start_arp()\n\n    def set_stream_dhcp_client_mac(self, stream_name, mac_addr):\n        \"\"\"\n        change the mac_ddr of dhcpclientmsg of specific stream\n\n        :param stream_name: stream on which dhcpclientmsg is configured\n        :param mac_addr: mac_addr that needs to replace mac_addr in dhcpclientmsg\n        :return: True if successful else Raise Exception\n\n        :Example: set_stream_dhcp_client_mac('Traffic Item 4','0xaa0a0a0a0a0a')\n        \"\"\"\n\n        self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(\n            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue = mac_addr\n\n        return True\n\n    def set_device_vlan_count(self,device_name,vlan_count):\n        \"\"\"\n        Set device VLAN parameters\n        :param device_name: device Group name\n        :param vlan_count: vlan number,  Default is 1\n\n        :return: True if successful\n        :Example: set_device_vlan_count(device_name='Device Group 1', vlan_count=2)\n        \"\"\"\n        self.log.info(f'Setting vlan count {vlan_count} for device name {device_name}')\n        if vlan_count > 6:\n            self.log.warning('Maximum supported vlan count is 6')\n        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$'):\n            try:\n                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find().VlanCount = vlan_count\n            except:\n                self.log.error(\"Error in setting vlan count\")\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def set_device_vlan(self, router_id, vlan_number=1, vlan_id=None, vlan_priority=None, vlan_type=None, **kwargs):\n        \"\"\"\n        Set device VLAN parameters\n\n        :param router_id: NA for IXIA\n        :param vlan_number: vlan number,  Default is 1\n        :param vlan_id: VLAN ID to be set\n        :param vlan_priority: Priority to be set, Type is Integer. Range [0-7]. Default is 7\n        :param vlan_type: Type to be set,  '8100', '88a8', '9100', '9200', '9300'\n        :param kwargs: device_name, Mandatory for IXIA\n\n        :return: True if successful\n\n        :Example: set_device_vlan(router_id=None, device_name='Device Group 13' , vlan_number=8 , vlan_priority=0, vlan_id = 3, vlan_type = '0x9200')\n        \"\"\"\n        device_name = kwargs.get('device_name',None)\n        if device_name is None:\n            raise IxiaOperationException(\"Device Group Name Mandatory for IXIA\")\n        self.log.info(\"Changing VLAN Parameters for Vlan {0} in {1}\".format(vlan_number, device_name))\n        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',\n                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}\n        try:\n            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values\n\n        except:\n            raise IxiaOperationException(\"Device Group not Found\")\n        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(\n            Name=device_name).Ethernet.find().Vlan.find().Priority.Values\n        tpidList = self.ixNetwork.Topology.find().DeviceGroup.find(\n            Name=device_name).Ethernet.find().Vlan.find().Tpid.Values\n        vlanIdList = self.ixNetwork.Topology.find().DeviceGroup.find(\n            Name=device_name).Ethernet.find().Vlan.find().VlanId.Values\n        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]\n        if indexList:\n            for index in indexList:\n                priorityList.pop(index)\n                priorityList.insert(index, str(vlan_priority))\n                vlanIdList.pop(index)\n                vlanIdList.insert(index, str(vlan_id))\n\n            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():\n                vlan.Priority.ValueList(values=priorityList)\n                vlan.Tpid.Single(vlanTpid[vlan_type])\n                vlan.VlanId.ValueList(values=vlanIdList)\n            self.log.info(\"VLAN Parameters Changed for Vlan {0} in {1}\".format(vlan_number, device_name))\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        else:\n            raise IxiaConfigException(\"VLAN Number not Found\")\n        return True\n\n    def set_vlan(self,device_name,vlan_id,**kwargs):\n        \"\"\"\n        Set device VLAN id and enable/disable vlan\n        :param device_name: device name to set vlan id\n        :param vlan_id: VLAN ID to be set\n        :param kwargs:\n                vlan_number: vlan ID need to be modified\n                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111\n                vlan_count : vlan number which need to be changes, defalut is 1\n                            Ex : vlan_count = 1, vlan ID 1 will be changed\n                                 vlan_count = 2, vlan ID 2 will be changed\n                vlan_step : Step to increment vlan_id, default 1\n                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'\n                enable_vlan : enable/disable vlan based on device_name\n                              Ex : enable_vlan = True, vlan is enabled on device_name\n                                   enable_vlan = False, vlan is disabled on device_name\n\n        :return: None\n        :Example: set_vlan(device_name='IPv4 Device Group 1' , vlan_id = 101)\n                  set_vlan(device_name='IPv4 Device Group 1'  ,vlan_id = 300,enable_vlan =True )\n        \"\"\"\n        try:\n            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()\n        except:\n            raise IxiaOperationException(\"Device Group not Found\")\n        enable_vlan = kwargs.get('enable_vlan', None)\n        vlan_index = kwargs.get('vlan_index', None)\n        try:\n            enable_vlan_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().EnableVlans\n            enable_vlan_obj.ClearOverlays()\n            if vlan_index:\n                for index in vlan_index:\n                    enable_vlan_obj.Overlay(index, enable_vlan)\n            else:\n                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)\n        except:\n            pass\n        vlan_count = kwargs.get('vlan_count', 1)\n        vlan_number = kwargs.get('vlan_number', None)\n        if vlan_count:\n            vlanObj = deviceObj.Vlan.find()[vlan_count-1]\n        else:\n            vlanObj = deviceObj.Vlan.find()[0]\n        vlanIdList = vlanObj.VlanId.Values\n        vlanList = vlanObj.VlanId.Values\n        if vlan_number:\n            indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]\n            if indexList:\n                for index in indexList:\n                    try:\n                        vlanObj.VlanId.Overlay(index+1, str(vlan_id))\n                    except:\n                        pass\n        else:\n            vlan_direction = kwargs.get('vlan_direction', 'increment')\n            vlanObj.VlanId.ClearOverlays()\n            if vlan_direction.lower() == 'decrement':\n                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))\n            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n    def set_device_vlan_parameters(self, device_name,**kwargs):\n        \"\"\"\n        Set device VLAN parameters\n        :param device_name: device name to set vlan and vlan parameters\n        :param kwargs:\n            vlan1: (list) if vlan id 1 parameters has to be set\n            priority1: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0\n            tpid1: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'\n            vlan2: (list) if vlan id 1 parameters has to be set\n            priority2: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0\n            tpid2: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'\n        :return: True if successful\n\n        :Example: set_device_vlan_parameters(device_name='IPv4 Device Group 1',vlan1=['703-705'],priority1=['4','5','6'],tpid1=['0x88a8','0x88a8','0x88a8'])\n        \"\"\"\n        self.log.info(\"Changing VLAN Parameters for device \".format(device_name))\n        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',\n                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}\n        try:\n            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find()\n        except:\n            raise IxiaOperationException(\"Device Group not Found\")\n        vlan1 = kwargs.get('vlan1', None)\n        vlan2 = kwargs.get('vlan2', None)\n        if vlan1:\n            priority1 = kwargs.get('priority1', None)\n            tpid1 = kwargs.get('tpid1', None)\n            vlan1Obj = deviceObj.Vlan.find()[0]\n            for id in vlan1:\n                if '-' in id:\n                    vlanList = id.split('-')\n                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]\n                else:\n                    vlanIdList = vlan1\n            vlanList1 = vlan1Obj.VlanId.Values\n            tpidList1 = vlan1Obj.Tpid.Values\n            priorityList1 = vlan1Obj.Priority.Values\n            indexList = [index for index in range(len(vlanList1)) if vlanList1[index] in vlanIdList]\n            for index in indexList:\n                if type(priority1) == list:\n                    for value in range(len(priorityList1)):\n                        try:\n                            priorityList1.pop(indexList[value])\n                            priorityList1.insert(indexList[value], priority1[value])\n                        except:\n                            pass\n                if  type(tpid1) == list:\n                    for value in range(len(tpidList1)):\n                        try:\n                            vlan1Obj.Tpid.Overlay(indexList[value]+1, vlanTpid[tpid1[value]])\n                        except:\n                            pass\n                if type(priority1)== str:\n                    priorityList1.pop(index)\n                    priorityList1.insert(index, str(priority1))\n                if type(tpid1) == str:\n                    try:\n                        vlan1Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid1]))\n                    except:\n                        pass\n            vlan1Obj.Priority.ValueList(values=priorityList1)\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        if vlan2:\n            priority2 = kwargs.get('priority2', None)\n            tpid2 = kwargs.get('tpid2', None)\n            vlan2Obj = deviceObj.Vlan.find()[1]\n            for id in vlan2:\n                if '-' in id:\n                    vlanList = id.split('-')\n                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]\n                else:\n                    vlanIdList = vlan2\n            vlanList2 = vlan2Obj.VlanId.Values\n            tpidList2 = vlan2Obj.Tpid.Values\n            priorityList2 = vlan2Obj.Priority.Values\n            indexList = [index for index in range(len(vlanList2)) if vlanList2[index] in vlanIdList]\n            for index in indexList:\n                if type(priority2) == list:\n                    for value in range(len(priorityList2)):\n                        try:\n                            priorityList2.pop(indexList[value])\n                            priorityList2.insert(indexList[value], priority2[value])\n                        except:\n                            pass\n                if  type(tpid2) == list:\n                    for value in range(len(tpidList2)):\n                        try:\n                            vlan2Obj.Tpid.Overlay(indexList[value] + 1, vlanTpid[tpid2[value]])\n                        except:\n                            pass\n                if type(priority2)== str:\n                    priorityList2.pop(index)\n                    priorityList2.insert(index, str(priority2))\n                if type(tpid2) == str:\n                    try:\n                        vlan2Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid2]))\n                    except:\n                        pass\n            vlan2Obj.Priority.ValueList(values=priorityList2)\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n    def _setup_stc_connection(self, server_ip, timeout=300, api_version=1):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n\n        :param server_ip: Server IP of IXIA\n        :param timeout: Timout for the IXIA connection\n        :param api_version: IXIA API version\n        \"\"\"\n        pass\n\n    def _initiate_stream_results(self,**kwargs):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        pass\n\n    def _apply(self,**kwargs):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        pass\n\n    def _enable_data_mining(self, datamining_list):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n\n        :param datamining_list: N/A\n        \"\"\"\n        pass\n\n    def _bll_version(self,**kwargs):\n        \"\"\"\n        Function NA for IXIA, returns version to bypass the check\n        \"\"\"\n        return \"1.79\"\n\n    def set_auto_negotiate(self, port_list=None, auto_negotiate=True):\n        \"\"\"\n        Function to set auto-negotiation of port speeds.\n\n        :param port_list: List of port names\n        :param auto_negotiate: True or False\n\n        :Example: set_auto_negotiate(port_list=['port1'], auto_negotiate=False)\n        \"\"\"\n        if port_list == None:\n            self.log.info(\"Setting Auto Negotiation of all available ports in the config\")\n            for vport in self.ixNetwork.Vport.find():\n                port_type = vport.Type\n                capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)\n                try:\n                    port_obj = getattr(vport.L1Config, capitalized_card_type)\n                    port_obj.update(AutoNegotiate=auto_negotiate)\n                    self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {vport.Name}\")\n                except TypeError:\n                    port_obj = getattr(vport.L1Config, capitalized_card_type)\n                    port_obj.update(EnableAutoNegotiation=auto_negotiate)\n                    self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {vport.Name}\")\n                except:\n                    self.log.info(f\"card type {capitalized_card_type} might not supported auto negotiation for port: {vport.Name}\")\n                    return False\n        else:\n            self.log.info(f\"Setting Auto Negotiation of ports - {port_list} in the config\")\n            for port in port_list:\n                if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', port)):\n                    port = port.replace(\"/\", \":\")\n                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + port + '$')\n                else:\n                    vport = self.ixNetwork.Vport.find(Name='^' + port + '$')\n                if vport:\n                    if port in [vport.Name, vport.AssignedTo]:\n                        port_type = vport.Type\n                        capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)\n                        try:\n                            port_obj = getattr(vport.L1Config, capitalized_card_type)\n                            port_obj.update(AutoNegotiate=auto_negotiate)\n                            self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {port}\")\n                        except TypeError:\n                            port_obj = getattr(vport.L1Config, capitalized_card_type)\n                            port_obj.update(EnableAutoNegotiation=auto_negotiate)\n                            self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {port}\")\n                        except:\n                            self.log.info(f\"card type {capitalized_card_type} might not supported auto negotiation for port: {port}\")\n                            return False\n                else:\n                    self.log.info(f\"port {port} not available in the config\")\n                    return False\n        return True\n\n    def _end_session(self,**kwargs):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        return self.tgn_disconnect()\n\n    def _delete(self,**kwargs):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        pass\n\n    def _connect(self, chassis_list):\n        \"\"\"\n        Establish connection to one or more chassis.\n\n        :param chassis_list: List of chassis (IP addresses or DNS names)\n        \"\"\"\n        self.connect_to_chassis(chassis_list)\n\n    def _stop_devices(self):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        pass\n\n    def _get_dict_emulated_devices(self):\n        \"\"\"\n        Function NA for IXIA, added just to avoid AP error\n        \"\"\"\n        pass\n\n    def get_ospf_router_status(self, router_ids):\n        \"\"\"\n        The API returns the ospf status for the given router ids\n\n        :param router_ids: List of router_ids\n        :return: Dictionary of router ids with their correspoding ospf status\n\n        :Example: get_ospf_router_status(['192.0.0.1','193.0.0.1'])\n        \"\"\"\n        routerIdStatusMapping = {}\n        for routerId in router_ids:\n            try:\n                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Ospfv2.find():\n                    if routerId in ospf.LocalRouterID:\n                        routerIdIndex = ospf.LocalRouterID.index(routerId)\n                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]\n            except:pass\n\n        return routerIdStatusMapping\n\n    def get_bgp_router_status(self, router_ids):\n        \"\"\"\n        The API returns the bgp status for the given router ids\n\n        :param router_ids: List of router_ids\n        :return: Dictionary of router ids with their correspoding bgp status\n\n        :Example: get_bgp_router_status(['200.0.0.1','200.0.0.2','200.0.0.3','200.0.0.4'])\n        \"\"\"\n        routerIdStatusMapping = {}\n        for routerId in router_ids:\n            try:\n                for bgp in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                    if routerId in bgp.LocalRouterID:\n                        routerIdIndex = bgp.LocalRouterID.index(routerId)\n                    routerIdStatusMapping[routerId] = bgp.SessionStatus[routerIdIndex]\n            except:pass\n\n        return routerIdStatusMapping\n\n    def get_ospfv3_router_status(self, router_ids):\n        \"\"\"\n        The API returns the ospfv3 status for the given router ids\n\n        :param router_ids: List of router_ids\n        :return: Dictionary of router ids with their correspoding ospfv3 status\n\n        :Example: get_ospfv3_router_status(['194.0.0.1','195.0.0.1'])\n        \"\"\"\n\n        routerIdStatusMapping = {}\n        for routerId in router_ids:\n            try:\n                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ospfv3.find():\n                    if routerId in ospf.LocalRouterID:\n                        routerIdIndex = ospf.LocalRouterID.index(routerId)\n                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]\n            except:pass\n\n        return routerIdStatusMapping\n\n    def set_device_count(self, device_count, router_id=None, device_name=None, **kwargs):\n        \"\"\"\n        Set device count\n        :param device_count: new device count. Should be >=1\n        :param router_id: router ID of Emulated device\n        :param device_name: Device Group Name\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                nested_device: For IXIA Device name if device count of nested DG to be set\n                                And for nested device device_name param in mandatory\n        :return: True if successful\n                raise exception if router id not found in Ixia\n\n        :Example: set_device_count(device_count = 5, router_id = '200.0.0.1')\n                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1')\n                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')\n       \"\"\"\n        nested_device = kwargs.get('nested_device')\n        if device_count >= 1:\n            if router_id and device_name == None:\n                routerIdList = [routerObj.RouterId for routerObj in\n                                self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]\n                for routerId in routerIdList:\n                    if re.search(router_id, str(routerId)):\n                        deviceList = [deviceGroupName.Name for deviceGroupName in\n                                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]\n                        for device in deviceList:\n                            try:\n                                deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                    Name=device).RouterData.find().RouterId\n                            except:\n                                pass\n                            if re.search(router_id, str(deviceRouterId)):\n                                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Multiplier = device_count\n            if device_name and nested_device is None:\n                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):\n                    self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + device_name + '$').Multiplier = device_count\n                else:\n                    raise IxiaConfigException(\"Device Group (%s) Not found in the config' % device_name\")\n            if device_name and nested_device:\n                try:\n                    self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(\n                        Name='^' + nested_device + '$').Multiplier = device_count\n                except:\n                    pass\n                try:\n                    self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').DeviceGroup.find(\n                        Name='^' + nested_device + '$').Multiplier = device_count\n                except:\n                    pass\n        else:\n            raise CafyException.InvalidValueError(\n                'Device count (%s) has to be greater than or equal to 1' % device_count)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def get_link_status(self, print_info=False):\n        \"\"\"\n        Get Link status information(Port, portStatus) for each port\n\n        :param print_info: log link status info if this True\n        :return: List of LinkStatusInfo objects\n\n        :Example: get_link_status()\n        \"\"\"\n        linkStatus = []\n        for vport in self.ixNetwork.Vport.find():\n            vport_name = vport.Name\n            if re.search(r'\\d+\\/\\d+', vport_name):\n                vport_name = re.findall(r'\\d+\\/\\d+', vport.Name)[0]\n\n            linkStatus.append([\"Name:\" + vport_name, \"State:\" + vport.State])\n            if print_info:\n                log.info(f'Link Status Info for Port: {vport_name}, {vport.State}')\n        return linkStatus\n\n    def set_stream_frame(self, stream_name, frame_config,**kwargs):\n        \"\"\"\n        Set the header field value of specific stream frame\n\n        :param stream_name: stream on which specific header configured\n        :param frame_config: dict with header name and field name with values to be configured \\n\n            Example: frame_config - single field: {'ipv4':{'sourceAddr':'10.1.1.1'}} \\n\n            Example: frame_config - list: {'ipv4':{'sourceAddr':['10.1.1.1','10.1.2.1','10.1.3.1']}} \\n\n            Example: frame_config - modifier: {'ipv4':{'destAddr':{'start': '10.1.1.10','step': '0.0.0.1', 'count': '3',\n            'valueType': 'decrement','mask':'255.255.255.255'}}}\n        :return: True if successful else Raise Exception\n\n        :Example:\n            set_stream_frame('Traffic Item 4', {'ipv4':{'destAddr':{'value': '10.1.1.12',\n                'step': '0.0.0.1', 'count': '3','valueType': 'increment','mask':'255.255.255.255'}}})\n\n            set_stream_frame(stream_name='Traffic Item 9', frame_config={\n                'ipv6': {'destAddr': {'start': '2000:1:1::2', 'valueType': 'increment', 'step': '0::1', 'count': 100}}})\n\n            set_stream_frame(stream_name='Traffic Item 11', frame_config={\n                'udp': {'sourcePort': {'start': 68, 'valueType': 'increment', 'step': 1, 'count': 10}}})\n\n            set_stream_frame(stream_name='Traffic Item 13', frame_config={'udp': {'sourcePort': 68}})\n        \"\"\"\n        field_dict = {}\n        self.log.info(f'Setting Stream Frame for Traffic Stream - {stream_name}')\n        ipv4_map_dict = {'checksum': 'checksum', 'destAddr': 'dest_ip', 'fragOffset': 'fragment_offset',\n                        'totalLength': 'total_len', 'protocol': 'protocol', 'sourceAddr': 'source_ip',\n                        'identification': 'identification', 'ttl': 'ttl', 'version': 'version'}\n        ipv6_map_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit', 'flowLabel': 'flowLabel',\n                        'sourceAddr': 'source_ip', 'trafficClass': 'trafficClass', 'version': 'version',\n                        'destAddr': 'dest_ip', 'nextHeader': 'nextHeader'}\n        udp_map_dict = {'sourcePort': 'udp_src_prt', 'destPort': 'udp_dst_prt'}\n        tcp_map_dict = {'urgBit': 'u_bit', 'protocolType': 'protocol', 'synBit': 's_bit', 'rstBit': 'r_bit',\n                        'cwrBit': 'c_bit', 'pshBit': 'p_bit', 'ackBit': 'a_bit', 'finBit': 'f_bit', 'ecnBit': 'e_bit',\n                        'ackNum': 'ack_num', 'reserved': 'reserved', 'seq_num': 'seqNum', 'offset': 'data_offset',\n                        'sourcePort': 'tcp_src_prt', 'destPort': 'tcp_dst_prt', 'window': 'tcp_window',\n                        'checksum': 'tcp_checksum', 'urgentPtr': 'urgent_ptr'}\n        ethernet_map_dict = {'dstMac': 'destinationAddress', 'etherType': 'ether_type', 'srcMac': 'sourceAddress'}\n        vlan_map_dict = {'vlan_user_priority': 'vlan_user_priority', 'vlan_cfi': 'vlan_cfi', 'id': 'vlan_id',\n                         'vlan_tag_type': 'vlan_tag_type'}\n\n        regex_dict = {'ipv4': ipv4_map_dict,'ipv6':ipv6_map_dict,'udp':udp_map_dict,'tcp':tcp_map_dict,'ethernet':ethernet_map_dict,\n                      'vlan': vlan_map_dict}\n\n        enable_stream = kwargs.get('enable_stream', False)\n\n        stream_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream_name+'$')\n        if not stream_obj:\n            raise IxiaConfigException(f\"{stream_name} stream not found\")\n        for header_name, header_config in frame_config.items():\n            if header_name in regex_dict.keys():\n                field_dict = regex_dict[header_name]\n            else:\n                raise IxiaConfigException(f'Invalid header name {header_name}')\n\n            for header_field, header_field_value in header_config.items():\n                header_field = field_dict[header_field]\n                field = stream_obj.ConfigElement.find().Stack.find(StackTypeId='^'+header_name.lower()+'$').Field.find(Name='^'+header_field+'$')\n                if not field:\n                    err_msg = f\"Invalid inputs for stack type {header_name} and field name {header_field}\"\n                    raise IxiaConfigException(err_msg)\n                if isinstance(header_field_value, dict) and header_field_value.get('value'):\n                    header_field_value['start'] = header_field_value['value']\n                self._update_field_values(field, header_field_value)\n            if enable_stream:\n                self.enable_traffic_item([stream_name])\n        return True\n\n    def set_port_transmit_deviation(self, port_list=None, deviation='enabled', deviation_value=0, **kwargs):\n        \"\"\"\n        Sets the transmit deviation type and value for a given set of ports\n\n        :param port_list: (list) The port(s) to configure\n            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']\n            Note - for IXIA all ports in the same group will be enabled/disabled regardless of port_list\n        :param deviation: (str) Selects whether transmit deviation is enabled or disabled\n            e.g. 'enabled', 'disabled'\n        :param deviation_value: (int/str): The desired PPM deviation value\n            e.g. 10, \"10\"\n        :param kwargs:\n                    wait_interval : (int) sleep time default 0\n                    repetition : (int) Number of time opertaion to be repeated Ex : 5\n                    operation : \"increment\"/\"decrement\" if \"decrement\" then negative deviation_value will be set EX : -10\n        :return: True on success, exception otherwise\n\n        :Example: set_port_transmit_deviation(deviation_value=10)\n                  set_port_transmit_deviation(deviation_value=10,operation=\"increment\",wait_interval=5, repetition=2)\n        \"\"\"\n        wait_interval = kwargs.get(\"wait_interval\", 0)\n        repetition = kwargs.get(\"repetition\", 1)\n        operation = kwargs.get(\"operation\", \"increment\")\n        if operation == \"decrement\":\n            deviation_value = - deviation_value\n\n        cardTypeList = ['atlasFourHundredGigLan',\n                        'atm',\n                        'ethernet',\n                        'ethernetImpairment',\n                        'ethernetvm',\n                        'fc',\n                        'fortyGigLan',\n                        'hundredGigLan',\n                        'krakenFourHundredGigLan',\n                        'novusHundredGigLan',\n                        'novusTenGigLan',\n                        'pos',\n                        'tenFortyHundredGigLan',\n                        'tenGigLan',\n                        'tenGigWan',\n                        'aresOneFourHundredGigLan',\n                        'starFourHundredGigLan',\n                        'aresOneM']\n\n        while repetition != 0:\n            if port_list:\n                vports = self.ixNetwork.Vport.find()\n                vports.ReleasePort()\n                for port in port_list:\n                    if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', port)):\n                        port = port.replace(\"/\", \":\")\n                        card_type = self.ixNetwork.Vport.find(AssignedTo=port).Type\n                        port_type = \"IP\"\n                    else:\n                        card_type = self.ixNetwork.Vport.find(Name=port).Type\n                        port_type = \"NAME\"\n\n                    if card_type in cardTypeList:\n                        card_type = card_type[0].upper() + card_type[1:]\n                    else:\n                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found. Code may need to be updated to support it')\n                    if deviation.lower() == 'enabled':\n                        if port_type == \"NAME\":\n                            card_obj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + card_type)\n                        if port_type == \"IP\":\n                            card_obj = eval('self.ixNetwork.Vport.find(AssignedTo=port).L1Config.' + card_type)\n                        card_obj.EnablePPM = True\n                        card_obj.Ppm = deviation_value\n                        self.log.info(f\"On Port: {port} Enabled deviation and value set to: {deviation_value}\")\n                    elif deviation.lower() == 'disabled':\n                        if port_type == \"NAME\":\n                            card_obj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + card_type)\n                        if port_type == \"IP\":\n                            card_obj = eval('self.ixNetwork.Vport.find(AssignedTo=port).L1Config.' + card_type)\n                        card_obj.EnablePPM = False\n                        card_obj.Ppm = deviation_value\n                        self.log.info(f\"On Port: {port} Disabled deviation and value set to: {deviation_value}\")\n                vports.ConnectPorts()\n            else:\n                vports = self.ixNetwork.Vport.find()\n                vports.ReleasePort()\n                for vport in self.ixNetwork.Vport.find():\n                    cardType = vport.Type\n                    if cardType in cardTypeList:\n                        cardType = cardType[0].upper() + cardType[1:]\n                    else:\n                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found. Code may need to be updated to support it')\n                    if deviation.lower() == 'enabled':\n                        cardObj = eval('vport.L1Config.' + cardType)\n                        cardObj.EnablePPM = True\n                        cardObj.Ppm = deviation_value\n                        self.log.info(f\"On Port: {vport.Name} Enabled deviation and value set to: {deviation_value}\")\n                    elif deviation.lower() == 'disabled':\n                        cardObj = eval('vport.L1Config.' + cardType)\n                        cardObj.EnablePPM = False\n                        cardObj.Ppm = deviation_value\n                        self.log.info(f\"On Port: {vport.Name} Disabled deviation and value set to: {deviation_value}\")\n                vports.ConnectPorts()\n            time.sleep(wait_interval)\n            repetition -= 1\n        return True\n\n    def new_session(self, user_name=None, session_name=None, kill_existing=False, **kwargs):\n        \"\"\"\n        Creates a new test session. Applicable only for Linux or Windows Connection Manager\n\n        :param user_name: User name part of session ID.\n        :param session_name: Session name part of session ID.\n        :param kill_existing: If there is an existing session, with the same session name\n                              and user name, then terminate it before creating a new session\n        :return: True is session started, False if session was already started.\n\n        :Example: new_session(()\n        \"\"\"\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n        if session_name:\n            self.log.info(f\"Creating New session - '{session_name}'\")\n        else:\n            self.log.info(\"Creating new Session\")\n        self._new_session(user_name=user_name, session_name=session_name, kill_existing=kill_existing)\n        self.log.info(\"Created new session - '%s'\"%self.session_name)\n\n        return True\n\n    def isListEmpty(self, inList):\n        \"\"\"\n        Check if the list is empty for each port,This API is not applicable to ixia\n\n        :param inList: list of streams per port\n\n        :Example: isListEmpty([])\n        \"\"\"\n        pass\n\n    def get_router_ids(self, device_list=None):\n        \"\"\"\n        Retrieves router IDs for a given set of devices\n\n        :param device_list: (str/list) A single device or a list of devices\n                to retrieve the router id for. If None get for all devices\n                e.g. 'device1' or ['device1', 'device2']\n        :returns: a dict of device names/router IDs on pass, exception on failure\n\n        :Example: get_router_ids(device_list=['Device Group 4','Device Group 3'])\n        \"\"\"\n        devices_to_check = []\n        router_ids = {}\n        if device_list:\n            if isinstance(device_list, str):\n                devices_to_check = device_list.split(',')\n            elif isinstance(device_list, list):\n                devices_to_check = device_list\n            else:\n                raise CafyException.InvalidValueError('Invalid input type for device_list. Please use a str or a list')\n        else:\n            devices_to_check = self.get_device_names()\n        for device in devices_to_check:\n            deviceName = device\n            dName = '^' + deviceName.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dName + '$'):\n                try:\n                    routerId = deviceGroupObj.RouterData.find().RouterId.Values\n                    router_ids[device] = [str(id) for id in routerId]\n                except:\n                    pass\n        return router_ids\n\n    def enable_ping(self, router_id='all'):\n        \"\"\"\n        Enable the ping on a device or on all devices, ping enabled by default in IXIA\n\n        :param router_id: Router ID of the device\n        :return: True on success else raises exception\n\n        :Example: enable_ping()\n        \"\"\"\n\n        return True\n\n    def disable_ping(self, router_id='all'):\n        \"\"\"\n        Disable the ping on a device or on all devices\n\n        :param router_id: Router ID of the device\n        :return: True on success else raises exception\n\n        :Example: disable_ping()\n        \"\"\"\n\n        return True\n\n    def get_device_ip_info(self, router_id, ip_version='ipv4', key=None):\n        \"\"\"\n        Get emulated device IP info\n\n        :param router_id: Router ID of the device\n        :param ip_version: IP Version\n        :param key: Get specific key value\n        :return: Device key info\n\n        :Example: get_device_ip_info(\"192.0.0.1\", ip_version='ipv4', key='Address')\n        \"\"\"\n        if ip_version not in ('ipv4', 'ipv6'):\n            raise IxiaOperationException(\"Invalid Ip version\")\n\n        if type(router_id) is str:\n            router_id = router_id.split(\",\")\n\n        routerIdList = self.get_device_names()\n        flag = False\n        ipFieldsList = []\n        for routerId in router_id:\n            if '.' in routerId:\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if routerId in deviceGroupObj.RouterData.find().RouterId.Values:\n                            routerId = deviceGroupObj.Name\n                            break\n            else:\n                routerId = routerId\n            if routerId in routerIdList:\n                flag = True\n                if ip_version == 'ipv4':\n                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find()\n                else:\n                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find()\n\n                ipFieldsList = re.findall('([a-zA-z]+): (.*)', str(ipData))\n                ipFieldsList.pop(0)\n                ipFieldsList = dict(ipFieldsList)\n                if ip_version == 'ipv4':\n                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find().Address.Values\n                else:\n                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find().Address.Values\n                ipFieldsList['address'] = ipData\n\n        if not flag:\n            raise IxiaOperationException(\"Router id not found\")\n        if not key:\n            return ipFieldsList\n        if key not in ipFieldsList:\n            raise IxiaConfigException(\"key not available in ip info\")\n        return ipFieldsList[key]\n\n    def set_bgp_route_count_all(self, route_count, ip_type=\"ipv4\", **kwargs):\n        \"\"\"\n        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs. For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_bgp_route_count_all(route_count=20, ip_type=\"ipv4\")\n        \"\"\"\n        protocolStatus = False\n        self.log.info(\"Setting Bgp Route Count for all devices with bgp configured\")\n        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]\n        for deviceName in deviceNameList:\n            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():\n                if ip_type.lower() == \"ipv4\":\n                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():\n                        if ipv4PoolObj.BgpIPRouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv4PoolObj, route_count)\n                        if ipv4PoolObj.BgpV6IPRouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv4PoolObj, route_count)\n                else:\n                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name=networkGroupObj.Name).Ipv6PrefixPools.find():\n                        if ipv6PoolObj.BgpV6IPRouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv6PoolObj, route_count)\n                        if ipv6PoolObj.BgpIPRouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv6PoolObj, route_count)\n        if protocolStatus:\n            return protocolStatus\n        else:\n            raise IxiaConfigException(\"BGP protocol not configured or Configuration issue.\")\n\n    def set_isis_route_count_all(self, route_count, ip_type=\"ipv4\", **kwargs):\n        \"\"\"\n        Configures the route count for all isis devices. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_isis_route_count_all(route_count=20, ip_type=\"ipv4\")\n        \"\"\"\n        protocolStatus = False\n        self.log.info(\"Setting ISIS Route Count for all devices with ISIS configured\")\n        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]\n        for deviceName in deviceNameList:\n            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():\n                if ip_type.lower() == \"ipv4\":\n                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():\n                        if ipv4PoolObj.IsisL3RouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv4PoolObj, route_count)\n                else:\n                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv6PrefixPools.find():\n                        if ipv6PoolObj.IsisL3RouteProperty.find():\n                            protocolStatus = True\n                            self._set_route_count(ipv6PoolObj, route_count)\n        if protocolStatus:\n            return protocolStatus\n        else:\n            raise IxiaConfigException(\"ISIS protocol not configured or Configuration issue.\")\n\n    def get_device_names(self):\n        \"\"\"\n        Retrieves a list of device names\n\n        :returns: device_names (list) on pass, exception on failure\n\n        :Example: get_device_names()\n        \"\"\"\n        deviceList = []\n        deviceList = [deviceGroupName.Name for deviceGroupName in\n                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]\n        return deviceList\n\n    def enable_gateway_mac_address(self, ip_type, router_ids=None):\n        \"\"\"\n        The API sets the gateway mac status to True\n\n        :param ip_type: ipv4/ipv6\n        :param router_ids: List of router_ids\n        :return: return True if gateway mac address is enabled else raises exception\n\n        :Example: enable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])\n        \"\"\"\n        deviceList = [deviceGroupName.Name for deviceGroupName in\n                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]\n        routerIdList = [routerObj.RouterId for routerObj in\n                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]\n        if router_ids is not None:\n            for routerId in router_ids:\n                routerId = ' ' + routerId\n                if re.search(routerId, str(routerIdList)):\n                    for device in deviceList:\n                        try:\n                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).RouterData.find().RouterId\n                        except:\n                            pass\n                        if re.search(routerId, str(deviceRouterId)):\n                            if ip_type == 'ipv4':\n                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)\n                            else:\n                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)\n                else:\n                    raise IxiaConfigException('router id %s not found ', routerId)\n        else:\n            for device in deviceList:\n                deviceRouterId = None\n                try:\n                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=device).RouterData.find().RouterId\n                except:\n                    pass\n                if re.search(r'\\d+.\\d+.\\d+.\\d+', str(deviceRouterId)):\n                    if ip_type == 'ipv4':\n                        try:\n                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)\n                        except:\n                            pass\n                    elif ip_type == 'ipv6':\n                        try:\n                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)\n                        except:\n                            pass\n        return True\n\n    def disable_gateway_mac_address(self, ip_type, router_ids=None):\n        \"\"\"\n        The API sets the gateway mac status to True\n\n        :param ip_type: ipv4/ipv6\n        :param router_ids: List of router_ids\n        :return: return True if gateway mac address is enabled else raises exception\n\n        :Example: disable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])\n        \"\"\"\n        deviceList = [deviceGroupName.Name for deviceGroupName in\n                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]\n        routerIdList = [routerObj.RouterId for routerObj in\n                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]\n        if router_ids is not None:\n            for routerId in router_ids:\n                routerId = ' ' + routerId\n                if re.search(routerId, str(routerIdList)):\n                    for device in deviceList:\n                        try:\n                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).RouterData.find().RouterId\n                        except:\n                            pass\n                        if re.search(routerId, str(deviceRouterId)):\n                            if ip_type == 'ipv4':\n                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)\n                            else:\n                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)\n                else:\n                    raise IxiaConfigException('router id %s not found ', routerId)\n        else:\n            for device in deviceList:\n                deviceRouterId = None\n                try:\n                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=device).RouterData.find().RouterId\n                except:\n                    pass\n                if re.search(r'\\d+.\\d+.\\d+.\\d+', str(deviceRouterId)):\n                    if ip_type == 'ipv4':\n                        try:\n                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)\n                        except:\n                            pass\n                    elif ip_type == 'ipv6':\n                        try:\n                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)\n                        except:\n                            pass\n        return True\n\n    def change_ipv4_ipv6_src_address(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Changes the IPv4/Ipv6 source address configuration for a given set\n        of traffic streams\n\n        :param cfg_dict: Dict including the data need to be modified\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n\n        :Example: tgnObj.change_ipv4_ipv6_src_address(traffic_item_list=[\"Traffic Item 4\"],\n                                            cfg_dict={'fieldValue':\"3.3.53.3\",'startValue':\"3.3.53.3\",'valueType':\"increment\",'countValue':100})\n        \"\"\"\n        self.log.info(\"Change IPv4/IPv6 Source Address %s\")\n        if traffic_item_list:\n            for trafficItemName in traffic_item_list:\n                traffic_item_name = re.escape(trafficItemName)\n                for config_element in self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_name}$').ConfigElement.find():\n                    if config_element.Stack.find(DisplayName=\"IPv4\"):\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")\n                        fieldNames = [fieldObj.DisplayName for fieldObj in stack_obj.Field.find()]\n                        for fieldName in fieldNames:\n                            if fieldName.lower() == 'Source Address'.lower():\n                                field = stack_obj.Field.find(DisplayName=fieldName)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \\\n                                cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \\\n                                cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"0.0.0.1\")\n                    elif config_element.Stack.find(DisplayName=\"IPv6\"):\n                        stackObj = config_element.Stack.find(DisplayName=\"IPv6\")\n                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n                        for fieldName in fieldNames:\n                            if fieldName.lower() == 'Source Address'.lower():\n                                field = stackObj.Field.find(DisplayName=fieldName)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \\\n                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\\\n                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"::1\")\n\n                    else:\n                        raise IxiaConfigException(\"Ipv4/Ipv6 stack not configured on %s\" % trafficItemName)\n        else:\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                try:\n                    if configElement.Stack.find(DisplayName=\"IPv4\"):\n                        stackObj = configElement.Stack.find(DisplayName=\"IPv4\")\n                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n                        for fieldName in fieldNames:\n                            if fieldName.lower() == 'Source Address'.lower():\n                                field = stackObj.Field.find(DisplayName=fieldName)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \\\n                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\\\n                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"0.0.0.1\")\n                    elif configElement.Stack.find(DisplayName=\"IPv6\"):\n                        stackObj = configElement.Stack.find(DisplayName=\"IPv6\")\n                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]\n                        for fieldName in fieldNames:\n                            if fieldName.lower() == 'Source Address'.lower():\n                                field = stackObj.Field.find(DisplayName=fieldName)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \\\n                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \\\n                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"::1\")\n                except:pass\n        self.log.info(\"IPv4/Ipv6 Source Address Updated in Traffic Items\")\n        return True\n\n    def change_ipv4_ipv6_dst_address(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Changes the IPv4/Ipv6 source address configuration for a given set\n        of traffic streams\n\n        :param cfg_dict: Dict including the data need to be modified\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n\n        :Example: tgnObj.change_ipv4_ipv6_dst_address(traffic_item_list=[\"Traffic Item 4\"],\n                    cfg_dict={'fieldValue':\"3.3.53.3\",'startValue':\"3.3.53.3\",'valueType':\"increment\",'countValue':100})\n        \"\"\"\n\n        self.log.info(\"Change IPv4/IPv6 Source Address\")\n        if 'singleValue' in cfg_dict.keys():\n            cfg_dict['fieldValue'] = cfg_dict['singleValue']\n\n        if cfg_dict['valueType'] == 'increment' or cfg_dict['valueType'] == 'decrement':\n            cfg_dict['fieldValue'] = cfg_dict['startValue']\n\n        if traffic_item_list:\n            for traffic_item_name in traffic_item_list:\n                traffic_item = re.escape(traffic_item_name)\n                for config_element in self.ixNetwork.Traffic.TrafficItem.find(\n                        Name='^' + traffic_item + '$').ConfigElement.find():\n                    if config_element.Stack.find(DisplayName=\"IPv4\"):\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")\n                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]\n                        for field_name in field_names:\n                            if field_name.lower() == 'Destination Address'.lower():\n                                field = stack_obj.Field.find(DisplayName=field_name)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \\\n                                    cfg_dict.get('valueType', 'singleValue'),cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \\\n                                    cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"0.0.0.1\"), cfg_dict.get('valueList',['0.0.0.0'])\n                    elif config_element.Stack.find(DisplayName=\"IPv6\"):\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv6\")\n                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]\n                        for field_name in field_names:\n                            if field_name.lower() == 'Destination Address'.lower():\n                                field = stack_obj.Field.find(DisplayName=field_name)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \\\n                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \\\n                                    cfg_dict.get('startValue',None), cfg_dict.get('stepValue', \"::1\"), cfg_dict.get('valueList',['0::0'])\n                    else:\n                        raise IxiaConfigException(f\"Ipv4/Ipv6 stack not configured on {traffic_item_name}\")\n        else:\n            for config_element in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n                try:\n                    if config_element.Stack.find(DisplayName=\"IPv4\"):\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")\n                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]\n                        for field_name in field_names:\n                            if field_name.lower() == 'Destination Address'.lower():\n                                field = stack_obj.Field.find(DisplayName=field_name)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \\\n                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get('countValue', None), \\\n                                    cfg_dict.get('startValue',None), cfg_dict.get('stepValue', \"0.0.0.1\"), cfg_dict.get('valueList',['0.0.0.0'])\n                    elif config_element.Stack.find(DisplayName=\"IPv6\"):\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv6\")\n                        field_names = [field_obj.DisplayName for field_obj in stack_obj.Field.find()]\n                        for field_name in field_names:\n                            if field_name.lower() == 'Destination Address'.lower():\n                                field = stack_obj.Field.find(DisplayName=field_name)\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.ValueList = \\\n                                    cfg_dict.get('valueType', 'singleValue'), cfg_dict.get('fieldValue',None), cfg_dict.get( 'countValue', None), \\\n                                    cfg_dict.get('startValue', None), cfg_dict.get('stepValue', \"::1\"),cfg_dict.get('valueList', ['0::0'])\n                except:\n                    pass\n        self.log.info(\"IPv4/Ipv6 Destination Address Updated in Traffic Items\")\n        return True\n\n    def _addTimestampToFile(self,filename):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param filename: filename for which timestamp to be added\n        \"\"\"\n        currentTimestamp = datetime.datetime.now().strftime('%H%M%S')\n        if '\\\\' in filename:\n            filename = filename.split('\\\\')[-1]\n\n        if '/' in filename:\n            filename = filename.split('/')[-1]\n\n        newFilename = filename.split('.')[0]\n        newFileExtension = filename.split('.')[1]\n        newFileWithTimestamp = '{}_{}.{}'.format(newFilename, currentTimestamp, newFileExtension)\n        return newFileWithTimestamp\n\n    def _getQuickTestCurrentAction(self,quickTestHandle):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param quickTestHandle: QucikTestHandle to test current Action\n        \"\"\"\n        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber\n        match = re.match(r'([0-9]+)\\.[^ ]+ *', ixNetworkVersion)\n        ixNetworkVersion = int(match.group(1))\n\n        if ixNetworkVersion >= 8:\n            timer = 10\n            for counter in range(1, timer + 1):\n                currentActions = quickTestHandle.Results.CurrentActions\n\n                self.log.info('\\n\\ngetQuickTestCurrentAction:\\n')\n                for eachCurrentAction in quickTestHandle.Results.CurrentActions:\n                    self.log.info('\\t{}'.format(eachCurrentAction['arg2']))\n\n                self.log.info('\\n')\n\n                if counter < timer and currentActions == []:\n                    self.log.info('\\n\\ngetQuickTestCurrentAction is empty. Waiting %s/%s\\n\\n' % (counter, timer))\n                    time.sleep(1)\n                    continue\n\n                if counter < timer and currentActions != []:\n                    break\n\n                if counter == timer and currentActions == []:\n                    raise Exception('\\n\\ngetQuickTestCurrentActions: Has no action')\n\n            return currentActions[-1]['arg2']\n        else:\n            return quickTestHandle.Results.Progress\n\n    def _verifyQuickTestInitialization(self,quickTestHandle):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param quickTestHandle: QucikTest handle to verify Quick Test Initilization\n        \"\"\"\n        for timer in range(1, 30 + 1):\n            currentAction = self._getQuickTestCurrentAction(quickTestHandle)\n            self.log.info('\\n\\nverifyQuickTestInitialization currentAction: {}\\n'.format(currentAction))\n            if currentAction == 'TestEnded':\n                raise Exception('VerifyQuickTestInitialization: QuickTest failed during initialization: {}'.format(quickTestHandle.Results.Status))\n\n            if timer < 30 and currentAction == 'None':\n                self.log.info('\\n\\nverifyQuickTestInitialization CurrentState = %s\\n\\tWaiting %s/30 seconds to change state\\n' % (currentAction, timer))\n                time.sleep(1)\n                continue\n            else:\n                break\n\n            if timer == 20 and currentAction == 'None':\n                raise Exception('\\n\\nQuick Test is stuck.')\n\n        successStatusList = ['TransmittingComplete', 'TransmittingFrames', 'WaitingForStats', 'CollectingStats', 'TestEnded']\n        quickTestApplyStates = ['InitializingTest', 'ApplyFlowGroups', 'SetupStatisticsCollection']\n        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber\n        match = re.match(r'([0-9]+)\\.[^ ]+ *', ixNetworkVersion)\n        ixNetworkVersion = int(match.group(1))\n\n        applyQuickTestCounter = 120\n        for counter in range(1, applyQuickTestCounter + 1):\n            currentAction = self._getQuickTestCurrentAction(quickTestHandle)\n            self.log.info('\\n\\nverifyQuickTestInitialization: CurrentState: %s  Expecting: TransmittingFrames\\n\\tWaiting %s/%s seconds\\n' % (currentAction, counter, applyQuickTestCounter))\n\n            if currentAction == 'TestEnded':\n                raise Exception('\\n\\nVerifyQuickTestInitialization: QuickTest failed!!: {}'.format(quickTestHandle.Results.Status))\n\n            if currentAction == None:\n                currentAction = 'ApplyingAndInitializing'\n\n            if ixNetworkVersion >= 8:\n                if counter < applyQuickTestCounter and currentAction not in successStatusList:\n                    time.sleep(1)\n                    continue\n\n                if counter < applyQuickTestCounter and currentAction in successStatusList:\n                    self.log.info('\\n\\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\\n')\n                    break\n\n            if ixNetworkVersion < 8:\n                if counter < applyQuickTestCounter and currentAction != 'ApplyingAndInitializing':\n                    time.sleep(1)\n                    continue\n\n                if counter < applyQuickTestCounter and currentAction == 'ApplyingAndInitializing':\n                    self.log.info('\\n\\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\\n')\n                    break\n\n            if counter == applyQuickTestCounter:\n                if ixNetworkVersion >= 8 and currentAction not in successStatusList:\n                    if currentAction == 'ApplyFlowGroups':\n                        self.log.info('\\n\\nVerifyQuickTestInitialization: IxNetwork is stuck on Applying Flow Groups. You need to go to the session to FORCE QUIT it.\\n')\n\n                    raise Exception('\\n\\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (\n                        currentAction, counter, applyQuickTestCounter))\n\n                if ixNetworkVersion < 8 and currentAction != 'Trial':\n                    raise Exception('\\n\\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (\n                        currentAction, counter, applyQuickTestCounter))\n\n    def _monitorQuickTestRunningProgress(self,quickTestHandle, getProgressInterval=10):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param quickTestHandle: qucikTest Handle\n        :param getProgressInterval: Progressinterval\n        \"\"\"\n        isRunningBreakFlag = 0\n        trafficStartedFlag = 0\n        waitForRunningProgressCounter = 0\n        counter = 1\n        connectionFailureCounter = 0\n        maxRetries = 10\n\n        while True:\n            # This while loop was implemented because sometimes there could be failure to connect to the\n            # API server.  It could be caused by many various issues not related to IxNetwork.\n            # Going to retry doing GETs up to 10 times.\n            connectedToApiServerFlag = False\n\n            while True:\n                try:\n                    isRunning = quickTestHandle.Results.IsRunning\n                    currentRunningProgress = quickTestHandle.Results.Progress\n                    self.log.info('\\nmonitorQuickTestRunningProgress: isRuning: %s', isRunning)\n                    break\n                except:\n                    self.log.info('\\n\\nmonitorQuickTestRunningProgress: Failed to connect to API server {}/{} times\\n'.format(connectionFailureCounter, maxRetries))\n                    if connectionFailureCounter == maxRetries:\n                        raise Exception('\\n\\nmonitorQuickTestRunningProgress: Giving up trying to connecto the the API server after {} attempts\\n'.format(maxRetries))\n\n                    if connectionFailureCounter <= maxRetries:\n                        connectionFailureCounter += 1\n                        time.sleep(3)\n                        continue\n\n            self.log.info('\\n\\nmonitorQuickTestRunningProgress: isRunning: {}  CurrentRunningProgress: {}\\n'.format(isRunning, currentRunningProgress))\n\n            if isRunning == True:\n                if bool(re.match('^Trial.*', currentRunningProgress)) == False:\n                    if waitForRunningProgressCounter < 40:\n                        self.log.info('\\n\\nmonitorQuickTestRunningProgress: Waiting for trial runs {0}/30 seconds\\n'.format(waitForRunningProgressCounter))\n                        waitForRunningProgressCounter += 1\n                        time.sleep(1)\n\n                    if waitForRunningProgressCounter == 40:\n                        raise Exception('\\n\\nmonitorQuickTestRunningProgress: isRunning=True. QT is running, but no quick test iteration stats showing after 40 seconds.')\n                else:\n                    # The test is running fine.  Keep running until isRunning == False.\n                    trafficStartedFlag = 1\n                    time.sleep(getProgressInterval)\n                    continue\n            else:\n                if trafficStartedFlag == 1:\n                    # We only care about traffic not running in the beginning.\n                    # If traffic ran and stopped, then break out.\n                    self.log.info('\\n\\nmonitorQuickTestRunningProgress: isRunning=False. Quick Test ran and is complete\\n\\n')\n                    return True\n\n                if trafficStartedFlag == 0 and isRunningBreakFlag < 40:\n                    self.log.info('\\n\\nmonitorQuickTestRunningProgress: isRunning=False. QT did not run yet. Wait {0}/40 seconds\\n\\n'.format(isRunningBreakFlag))\n                    isRunningBreakFlag += 1\n                    time.sleep(1)\n                    continue\n\n                if trafficStartedFlag == 0 and isRunningBreakFlag == 40:\n                    raise Exception('\\n\\nmonitorQuickTestRunningProgress: Quick Test failed to start:: {}'.format(quickTestHandle.Results.Status))\n\n    def _copyFileWindowsToLocalWindows(self,windowsPathAndFileName, localPath, includeTimestamp=False):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param windowsPathAndFileName: windowspathandfilename\n        :param localPath: localpath\n        :param includeTimestamp: boolean True or False\n        \"\"\"\n        self.log.info('\\n\\ncopyFileWindowsToLocalWindows: From: %s to %s\\n\\n' % (windowsPathAndFileName, localPath))\n        fileName = windowsPathAndFileName.split('\\\\')[-1]\n        fileName = fileName.replace(' ', '_')\n        if includeTimestamp:\n            fileName = self._addTimestampToFile(fileName)\n\n        destinationPath = localPath + '\\\\' + fileName\n        self.log.info('\\nCopying from {} -> {}'.format(windowsPathAndFileName, destinationPath))\n        self.ixNetwork.CopyFile(windowsPathAndFileName, destinationPath)\n\n    def _copyApiServerFileToLocalLinux(self,apiServerPathAndFileName, localPath, localPathOs='linux', includeTimestamp=False):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param apiServerPathAndFileName: apiServerPathAndFileName\n        :param localPath: localPath\n        :param localPathOs: localPathOs\n        :param includeTimestamp: boolean True or False\n        \"\"\"\n        if '/' in apiServerPathAndFileName:\n            fileName = apiServerPathAndFileName.split('/')[-1]\n\n        if '\\\\' in apiServerPathAndFileName:\n            fileName = apiServerPathAndFileName.split('\\\\')[-1]\n\n        fileName = fileName.replace(' ', '_')\n\n        if includeTimestamp:\n            fileName = self._addTimestampToFile(fileName)\n\n        if localPathOs == 'linux':\n            destinationPath = localPath + '/' + fileName\n\n        if localPathOs == 'windows':\n            destinationPath = localPath + '//' + fileName\n\n        self.log.info('\\nCopying file from API server:{} -> {}'.format(apiServerPathAndFileName, destinationPath))\n        self.session.DownloadFile(apiServerPathAndFileName, destinationPath)\n\n    def _getQuickTestCsvFiles(self,quickTestHandle, copyToPath, csvFile='all', includeTimestamp=False):\n        \"\"\"\n        Function used internally by API rfc2544_quicktest\n\n        :param quickTestHandle: quickTestHandle\n        :param copyToPath: copyToPath\n        :param csvFile: csvFile\n        :param includeTimestamp: boolean True or False\n        \"\"\"\n        resultsPath = quickTestHandle.Results.ResultPath\n        self.log.info('\\ngetQuickTestCsvFiles: %s' % resultsPath)\n\n        if csvFile == 'all':\n            getCsvFiles = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']\n        else:\n            if type(csvFile) is not list:\n                getCsvFiles = [csvFile]\n            else:\n                getCsvFiles = csvFile\n\n        for eachCsvFile in getCsvFiles:\n            # Backslash indicates the results resides on a Windows OS.\n            if '\\\\' in resultsPath:\n                windowsSource = resultsPath + '\\\\{0}'.format(eachCsvFile)\n\n                if bool(re.match('[a-z]:.*', copyToPath, re.I)):\n                    self._copyFileWindowsToLocalWindows(windowsSource, copyToPath, includeTimestamp=includeTimestamp)\n                else:\n                    # Copy From Windows API server to local Linux client filesystem\n                    self._copyApiServerFileToLocalLinux(windowsSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)\n\n            else:\n                linuxSource = resultsPath + '/{0}'.format(eachCsvFile)\n\n                # Copy from Linux api server to Local Linux client filesystem.\n                try:\n                    self.log.info('\\nCopying file from Linux API server:{} to local Linux:{}'.format(linuxSource, eachCsvFile))\n                    self._copyApiServerFileToLocalLinux(linuxSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)\n\n                except Exception as errMsg:\n                    self.log.info('copyApiServerFileToLocalLinux ERROR: %s', errMsg)\n\n    def rfc2544_quicktest(self,name,options_dict,result_type='csv',timeout=600):\n        \"\"\"\n        Creates a new rfc2544 throughput quicktest and configs the desired parameters\n\n        :param name: (str) The name given to the new quicktest e.g. 'RFC2544_QuickTest'\n        :param options_dict: (dict) A dict of options to configure\n\n        :Traffic Selection Options:\n            traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\\n\n            flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']\\n\n            background_traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\\n\n            background_flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']\n\n        :Protocol Options:\n            protocol_state (str): e.g. default, restart, stop, start\\n\n            wait_after_start (int): e.g. 120\\n\n            wait_after_stop (int): e.g. 30\\n\n\n        :Traffic Options:\n            regenerate_traffic (bool): e.g. True, False\\n\n            frame_size_mode (str): e.g. increment, random, custom, unchanged\\n\n            start_size (int): e.g. 64\\n\n            step_size (int): e.g. 1\\n\n            end_size (int): e.g. 1280\\n\n            custom_frame_size (list): e.g ['64', '128', '256', '512', '1024']\\n\n            use_4_byte_sig (bool): e.g. True, False\n\n        :Learning Frame Options\n            learning_Frequency (str): e.g. never,onBinaryIteration,oncePerFramesize,oncePerTest,onTrial\\n\n\n        :Stats Parameters Options:\n            aggregate_per_iteration (bool): e.g. True, False\\n\n            show_flooded_frames (bool): e.g. True, False\\n\n            calculate_latency (bool): e.g. True, False\\n\n            latency_type (str): e.g. 'cutThrough, forwardingDelay, mef, storeForward'\\n\n            calculate_jitter (bool): e.g. True, False\\n\n            sequence_errors (bool): e.g. True, False\\n\n            data_integrity_checl (bool): e.g. True, False\\n\n            tx_rx_l1_rates (bool): e.g. True, False\\n\n            per_flow_stats (bool): e.g. True, False\\n\n            per_port_stats (bool): e.g. True, False\n\n        :Test Parameters Options:\n            duration (int): e.g. 300\\n\n            trials (int): e.g. 2\\n\n            initial_rate (double): e.g. 10\\n\n            min_rate (double): e.g. 10\\n\n            max_rate (double): e.g. 99.99\\n\n            resolution (double): e.g. 3\\n\n            backoff (double): e.g. 50\n            acceptable_frame_loss (double): e.g 5\n\n        :param result_type: (str) Choose whether you want to save results as a csv, pdf, or both\n        :param timeout: The timeout value set before failing the quicktest\n\n        :return: True if successful, else raise an exception\n\n        :Example: rfc2544_quicktest(\"QuickTestRFC2544\",options_dict={'regenerate_traffic':True,'traffic_items':['Traffic Item 1']},result_type='csv',timeout=600)\n        \"\"\"\n\n        quickTestHandle = self.ixNetwork.QuickTest.Rfc2544throughput.add(Name=name,ForceApplyQTConfig=None, Mode='existingMode')\n        # for quickTestHandle in self.ixNetwork.QuickTest.Rfc2544throughput.find():\n\n        if self.tgn_server_type == \"linux\":\n            api_key = self.test_platform.ApiKey\n            headers = {'content_type': 'application/json', 'x-api-key': api_key}\n            server_url = 'https://' + self.server_ip + ':' + str(self.port)\n            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n        else:\n            headers = {\"content_type\": \"application/json\"}\n            try:\n                server_url = 'http://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)\n            except:\n                server_url = 'https://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n\n        quicktest_href = quickTestHandle.href\n        #RestAPI\n        protocols_args = {'protocol_state': 'protocolState', 'wait_after_start': 'waitAfterStart',\n                          'wait_after_stop': 'waitAfterStop'}\n\n        traffic_options_args = {'regenerate_traffic': 'forceRegenerate', 'frame_size_mode': 'frameSizeMode',\n                                'start_size': 'minIncrementFrameSize', 'step_size': 'stepIncrementFrameSize',\n                                'end_size': 'maxIncrementFrameSize', 'custom_frame_size': 'framesizeList',\n                                'use_4_byte_sig': 'enableMinFrameSize'}\n\n        learning_options_args = {'learning_Frequency': 'learnFrequency'}\n\n        stats_parameters_args = {'aggregated_results_per_iteration': '', 'flooded_frames': 'floodedFramesEnabled',\n                                 'calculate_latency': 'calculateLatency', 'latency_type': 'latencyType',\n                                 'calculate_jitter': 'calculateJitter', 'sequence_errors': 'reportSequenceError',\n                                 'data_integrity_check': 'enableDataIntegrity', 'tx_rx_l1_rates': 'enableLayer1Rate',\n                                 'per_flow_stats': '', 'per_port_stats': ''}\n\n        test_parameters_args = {'duration': 'duration', 'trials': 'numtrials', 'initial_rate': 'initialBinaryLoadRate',\n                                'min_rate': 'minBinaryLoadRate', 'max_rate': 'maxBinaryLoadRate',\n                                'resolution': 'binaryResolution', 'backoff': 'binaryBackoff',\n                                'acceptable_frame_loss': 'binaryTolerance', 'load_type': 'loadType','custom_load_list':'loadRateList'}\n\n        # Get traffic item hrefs\n        traffic_item_hrefs = []\n        background_traffic_item_hrefs = []\n        flow_item_hrefs = []\n        background_flow_item_hrefs = []\n        streams = self.get_traffic_items()\n        for stream in streams:\n            if 'traffic_items' in options_dict:\n                if stream in options_dict['traffic_items']:\n                    traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)\n            if 'background_traffic_items' in options_dict:\n                if stream in options_dict['background_traffic_items']:\n                    background_traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)\n\n        url = server_url + quicktest_href + '/trafficSelection'\n        for href in traffic_item_hrefs:\n            traffic_item_type = self.ixNetwork.Traffic.TrafficItem.read(traffic_item_hrefs[0]).TrafficType\n            if traffic_item_type == 'raw':\n                traffic_item_type = 'mac'\n            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'inTest','trafficItemType': traffic_item_type}\n            requests.post(url, json=data, headers=headers, verify=False)\n        for href in background_traffic_item_hrefs:\n            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'background'}\n            requests.post(url, json = data, headers=headers,verify=False)\n        for href in flow_item_hrefs:\n            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'inTest'}\n            requests.post(url, json = data, headers=headers,verify=False)\n        for href in background_flow_item_hrefs:\n            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'background'}\n            requests.post(url, json = data, headers=headers,verify=False)\n\n        # Modify the protocol options\n        url = server_url + quicktest_href + '/protocols'\n        protocol_args_config = {}\n        for key, value in protocols_args.items():\n            if key in options_dict.keys():\n                protocol_args_config[value] = options_dict[key]\n        if protocol_args_config:\n            log.info('Configuring the quicktest protocol options...')\n            requests.patch(url, json = protocol_args_config, headers=headers,verify=False)\n\n        # Modify the traffic options\n        url = server_url + quicktest_href + '/testConfig'\n        traffic_options_config = {}\n        for key, value in traffic_options_args.items():\n            if key in options_dict.keys():\n                traffic_options_config[value] = options_dict[key]\n        if traffic_options_config:\n            log.info('Configuring the quicktest traffic options...')\n            requests.patch(url, json = traffic_options_config, headers=headers,verify=False)\n\n        # Modify Learning frames\n        url = server_url + quicktest_href + '/learnFrames'\n        learn_frames_config = {}\n        for key, value in learning_options_args.items():\n            if key in options_dict.keys():\n                learn_frames_config[value] = options_dict[key]\n        if learn_frames_config:\n            log.info('Configuring the quicktest learning frame options...')\n            requests.patch(url, json=learn_frames_config, headers=headers, verify=False)\n\n        # Modify the stats parameters options\n        url =server_url + quicktest_href + '/testConfig'\n        stats_parameters_config = {}\n        for key, value in stats_parameters_args.items():\n            if key in options_dict.keys():\n                stats_parameters_config[value] = options_dict[key]\n        if stats_parameters_config:\n            log.info('Configuring the quicktest stats parameters...')\n            requests.patch(url, json = stats_parameters_config, headers=headers,verify=False)\n\n        # Modify the test parameters options\n        url = server_url + quicktest_href + '/testConfig'\n        test_parameters_config = {}\n        for key, value in test_parameters_args.items():\n            if key in options_dict.keys():\n                if key == 'custom_load_list':\n                    options_dict['custom_load_list'] = ','.join(map(str, options_dict['custom_load_list']))\n                test_parameters_config[value] = options_dict[key]\n        if test_parameters_config:\n            log.info('Configuring the quicktest test parameters...')\n            requests.patch(url, json=test_parameters_config, headers=headers, verify=False)\n\n        #Restpy\n        quickTestHandle.Apply()\n        quickTestHandle.Start()\n        self._verifyQuickTestInitialization(quickTestHandle)\n        self._monitorQuickTestRunningProgress(quickTestHandle)\n\n        try:\n            # Store the results in the working dir\n            path = CafyLog.work_dir + '/quicktest_results/{}'.format(name)\n            os.makedirs(path)\n            self.log.info('Saving quick test results to the following dir: {}'.format(path))\n        except:\n            # Quicktest results dir already exists - skip this step\n            self.log.info('Quick test results folder {} already exists - copy the new results over'.format(path))\n\n        linuxDestinationFolder = path\n        windowsDestinationFolder = path\n\n        if options_dict.get(\"load_type\", \"\").lower() == [\"binary\",\"quick\",\"combo\"]:\n            csv_files = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']\n        else:\n            csv_files = ['AggregateResults.csv', 'results.csv', 'logFile.txt', 'portMap.csv']\n\n        if result_type == 'csv' or result_type == 'both':\n            self._getQuickTestCsvFiles(quickTestHandle, csvFile=csv_files, copyToPath=path, includeTimestamp=False)\n\n        if 'test_type' in options_dict.keys() and options_dict['test_type'] == 'latency_test':\n            result_path = path + '/results.csv'\n            result_info = pd.read_csv(result_path)\n            result_info['Min Latency (ns)'] = result_info['Min Latency (ns)'] / 1000\n            result_info['Max Latency (ns)'] = result_info['Max Latency (ns)'] / 1000\n            result_info['Avg Latency (ns)'] = result_info['Avg Latency (ns)'] / 1000\n\n            result_info.rename(columns={'Min Latency (ns)': 'Min Latency (us)', 'Max Latency (ns)': 'Max Latency (us)',\n                                        'Avg Latency (ns)': 'Avg Latency (us)'}, inplace=True)\n            with open(result_path, 'w') as file:\n                file.truncate(0)\n            result_info.to_csv(result_path, index=False)\n        \n        else:\n            result_path = path + '/results.csv'\n            result_info = pd.read_csv(result_path)\n            result_info.to_csv(result_path, index=False)\n\n        if result_type == 'pdf' or result_type == 'both':\n            if self.tgn_server_type != 'linux':\n                pdfFile = quickTestHandle.GenerateReport()\n                destPdfTestResult = self._addTimestampToFile(pdfFile)\n\n                # Copying the PDF from Windows to local Windows.\n                self._copyFileWindowsToLocalWindows(pdfFile, windowsDestinationFolder + '\\\\' + destPdfTestResult)\n\n                # Copying PDF from either a Windows API server or from a Linux API server to local Linux filesystem.\n                self.log.info('Copying test result PDF to: {}'.format(linuxDestinationFolder + destPdfTestResult))\n                self.session.DownloadFile(pdfFile, linuxDestinationFolder + destPdfTestResult)\n\n        # Check the result to see if the test passed\n        result = quickTestHandle.Results.Result\n        if result == 'pass':\n            log.info('RFC2544 Throughput Quicktest {} has passed'.format(name))\n            return True\n        else:\n            log.info('RFC2544 Throughput Quicktest {} did not pass'.format(name))\n            return False\n\n    def _get_igmp_mld_dict_info(self, igmpMldObj, vlanIndex):\n        \"\"\"\n        Function used internally by APIs to get emulated devices and their multicast information.\n\n        :param igmpMldObj: Igmp or Mld object handle\n        :param vlanIndex: Vlan id index\n        :return: Return emulated devices and thier multicast information\n        \"\"\"\n        igmpMldDict = dict()\n        if \"igmp\" in igmpMldObj.href:\n            igmpMldDict[\"igmp\"] = {}\n            igmpVersion = \"IGMP_V2\"\n            versionTypeValues = igmpMldObj.VersionType.Values\n            startMcastAddr = igmpMldObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values\n            groupAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.McastAddrCnt.Values\n            sourceRange = igmpMldObj.IgmpMcastIPv4GroupList.NoOfSrcRanges\n            sourceAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values\n            if versionTypeValues[vlanIndex] == \"version3\":\n                igmpVersion = \"IGMP_V3\"\n            igmpMldDict[\"igmp\"][\"group_count\"] = groupAddrCount[vlanIndex]\n            igmpMldDict[\"igmp\"][\"source_list\"] = sourceAddrCount[vlanIndex*sourceRange]\n            igmpMldDict[\"igmp\"][\"start_group_address\"] = startMcastAddr[vlanIndex]\n            igmpMldDict[\"igmp\"][\"version\"] = igmpVersion\n        if \"mld\" in igmpMldObj.href:\n            igmpMldDict[\"mld\"] = {}\n            mldVersion = \"MLD_V1\"\n            versionTypeValues = igmpMldObj.VersionType.Values\n            startMcastAddr = igmpMldObj.MldMcastIPv6GroupList.StartMcastAddr.Values\n            groupAddrCount = igmpMldObj.MldMcastIPv6GroupList.McastAddrCnt.Values\n            sourceRange = igmpMldObj.MldMcastIPv6GroupList.NoOfSrcRanges\n            sourceAddrCount = igmpMldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values\n            if versionTypeValues[vlanIndex] == \"version2\":\n                mldVersion = \"MLD_V2\"\n            igmpMldDict[\"mld\"][\"group_count\"] = groupAddrCount[vlanIndex]\n            igmpMldDict[\"mld\"][\"source_list\"] = sourceAddrCount[vlanIndex*sourceRange]\n            igmpMldDict[\"mld\"][\"start_group_address\"] = startMcastAddr[vlanIndex]\n            igmpMldDict[\"mld\"][\"version\"] = mldVersion\n        if \"pimV4\" in igmpMldObj.href:\n            igmpMldDict[\"pimV4\"] = {}\n            pimVersion = \"PIMv4\"\n            groupaddr = igmpMldObj.PimV4JoinPruneList.GroupV4Address.Values\n            groupAddrCount = igmpMldObj.PimV4JoinPruneList.GroupAddressCount.Values\n            sourceAddr = igmpMldObj.PimV4JoinPruneList.SourceV4Address.Values\n            sourceCount = igmpMldObj.PimV4JoinPruneList.SourceAddressCount.Values\n            igmpMldDict[\"pimV4\"][\"start_group_address\"] = groupaddr[vlanIndex]\n            igmpMldDict[\"pimV4\"][\"group_count\"] = groupAddrCount[vlanIndex]\n            igmpMldDict[\"pimV4\"][\"source_list\"] = sourceAddr[vlanIndex]\n            igmpMldDict[\"pimV4\"][\"version\"] = pimVersion\n        if \"pimV6\" in igmpMldObj.href:\n            igmpMldDict[\"pimV6\"] = {}\n            pimVersion = \"PIMv6\"\n            groupaddr = igmpMldObj.PimV6JoinPruneList.GroupV6Address.Values\n            groupAddrCount = igmpMldObj.PimV6JoinPruneList.GroupAddressCount.Values\n            sourceAddr = igmpMldObj.PimV6JoinPruneList.SourceV6Address.Values\n            sourceCount = igmpMldObj.PimV6JoinPruneList.SourceAddressCount.Values\n            igmpMldDict[\"pimV6\"][\"start_group_address\"] = groupaddr[vlanIndex]\n            igmpMldDict[\"pimV6\"][\"group_count\"] = groupAddrCount[vlanIndex]\n            igmpMldDict[\"pimV6\"][\"source_list\"] = sourceAddr[vlanIndex]\n            igmpMldDict[\"pimV6\"][\"version\"] = pimVersion\n        return igmpMldDict\n\n    def get_emulator_info(self, port_name=None, vlan_id=None):\n        \"\"\"\n        Creates dictionary of emulated devices(handler) and its multicast configuration information and returns the same\n        This Function gets the portname and vlanid and returns the emulated devices and only thier multicast config info like\n        start group address, group count and source IP list created in specified portname and having specified vlan ID.\n\n        :param port_name: Name of the port\n        :param vlan_id: vlanid of emulated device.\n        :return Returns nested dictionary of emulated devices and thier multicast information\n\n        Usage Example:\n        tgn.get_emulator_info(port_name=\"1/15\", vlan_id=\"6\")\n        Return Output:\n        {'P22_SM_v4_Auto_VRF6': {'igmp': {'group_count': '1',\n                                          'source_list': '192.0.1.0',\n                                          'start_group_address': '226.0.0.1',\n                                          'version': 'IGMP_V2'}},\n         'P22_SM_v4_BSR_VRF6': {'igmp': {'group_count': '1',\n                                         'source_list': '192.0.1.0',\n                                         'start_group_address': '227.0.0.1',\n                                         'version': 'IGMP_V2'}},\n         'P22_SM_v4_Static_VRF6': {'igmp': {'group_count': '1',\n                                            'source_list': '192.0.1.0',\n                                            'start_group_address': '225.0.0.1',\n                                            'version': 'IGMP_V2'}}}\n        \"\"\"\n        emulatedInfo = dict()\n        dG = None\n        if port_name:\n            for topology in self.ixNetwork.Topology.find():\n                if self.ixNetwork.Vport.find(Name=port_name).href in topology.Vports:\n                    igmpMldObjDict = {}\n                    for deviceGroupObj in topology.DeviceGroup.find():\n                        try:\n                            if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                for igmpObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                    if deviceGroupObj.href in igmpObj.href:\n                                        igmpMldObjDict[igmpObj] = deviceGroupObj\n                        except:\n                            pass\n                        try:\n                            if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                for mldObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                    if deviceGroupObj.href in mldObj.href:\n                                        igmpMldObjDict[mldObj] = deviceGroupObj\n                        except:\n                            pass\n                        try:\n                            if deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():\n                                for pimV4Obj in deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():\n                                    if deviceGroupObj.href in pimV4Obj.href:\n                                        igmpMldObjDict[pimV4Obj] = deviceGroupObj\n                        except:\n                            pass\n                        try:\n                            if deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():\n                                for pimV6Obj in deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():\n                                    if deviceGroupObj.href in pimV6Obj.href:\n                                        igmpMldObjDict[pimV6Obj] = deviceGroupObj\n                        except:\n                            pass\n\n                    for igmpMldOBj, deviceGroupObj in igmpMldObjDict.items():\n                        for vlanObj in deviceGroupObj.Ethernet.find().Vlan.find():\n                            if vlan_id and vlan_id in vlanObj.VlanId.Values:\n                                dG = deviceGroupObj.Name\n                                vlanIndex = (vlanObj.VlanId.Values).index(vlan_id)\n                                igmpDictInfo = self._get_igmp_mld_dict_info(igmpMldOBj, vlanIndex)\n                                if dG in emulatedInfo:\n                                    emulatedInfo[dG].update(igmpDictInfo)\n                                else:\n                                    emulatedInfo[dG] = igmpDictInfo\n                                break\n                    break\n        if dG is None:\n            log.info('No Emulated devices are configured on port %s with vlan %s' % (port_name, str(vlan_id)))\n            return None\n        else:\n            return emulatedInfo\n\n    def _process_stream_block(self, high_level_stream_entry, endpointset_entry, traffic_item_obj, vlan_index, mcast_addr_dict, mcast_device):\n        \"\"\"\n        Internal Method to process stream block\n        :param high_level_stream_entry: Details related to frame rate,type,fixed size etc in high level stream\n        :param endpointset_entry: Details of Endpoint set to traffic item\n        :param traffic_item_obj:Traffic Item Object on which mcast details are captured\n        :param vlan_index: Vlan index of Vlan\n        :param mcast_addr_dict:Multicast address dictionary\n        :param mcast_device: Multicast device details in topology\n        \"\"\"\n        streamblock_info = dict()\n        stream_source_ip = ''\n        stream_destination_ip = ''\n\n        frame_rate = high_level_stream_entry['frameRate']['rate']\n        frame_type = high_level_stream_entry['frameRate']['type']\n        frame_rate_type = str(frame_rate) + ' ' + frame_type\n        frame_size = str(high_level_stream_entry['frameSize']['fixedSize'])\n        flow_index = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 0))['arg3']\n        source_ip_index = flow_index.index('Source Address')\n        destination_ip_index = flow_index.index('Destination Address')\n\n        flow_data = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 1))['arg4']\n        if endpointset_entry['multicastDestinations']!= []:\n            mcast_receivers = endpointset_entry['multicastReceivers']\n\n            list(map(lambda x:x.update({'ethHandle': re.search(r'(\\S+ethernet\\[\\d+\\])', x['arg1']).group(0)}),mcast_receivers))\n\n            eth_to_mcast_df = pd.DataFrame(map(lambda x: [x['ethHandle'], x['arg1']],\n                                            mcast_receivers))\n            eth_to_mcast_df.columns = ['ethHandle', 'mcastProto']\n            eth_to_mcast_df.drop_duplicates(inplace=True)\n            mcast_href_str = ' '.join(eth_to_mcast_df['mcastProto'])\n\n            mcast_ip_list = list(\n                map(lambda x: x['arg3'], endpointset_entry['multicastDestinations']))\n\n            if mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index] in mcast_ip_list:\n                mcast_ip = mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index]\n                ip_type = ipaddress.ip_address(mcast_ip).version\n                if (ip_type == 4 and mcast_device in ['igmp', 'pimv4']) or \\\n                    (ip_type == 6 and mcast_device in ['mld', 'pimv6']):\n                    for value in flow_data:\n                        stream_source_ip = value[source_ip_index]\n                        stream_destination_ip = value[destination_ip_index]\n                        if mcast_device in mcast_href_str:\n                            mcast_source_ip = mcast_addr_dict[mcast_device][mcast_device + '_source_addr_list'][vlan_index]\n                            streamblock_info[traffic_item_obj.Name] = {\n                                'packet_rate': frame_rate_type,\n                                'packet_size': frame_size,\n                                'source_list': mcast_source_ip,\n                                'start_group_address': mcast_ip,\n                                'source_address': stream_source_ip,\n                                'destination_address': stream_destination_ip}\n\n        if streamblock_info:\n            return streamblock_info\n        else:\n            return None\n\n    def get_streamblock_info(self, port_name=None, vlan_id=None, **kwargs):\n        \"\"\"\n        Creates dictionary of streamblocks and its multicast configuration information and returns the same\n        This Function gets the portname and vlanid and returns the streamblocks and only thier multicast config info like\n        start group address, group count and source IP list created in specified portname and having specified vlan ID.\n\n        :param port_name: Name of the port. Make sure portname doesnt have \"//\". Ex: 172.27.152.15/7/12 instead of 172.27.152.15//7/12. This is as per Cisco request.\n        :param vlan_id: vlanid of emulated device.\n        :return Returns nested dictionary of Streamblocks and thier multicast information\n\n        Usage Example:\n        tgn.get_streamblock_info(port_name=\"172.27.152.15/7/12\", vlan_id=\"6\")\n        Return Output:\n        {'P22_Static_v4_1_7_12': {'packet_rate': '10 % Line Rate',\n                                  'packet_size': '128',\n                                  'source_list': '192.0.1.0',\n                                  'start_group_address': '225.0.0.1'}}\n        \"\"\"\n        streamblock_info = dict()\n        port_index = kwargs.get('port_index')\n        vlan_index = kwargs.get('vlan_index')\n\n        mcast_device = kwargs.get('mcast_device')\n        mcast_addr_dict = kwargs.get('mcast_addr_dict')\n        if vlan_id != None:\n            vlan_id = re.sub(r\"\\D\", \"\", vlan_id)\n        else:\n            return None\n\n        for index, traffic_item_obj in enumerate(self.ixNetwork.Traffic.TrafficItem.find()):\n            traffic_item_json = self._get_json_trafficitem(index)\n            high_level_stream_list = traffic_item_json['highLevelStream']\n            endpointset_list = traffic_item_json['endpointSet']\n\n            for _, high_level_stream_obj in enumerate(high_level_stream_list):\n                if 'txPortId' in high_level_stream_obj:\n                    streamblock_info = self._process_stream_block(high_level_stream_obj, endpointset_list[0],\n                                                                     traffic_item_obj, vlan_index, mcast_addr_dict,\n                                                                                 mcast_device)\n                    if streamblock_info:\n                        return streamblock_info\n\n    def _update_version(self, version, prepend):\n        \"\"\"\n        Internal Method to update the Multicast protocols (IGMP , MLD) version\n        :param version: Version of the Multicast protocols\n        :param prepend: Version type to be added\n        \"\"\"\n        if version == 'version2':\n            return prepend+ \"_V2\"\n        elif version == \"version1\":\n            return prepend + \"_V1\"\n        else:\n            return prepend + \"_V3\"\n\n    def _retrieve_mcast_device_details(self, device_group_obj, mcast_type):\n        \"\"\"\n        Internal Method to retrieve multicast device details\n        :param device_group_obj: Device Group Object in topology\n        :param mcast_type: given multicast type\n        \"\"\"\n        if mcast_type == 'igmp':\n            return self._retrieve_igmp_device_details(device_group_obj)\n        elif mcast_type == 'mld':\n            return self._retrieve_mld_device_details(device_group_obj)\n        elif mcast_type == 'pimv4':\n            return self._retrieve_pim4_device_details(device_group_obj)\n        else:\n            return self._retrieve_pim6_device_details(device_group_obj)\n\n    def _retrieve_igmp_device_details(self, deviceGroupObj):\n        \"\"\"\n        Internal Method to get the IGMP protocol device details\n        :param deviceGroupObj: Device Group Object of IGMP\n        return IGMP protocol related details\n        \"\"\"\n        igmp_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr.Values\n        igmp_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Values\n        igmp_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values\n        igmp_versions = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().VersionType.Values\n        igmp_version_list = [self._update_version(version, \"IGMP\") for version in igmp_versions]\n        return [igmp_group_addr_values, igmp_group_addr_count, igmp_source_addr_list, igmp_version_list]\n\n    def _retrieve_mld_device_details(self, deviceGroupObj):\n        \"\"\"\n        Internal Method to get the MLD protocol device details\n        :param deviceGroupObj: Device Group Object of MLD\n        return MLD protocol related details\n        \"\"\"\n        mld_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr.Values\n        mld_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Values\n        mld_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values\n        mld_versions = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().VersionType.Values\n        mld_version_list = [self._update_version(version, \"MLD\") for version in mld_versions]\n        return [mld_group_addr_values, mld_group_addr_count, mld_source_addr_list, mld_version_list]\n\n    def _retrieve_pim4_device_details(self, deviceGroupObj):\n        \"\"\"\n        Internal Method to get the PIMv4 protocol device details\n        :param deviceGroupObj: Device Group Object of PIMv4\n        return PIMv4 protocol related details\n        \"\"\"\n        pimv4_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupV4Address.Values\n        pimv4_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupAddressCount.Values\n        pimv4_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.SourceV4Address.Values\n        pimv4_versions = [\"PIMv4\"] * len(pimv4_group_addr_count)\n        return [pimv4_group_addr_values, pimv4_group_addr_count, pimv4_source_addr_list, pimv4_versions]\n\n    def _retrieve_pim6_device_details(self, deviceGroupObj):\n        \"\"\"\n        Internal Method to get the PIMv6 protocol device details\n        :param deviceGroupObj: Device Group Object of PIMv6\n        return PIMv6 protocol related details\n        \"\"\"\n        pimv6_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupV6Address.Values\n        pimv6_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupAddressCount.Values\n        pimv6_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.SourceV6Address.Values\n        pimv6_versions = [\"PIMv6\"] * len(pimv6_group_addr_count)\n        return [pimv6_group_addr_values, pimv6_group_addr_count, pimv6_source_addr_list, pimv6_versions]\n\n    def _create_json_trafficitem(self):\n        \"\"\"\n        Internal Method to create Traffic Item Json\n        \"\"\"\n        traffic_xpath = '/traffic/trafficItem'\n        json_str = self.ixNetwork.ResourceManager.ExportConfig([traffic_xpath+\"/descendant-or-self::*\"], True, \"json\")\n        self.trafficitem_json = json.loads(json_str)\n\n    def _get_json_trafficitem(self, index):\n        \"\"\"\n        Internal Method to get Traffic Item Json\n        :param index: Represents traffic item index\n        \"\"\"\n        return self.trafficitem_json['traffic']['trafficItem'][index]\n\n    def get_mcast_tgn_info(self, **kwargs):\n        \"\"\"\n        Get the emulated device, streamblock info for a given port and vlan combination\n\n        eg of the output:- {'172.27.152.15/7/1': {'vlan1': {'P14_SM_V4_Static_VRF1_7_1': {'igmp': {'group_count': '2500',\n                                                                        'source_list': '192.0.1.0',\n                                                                        'start_group_address': '225.0.0.1',\n                                                                        'version': 'version2'}},\n                                 'streamblock': {'P14_SM_V4_VRF1_STATIC_7_1': {'group_count': '2500',\n                                                                               'packet_rate': '1004.0 framesPerSecond',\n                                                                               'packet_size': '128',\n                                                                               'source_list': '192.0.1.0',\n                                                                               'start_group_address': '225.0.0.1'}}}}}\n        return: Dictionary of emulated devices and stream block info\n        \"\"\"\n        port_names_list = self.get_list_port_name()\n        topology_dict = {}\n        vports_dict = {}\n\n        for port_name, topology_obj in product(port_names_list, self.ixNetwork.Topology.find()):\n            vport_href = self.ixNetwork.Vport.find(Name=port_name).href\n            if vport_href in topology_obj.Vports:\n                topology_dict[port_name] = topology_obj\n                vports_dict[port_name] = vport_href\n\n\n        self._create_json_trafficitem()\n        igmp_mld_obj_dict = {}\n        mapping_dict = dict()\n\n        for port_name, topology_obj in topology_dict.items():\n            if port_name not in mapping_dict:\n                mapping_dict.update({port_name: {}})\n            if port_name not in igmp_mld_obj_dict:\n                igmp_mld_obj_dict.update({port_name: {}})\n\n            for device_group_obj in topology_obj.DeviceGroup.find():\n                if device_group_obj.Name not in mapping_dict[port_name]:\n                    mapping_dict[port_name].update({device_group_obj.Name: {}})\n                vport_count = topology_obj.PortCount\n                vports_obj_list = topology_obj.Ports\n\n                vlan_list = device_group_obj.Ethernet.find().Vlan.find().VlanId.Values\n                vlan_split_count = len(vlan_list) // vport_count\n                port_index = (vports_obj_list.index(vports_dict[port_name]))\n                length_to_split = [vlan_split_count] * vport_count\n                vlan_id_list = iter(vlan_list)\n                vlan_id_split_list = [list(islice(vlan_id_list, elem)) for elem in length_to_split]\n                vlan_list = vlan_id_split_list[port_index]\n                vlan_list = list(set(vlan_list))  ## TODO\n                mapping_dict[port_name][device_group_obj.Name].update(\n                    {'vlan': dict(zip(range(len(vlan_list)), (vlan_list)))})\n\n                mcast_deviceobj_dict = {}\n                if device_group_obj.Ethernet.find().Ipv4.find():\n                    if len(device_group_obj.Ethernet.find().Ipv4.find().IgmpHost.find()) > 0:\n                        mcast_deviceobj_dict.update({'igmp': device_group_obj})\n                        mapping_dict[port_name][device_group_obj.Name].update({'igmp': {}})\n\n                    if len(device_group_obj.Ethernet.find().Ipv4.find().PimV4Interface.find()) > 0:\n                        mcast_deviceobj_dict.update({'pimv4': device_group_obj})\n                        mapping_dict[port_name][device_group_obj.Name].update({'pimv4': {}})\n\n                if device_group_obj.Ethernet.find().Ipv6.find():\n                    if len(device_group_obj.Ethernet.find().Ipv6.find().MldHost.find()) > 0:\n                        mcast_deviceobj_dict.update({'mld': device_group_obj})\n                        mapping_dict[port_name][device_group_obj.Name].update({'mld': {}})\n\n                    if len(device_group_obj.Ethernet.find().Ipv6.find().PimV6Interface.find()) > 0:\n                        mcast_deviceobj_dict.update({'pimv6': device_group_obj})\n                        mapping_dict[port_name][device_group_obj.Name].update({'pimv6': {}})\n\n                group_addr_values = []\n                group_addr_count = []\n                source_addr_list = []\n                version_list = []\n\n\n                for key, device_group_obj in mcast_deviceobj_dict.items():\n                    group_addr_values, group_addr_count, source_addr_list, version_list = \\\n                        self._retrieve_mcast_device_details(device_group_obj, key)\n                    if len(vlan_list) < len(group_addr_values):\n                        vlan_list = vlan_list * int(len(group_addr_values) / len(vlan_list))\n                        port_index = 0\n                    vlan_len = len(vlan_list)\n                    start_index = port_index * vlan_len\n                    end_index = (port_index + 1) * vlan_len\n\n                    group_addr_count = group_addr_count[start_index:end_index]\n                    source_addr_list = source_addr_list[start_index:end_index]\n                    group_addr_values = group_addr_values[start_index:end_index]\n                    version_list = version_list[start_index:end_index]\n\n                    mapping_dict[port_name][device_group_obj.Name][key].update(\n                        {key + '_group_addr_count': dict(zip(range(len(group_addr_count)), group_addr_count))})\n                    mapping_dict[port_name][device_group_obj.Name][key].update(\n                        {key + '_source_addr_list': dict(zip(range(len(source_addr_list)), source_addr_list))})\n                    mapping_dict[port_name][device_group_obj.Name][key].update(\n                        {key + '_group_addr_values': dict(zip(range(len(group_addr_values)), group_addr_values))})\n                    mapping_dict[port_name][device_group_obj.Name][key].update(\n                        {key + '_version_list': dict(zip(range(len(version_list)), version_list))})\n\n\n        for port_name in mapping_dict.keys():\n            for device_name in mapping_dict[port_name].keys():\n                for mcast_device in mapping_dict[port_name][device_name].keys():\n                    group_count = mcast_device + '_group_addr_count'\n                    source_addr = mcast_device + '_source_addr_list'\n                    group_addr = mcast_device + '_group_addr_values'\n                    version = mcast_device + '_version_list'\n\n                    for vlan_index, vlan_id in mapping_dict[port_name][device_name]['vlan'].items():\n                        if 'vlan' + vlan_id not in igmp_mld_obj_dict[port_name]:\n                            igmp_mld_obj_dict[port_name].update({'vlan' + vlan_id: {}})\n\n                        if device_name not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():\n                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({device_name: {}})\n\n                        if mcast_device != 'vlan' and mcast_device not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id][\n                            device_name].keys():\n                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name].update({mcast_device: {}})\n\n                        port_index = port_names_list.index(port_name)\n\n                        if mcast_device != 'vlan' and len(mapping_dict[port_name][device_name][mcast_device]) > 0:\n                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name][mcast_device] = \\\n                                {'group_count': mapping_dict[port_name][device_name][mcast_device][group_count][\n                                    vlan_index],\n                                 'source_list': mapping_dict[port_name][device_name][mcast_device][source_addr][\n                                     vlan_index],\n                                 'start_group_address': mapping_dict[port_name][device_name][mcast_device][group_addr][\n                                     vlan_index],\n                                 'version': mapping_dict[port_name][device_name][mcast_device][version][vlan_index],\n                                 }\n                        if 'streamblock' not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():\n                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({'streamblock': {}})\n                        if mcast_device != 'vlan':\n                            streamblock = self.get_streamblock_info(port_name=port_name, vlan_id=vlan_id, vlan_index=vlan_index,\n                                                          port_index=port_index,\n                                                          mcast_device=mcast_device,\n                                                          mcast_addr_dict=mapping_dict[port_name][device_name])\n                            if streamblock:\n                                if igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock']:\n                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'].update(streamblock.items())\n                                else:\n                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'] = streamblock\n\n        return igmp_mld_obj_dict\n\n    def get_dhcp_session_info(self, device, protocol='ipv4'):\n        \"\"\"\n        Retrieves the DHCP session info for a given device\n\n        :param device: The name of the device as seen in the GUI\n        :param protocol: retrieves either the v4 'ipv4' or v6 'ipv6' session info\n        :return: The DHCP session info on success, exception on failure\n        \"\"\"\n        dhcpSessionDict = {}\n        if protocol == 'ipv4':\n            try:\n                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find()\n            except:\n                raise IxiaConfigException(\"DHCP Server config is not present on this device : '%s' \" % device)\n        else:\n            try:\n                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find()\n            except:\n                raise IxiaConfigException(\"DHCP Server config is not present on this device : '%s' \" % device)\n        sessionInfoList = dhcpserversessions.SessionInfo\n        for sessionIndex in range(0, len(sessionInfoList)):\n            sessionId = 'Session ' + str(sessionIndex + 1)\n            dhcpSessionDict[sessionId] = sessionInfoList[sessionIndex]\n        return dhcpSessionDict\n\n    def set_dhcp_server(self, device, cfg_dict, protocol='ipv4'):\n        \"\"\"\n        Configures a DHCP server based on a given dict of attributes\n\n        :param device: The name of the DHCP server device as seen in the GUI\n        :param protocol: Can be 'ipv4' or 'ipv6'\n        :param cfg_dict: The dictionary of attributes to be used for configuration\n            lease_time (int): The desired lease time\n            pool_start_addr (str): Starting IP address for DHCP pools\n            pool_incr_addr (str): Increment for pool_start_addr\n            pool_host_count (int): The host count for address leasing\n            pool_host_incr (int): Increment for pool_host_count\n\n        :return: True on success, exception on failure\n        \"\"\"\n\n        if protocol == 'ipv4':\n            try:\n                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find().Dhcp4ServerSessions\n            except:\n                raise IxiaConfigException(\"DHCP Server config is not present on this device : '%s' \" % device)\n        else:\n            try:\n                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find().Dhcp6ServerSessions\n            except:\n                raise IxiaConfigException(\"DHCP Server config is not present on this device : '%s' \" % device)\n        dhcpServersessions.DefaultLeaseTime.Single(cfg_dict.get('lease_time', None))\n        dhcpServersessions.IpAddress.Increment(start_value=cfg_dict.get('pool_start_addr', None),\n                                               step_value=cfg_dict.get('pool_start_step', None))\n        dhcpServersessions.IpAddressIncrement.Increment(start_value=cfg_dict.get('pool_incr_addr', None),\n                                                        step_value=cfg_dict.get('pool_incr_step', None))\n        dhcpServersessions.PoolSize.Increment(start_value=cfg_dict.get('pool_host_count', None),\n                                              step_value=cfg_dict.get('pool_host_incr', None))\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def set_bgp_med(self, router_id, med, route_block_name=None, ip_type=\"ipv4\"):\n        \"\"\"\n        Modify MED for the eBGP route blocks\n\n        :param med: Integer/string representing new MED value\n        :param router_id: Router ID of the device\n        :param route_block_name: route block name from config\n        :param ip_type: \"ipv4\" or \"ipv6\"\n        :return:\n        \"\"\"\n        self.log.info(\"setting MED value\")\n        result = False\n        device = None\n        if route_block_name == None:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroup.RouterData.find():\n                    if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                        device = deviceGroup\n                        indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)\n                        break\n                else:\n                    self.log.info(\"Router Configuration doesn't found on this device group '%s'\"%(deviceGroup.Name))\n            if device and device.NetworkGroup.find():\n                for networkGroup in device.NetworkGroup.find():\n                    networkMultiplier = networkGroup.Multiplier\n                    enableList = ['True'] * networkMultiplier\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()\n                            if networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():\n                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()\n\n                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values\n                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList\n                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)\n\n                            medValueList = bgpIpRoute.MultiExitDiscriminator.Values\n                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med] * networkMultiplier\n                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)\n                            result = True\n                        except:\n                            pass\n                    else:\n                        try:\n                            if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():\n                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()\n                            if networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():\n                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()\n\n                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values\n                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList\n                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)\n\n                            medValueList =bgpIpRoute.MultiExitDiscriminator.Values\n                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med]*networkMultiplier\n                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)\n                            result = True\n                        except:\n                            pass\n            else:\n                self.log.error(\"Network Group Configuration doesn't found on this device group '%s'\" % (deviceGroup.Name))\n        if route_block_name:\n            if ip_type.lower() == \"ipv4\":\n                try:\n                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + route_block_name + '$').Ipv4PrefixPools.find().href\n                except:\n                    raise IxiaConfigException(\"Network group name '%s' not found for Ip version '%s'\"%(route_block_name,ip_type))\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.href in networkGroupObj:\n                        for ipv4PoolObj in deviceGroupObj.NetworkGroup.find().Ipv4PrefixPools.find():\n                            if ipv4PoolObj.BgpIPRouteProperty.find():\n                                result = True\n                                bgpV4Route = ipv4PoolObj.BgpIPRouteProperty.find()\n                            if ipv4PoolObj.BgpV6IPRouteProperty.find():\n                                result = True\n                                bgpV4Route = ipv4PoolObj.BgpV6IPRouteProperty.find()\n                            bgpV4Route.EnableMultiExitDiscriminator.Single(True)\n                            bgpV4Route.MultiExitDiscriminator.Single(med)\n            else:\n                try:\n                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().href\n                except:\n                    raise IxiaConfigException(\"Network group name '%s' not found for Ip version '%s'\"%(route_block_name,ip_type))\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.href in networkGroupObj:\n                        for ipv6PoolObj in deviceGroupObj.NetworkGroup.find().Ipv6PrefixPools.find():\n                            if ipv6PoolObj.BgpV6IPRouteProperty.find():\n                                result = True\n                                bgpV6Route = ipv6PoolObj.BgpV6IPRouteProperty.find()\n                            if ipv6PoolObj.BgpIPRouteProperty.find():\n                                result = True\n                                bgpV6Route = ipv6PoolObj.BgpIPRouteProperty.find()\n                            bgpV6Route.EnableMultiExitDiscriminator.Single(True)\n                            bgpV6Route.MultiExitDiscriminator.Single(med)\n\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        if result:\n            return result\n        else:\n            self.log.error(\"Failed due to the config issue\")\n            return result\n\n    def set_bgp_local_preference(self, router_id, local_preference, route_block_name=None, ip_type=\"ipv4\"):\n        \"\"\"\n        Modify local preference for the iBGP route blocks\n\n        :param local_preference: Integer/string representing new local preference. Ex: 100\n        :param router_id: Router ID of the device. Ex: 1.1.1.1\n        :param route_block_name: route block name from config. Ex: ipv4routerblock101\n        :param ip_type: \"ipv4\" or \"ipv6\"\n        :return:\n        \"\"\"\n        self.log.info(\"setting local_preference value\")\n        result = True\n        if route_block_name == None:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                    device = deviceGroup\n                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)\n                    break\n\n            for networkGroup in device.NetworkGroup.find():\n                networkMultiplier = networkGroup.Multiplier\n                enableList = ['True'] * networkMultiplier\n                if ip_type.lower() == \"ipv4\":\n                    try:\n                        if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                            bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()\n\n                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values\n                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList\n                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)\n\n                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values\n                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier\n                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)\n                    except:\n                        pass\n                else:\n                    try:\n                        if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():\n                            bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()\n\n                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values\n                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList\n                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)\n\n                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values\n                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier\n                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)\n                    except:\n                        pass\n        if route_block_name:\n            if ip_type.lower() == \"ipv4\":\n                try:\n                    bgpV4Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv4PrefixPools.find().BgpIPRouteProperty.find()\n                    bgpV4Route.EnableLocalPreference.Single(True)\n                    bgpV4Route.LocalPreference.Single(local_preference)\n                except:\n                    result = False\n            else:\n                try:\n                    bgpV6Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().BgpIPRouteProperty.find()\n                    bgpV6Route.EnableLocalPreference.Single(True)\n                    bgpV6Route.LocalPreference.Single(local_preference)\n                except:\n                    result = False\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return result\n\n    def _bgp_asn_type(self, bgpObj, asn, dutAsn, index_value):\n        \"\"\"\n        Internal function used by set_bgp_asn API .Configure type of BGP based on asn and dut_asn value.\n\n        :param bgpObj: BGP Object\n        :param asn: Ex: 100\n        :param dutAsn: Ex: 100\n        :param index_value: Ex: 1\n        :return:\n        \"\"\"\n        if dutAsn and asn:\n            bgpTypeList = bgpObj.Type.Values\n            if int(asn) != int(dutAsn):\n                bgpTypeList[index_value] = 'external'\n            else:\n                bgpTypeList[index_value] = 'internal'\n            bgpObj.Type.ClearOverlays()\n            bgpObj.Type.ValueList(bgpTypeList)\n        if dutAsn and asn is None:\n            for asn in bgpObj.LocalAs2Bytes.Values:\n                if int(asn) != int(dutAsn):\n                    bgpObj.Type.Single('external')\n                else:\n                    bgpObj.Type.Single('internal')\n\n    def set_bgp_asn(self, router_id, asn=None, dut_asn=None):\n        \"\"\"\n        Modify AS number on BGP devices.\n        Note: First set ASPATH and then modify ASN if changing from IBGP to EBGP.\n\n        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1\n        :param asn: AS number of the device on TGN. Ex: 100\n        :param dut_asn: NA for IXIA\n        :return:\n\n        :Example: set_bgp_asn(router_id=\"192.0.0.2\", asn=1000)\n        \"\"\"\n        self.log.info(\"setting asn value\")\n        deviceGroupObj = None\n        for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n            if deviceGroup.RouterData.find():\n                if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                    deviceGroupObj = deviceGroup\n                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)\n                    break\n        if deviceGroupObj:\n            try:\n                if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                        asnValueList = bgpObj.LocalAs2Bytes.Values\n                        asnValueList[indexValue] = asn\n                        bgpObj.LocalAs2Bytes.ClearOverlays()\n                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)\n                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)\n            except:\n                pass\n\n            try:\n                if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():\n                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():\n                        asnValueList = bgpObj.LocalAs2Bytes.Values\n                        asnValueList[indexValue] = asn\n                        bgpObj.LocalAs2Bytes.ClearOverlays()\n                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)\n                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)\n            except:\n                pass\n        else:\n            raise IxiaConfigException(\"Router Id '%s' not found on this configuration.\" % router_id)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n    def _config_bgp_aspath(self, ipPoolsObj, aspath, ipType):\n        \"\"\"\n        Configure BGP Aspath\n        :param ipPoolsObj: Ipv4/Ipv6 Prefix Pool Object\n        :param aspath: asPath value\n        :param ipType: v4/v6\n        :return:\n        \"\"\"\n        if ipType == \"v4\":\n            if ipPoolsObj.BgpIPRouteProperty.find():\n                for bgpIpRoute in ipPoolsObj.BgpIPRouteProperty.find():\n                    bgpIpRoute.Stop()\n                    bgpIpRoute.OverridePeerAsSetMode.Single(\"True\")\n                    bgpIpRoute.EnableAsPathSegments.Single(\"True\")\n                    bgpIpRoute.AsSetMode.Single(\"dontincludelocalas\")\n                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():\n                        pathSegmentObj.SegmentType.Single(\"asseq\")\n                    if aspath:\n                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(aspath)\n                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),\n                                                        aspath):\n                            bgpAspath.AsNumber.Single(pathValue)\n                    else:\n                        self.log.info(\"Aspath passed as null, not configured Aspath\")\n                    bgpIpRoute.Start()\n        else:\n            if ipPoolsObj.BgpV6IPRouteProperty.find():\n                for bgpIpRoute in ipPoolsObj.BgpV6IPRouteProperty.find():\n                    bgpIpRoute.Stop()\n                    bgpIpRoute.OverridePeerAsSetMode.Single(\"True\")\n                    bgpIpRoute.EnableAsPathSegments.Single(\"True\")\n                    bgpIpRoute.AsSetMode.Single(\"dontincludelocalas\")\n                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():\n                        pathSegmentObj.SegmentType.Single(\"asseq\")\n                    if aspath:\n                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(\n                            aspath)\n                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),\n                                                        aspath):\n                            bgpAspath.AsNumber.Single(pathValue)\n                    else:\n                        self.log.info(\"Aspath passed as null, not configured Aspath\")\n                    bgpIpRoute.Start()\n        return True\n\n    def set_bgp_aspath(self, router_id, aspath=[], route_block_name=None, ip_type=\"ipv4\"):\n        \"\"\"\n        Modify AS path on BGP route blocks\n\n        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1\n        :param aspath: AS path to be set on TGN for the route_block. Ex: [10,20,30]\n        :param route_block_name: BGP route block name under the BGP device. Ex: \"ipv4routeblock101\"\n        :param ip_type: \"ipv4\" or \"ipv6\"\n        :return: True or raise exception\n        \"\"\"\n        self.log.info(\"setting BGP AP path value\")\n        deviceGroupObj = None\n        result = False\n        if route_block_name is None:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroup.RouterData.find():\n                    if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                        deviceGroupObj = deviceGroup\n                        break\n            if deviceGroupObj.NetworkGroup.find():\n                for networkGroup in deviceGroupObj.NetworkGroup.find():\n                    if ip_type.lower() == \"ipv4\":\n                        if networkGroup.Ipv4PrefixPools.find():\n                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()\n                            result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v4\")\n                        if networkGroup.Ipv6PrefixPools.find():\n                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()\n                            result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v4\")\n                    if ip_type.lower() == 'ipv6':\n                        if networkGroup.Ipv6PrefixPools.find():\n                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()\n                            result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v6\")\n                        if networkGroup.Ipv4PrefixPools.find():\n                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()\n                            result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v6\")\n\n        if route_block_name and router_id:\n            if type(route_block_name) is list:\n                routeBlockNameList = route_block_name\n            else:\n                routeBlockNameList = [route_block_name]\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroup.RouterData.find():\n                    if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                        deviceGroupObj = deviceGroup\n                        break\n            if deviceGroupObj:\n                for routeBlockName in routeBlockNameList:\n                    if ip_type.lower() == \"ipv4\":\n                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):\n                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):\n                                if networkGroupObj.Ipv4PrefixPools.find():\n                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()\n                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v4\")\n                                if networkGroupObj.Ipv6PrefixPools.find():\n                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()\n                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v4\")\n                    else:\n                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):\n                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):\n                                if networkGroupObj.Ipv6PrefixPools.find():\n                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()\n                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v6\")\n                                if networkGroupObj.Ipv4PrefixPools.find():\n                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()\n                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, \"v6\")\n        if result:\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n            return result\n        else:\n            raise IxiaConfigException(\n                \"Failed due to configuration issue, Please check RouterId/Route Block Name/IpType\")\n\n    def enable_ecn(self, traffic_item, reserved):\n        \"\"\"\n        The API is to enable ECN bits on  ipv4 or ipv6 stream\n\n        :param traffic_item: Name of the stream on which ECN bit is to be enabled\n        :param reserved: Reserved bits\n        :return: None\n\n        \"\"\"\n        self.log.info(\"Changing ECN value for the traffic item\")\n        reserved = int(reserved, 2)\n        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item+'$')\n        if not trafficItemObj:\n            raise IxiaConfigException(\"Traffic item not found\")\n        if trafficItemObj.ConfigElement.find().Stack.find(DisplayName=\"IPv4\"):\n            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=\"IPv4\")\n            if headerHandle.Field.find(Name='default_phb').ActiveFieldChoice == True:\n                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved\n            elif headerHandle.Field.find(Name='class_selector_phb').ActiveFieldChoice == True:\n                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.classSelectorPHB.unused').FieldValue = reserved\n            elif headerHandle.Field.find(Name='assured_forwarding_phb').ActiveFieldChoice == True:\n                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.assuredForwardingPHB.unused').FieldValue = reserved\n            elif headerHandle.Field.find(Name='expedited_forwarding_phb').ActiveFieldChoice == True:\n                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.expeditedForwardingPHB.unused').FieldValue = reserved\n            else:\n                headerHandle.Field.find(Name='default_phb').ActiveFieldChoice = True\n                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved\n        elif trafficItemObj.ConfigElement.find().Stack.find(DisplayName=\"IPv6\"):\n            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=\"IPv6\")\n            headerHandle.Field.find(Name='trafficClass').FieldValue = reserved\n        else:\n            raise IxiaConfigException(\"IPV4/V6 stack not configured on traffic item\")\n\n    def retrieve_per_prefix_frame_loss(self, ip_type=\"ipv4\", show_all=False, traffic_item_list=None):\n        \"\"\"\n        API to retrieve per prefix frame-loss (Provided by Spirent vendor).\n        On Spirent, a stream can have max 4000 flows and a dynamic result view\n        can show upto 2000 entries only.\n        Once a user-defined view is created, pages of 2000 entries need to be\n        scanned to get the least loss and most loss for the flows.\n\n        :param ip_type: If prefix is ipv4 or ipv6.\n        :param show_all: True/False\n        :param traffic_item_list: list of traffic items on which stats to be retrieved\n        :return: Dictionary containing loss prefixes with loss duration\n        Examples:\n                retrieve_per_prefix_frame_loss()\n                retrieve_per_prefix_frame_loss(\"ipv6\",show_all=False)\n                retrieve_per_prefix_frame_loss(\"ipv4\",show_all=True)\n                retrieve_per_prefix_frame_loss(\"ipv4\",show_all= True, traffic_item_list=['Traffic_item1'])\n        \"\"\"\n        prefixesLossDict = {}\n        drildownIndex = 0\n        prefixBaseStats = None\n        all_traffic_items = self.get_traffic_items()\n\n        if not traffic_item_list:\n            traffic_item_list = self.get_active_streams()\n\n            if ip_type.lower() == \"ipv4\":\n                for item in all_traffic_items:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == \"ipv6\":\n                        try:\n                            traffic_item_list.remove(item)\n                        except:\n                            pass\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == \"raw\":\n                        if 'ipv4DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(\n                                Name='^' + item + '$').Tracking.find().TrackBy:\n                            try:\n                                traffic_item_list.remove(item)\n                            except:\n                                pass\n\n            if ip_type.lower() == \"ipv6\":\n                for item in all_traffic_items:\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == \"ipv4\":\n                        try:\n                            traffic_item_list.remove(item)\n                        except:\n                            pass\n                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == \"raw\":\n                        if 'ipv6DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(\n                                Name='^' + item + '$').Tracking.find().TrackBy:\n                            try:\n                                traffic_item_list.remove(item)\n                            except:\n                                pass\n\n        log.info(f\"processing traffic items :: {traffic_item_list}\")\n        trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')\n        rowList = [rowNumber for rowNumber, stat in enumerate(trafficItemStats.Rows) if\n                   stat['Traffic Item'] in traffic_item_list]\n        for rowIndex in rowList:\n            trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')\n            if ip_type == \"ipv4\":\n                destType = 'IPv4 :Destination Address'\n            else:\n                destType = 'IPv6 :Destination Address'\n\n            for _ in range(3):\n                try:\n                    prefixBaseStats = trafficItemStats.Drilldown(rowIndex,\n                                                                 trafficItemStats.DrillDownOptions(rowIndex)[\n                                                                     drildownIndex],\n                                                                 trafficItemStats.TargetRowFilters()[rowIndex])\n                    break\n                except Exception as e:\n                    log.info(f\"failed with error {e} \\\\n\\\\nretrying\")\n                    time.sleep(10)\n\n\n            if prefixBaseStats:\n                trafficHeadersList = prefixBaseStats.ColumnHeaders\n                trafficPrefixStatsDict = []\n                for rowNumber, stat in enumerate(prefixBaseStats.Rows):\n                    headerDict = {}\n                    for column in trafficHeadersList:\n                        if destType == column or column == 'Packet Loss Duration (ms)':\n                            headerDict[column] = stat[column]\n                            trafficPrefixStatsDict.append(headerDict)\n\n                for trafficdict in trafficPrefixStatsDict:\n                    try:\n                        prefixIp = trafficdict[destType]\n                        lossDuration = trafficdict['Packet Loss Duration (ms)']\n                        if show_all:\n                            prefixesLossDict.update({prefixIp: lossDuration})\n                        else:\n                            if int(float(lossDuration)) != 0:\n                                prefixesLossDict.update({prefixIp: lossDuration})\n                    except Exception as e:\n                        if drildownIndex == 0:\n                            drildownIndex = drildownIndex + 1\n                        log.info(f\"failed with error {e}\")\n                        break\n            else:\n                raise IxiaConfigException(\"Failed at drill down\")\n        if prefixesLossDict:\n            return prefixesLossDict\n        else:\n            raise IxiaConfigException(\"%s type Traffic stream not found\" % ip_type)\n\n    def get_arp_status(self, devices=None):\n        \"\"\"\n        Get ARP/ND status for All/specific devices\n        :param devices: list of devices' router IDs and/or names\n        :return: arp status for each device. Ex: {'192.0.0.20': 'FAILED', 'TestDeviceLDP1': 'FAILED'}\n        \"\"\"\n        arpStatus = {}\n        if not devices:\n            log.info(\"Devices arg not passed. Fetching all devices from config\")\n            devices = [device.Name for device in self.ixNetwork.Topology.find().DeviceGroup.find()]\n        for device in devices:\n            try:\n                if '.' in device:\n                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                        routerIdIndex = None\n                        for routerDataObj in deviceObj.RouterData.find():\n                            if device in routerDataObj.RouterId.Values:\n                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)\n                                break\n                        if routerIdIndex is not None:\n                            resolveGatewayList = deviceObj.Ethernet.find().Ipv4.find().ResolvedGatewayMac\n                            if \"Unresolved\" in resolveGatewayList[routerIdIndex]:\n                                arpStatus[device] = 'Failed'\n                            else:\n                                arpStatus[device] = 'Resolved'\n                else:\n                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv4.find().ResolvedGatewayMac\n                    if \"Unresolved\" in resolveGatewayList[0]:\n                        arpStatus[device] = 'Failed'\n                    else:\n                        arpStatus[device] = 'Resolved'\n            except:\n                pass\n            try:\n                if '.' in device:\n                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                        routerIdIndex = None\n                        for routerDataObj in deviceObj.RouterData.find():\n                            if device in routerDataObj.RouterId.Values:\n                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)\n                                break\n                        if routerIdIndex is not None:\n                            resolveGatewayList = deviceObj.Ethernet.find().Ipv6.find().ResolvedGatewayMac\n                            if \"Unresolved\" in resolveGatewayList[routerIdIndex]:\n                                arpStatus[device] = 'Failed'\n                            else:\n                                arpStatus[device] = 'Resolved'\n                else:\n                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv6.find().ResolvedGatewayMac\n                    if \"Unresolved\" in resolveGatewayList[0]:\n                        arpStatus[device] = 'Failed'\n                    else:\n                        arpStatus[device] = 'Resolved'\n            except:\n                pass\n        return arpStatus\n\n    def get_worst_flows(self, sort_by=\"Dropped Frame\", traffic_items=None, size=10):\n        \"\"\"\n        Creates a new DRV and grabs the 10 worst flows\n\n        Code is a modified version that was initially provided by Spirent (Matt Jefferson)\n        :param sort_by: which property to sort Dynamic Result View\n            \"Dropped Frame\"\n            \"Dropped Frame Duration\"\n        :param traffic_items: List of traffic items that interested to view it. Default is None, which will view\n                            all flows that meet the conditions limited by size\n        :param size: number flows per item.\n        :return: A list of dictionaries on success, exception on failure\n        \"\"\"\n        worstFlows = []\n        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)\n        flowHeadersList = flowStats.ColumnHeaders\n        flowStatHeaderValues = []\n        for rowNumber, stat in enumerate(flowStats.Rows):\n            headerDict = {}\n            for column in flowHeadersList:\n                headerDict[column] = stat[column]\n            flowStatHeaderValues.append(headerDict)\n        if traffic_items:\n            trafficItemList = []\n            for trafficItemName in traffic_items:\n                for trafficItemDict in flowStatHeaderValues:\n                    for key,value in trafficItemDict.items():\n                        if value == trafficItemName:\n                            trafficItemList.append(trafficItemDict)\n        else:\n            trafficItemList = flowStatHeaderValues\n        sortedTrafficItemsDict = dict()\n        if sort_by == \"Dropped Frame\":\n            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: int(trafficItem.get('Frames Delta')),reverse=True)\n        if sort_by == \"Dropped Frame Duration\":\n            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: float(trafficItem.get('Packet Loss Duration (ms)')),reverse=True)\n        for trafficItemIndex in range(0,len(sortedTrafficItemsDict)):\n            if trafficItemIndex < size:\n                worstFlows.append(sortedTrafficItemsDict[trafficItemIndex])\n        if worstFlows:\n            return worstFlows\n        else:\n            raise CafyException.InvalidValueError('No results found')\n\n    def enable_traffic_minimum_size(self):\n        \"\"\"\n        API to enable to send minimum size traffic\n        :return:\n        \"\"\"\n        self.ixNetwork.Traffic.EnableMinFrameSize = True\n\n    def change_port_speed(self,port_list, speed='1G', media='fiber'):\n        \"\"\"\n        To change the speed of the port\n\n        :param port_list: list of ports\n        :param speed: type of speed 1G, 10G\n        :param media: type of media - \"fiber\" , \"copper\"\n\n        Ex: tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='1G', media='copper')\n            tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='10G')\n        \"\"\"\n        speedDictIxiaMapping = {'1G': 'speed1000','10G':'speed10g'}\n        for port in port_list:\n            for vport in self.ixNetwork.Vport.find():\n                if port.replace(\"/\",\":\") == vport.AssignedTo:\n                    cardType = vport.Type\n                    if cardType == 'novusTenGigLan':\n                        cardType = cardType[0].upper() + cardType[1:]\n                        cardObj = eval('vport.L1Config.' + cardType)\n                        cardObj.Media = media\n                        if media == 'fiber':\n                            cardObj.AutoNegotiate = False\n                        cardObj.Speed = speedDictIxiaMapping[speed]\n                    else:\n                        self.log.info(\"Skipping changing the port speed as card type is not novusTenGigLan\")\n\n    def get_frame_l3_information(self,stream_name, mode='ipv4'):\n        \"\"\"\n        Returns L3 header info for the stream requested\n\n        :param stream_name: stream name used in TGN GUI\n        :param mode: ipv4 or ipv6\n        :return: dictionary containing L3 header info\n\n        Example of data returned:\n        {'VLAN Priority': '7', 'VLAN-ID': '2', 'Precedence': '110 Internetwork Control', 'Source Address': '50.0.0.2',\n        'Destination Address': '70.0.0.2', 'TCP-Source-Port': '1024', 'TCP-Dest-Port': '1024', 'Name': 'v4-stream-2-1'}\n        \"\"\"\n        try:\n            trafficitem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')\n        except:\n            raise IxiaConfigException(\"Stream Not available\")\n\n        highlevelstream = trafficitem.HighLevelStream.find()\n        output = highlevelstream.PreviewFlowPackets(0,1)\n        l3Info = dict(zip(output['arg3'], output['arg4'][0]))\n        remove = ['Packet #', 'Destination MAC Address', 'Source MAC Address', 'Ethernet-Type', 'PFC Queue']\n        l3Info = dict([(k, v) for k, v in l3Info.items() if k not in remove])\n        l3Info['Name'] = stream_name\n        return l3Info\n\n    def add_multiple_devices(self, port_tuple=None, device_info=None, csv_file=None, new_config=True, **kwargs):\n        \"\"\"\n        API to create multiple devices in single attempt\n\n        :param port_tuple: list of ports\n        :param device_info: list of dictionary as shown in example\n        :param csv_file: csv file\n        :param new_config: boolean, True if want to clear the config else False\n\n        :Example: add_multiple_devices(port_tuple = ['10.39.64.137/1/3', '10.39.64.137/2/3', '10.39.64.137/1/5', '10.39.64.137/2/4'],\n                                       device_info = [{'port_name':'hu2_39_np0_sl0',  'device_name':'hu2_39_np0_sl0_v4',  'ipv4_address':'120.0.0.2',  'ipv4_gateway':'120.0.0.1'},\n                                                      {'port_name': 'hu2_21_np0_sl1', 'device_name': 'hu2_21_np0_sl1_v4', 'ipv4_address': '120.0.1.2', 'ipv4_gateway': '120.0.1.1'}],\n                                                      csv_file=device.csv)\n        \"\"\"\n        self.log.info(\"Adding Multiple devices\")\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n        if self.update_license == False and new_config == True:\n            self._new_session(self.user_name, self.session_name, kill_existing=True)\n        devicesInfo = list()\n        portTuple = list()\n        if csv_file:\n            devicesInfoTemp = list()\n            portTupleTemp = list()\n            with open(csv_file) as csvFile:\n                reader = csv.DictReader(csvFile)\n                for row in reader:\n                    rowAsDict = {key: value for key, value in row.items()}\n                    devicesInfoTemp.append(rowAsDict)\n\n            for deviceInfo in devicesInfoTemp:\n                portTupleTemp.append(deviceInfo['port'])\n\n            for port in portTupleTemp:\n                if port not in portTuple and port != '':\n                    portTuple.append(port)\n\n            for deviceInfo in devicesInfoTemp:\n                del deviceInfo['port']\n                devicesInfo.append(deviceInfo)\n        else:\n            devicesInfo = device_info\n            portTuple = port_tuple\n\n        if new_config:\n            self.ixNetwork.NewConfig()\n        self.ixNetwork.Traffic.UseRfc5952 = True\n        for device in devicesInfo:\n            if device['port_name'] == '':\n                continue\n            else:\n                if self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$'):\n                    topology = self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$')\n                else:\n                    topology = self.ixNetwork.Topology.add(Name=device['port_name'], Note=None, Ports=None, Vports=self.ixNetwork.Vport.add(Name=device['port_name']))\n\n                if 'subinterfaces_count' in device and device['subinterfaces_count']!= '':\n                    multiplier = device['subinterfaces_count']\n                else:\n                    multiplier = 1\n                if topology.DeviceGroup.find(Name=device['device_name']):\n                    devicegroupObj = topology.DeviceGroup.find(Name=device['device_name'])\n                    ethernetObj = devicegroupObj.Ethernet.find()\n                else:\n                    devicegroupObj = topology.DeviceGroup.add(Multiplier=multiplier, Name=device['device_name'])\n                    ethernetObj = devicegroupObj.Ethernet.add()\n\n                if 'vlan' in device and device['vlan'] != '':\n                    ethernetObj.EnableVlans.Single(True)\n                    if 'vlan_valuetype' not in device:\n                        device['vlan_valuetype'] = 'increment'\n                    if device['vlan_valuetype'] == 'custom' :\n                        ethernetObj.Vlan.find()[0].VlanId.Custom(start_value= device['vlan_start_value'],\n                                                                 step_value=device['vlan_step_value'],\n                                                                 increments=[(0, device['vlan_repeat_count'], [])])\n                    else:\n                        ethernetObj.Vlan.find()[0].VlanId.Increment(start_value=device['vlan'], step_value=1)\n\n                if 'ipv4_address' in device and device['ipv4_address'] != '':\n                    if ethernetObj.Ipv4.find():\n                        ipv4Obj = ethernetObj.Ipv4.find()\n                    else:\n                        ipv4Obj = ethernetObj.Ipv4.add()\n                    if 'ipv4_address_step' in device  and device['ipv4_address_step'] != '':\n                        step = device['ipv4_address_step']\n                    else:\n                        step = \"0.0.1.0\"\n                    ipv4Obj.Address.Increment(start_value=device['ipv4_address'], step_value=step)\n                if 'ipv4_prefix' in device and device['ipv4_prefix'] != '':\n                    ipv4Obj.Prefix.Single(device['ipv4_prefix'])\n                if 'ipv4_gateway' in device and device['ipv4_gateway'] != '':\n                    if 'ipv4_gateway_step' in device  and device['ipv4_gateway_step'] != '':\n                        step = device['ipv4_gateway_step']\n                    else:\n                        step = \"0.0.1.0\"\n                    ipv4Obj.GatewayIp.Increment(start_value=device['ipv4_gateway'], step_value=step)\n                if 'ipv4_suppress_arp_gateway' in device and device['ipv4_suppress_arp_gateway'] != '':\n                    if ethernetObj.Ipv4.find():\n                        self.ixNetwork.Globals.Topology.Ipv4.SuppressArpForDuplicateGateway.Single(device['ipv4_suppress_arp_gateway'])\n                if 'ipv6_address' in device and device['ipv6_address'] != '':\n                    if ethernetObj.Ipv6.find():\n                        ipv6Obj = ethernetObj.Ipv6.find()\n                    else:\n                        ipv6Obj = ethernetObj.Ipv6.add()\n                    if 'ipv6_address_step' in device  and device['ipv6_address_step'] != '':\n                        step = device['ipv6_address_step']\n                    else:\n                        step = \"::1:0\"\n                    ipv6Obj.Address.Increment(start_value=device['ipv6_address'], step_value=step)\n                if 'ipv6_prefix' in device and device['ipv6_prefix'] != '':\n                    ipv6Obj.Prefix.Single(device['ipv6_prefix'])\n                if 'ipv6_gateway' in device and device['ipv6_gateway'] != '':\n                    if 'ipv6_gateway_step' in device  and device['ipv6_gateway_step'] != '':\n                        step = device['ipv6_gateway_step']\n                    else:\n                        step = \"::1:0\"\n                    ipv6Obj.GatewayIp.Increment(start_value=device['ipv6_gateway'], step_value=step)\n                if 'ipv6_suppress_ns_gateway' in device and device['ipv6_suppress_ns_gateway'] != '':\n                    if ethernetObj.Ipv6.find():\n                        self.ixNetwork.Globals.Topology.Ipv6.SuppressNsForDuplicateGateway.Single(device['ipv6_suppress_ns_gateway'])\n\n                igmpKwargs = {key: device[key] for key in device if \"igmp\" in key and device[key] != \"\"}\n                mldKwargs = {key: device[key] for key in device if \"mld\" in key and device[key] != \"\"}\n                ospfv2Kwargs = {key: device[key] for key in device if \"ospf_v2\" in key and device[key] != \"\"}\n                ospfv3Kwargs = {key: device[key] for key in device if \"ospf_v3\" in key and device[key] != \"\"}\n                ldpv4Kwargs = {key: device[key] for key in device if \"ldp_v4\" in key and device[key] != \"\"}\n                ldpv6Kwargs = {key: device[key] for key in device if \"ldp_v6\" in key and device[key] != \"\"}\n                bgpv4Kwargs = {key: device[key] for key in device if \"bgp_v4\" in key and device[key] != \"\"}\n                bgpv6Kwargs = {key: device[key] for key in device if \"bgp_v6\" in key and device[key] != \"\"}\n                isisKwargs = {key: device[key] for key in device if \"isis\" in key and device[key] != \"\"}\n\n                # Create IGMP\n                if igmpKwargs != {}:\n                    igmpObj = IGMP(ixNetwork=self.ixNetwork,\n                                   obj=ipv4Obj,\n                                   **igmpKwargs)\n                    igmpObj.config()\n                    igmp_rate_interval = igmpKwargs.get('igmp_rate_interval', 0)\n                    devicegroup_name = devicegroupObj.Name\n                    if igmp_rate_interval:\n                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name)\n\n                # Create MLD\n                if mldKwargs != {}:\n                    mldObj = MLD(ixNetwork=self.ixNetwork,\n                                 obj=ipv6Obj,\n                                 **mldKwargs)\n                    mldObj.config()\n                    mld_rate_interval = mldKwargs.get('mld_rate_interval', 0)\n                    devicegroup_name = devicegroupObj.Name\n                    if mld_rate_interval:\n                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name)\n\n                # Create OSPFv2\n                if ospfv2Kwargs != {}:\n                    ospfv2Obj = OSPFv2(ixNetwork=self.ixNetwork,\n                                       obj=ipv4Obj,\n                                       **ospfv2Kwargs)\n                    ospfv2Obj.config()\n\n                # Create OSPFv3\n                if ospfv3Kwargs != {}:\n                    ospfv3Obj = OSPFv3(ixNetwork=self.ixNetwork,\n                                       obj=ipv6Obj,\n                                       **ospfv3Kwargs)\n                    ospfv3Obj.config()\n\n                #Create LDP on IPV4\n                if ldpv4Kwargs != {}:\n                    ldpv4Obj = LDPv4(ixNetwork=self.ixNetwork,\n                                       obj=ipv4Obj,\n                                       **ldpv4Kwargs)\n                    ldpv4Obj.config()\n\n                #Create LDP on IPV6\n                if ldpv6Kwargs != {}:\n                    ldpv6Obj = LDPv6(ixNetwork=self.ixNetwork,\n                                       obj=ipv6Obj,\n                                       **ldpv6Kwargs)\n                    ldpv6Obj.config()\n\n                # Create BGPv4\n                if bgpv4Kwargs != {}:\n                    bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork,\n                                     obj=ipv4Obj,\n                                     **bgpv4Kwargs)\n                    bgpv4Obj.config()\n\n                # Create BGPv6\n                if bgpv6Kwargs != {}:\n                    bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork,\n                                     obj=ipv6Obj,\n                                     **bgpv6Kwargs)\n                    bgpv6Obj.config()\n\n                # Create ISIS\n                if isisKwargs != {}:\n                    isisObj = ISIS(ixNetwork=self.ixNetwork,\n                                   obj=ethernetObj,\n                                   test_platform=self.test_platform,\n                                   server_type=self.tgn_server_type,\n                                   server_ip=self.server_ip,\n                                   port=self.port,\n                                   **isisKwargs)\n                    isisObj.config()\n\n        if portTuple:\n            chassisList = list()\n            portList = list()\n            for port in portTuple:\n                self.log.info(f\"Device created for: {port}\")\n                chassisListTemp = port.split('/')\n                portListTemp = port.split('/')\n                if len(chassisListTemp) < 3:\n                    chassisList.append(self.chassis_ip)\n                    portListTemp.insert(0, self.chassis_ip)\n                else:\n                    chassisList.append(port.split('/')[0])\n                portList.append(portListTemp)\n            chassisList = list(set(chassisList))\n            self.connect_to_chassis(chassisList)\n            if self.primary:\n                self.connect_to_chassis([self.primary])\n                self.set_chassis_mode(primary=self.primary, secondary=chassisList)\n            self._assign_ports(portList)\n\n    def add_multiple_traffic_streams(self, traffic_info=None, csv_file=None, **kwargs):\n        \"\"\"\n        API to create multiple traffic streams\n\n        :param traffic_info: list of dictionary [{'stream_name': 'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc',\n        'stream_type': 'Unicast', 'traffic_type': 'ipv4', 'stream_src': 'TenGigE0/2/0/0_v4',\n        'stream_dest': 'TenGigE0/2/0/1_v4', 'frame_size': '1518', 'multicast_address': '', 'bi-directional': 'FALSE',\n        'Groupname(multicast) (Eg: ipv4Group1)': '', 'Increment(Multicast)(Eg: 3:1)': '255.255.255.255', 'txLoad(%)': '100',\n        'tolerance(%)': '', 'tcp_header': 'TRUE', 'tcp_src_port': '2000', 'tcp_dst_port': '3000', 'udp_header': '',\n        'udp_src_port': '', 'udp_dst_port': '', 'throughput(%)': '', 'tos': 'Precedence'}]\n\n        :param csv_file: csv file\n        :param  stream_name'    Ex:  'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc'\n        :param   'stream_type'  Ex:  'Unicast'\n        :param   'traffic_type' Ex:  'ipv4'\n        :param   'stream_src'   Mandatory parameter Ex:  'TenGigE0/2/0/0_v4'\n        :param   'stream_dest'  Mandatory parameter Ex:  'TenGigE0/2/0/1_v4'\n        :param   'frame_size'   Ex:  '1518'\n        :param   'multicast_address'    Ex:  '255.255.255.255'\n        :param   'bi-directional'   Ex:  'FALSE'\n        :param   'Groupname(multicast)  Ex:  ipv4Group1)'\n        :param   'Increment(Multicast)  Ex: 3\n        :param   'txLoad(%)'    Ex:  '100'\n        :param   'tolerance(%)' Ex:  ''\n        :param   'tcp_header'   Ex:  'TRUE'\n        :param   'tcp_src_port' Ex:  '2000'\n        :param   'tcp_dst_port' Ex:  '3000'\n        :param   'udp_header'   Ex:  'TRUE'\n        :param   'udp_src_port' Ex:  '2000'\n        :param   'udp_dst_port' Ex:  '3000'\n        :param   'throughput(%)'Ex: '100'\n        :param   'tos' if value is from '0'-'255'\n                  IP Priority will be set to 'TOS' if 'tos' value is  from '0' to '7' or \"\"000 Routine\",\"001 Priority\",\"010 Immediate\",\"011 Flash\",\"100 Flash Override\",\"101 CRITIC/ECP\",\"110 Internetwork Control\"\n                  IP Priority will be set to 'Raw Priority' if value is from '8' to '255'\n        :param   'enable' bool\n        :param   'raw_stream_ip_stack' : ipv4 or ipv6\n        :param   'eth_src_mac' Ex: '00:00:00:00:00:01'\n        :param   'eth_dst_mac' Ex: '00:00:00:00:01:01'\n        :param   'eth_dst_mac_mode' Ex: 'INCR'\n        :param   'eth_src_mac_mode' Ex: 'INCR'\n        :param   'eth_src_mac_count' Ex: 1\n        :param   'eth_dst_mac_count' Ex: 1\n        :param   'eth_dst_mac_step' Ex: '00:00:00:00:00:01'\n        :param   'eth_src_mac_step' Ex: '00:00:00:00:00:01'\n        :param   'src_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'\n        :param   'src_count' Ex: 1\n        :param   'dst_mode' Ex: 'INCR'\n        :param   'dst_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'\n        :param   'dst_count' Ex: 1\n        :param   'dst_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'\n        :param   'src_mode' Ex: 'INCR'\n        :param   'src_count' Ex: 1\n        :param   'src_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'\n        :return:\n        \"\"\"\n        self.log.info(\"Adding Multiple Traffic Items\")\n        tos_value_list = [0, 20, 40, 60, 80, 28, 30, 38, 48, 50, 58, 68, 70, 78, 88, 90, 98]\n        trafficsItemInfo = list()\n\n        def _is_ip(value):\n\n            try:\n                ipaddress.ip_address(value)\n                return True\n            except ValueError:\n                return False\n\n        if csv_file:\n            with open(csv_file) as csvFile:\n                reader = csv.DictReader(csvFile)\n                for row in reader:\n                    rowAsDict = {key: value for key, value in row.items()}\n                    trafficsItemInfo.append(rowAsDict)\n        else:\n            trafficsItemInfo = traffic_info\n\n        if traffic_info:\n            try:\n                save_dir = CafyLog.work_dir\n                os.makedirs(save_dir, exist_ok=True)\n\n                timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                save_path = os.path.join(save_dir, f\"traffic_info_{timestamp}.json\")\n\n                with open(save_path, \"w\", encoding=\"utf-8\") as f:\n                    f.write(\"# === Traffic Info Snapshot ===\\n\\n\")\n                    f.write(json.dumps(trafficsItemInfo, indent=4, ensure_ascii=False))\n\n                self.log.info(f\"Traffic info saved to: {save_path}\")\n            except Exception as e:\n                self.log.warning(f\"Failed to save traffic_info snapshot: {e}\")\n\n        for trafficItemInfo in trafficsItemInfo:\n\n            src_ip = None\n            dst_ip = None\n\n            trafficItemInfo['stream_type'] = trafficItemInfo.get('stream_type', 'Unicast')\n            if trafficItemInfo['stream_type'] == '':\n                continue\n            else:\n                trafficItemInfo['stream_name'] = trafficItemInfo['stream_name'].replace('+', r'\\+').replace('*', r'\\*')\n                if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemInfo['stream_name'] + '$'):\n                    trafficItem = self.ixNetwork.Traffic.TrafficItem.find(\n                        Name='^' + trafficItemInfo['stream_name'] + '$')\n                else:\n                    trafficItem = self.ixNetwork.Traffic.TrafficItem.add(Name=trafficItemInfo['stream_name'],\n                                                                         TrafficType=trafficItemInfo['traffic_type'],\n                                                                         BiDirectional=trafficItemInfo.get(\n                                                                             'bi-directional', False))\n                if 'enable' in trafficItemInfo:\n                    if trafficItemInfo['enable'] != '':\n                        trafficItem.Enabled = trafficItemInfo['enable']\n                sources_ip = list()\n                destinations_ip = list()\n                sources = list()\n                destinations = list()\n\n                if trafficItemInfo['stream_type'] == 'Unicast':\n\n                    if 'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] != '':\n                        if trafficItemInfo['traffic_type'] == \"raw\":\n                            if 'stream_src' not in trafficItemInfo or trafficItemInfo['stream_src'] == '':\n                                raise IxiaConfigException(\n                                    \"Please send 'stream_src' parameter value to create Raw Traffic\")\n                            else:\n                                if isinstance(trafficItemInfo['stream_src'], str):\n                                    trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]\n                                if isinstance(trafficItemInfo['stream_src'], list):\n                                    for src in trafficItemInfo['stream_src']:\n                                        vport_href = self.ixNetwork.Vport.find(\n                                            Name='^' + src + '$').href\n                                        sources.append(vport_href + '/protocols')\n\n                        else:\n                            sources_ip = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],\n                                                                       topology=None)\n                    else:\n                        if trafficItemInfo['traffic_type'] == \"raw\":\n                            if isinstance(trafficItemInfo['stream_src'], str):\n                                trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]\n                            if isinstance(trafficItemInfo['stream_src'], list):\n                                for src in trafficItemInfo['stream_src']:\n                                    vport_href = self.ixNetwork.Vport.find(\n                                        Name='^' + src + '$').href\n                                    sources.append(vport_href + '/protocols')\n                            else:\n                                raise IxiaConfigException(\"Port Name '%s' not found\" % trafficItemInfo['stream_src'])\n                        else:\n\n                            if isinstance(trafficItemInfo['stream_src'], str):\n                                trafficItemInfo['stream_src'] = [trafficItemInfo['stream_src']]\n\n                            sources = []\n                            for src_stream in trafficItemInfo['stream_src']:\n                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + src_stream + '$')\n                                if dg and len(dg) > 0:\n                                    sources.extend([dg_item.href for dg_item in dg])\n                                else:\n                                    self.log.warning(f\"DeviceGroup '{src_stream}' not found in topology.\")\n\n                    if 'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] != '':\n                        if trafficItemInfo['traffic_type'] == \"raw\":\n                            if 'stream_dest' not in trafficItemInfo or trafficItemInfo['stream_dest'] == '':\n                                raise IxiaConfigException(\n                                    \"Please send 'stream_dest' parameter value to create Raw Traffic\")\n                            else:\n                                if isinstance(trafficItemInfo['stream_dest'], str):\n                                    trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]\n                                if isinstance(trafficItemInfo['stream_dest'], list):\n                                    for dest in trafficItemInfo['stream_dest']:\n                                        vport_href = self.ixNetwork.Vport.find(\n                                            Name='^' + dest + '$').href\n                                        destinations.append(vport_href + '/protocols')\n                        else:\n                            destinations_ip = self._endpoint_destination_handles(trafficItemInfo['dst_ip'],\n                                                                                 destinationsList=[], topology=None)\n                    else:\n                        if trafficItemInfo['traffic_type'] == \"raw\":\n                            if isinstance(trafficItemInfo['stream_dest'], str):\n                                trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]\n                            if isinstance(trafficItemInfo['stream_dest'], list):\n                                for dest in trafficItemInfo['stream_dest']:\n                                    vport_href = self.ixNetwork.Vport.find(\n                                        Name='^' + dest + '$').href\n                                    destinations.append(vport_href + '/protocols')\n                            else:\n                                raise IxiaConfigException(\"Port Name '%s' not found\" % trafficItemInfo['stream_dest'])\n                        else:\n\n                            if isinstance(trafficItemInfo['stream_dest'], str):\n                                trafficItemInfo['stream_dest'] = [trafficItemInfo['stream_dest']]\n\n                            destinations = []\n                            for dest_stream in trafficItemInfo['stream_dest']:\n                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dest_stream + '$')\n                                if dg and len(dg) > 0:\n                                    destinations.extend([dg_item.href for dg_item in dg])\n\n                                else:\n                                    self.log.warning(f\"DeviceGroup '{dest_stream}' not found in topology.\")\n\n                    # pdb.set_trace()\n                    if all(k in trafficItemInfo for k in ('stream_src', 'stream_dest', 'src_ip', 'dst_ip')) \\\n                            and trafficItemInfo['src_ip'] and trafficItemInfo['dst_ip']:\n                        sources_ip = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],\n                                                                   topology=None)\n                        destinations_ip = self._endpoint_destination_handles(trafficItemInfo['dst_ip'],\n                                                                             destinationsList=[], topology=None)\n\n                    src_ip = trafficItemInfo.get('src_ip')\n                    dst_ip = trafficItemInfo.get('dst_ip')\n                    stream_src = trafficItemInfo.get('stream_src')\n                    stream_dest = trafficItemInfo.get('stream_dest')\n\n                    if isinstance(src_ip, str):\n                        src_ip = [src_ip]\n                    if isinstance(dst_ip, str):\n                        dst_ip = [dst_ip]\n\n                    if isinstance(stream_src, str):\n                        stream_src = [stream_src]\n                    if isinstance(stream_dest, str):\n                        stream_dest = [stream_dest]\n\n                    trafficItemInfo['src_ip'] = src_ip\n                    trafficItemInfo['dst_ip'] = dst_ip\n                    trafficItemInfo['stream_src'] = stream_src\n                    trafficItemInfo['stream_dest'] = stream_dest\n\n                    if (\n                            'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] and\n                            'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] and\n                            'raw_stream_ip_stack' not in trafficItemInfo and\n                            trafficItemInfo['traffic_type'] != 'raw' and\n                            all(_is_ip(ip) for ip in trafficItemInfo.get('src_ip', [])) and\n                            all(_is_ip(ip) for ip in trafficItemInfo.get('dst_ip', [])) and\n                            all(k in trafficItemInfo for k in ('stream_src', 'stream_dest'))\n                    ):\n                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip,\n                                                    ScalableDestinations=destinations_ip)\n\n                    elif (\n                            'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] and\n                            'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] and\n                            'raw_stream_ip_stack' not in trafficItemInfo and\n                            trafficItemInfo['traffic_type'] != 'raw' and\n                            all(_is_ip(ip) for ip in trafficItemInfo.get('src_ip', [])) and\n                            all(_is_ip(ip) for ip in trafficItemInfo.get('dst_ip', [])) and\n                            not all(k in trafficItemInfo for k in ('stream_src', 'stream_dest'))\n                    ):\n                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip,\n                                                    ScalableDestinations=destinations_ip)\n\n                    # Case 1: One-to-Many (single src_ip \u2192 all in stream_dest)\n                    if (\n                            \"src_ip\" in trafficItemInfo and trafficItemInfo[\"src_ip\"] and\n                            \"stream_dest\" in trafficItemInfo and trafficItemInfo[\"stream_dest\"] and\n                            (\"dst_ip\" not in trafficItemInfo or not trafficItemInfo[\"dst_ip\"]) and\n                            trafficItemInfo[\"traffic_type\"] in [\"ipv4\", \"ipv6\"]\n                    ):\n                        sources_ip = self._endpoint_source_handles(trafficItemInfo[\"src_ip\"], sourcesList=[],\n                                                                   topology=None)\n\n                        if isinstance(trafficItemInfo[\"stream_dest\"], str):\n                            dest_dgs = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=f\"^{trafficItemInfo['stream_dest']}$\"\n                            )\n                            destinations = list(dest_dgs)\n                        elif isinstance(trafficItemInfo[\"stream_dest\"], list):\n                            destinations = []\n                            for dest_name in trafficItemInfo[\"stream_dest\"]:\n                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f\"^{dest_name}$\")\n                                if dg:\n                                    destinations.extend(list(dg))\n\n                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sources_ip, Destinations=destinations)\n\n                    # Case 2: Many-to-One (all in stream_src -> single dst_ip)\n                    elif (\n                            \"dst_ip\" in trafficItemInfo and trafficItemInfo[\"dst_ip\"] and\n                            \"stream_src\" in trafficItemInfo and trafficItemInfo[\"stream_src\"] and\n                            (\"src_ip\" not in trafficItemInfo or not trafficItemInfo[\"src_ip\"]) and\n                            trafficItemInfo[\"traffic_type\"] in [\"ipv4\", \"ipv6\"]\n                    ):\n                        # destinations_ip = self._endpoint_destination_handles(trafficItemInfo[\"dst_ip\"], destinationsList=[], topology=None)\n\n                        if isinstance(trafficItemInfo[\"stream_src\"], str):\n                            src_dgs = self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name=f\"^{trafficItemInfo['stream_src']}$\"\n                            )\n                            sources = list(src_dgs)\n                        elif isinstance(trafficItemInfo[\"stream_src\"], list):\n                            sources = []\n                            for src_name in trafficItemInfo[\"stream_src\"]:\n                                dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f\"^{src_name}$\")\n                                if dg:\n                                    sources.extend(list(dg))\n\n                        destinations_ip = self._endpoint_destination_handles(trafficItemInfo[\"dst_ip\"],\n                                                                             destinationsList=[], topology=None)\n                        trafficItem.EndpointSet.add(Name=None, Sources=sources, ScalableDestinations=destinations_ip)\n\n\n                    elif (\n                            trafficItemInfo.get('stream_src') == trafficItemInfo.get('src_ip') and\n                            trafficItemInfo['traffic_type'] != 'raw' and\n                            trafficItemInfo.get('stream_dest') == trafficItemInfo.get('dst_ip')\n                    ):\n                        trafficItem.EndpointSet.add(Name=None, Sources=sources_ip, Destinations=destinations_ip)\n\n                    elif (\n                            trafficItemInfo.get('stream_src') and\n                            trafficItemInfo.get('stream_dest') and\n                            trafficItemInfo['traffic_type'] != 'raw'\n                    ):\n                        trafficItem.EndpointSet.add(Name=None, Sources=sources, Destinations=destinations)\n\n\n                    elif trafficItemInfo['traffic_type'] == 'raw':\n                        trafficItem.EndpointSet.add(Name=None, Sources=sources, Destinations=destinations)\n\n                    elif sources_ip and not destinations_ip:\n                        raise IxiaConfigException(\"Raised exception due to destination Ip not passed\")\n\n                    elif not sources_ip and destinations_ip:\n                        raise IxiaConfigException(\"Raised exception due to source Ip not passed\")\n\n                else:\n\n                    if 'stream_dest' in trafficItemInfo:\n                        trafficItemInfo.pop('stream_dest')\n\n                    if 'dst_ip' in trafficItemInfo:\n                        trafficItemInfo.pop('dst_ip')\n\n                    stream_src = trafficItemInfo.get(\"stream_src\", [])\n                    if isinstance(stream_src, str):\n                        stream_src = [stream_src]\n                    trafficItemInfo[\"stream_src\"] = stream_src\n\n                    multicast_address = trafficItemInfo.get(\"multicast_address\")\n                    if not multicast_address:\n                        raise IxiaConfigException(\"Missing 'multicast_address' for multicast stream\")\n\n                    is_ipv6 = \":\" in multicast_address\n\n                    sources = []\n                    for src_name in stream_src:\n                        dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name=f\"^{src_name}$\")\n                        if dg:\n                            sources.extend(list(dg))\n                        else:\n                            self.log.warning(f\"[IXIA] DeviceGroup '{src_name}' not found for multicast source\")\n\n                    if not sources:\n                        raise IxiaConfigException(f\"No valid sources found for {trafficItemInfo['stream_src']}\")\n\n                    sources_ip = []\n                    if \"src_ip\" in trafficItemInfo and trafficItemInfo[\"src_ip\"]:\n                        sources_ip = self._endpoint_source_handles(\n                            trafficItemInfo[\"src_ip\"], sourcesList=[], topology=None\n                        )\n\n                    multicast_list = multicast_address if isinstance(multicast_address, list) else [multicast_address]\n                    mcastdestination = [\n                        {\n                            \"arg1\": False,\n                            \"arg2\": \"none\",\n                            \"arg3\": str(mcast_addr),\n                            \"arg4\": \"::\" if is_ipv6 else \"0.0.0.0\",\n                            \"arg5\": 1\n                        }\n                        for mcast_addr in multicast_list if mcast_addr\n                    ]\n\n                    if sources_ip:\n                        trafficItem.EndpointSet.add(\n                            Name=None, ScalableSources=sources_ip, MulticastDestinations=mcastdestination\n                        )\n                    else:\n                        trafficItem.EndpointSet.add(\n                            Name=None, Sources=sources, MulticastDestinations=mcastdestination\n                        )\n\n                if isinstance(src_ip, list):\n                    trafficItemInfo['src_ip'] = src_ip[0]\n                if isinstance(dst_ip, list):\n                    trafficItemInfo['dst_ip'] = dst_ip[0]\n\n                if 'frame_size' in trafficItemInfo and trafficItemInfo['frame_size'] != '':\n                    stackObj = trafficItem.ConfigElement.find().FrameSize\n                    setattr(stackObj, 'FixedSize', trafficItemInfo['frame_size'])\n\n                if 'txLoad(%)' in trafficItemInfo and trafficItemInfo['txLoad(%)'] != '':\n                    stackObj = trafficItem.ConfigElement.find().FrameRate\n                    setattr(stackObj, 'Type', 'percentLineRate')\n                    setattr(stackObj, 'Rate', trafficItemInfo['txLoad(%)'])\n\n                frame_rate_dict = {'rate_type': 'Type', 'frame_rate': 'Rate', 'bit_rate_units': 'BitRateUnitsType',\n                                   'enforce_min_inter_packet_gap': 'InterPacketGapUnitsType'}\n                frame_rate_options = list(set(frame_rate_dict.keys()).intersection(trafficItemInfo.keys()))\n                if frame_rate_options:\n                    for key in trafficItemInfo:\n                        if key in frame_rate_dict:\n                            setattr(trafficItem.ConfigElement.find().FrameRate, frame_rate_dict[key],\n                                    trafficItemInfo[key])\n\n                frame_size_dict = {'frame_size_type': 'Type', 'frame_size_fixed_size': 'FixedSize',\n                                   'frame_size_increment_start': 'IncrementFrom',\n                                   'frame_size_increment_stop': 'IncrementTo',\n                                   'frame_size_increment_step': 'IncrementStep',\n                                   'frame_size_preset_distribution': 'PresetDistribution',\n                                   'frame_size_quad_gaussian': 'QuadGaussian',\n                                   'frame_size_random_min': 'RandomMin', 'frame_size_random_max': 'RandomMax',\n                                   'frame_size_weighted_pairs': 'WeightedPairs',\n                                   'frame_size_weighted_pairs_range': 'WeightedRangePairs'}\n                frame_size_options = list(set(frame_size_dict.keys()).intersection(trafficItemInfo.keys()))\n                if frame_size_options:\n                    for key in trafficItemInfo:\n                        if key in frame_size_dict:\n                            setattr(trafficItem.ConfigElement.find().FrameSize, frame_size_dict[key],\n                                    trafficItemInfo[key])\n\n                if trafficItemInfo['traffic_type'] == \"raw\":\n                    if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',\n                                                                                                        None) is None or kwargs.get(\n                        'eth_dst_mac', None) is None:\n                        if kwargs.get('eth_dst_mac_mode', None) == \"INCR\" or kwargs.get('eth_dst_mac_mode',\n                                                                                        None) is None:\n                            kwargs['eth_dst_mac_mode'] = 'increment'\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(\n                            DisplayName=\"Destination MAC Address\")\n                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                            'eth_dst_mac_mode', None), \\\n                            kwargs.get(\n                                'eth_dst_mac',\n                                \"00:00:00:00:01:01\"), kwargs.get(\n                            'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', \"00:00:00:00:01:01\"), kwargs.get(\n                            'eth_dst_mac_step', \"00:00:00:00:00:01\")\n\n                        if kwargs.get('eth_src_mac_mode', None) == \"INCR\" or kwargs.get('eth_src_mac_mode',\n                                                                                        None) is None:\n                            kwargs['eth_src_mac_mode'] = 'increment'\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(\n                            DisplayName=\"Source MAC Address\")\n                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(\n                            'eth_src_mac_mode', None), \\\n                            kwargs.get(\n                                'eth_src_mac',\n                                \"00:00:00:00:00:01\"), kwargs.get(\n                            'eth_src_mac_count', 1), kwargs.get('eth_src_mac', \"00:00:00:00:00:01\"), kwargs.get(\n                            'eth_src_mac_step', \"00:00:00:00:00:01\")\n                    if 'raw_stream_ip_stack' in trafficItemInfo and (\n                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[\n                        'raw_stream_ip_stack'] == 'ipv46'):\n                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':\n                            pass\n                        else:\n                            trafficItemInfo['tos'] = 0\n                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')\n                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')\n                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                        if ipv4Stack:\n                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv4\")\n                            flag = False\n                            try:\n                                if int(trafficItemInfo['tos']) not in tos_value_list:\n                                    flag = True\n                            except:\n                                pass\n                            if flag:\n                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True\n                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))\n                            else:\n                                if isinstance(trafficItemInfo['tos'], list):\n                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                         cfg_dict={'displayName': 'precedence',\n                                                                   'valueType': 'valueList',\n                                                                   'valueList': trafficItemInfo['tos']})\n                                elif isinstance(trafficItemInfo['tos'], str):\n                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                         cfg_dict={'displayName': 'precedence',\n                                                                   'valueType': 'singleValue',\n                                                                   'singleValue': trafficItemInfo['tos']})\n                                else:\n                                    setattr(stackObj.Field.find(Name='precedence'), 'FieldValue',\n                                            trafficItemInfo['tos'])\n                        else:\n                            if ethernetStack and vlanStack and not ipv4Stack:\n                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\n                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv4Template))\n                            if ethernetStack and not vlanStack and not ipv4Stack:\n                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\n                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv4Template))\n                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv4\")\n                            flag = False\n                            try:\n                                if int(trafficItemInfo['tos']) not in tos_value_list:\n                                    flag = True\n                            except:\n                                pass\n                            if flag:\n                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True\n                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))\n                            else:\n                                if isinstance(trafficItemInfo['tos'], list):\n                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                         cfg_dict={'displayName': 'precedence',\n                                                                   'valueType': 'valueList',\n                                                                   'valueList': trafficItemInfo['tos']})\n                                elif isinstance(trafficItemInfo['tos'], str):\n                                    self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                         cfg_dict={'displayName': 'precedence',\n                                                                   'valueType': 'singleValue',\n                                                                   'singleValue': trafficItemInfo['tos']})\n                                else:\n                                    setattr(stackObj.Field.find(Name='precedence'), 'FieldValue',\n                                            trafficItemInfo['tos'])\n                    if 'raw_stream_ip_stack' in trafficItemInfo and (\n                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[\n                        'raw_stream_ip_stack'] == 'ipv46'):\n                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':\n                            pass\n                        else:\n                            trafficItemInfo['tos'] = 0\n                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')\n                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')\n                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                        ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                        if ipv6Stack:\n                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv6\")\n                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',\n                                    trafficItemInfo['tos'])\n                        else:\n                            if ethernetStack and vlanStack and not ipv6Stack and not ipv4Stack:\n                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv6Template))\n                            if ethernetStack and not vlanStack and not ipv6Stack and not ipv4Stack:\n                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv6Template))\n                            if ethernetStack and not vlanStack and not ipv6Stack and ipv4Stack:\n                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))\n                            if ethernetStack and vlanStack and not ipv6Stack and ipv4Stack:\n                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv6$\")\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))\n                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv6\")\n                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',\n                                    trafficItemInfo['tos'])\n                    if 'raw_stream_ip_stack' in trafficItemInfo and (\n                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[\n                        'raw_stream_ip_stack'] == 'ipv46' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv6'):\n                        if 'src_ip' in trafficItemInfo or 'dst_ip' in trafficItemInfo or 'src_count' in trafficItemInfo:\n                            if 'dst_mode' in trafficItemInfo:\n                                if trafficItemInfo['dst_mode'] == \"INCR\" or trafficItemInfo['dst_mode'] is None:\n                                    trafficItemInfo['dst_mode'] = 'increment'\n                            else:\n                                trafficItemInfo['dst_mode'] = 'increment'\n                            if 'dst_ip' in trafficItemInfo:\n                                if trafficItemInfo['dst_ip'] == '':\n                                    trafficItemInfo['dst_ip'] = None\n                            else:\n                                trafficItemInfo['dst_ip'] = None\n                            if 'dst_count' not in trafficItemInfo or 'src_count' not in trafficItemInfo:\n                                trafficItemInfo['dst_count'] = 1\n                                trafficItemInfo['src_count'] = 1\n                            if 'dst_step' not in trafficItemInfo or 'src_step' not in trafficItemInfo:\n                                if ':' in trafficItemInfo['src_ip']:\n                                    trafficItemInfo['dst_step'] = '::1'\n                                    trafficItemInfo['src_step'] = '::1'\n                                else:\n                                    trafficItemInfo['dst_step'] = '0.0.0.1'\n                                    trafficItemInfo['src_step'] = '0.0.0.1'\n                            if ':' in trafficItemInfo['dst_ip']:\n                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv6\").Field.find(\n                                    DisplayName=\"Destination Address\")\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \\\n                                    trafficItemInfo['dst_mode'], \\\n                                        trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo[\n                                        'dst_ip'], \\\n                                        trafficItemInfo['dst_step']\n                            else:\n                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv4\").Field.find(\n                                    DisplayName=\"Destination Address\")\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \\\n                                    trafficItemInfo['dst_mode'], \\\n                                        trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo[\n                                        'dst_ip'], \\\n                                        trafficItemInfo['dst_step']\n\n                            if 'src_mode' in trafficItemInfo:\n                                if trafficItemInfo['src_mode'] == \"INCR\" or trafficItemInfo['src_mode'] is None:\n                                    trafficItemInfo['src_mode'] = 'increment'\n                            else:\n                                trafficItemInfo['src_mode'] = 'increment'\n                            if 'src_ip' in trafficItemInfo:\n                                if trafficItemInfo['src_ip'] == '':\n                                    trafficItemInfo['src_ip'] = None\n                            else:\n                                trafficItemInfo['src_ip'] = None\n                            if ':' in trafficItemInfo['src_ip']:\n                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv6\").Field.find(\n                                    DisplayName=\"Source Address\")\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \\\n                                    trafficItemInfo['src_mode'], \\\n                                        trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo[\n                                        'src_ip'], \\\n                                        trafficItemInfo['src_step']\n                            else:\n                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv4\").Field.find(\n                                    DisplayName=\"Source Address\")\n                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \\\n                                    trafficItemInfo['src_mode'], \\\n                                        trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo[\n                                        'src_ip'], trafficItemInfo['src_step']\n\n                if trafficItemInfo['traffic_type'] == \"ipv4\" or trafficItemInfo[\n                    'traffic_type'] == \"ipv6\" or 'raw_stream_ip_stack' in trafficItemInfo and (\n                        trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[\n                    'raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv46'):\n                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[\n                        'traffic_type'] == \"ipv4\":\n                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv4\")\n                        flag = False\n                        try:\n                            if int(trafficItemInfo['tos']) not in tos_value_list:\n                                flag = True\n                        except:\n                            pass\n                        if flag:\n                            stackObj.Field.find(Name='raw').ActiveFieldChoice = True\n                            setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))\n                        else:\n                            if isinstance(trafficItemInfo['tos'], list):\n                                self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                     cfg_dict={'displayName': 'precedence', 'valueType': 'valueList',\n                                                               'valueList': trafficItemInfo['tos']})\n                            elif isinstance(trafficItemInfo['tos'], str):\n                                self.change_ipv4_tos(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                     cfg_dict={'displayName': 'precedence', 'valueType': 'singleValue',\n                                                               'singleValue': trafficItemInfo['tos']})\n                            else:\n                                setattr(stackObj.Field.find(Name='precedence'), 'FieldValue', trafficItemInfo['tos'])\n                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[\n                        'traffic_type'] == \"ipv6\":\n                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName=\"IPv6\")\n                        if isinstance(trafficItemInfo['tos'], list):\n                            self.change_ipv6_traffic_class(traffic_item_list=[trafficItemInfo[\"stream_name\"]],\n                                                           cfg_dict={'valueType': 'valueList',\n                                                                     'valueList': trafficItemInfo['tos']})\n                        else:\n                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',\n                                    trafficItemInfo['tos'])\n\n                    trafficItem.Tracking.find().TrackBy = ['trackingenabled0']\n\n                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] == 'Precedence':\n                        self.log.info(\"Configuring IP TOS\")\n\n                    if 'stats_track_by' in trafficItemInfo:\n                        stats_track_by = trafficItemInfo['stats_track_by']\n\n                        stats_track_by.append('trackingenabled0')\n                    else:\n                        stats_track_by = ['trackingenabled0']\n                    if \"ipv4_precedence_full_mesh\" not in trafficItemInfo:\n                        trafficItemInfo[\"ipv4_precedence_full_mesh\"] = False\n                    self.change_traffic_flow_tracking(traffic_item_list=[trafficItem.Name],\n                                                      cfg_dict={'trackBy': stats_track_by},\n                                                      ipv4_precedence_full_mesh=trafficItemInfo[\n                                                          \"ipv4_precedence_full_mesh\"])\n\n                    print(\n                        f\"Configuring traffic stack for stream: {trafficItemInfo.get('stream_name', 'Unnamed Stream')}\")\n\n                    # === ESP Header ===\n                    if 'esp_header' in trafficItemInfo and trafficItemInfo['esp_header'] in [True, 'TRUE']:\n                        try:\n                            espTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(\n                                StackTypeId=\"^ipEncapsulatingSecurityPayload$\")\n                            self.log.info(\"Appending ESP header.\")\n                            if trafficItemInfo['traffic_type'] == \"raw\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv4Stack and not ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(espTemplate))\n                                elif ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(espTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv4\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(espTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv6\":\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(espTemplate))\n                            else:\n                                self.log.warning(f\"Unknown traffic type for ESP: {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            self.log.error(f\"Failed to append ESP header: {e}\")\n\n                    # === GRE Header ===\n                    if 'gre_header' in trafficItemInfo and trafficItemInfo['gre_header'] in [True, 'TRUE']:\n                        try:\n                            greTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^gre$\")\n                            self.log.info(\"Appending GRE header.\")\n                            if trafficItemInfo['traffic_type'] == \"raw\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv4Stack and not ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(greTemplate))\n                                elif ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(greTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv4\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(greTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv6\":\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(greTemplate))\n                            else:\n                                self.log.warning(f\"Unknown traffic type for GRE: {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            print(f\"[ERROR] Failed to append GRE header: {e}\")\n\n                    # === TCP Header ===\n                    if 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [True, 'TRUE']:\n                        if 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [True, 'TRUE']:\n                            self.log.warning(\"Both TCP and UDP headers are enabled. Only TCP will be added.\")\n                        try:\n                            tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^tcp$\")\n                            self.log.info(\"Appending TCP header.\")\n                            if trafficItemInfo['traffic_type'] == \"raw\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv4Stack and not ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))\n                                elif ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv4\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv6\":\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))\n                            else:\n                                self.log.warning(f\"Unknown traffic type for TCP: {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            self.log.error(f\"Failed to append TCP header: {e}\")\n\n                    # === UDP Header ===\n                    elif 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [True, 'TRUE']:\n                        try:\n                            udpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^udp$\")\n                            self.log.info(\"Appending UDP header.\")\n                            if trafficItemInfo['traffic_type'] == \"raw\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv4Stack and not ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))\n                                elif ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv4\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv6\":\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))\n                            else:\n                                self.log.warning(f\"Unknown traffic type for UDP: {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            self.log.error(f\" Failed to append UDP header: {e}\")\n\n                    # === ICMPv6 Header ===\n                    if 'icmpv6_header' in trafficItemInfo and trafficItemInfo['icmpv6_header'] in [True, 'TRUE']:\n                        try:\n                            icmpv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^icmpv6$\")\n                            if trafficItemInfo['traffic_type'] in [\"raw\", \"ipv6\"]:\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv6Stack:\n                                    self.log.info(\"Appending ICMPv6 header.\")\n                                    trafficItem.ConfigElement.find().Stack.read(\n                                        ipv6Stack.AppendProtocol(icmpv6Template))\n                                else:\n                                    self.log.warning(\"IPv6 stack not found for ICMPv6 header.\")\n                            else:\n                                self.log.warning(\n                                    f\"ICMPv6 can only be added to IPv6 traffic. Type: {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            self.log.error(f\"Failed to append ICMPv6 header: {e}\")\n\n                    # === VLAN Header ===\n                    if 'vlan_header' in trafficItemInfo and trafficItemInfo['vlan_header'] in [True, 'TRUE']:\n                        try:\n                            vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\n                            ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')\n                            if ethernetStack:\n                                self.log.info(\"Appending VLAN header.\")\n                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(vlanTemplate))\n                            else:\n                                self.log.warning(\"Ethernet stack not found. VLAN header not applied.\")\n                        except Exception as e:\n                            self.log.error(f\"Failed to append VLAN header: {e}\")\n\n                    # === AHP (AH) Header ===\n                    if 'ahp_header' in trafficItemInfo and trafficItemInfo['ahp_header'] in [True, 'TRUE']:\n                        try:\n                            ahpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(\n                                StackTypeId=\"^ipAuthenticationHeader$\")\n                            self.log.info(\"Appending AH (AHP) header.\")\n                            if trafficItemInfo['traffic_type'] == \"raw\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                if ipv4Stack and not ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ahpTemplate))\n                                elif ipv6Stack:\n                                    trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(ahpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv4\":\n                                ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ahpTemplate))\n                            elif trafficItemInfo['traffic_type'] == \"ipv6\":\n                                ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')\n                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(ahpTemplate))\n                            else:\n                                self.log.warning(\n                                    f\"Unknown traffic type for AH (AHP): {trafficItemInfo['traffic_type']}\")\n                        except Exception as e:\n                            self.log.error(f\"Failed to append AH (AHP) header: {e}\")\n\n                    if 'tcp_src_port' in trafficItemInfo and trafficItemInfo[\n                        'tcp_src_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [\n                        True, 'TRUE']:\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName=\"TCP-Source-Port\")\n                        field.Auto = trafficItemInfo.get('tcp_src_auto', 'False')\n                        field.ValueType = trafficItemInfo.get('tcp_src_mode', 'singleValue')\n                        field.FieldValue = trafficItemInfo.get('tcp_src_port', 1024)\n                        field.CountValue = trafficItemInfo.get('tcp_src_count', 1)\n                        field.StartValue = trafficItemInfo.get('tcp_src_port', None)\n                        field.StepValue = trafficItemInfo.get('tcp_src_step', 1)\n                        field.FullMesh = trafficItemInfo.get('tcp_src_fullmesh', False)\n                        field.TrackingEnabled = trafficItemInfo.get('tcp_src_trackby', False)\n\n                    if 'tcp_dst_port' in trafficItemInfo and trafficItemInfo[\n                        'tcp_dst_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [\n                        True, 'TRUE']:\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName=\"TCP-Dest-Port\")\n                        field.Auto = trafficItemInfo.get('tcp_dst_auto', 'False')\n                        field.ValueType = trafficItemInfo.get('tcp_dst_mode', 'singleValue')\n                        field.FieldValue = trafficItemInfo.get('tcp_dst_port', 1024)\n                        field.CountValue = trafficItemInfo.get('tcp_dst_count', 1)\n                        # field.StartValue = trafficItemInfo.get('tcp_dst_port', None)\n                        field.StepValue = trafficItemInfo.get('tcp_dst_step', 1)\n                        field.FullMesh = trafficItemInfo.get('tcp_dst_fullmesh', False)\n                        field.TrackingEnabled = trafficItemInfo.get('tcp_dst_trackby', False)\n\n\n                    if 'udp_src_port' in trafficItemInfo and trafficItemInfo[\n                        'udp_src_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [\n                        True, 'TRUE']:\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName=\"UDP-Source-Port\")\n                        field.Auto = trafficItemInfo.get('udp_src_auto', 'False')\n                        field.ValueType = trafficItemInfo.get('udp_src_mode', 'singleValue')\n                        field.FieldValue = trafficItemInfo.get('udp_src_port', 1024)\n                        field.CountValue = trafficItemInfo.get('udp_src_count', 1)\n                        field.StartValue = trafficItemInfo.get('udp_src_port', None)\n                        field.StepValue = trafficItemInfo.get('udp_src_step', 1)\n                        field.FullMesh = trafficItemInfo.get('udp_src_fullmesh', False)\n                        field.TrackingEnabled = trafficItemInfo.get('udp_src_trackby', False)\n\n\n                    if 'udp_dst_port' in trafficItemInfo and trafficItemInfo[\n                        'udp_dst_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [\n                        True, 'TRUE']:\n                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName=\"UDP-Dest-Port\")\n                        field.Auto = trafficItemInfo.get('udp_dst_auto', 'False')\n                        field.ValueType = trafficItemInfo.get('udp_dst_mode', 'singleValue')\n                        field.FieldValue = trafficItemInfo.get('udp_dst_port', 1024)\n                        field.CountValue = trafficItemInfo.get('udp_dst_count', 1)\n                        field.StartValue = trafficItemInfo.get('udp_dst_port', None)\n                        field.StepValue = trafficItemInfo.get('udp_dst_step', 1)\n                        field.FullMesh = trafficItemInfo.get('udp_dst_fullmesh', False)\n                        field.TrackingEnabled = trafficItemInfo.get('udp_dst_trackby', False)\n\n\n    def add_device_traffic_configuration(self, csv_file=None):\n        \"\"\"\n        API to add devices and traffic configuration using csv file format\n\n        :param csv_file: csv file\n        :return:\n        \"\"\"\n        rows = list()\n        devicesInfo = list()\n        portTuple = list()\n\n        with open(csv_file, 'r') as csvfile:\n            csvreader = csv.reader(csvfile)\n\n            for row in csvreader:\n                rows.append(row)\n\n        for rowIndex in range(len(rows)):\n            if 'stream_name' in rows[rowIndex]:\n                trafficConfigRow = rowIndex\n\n        deviceConfigRows = rows[:trafficConfigRow]\n        trafficConfigRows = rows[trafficConfigRow:]\n\n        deviceHeaders = deviceConfigRows[0]\n        devicesInfoList = deviceConfigRows[1:]\n\n        devicesInfoTemp = [dict(zip(deviceHeaders, deviceInfo)) for deviceInfo in devicesInfoList]\n        portTupleTemp = [deviceInfo['port'] for deviceInfo in devicesInfoTemp]\n\n        for port in portTupleTemp:\n            if port not in portTuple and port != '':\n                portTuple.append(port)\n\n        for deviceInfo in devicesInfoTemp:\n            del deviceInfo['port']\n            devicesInfo.append(deviceInfo)\n\n        trafficHeaders = trafficConfigRows[0]\n        trafficInfoList = trafficConfigRows[1:]\n\n        trafficsItemInfo = [dict(zip(trafficHeaders, trafficInfo)) for trafficInfo in trafficInfoList]\n        self.add_multiple_devices(port_tuple=portTuple, device_info=devicesInfo)\n        self.add_multiple_traffic_streams(traffic_info=trafficsItemInfo)\n\n    def get_twamp_test_sessions(self):\n        \"\"\"\n        Get TWAMP Test Sessoin handler with respect to its Name\n\n        :return: List of Name and handler of TWAMP Test Sessions\n        :Example: get_twamp_test_sessions()\n        \"\"\"\n        ControlRangeName_list = []\n        for ControlRange in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampTestRange.find():\n            ControlRangeName_list.append(ControlRange.ControlRangeName)\n        return ControlRangeName_list\n\n    def start_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):\n        \"\"\"\n        Start TWAMP Sessions\n\n        :param delay_time: Delay Time (by default 30)\n        :param twamp_test_sessions: List of TWAMP Test session Name\n        :return: Raises exception on failure\n        :Example: start_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')\n        \"\"\"\n\n        if delay_time:\n            time.sleep(delay_time)\n        if twamp_test_sessions:\n            ControlRangeName_list = twamp_test_sessions\n        else:\n            ControlRangeName_list = self.get_twamp_test_sessions()\n        for ControlRange in ControlRangeName_list:\n            ControlRange = str(ControlRange)\n            try:\n                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n                    Name=ControlRange).Start()\n            except:\n                pass\n\n    def stop_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):\n        \"\"\"\n        Stop TWAMP Sessions\n\n        :param delay_time: Delay Time (by default 30)\n        :param twamp_test_sessions: List of TWAMP Test session Name\n        :return: Raises exception on failure\n        :Example: stop_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')\n        \"\"\"\n        if delay_time:\n            time.sleep(delay_time)\n        if twamp_test_sessions:\n            ControlRangeName_list = twamp_test_sessions\n        else:\n            ControlRangeName_list = self.get_twamp_test_sessions()\n        for ControlRange in ControlRangeName_list:\n            ControlRange = str(ControlRange)\n            try:\n                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n                    Name=ControlRange).Stop()\n            except:\n                pass\n\n    def request_twamp_sessions(self, router_ids):\n        \"\"\"\n        Start Requesting TWAMP session by client from server\n\n        :param router_ids: device list by default it request on all TWAMP client configured devices\n        :return: Raises exception on failure\n        :Example: request_twamp_sessions(router_ids='192.0.0.2')\n        \"\"\"\n        ControlRangeName_list = self.get_twamp_test_sessions()\n        for ControlRange in ControlRangeName_list:\n            ControlRange = str(ControlRange)\n            try:\n                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n                    Name='^' + ControlRange + '$').Enabled = False\n            except:\n                pass\n        if router_ids:\n            self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n                Name='^' + router_ids + '$').Enabled = True\n            try:\n\n                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n                    Name='^' + router_ids + '$').Start()\n            except:\n                pass\n\n    def create_custom_stats_view(self, custom_view_name=None):\n        \"\"\"\n        Create custome stats view for each traffic stream.\n        :param custom_view_name: Custom view name\n        :param tree_view_node_name: Tree view node name\n        :return:\n        \"\"\"\n\n        self.ixNetwork.Statistics.View.add(Caption=custom_view_name, Type='layer23ProtocolStack', Visible=True)\n        afil = self.ixNetwork.Statistics.View.find(\n            Caption='^' + custom_view_name + '$').AvailableProtocolStackFilter.find()\n\n        fil = \\\n        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Layer23ProtocolStackFilter.find()[0]\n        fil.update(DrilldownType='perSession', ProtocolStackFilterId=afil[-1], SortAscending=True)\n        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Statistic.find():\n            stats.Enabled = True\n        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Enabled = True\n\n        TrafficItemStats = StatViewAssistant(self.ixNetwork, custom_view_name, LocalCsvStorage=CafyLog.work_dir)\n        trafficItemStatsDict = {}\n        columnCaptions1 = TrafficItemStats.ColumnHeaders\n        columnCaptions = []\n\n        for ele in columnCaptions1:\n            if ele == ' Max Latency [us]':\n                columnCaptions.append('\" Max Latency [us]\"')\n            else:\n                columnCaptions.append(ele)\n\n        for rowNumber, stat in enumerate(TrafficItemStats.Rows):\n            statsDict = {}\n            for column in columnCaptions:\n                statsDict[column] = stat[column]\n            trafficItemStatsDict[rowNumber + 1] = statsDict\n        dict = {'avg_jitter': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Jitter Max [us]'],\n                'avg_latency': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Max Latency [us]']}\n        for key, value in trafficItemStatsDict.items():\n            value.update(dict)\n        return trafficItemStatsDict\n\n    def get_twamp_test_session_results(self, router_id):\n        \"\"\"\n        Get TWAMP Test Sessions Results of TWMP client device\n\n        :param router_id: TWAMP Client ID on which TWAMP result should be obtained\n        :return: TWAMP Test session result in dictionary\n        :Example: get_twamp_test_session_results(router_id = '192.0.0.4')\n        \"\"\"\n        view_name = self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(\n            Name='^' + router_id + '$').Name\n        return self.create_custom_stats_view(custom_view_name=view_name)\n\n    def start_twamp(self, router_ids):\n        \"\"\"\n        Start TWAMP on mentioned hosts or on all\n        :param router_ids: List of router_id by default it starts on all TWAMP configured devices\n        :return: Raises exception on failure\n        :Example: start_twamp(router_ids = '192.0.0.4')\n        \"\"\"\n        if router_ids:\n            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():\n                try:\n                    if range.TwampControlRange.find():\n                        range.TwampControlRange.find(Name='^' + router_ids + '$').Start()\n                except:\n                    pass\n        else:\n            for port in self.ixNetwork.Vport.find():\n                try:\n                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):\n                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStart()\n                except:\n                    pass\n                try:\n                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):\n                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStart()\n                except:\n                    pass\n\n    def stop_twamp(self, router_ids):\n        \"\"\"\n        Stop TWAMP on mentioned hosts or on all\n        :param router_ids: List of router_id by default it stops on all TWAMP configured devices\n        :return: Raises exception on failure\n        :Example: stop_twamp(router_ids = '192.0.0.4')\n        \"\"\"\n        if router_ids:\n            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():\n                try:\n                    if range.TwampControlRange.find():\n                        range.TwampControlRange.find(Name='^' + router_ids + '$').Stop()\n                except:\n                    pass\n        else:\n            for port in self.ixNetwork.Vport.find():\n                try:\n                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):\n                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStop()\n                except:\n                    pass\n                try:\n                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):\n                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStop()\n                except:\n                    pass\n\n    def get_twamp_test(self, router_id, delay=10):\n        \"\"\"\n        Start TWAMP hosts, establish & start sessions and obtain their test results\n        :param router_id: TWAMP Client device id from which TWAMP results to be obtained\n        :param delay: Delay duration between Start and Stop\n        :return: Results of TWAMP Test\n        :Example: get_twamp_test(router_id = '192.0.0.4', delay = 10)\n        \"\"\"\n        self.start_twamp()\n        Helper.sleep(5, msg='Starting TWAMP on all Hosts')\n        self.request_twamp_sessions()\n        Helper.sleep(5, msg='Starting all TWAMP sessions')\n        self.start_twamp_sessions()\n        Helper.sleep(delay, msg='TWAMP Test delay')\n        self.stop_twamp_sessions()\n        results = self.get_twamp_test_session_results(router_id)\n        self.stop_twamp()\n        Helper.sleep(3, msg='Collecting TWAMP Results')\n        return results\n\n    def set_stream_only_generation(self, stream_block_name, enable=True):\n        \"\"\"\n        This API is not applicable for IXIA and adding a dummy API to make it TGN vendor agnostic\n\n        Set or unset stream only generation option for stream block(s)\n        :param stream_block_name: string representing a stream block or 'all' representing all the streamblocks\n        :param enable: boolean, false if you want to disable the stream only generation option\n        :example: set_stream_only_generation(stream_block_name='StreamBlock 1',enable=False)\n        :return:\n        \"\"\"\n        pass\n\n    def connect_to_lab_server(self,server_ip, timeout=300, api_version=1):\n        \"\"\"\n        To connect to given TGN Lab server or API Server\n        :param server_ip: IP address of TGN LabServer/APISerer\n        :param timeout: Spirent Only Argument. Time to wait to receive response from server\n        :param api_version: Spirent Only Argument. API version to use. Default is 1\n        :return:\n        \"\"\"\n        self.server_ip = server_ip\n        self.log.info(\"Connecting to Ixia Lab Server - '%s'\" %server_ip)\n\n        if self.tgn_server_type == 'linux':\n            self.test_platform = TestPlatform(ip_address=server_ip, rest_port=self.port, platform='linux',\n                                             log_file_name=CafyLog.work_dir + '/restpy.log')\n            self.test_platform.Authenticate(self.tgn_server_user, self.tgn_server_pw)\n\n        if self.tgn_server_type == 'windows':\n            self.log.warning(\"Connect Lab Server is Not Supported for Ixia Windows Lab Server\")\n\n    def _download_debug_files(self, type='ixncfg'):\n        \"\"\"\n        To download debug files  and config files from Labserver to Cafy working directory.\n        :param type: Format to save the Ixia config. Supports 'ixncfg' & 'json'. Default is 'ixncfg' format.\n        :return: None\n        :Example: _download_debug_files(type='ixncfg')\n                  _download_debug_files(type='json')\n        \"\"\"\n        filesToZip = []\n        path = self.ixNetwork.Globals.PersistencePath\n        if type == 'ixncfg':\n            if self.tgn_server_type == 'windows':\n                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')\n                self._copyApiServerFileToLocalLinux(path + '\\\\' + 'IxiaConfig.ixncfg', CafyLog.work_dir,\n                                                    localPathOs='windows',\n                                                    includeTimestamp=False)\n                timestamp = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')\n                diag_file = 'diags_' + timestamp + '.zip'\n                if not self.disable_diag_log and not self.disable_trace_log:\n                    self.ixNetwork.CollectLogs(Arg1=(path + '\\\\' + diag_file), Arg2='currentInstance')\n                    self._copyApiServerFileToLocalLinux(path + '\\\\' + diag_file, CafyLog.work_dir,\n                                                    localPathOs='windows',\n                                                    includeTimestamp=False)\n                    self.session.RemoveFile(path + \"\\\\\" + diag_file)\n            if self.tgn_server_type == 'linux':\n                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')\n                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.ixncfg', CafyLog.work_dir,\n                                                    localPathOs='linux',\n                                                    includeTimestamp=False)\n                path = path.replace('IxNetwork', '')\n                path_linux = path + 'sdmStreamManager/common/diagnostics/'\n                timestamp = datetime.datetime.now().strftime('%Y_%m_%d_%H%M%S')\n                diag_file = 'diags_' + timestamp + '.zip'\n                if not self.disable_diag_log:\n                    self.ixNetwork.CollectLogs(Arg1=(path_linux + diag_file), Arg2='currentInstance')\n                    self._copyApiServerFileToLocalLinux(path_linux + '/' + diag_file, CafyLog.work_dir,\n                                                    localPathOs='linux',\n                                                    includeTimestamp=False)\n                    self.session.RemoveFile(path_linux + diag_file)\n            filesToZip.append('IxiaConfig.ixncfg')\n            filesToZip.append(diag_file)\n        elif type == 'json':\n            if self.tgn_server_type == 'windows':\n                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')\n                self._copyApiServerFileToLocalLinux(path + '\\\\' + 'IxiaConfig.json', CafyLog.work_dir,\n                                                    localPathOs='windows',\n                                                    includeTimestamp=False)\n            if self.tgn_server_type == 'linux':\n                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')\n                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.json', CafyLog.work_dir,\n                                                    localPathOs='linux',\n                                                    includeTimestamp=False)\n            filesToZip.append('IxiaConfig.json')\n        error_files = 'ixiaerror.log'\n        error_log_path = os.path.join(CafyLog.work_dir, error_files)\n        globals = self.ixNetwork.Globals\n        with open(error_log_path, 'w') as error_file:\n            for apperrors in globals.AppErrors.find():\n                for error in apperrors.Error.find():\n                    if hasattr(error, 'Description') :\n                        if error.ErrorLevel == 'kMessage':\n                            continue\n                        error_file.write(error.Description + '\\n')\n                        self.log.info(error.Description)\n                        error_file.write(error.Name + '\\n')\n                        self.log.info(error.Name)\n        filesToZip.append(error_files)\n        filesToZip.append('all.log')\n        debug_logs = 'IxiaDebugLogs_' + timestamp + '.zip'\n        zip_file = os.path.join(CafyLog.work_dir, debug_logs)\n        lenDirPath = len(CafyLog.work_dir)\n        with ZipFile(zip_file, 'w') as zip:\n            # writing each file one by one\n            for file in filesToZip:\n                log.info(\"Downloading %s from LabServer to %s\" % (file, CafyLog.work_dir))\n                file = CafyLog.work_dir + '/' + file\n                zip.write(file, file[lenDirPath:])\n                if file[lenDirPath:] != '/all.log':\n                    os.remove(file)\n\n    def traffic_options(self, **kwargs):\n        \"\"\"\n        This API is used for the traffic options stats related changes\n        :param kwargs:\n                Argument:\"frames_ordering\" --> \"No Ordering\" , \"peakLoading\", \"flowGroupSetup\", \"RFC2889\"\n        :return:\n        \"\"\"\n        frames_order = kwargs.get(\"frames_ordering\", None)\n        if frames_order:\n            if frames_order == 'RFC2889':\n                self.ixNetwork.Traffic.EnableStreamOrdering = True\n                self.ixNetwork.Traffic.FrameOrderingMode = frames_order\n            else:\n                self.ixNetwork.Traffic.EnableStreamOrdering = False\n                self.ixNetwork.Traffic.FrameOrderingMode = frames_order\n\n    def set_device_ip(self, device_name, ip_address_start, **kwargs):\n        \"\"\"\n        Sets Device Ip addresses based on the device group name\n        :param device_name: device name to which Ipv4/Ipv6 address need be set\n        :param ip_address_start: Start Ip address to be set\n        :param kwargs:\n            :type: Ipv4/IPv6, Default value is ipv4\n            :ip_address_step: Default Ipv4 ip address step is \"0.0.0.1\",\n                              Default Ipv6 ip address step is \"::0.1.0.0\"\n\n            :direction: increment|decrement, Default value is increment\n            :gateway_address_start: Gateway Start Address\n            :gateway_address_step: Default Ipv4 gateway address step is \"0.0.0.0\"\n                                   Default Ipv6 gateway address step is \"::0.0.0.0\"\n        :return: True if successful\n        :Example: set_device_ip(device_name= 'TenGigE0/2/0/0_v4', ip_address_start = '6.5.5.5', gateway_address_start = '6.5.5.1')\n        \"\"\"\n        # Setting Default values\n        kwargs['type'] = kwargs.get('type', 'ipv4')\n        kwargs['direction'] = kwargs.get('direction', 'increment')\n        if kwargs['type'].lower() == 'ipv6':\n            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '::0.1.0.0')\n            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '::0.0.0.0')\n            try:\n                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name='^' + device_name + '$').Ethernet.find().Ipv6.find()\n            except:\n                raise IxiaOperationException(\"Device Group not Found\")\n        elif kwargs['type'].lower() == 'ipv4':\n            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '0.0.0.1')\n            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '0.0.0.0')\n            try:\n                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name='^' + device_name + '$').Ethernet.find().Ipv4.find()\n            except:\n                raise IxiaOperationException(\"Device Group not Found\")\n\n        if type(ip_address_start) == list:\n            ipObj.Address.ValueList(values= ip_address_start)\n        else:\n            if kwargs['direction'].lower() == \"decrement\":\n                ipObj.Address.Decrement(start_value= ip_address_start, step_value= kwargs['ip_address_step'])\n                if kwargs['gateway_address_start']:\n                    ipObj.GatewayIp.Decrement(start_value=kwargs['gateway_address_start'], step_value=kwargs['gateway_address_step'])\n                else:\n                    pass\n            elif kwargs['direction'].lower() == \"increment\":\n                ipObj.Address.Increment(start_value=ip_address_start, step_value= kwargs['ip_address_step'])\n                if kwargs['gateway_address_start']:\n                    ipObj.GatewayIp.Increment(start_value=kwargs['gateway_address_start'],\n                                                  step_value=kwargs['gateway_address_step'])\n                else:\n                    pass\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        self.log.info(\"Device IP Address configured successfully\")\n        return True\n\n    def capture_start_or_stop(self, port_name_list=None, action='Start', **kwargs):\n        \"\"\"\n        API used to Collect Data or control plane packets\n\n        :param port_name_list: port name list on whc packet need to be captured. E.g. '1/10'\n        :param action: To start capture or stop capture. Default is \"start\". options are \"start\" and \"stop\"\n        :kwargs :\n                :param enable_data : to enable DATA capture (True/False) default False\n                :param enable_control : to enable control capture (True/False) default True\n                :param enable_slice : to enable data/control slicing on capture (True/False)\n\n        :return: filename with path\n\n        :Example: capture_start_or_stop(port_name_list=['1/9' ,'1/10'], action='stop',enable_data = True)\n                  capture_start_or_stop(port_name_list=['10.39.65.156/2/7'], action='start',enable_data = True,enable_control = False)\n                  capture_start_or_stop(port_name_list=['10.39.65.156/2/15'], action='start',enable_control= True,enable_slice = False)\n                  capture_start_or_stop(port_name_list=['10.39.65.156/2/15'], action='start',enable_data= True,enable_slice = True)\n        \"\"\"\n        port_list = []\n        filenames = []\n        self.log.info(f'Capturing port details {port_name_list} with action - {action}')\n        if not port_name_list:\n            self.log.info(f'Capture on all available ports with action - {action}')\n            for port in self.ixNetwork.Vport.find():\n                port_list.append(port.AssignedTo)\n        else:\n            if type(port_name_list) == str:\n                port_name_list = port_name_list.split(\",\")\n            for port in port_name_list:\n                port_info = port.split('/')\n                if len(port_info) < 3:\n                    vport_list = [vport.AssignedTo for vport in self.ixNetwork.Vport.find()]\n                    if isinstance(self.chassis_ip,str):\n                        if ',' in self.chassis_ip:\n                            self.chassis_ip = self.chassis_ip.split(',')\n                        else:\n                            self.chassis_ip = [self.chassis_ip]\n                    for chassis in self.chassis_ip:\n                        port_location = f'{chassis}:{port_info[0]}:{port_info[1]}'\n                        if port_location in vport_list:\n                            port_list.append(port_location)\n                else:\n                    port_list.append(':'.join(port_info))\n        self.log.info(f'Capturing Ports are - {port_list}')\n        if action.lower() == 'stop':\n            path = self.ixNetwork.Globals.PersistencePath\n            captured_files = self.ixNetwork.SaveCaptureFiles(path)\n            for port_name in port_list:\n                vport = self.ixNetwork.Vport.find(AssignedTo='^' + port_name + '$')\n                vport_name = re.sub('/', '-', (vport.Name))\n                for eachfile in captured_files:\n                    if vport_name in eachfile:\n                        timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n                        filename = \"capture_\" + re.sub(' |/', '_',(vport.Name).replace(\"(offline)\", \"\")) + \"_\" + timestamp + \".cap\"\n                        try:\n                            if self.tgn_server_type == 'windows':\n                                api_filename = eachfile.split('\\\\')[-1]\n                                api_filename = api_filename.replace(' ', '_')\n                                src_file = CafyLog.work_dir + \"/\" + api_filename\n                                dst_file = CafyLog.work_dir + \"/\" + 'capture_' + timestamp + '_' + api_filename\n                                self._copyApiServerFileToLocalLinux(eachfile, CafyLog.work_dir, localPathOs='windows')\n                            elif self.tgn_server_type == 'linux':\n                                api_filename = eachfile.split(\"/\")[-1]\n                                api_filename = api_filename.replace(' ', '_')\n                                src_file = CafyLog.work_dir + \"/\" + api_filename\n                                dst_file = CafyLog.work_dir + \"/\" + 'capture_' + timestamp + '_' + api_filename\n                                self._copyApiServerFileToLocalLinux(eachfile, CafyLog.work_dir, localPathOs='linux')\n                            os.rename(src_file, dst_file)\n                            filenames.append(dst_file)\n                            log.info(f\"Capture file successfully created: {dst_file}\")\n                        except:\n                            pass\n        elif action.lower() == 'start':\n            self.ixNetwork.CloseAllTabs()\n            for vport in self.ixNetwork.Vport.find():\n                vport.Capture.HardwareEnabled = False\n                vport.Capture.SoftwareEnabled = False\n            for each_port in port_list:\n                vport = self.ixNetwork.Vport.find(AssignedTo='^' + each_port + '$')\n                enable_data = kwargs.get('enable_data', True)\n                enable_control = kwargs.get('enable_control', True)\n                enable_slice = kwargs.get('enable_slice', '0')\n                self.ixNetwork.Vport.find().Capture.find().SliceSize = enable_slice\n                self.ixNetwork.Vport.find().Capture.find().ControlSliceSize = enable_slice\n                if enable_data:\n                    vport.Capture.HardwareEnabled = enable_data\n                if enable_control:\n                    vport.Capture.SoftwareEnabled = enable_control\n                vport.Capture.CaptureMode = \"captureContinuousMode\"\n                vport.RxMode = 'captureAndMeasure'\n                self.log.info(f\"Starting Packet Capture on Port - {each_port}\")\n                vport.Capture.Start()\n        return filenames\n\n    def set_bgp_ttl(self, ttl, router_id=None):\n        \"\"\"\n        Modify ttl value on BGP devices.\n        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.\n        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100\n        :return True on pass, Exception on failure.\n\n        :Example: set_bgp_ttl(ttl=255, router_id='192.0.0.1')\n        \"\"\"\n        if router_id:\n            self.log.info(\"setting BGP ttl value {} on BGP Router ID {}\".format(ttl, router_id))\n        else:\n            self.log.info(\"setting BGP ttl value {} on all BGP instances\".format(ttl))\n        self._set_get_bgp_ttl(action='set', ttl=ttl, router_id=router_id)\n        return True\n\n    def get_bgp_ttl(self, router_id=None):\n        \"\"\"\n        To fetch ttl value of BGP devices.\n        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.\n        :return ttl_dict: Dictionary of router_id's and ttl value on pass, Exception on failure.\n\n        :Example: get_bgp_ttl(router_id='192.0.0.1')\n        \"\"\"\n        if router_id:\n            self.log.info(\"getting BGP ttl value for BGP Router ID {}\".format(router_id))\n            dicttmp = self._set_get_bgp_ttl(action='get', router_id=router_id)\n            if router_id in dicttmp.keys():\n                ttl_dict = {router_id: dicttmp[router_id]}\n        else:\n            self.log.info(\"getting BGP ttl value for all BGP instances\")\n            ttl_dict = self._set_get_bgp_ttl(action='get', router_id=router_id)\n        return ttl_dict\n\n    def _set_get_bgp_ttl(self, action, ttl=None, router_id=None):\n        \"\"\"\n        To Modify or to get ttl value on/of BGP devices.\n        :param action: 'set' to set the ttl value on BGP devices, 'get' to get the ttl value of BGP devices.\n        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.\n        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100\n        :return True - If action is 'set'. ttl_dict - If action is 'get'.\n        \"\"\"\n        deviceGroupObjects = []\n        ttlDict = {}\n        if router_id:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroup.RouterData.find():\n                    if router_id in deviceGroup.RouterData.find().RouterId.Values:\n                        deviceGroupObjects.append(deviceGroup)\n                        break\n            else:\n                raise IxiaConfigException(\"Router Id '%s' not found on this configuration.\" % router_id)\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroup.RouterData.find():\n                    deviceGroupObjects.append(deviceGroup)\n        if deviceGroupObjects:\n            for deviceGroupObj in deviceGroupObjects:\n                try:\n                    if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                            if action.lower() == 'set':\n                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))\n                                if (len(listVal) > 1):\n                                    if router_id:\n                                        index = bgpObj.LocalRouterID.index(router_id)\n                                        ttlValueList = bgpObj.Ttl.Values\n                                        ttlValueList[index] = ttl\n                                    else:\n                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]\n                                    bgpObj.Ttl.ValueList(ttlValueList)\n                                else:\n                                    bgpObj.Ttl.Single(ttl)\n                            else:\n                                rIdValueList = bgpObj.LocalRouterID\n                                ttlValueList = bgpObj.Ttl.Values\n                                dictTmp = zip(rIdValueList, ttlValueList)\n                                ttlDict.update(dictTmp)\n                except:\n                    pass\n                try:\n                    if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():\n                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():\n                            if action.lower() == 'set':\n                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))\n                                if (len(listVal) > 1):\n                                    if router_id:\n                                        index = bgpObj.LocalRouterID.index(router_id)\n                                        ttlValueList = bgpObj.Ttl.Values\n                                        ttlValueList[index] = ttl\n                                    else:\n                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]\n                                    bgpObj.Ttl.ValueList(ttlValueList)\n                                else:\n                                    bgpObj.Ttl.Single(ttl)\n                            else:\n                                rIdValueList = bgpObj.LocalRouterID\n                                ttlValueList = bgpObj.Ttl.Values\n                                dictTmp = zip(rIdValueList, ttlValueList)\n                                ttlDict.update(dictTmp)\n                except:\n                    pass\n        else:\n            raise IxiaConfigException(\"No BGP found on this configuration.\")\n        if action.lower() == 'set':\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        else:\n            return ttlDict\n\n    def get_port_dict_streams(self, port='all'):\n        '''\n        Get dictionary of streams with port\n        :param port: Port under which streams to returned, by default it is all ports\n        :return: Dictionary of port and stream list\n\n        :Example: get_port_dict_streams(port = ['Ethernet - 001'])\n        '''\n        portDict = dict()\n        streamsList = []\n        if port != 'all':\n            ports = self._get_port_name_list(ports= port)\n            if ports == []:\n               raise CafyException.InvalidValueError('%s Port not available in config' % port)\n        else:\n            ports = [port.Name for port in self.ixNetwork.Vport.find()]\n        for port_name in ports:\n            for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find():\n                for highLevelStreamObj in trafficItemObj.HighLevelStream.find():\n                    if highLevelStreamObj.TxPortName == port_name:\n                        if port_name not in portDict:\n                            portDict[port_name] = []\n                        portDict[port_name].append(trafficItemObj)\n                    else:\n                        streamsList.append(trafficItemObj)\n        return portDict\n\n    def activate_devices(self, device_list=None):\n        \"\"\"\n        API to activate a given set of devices\n        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'\n        :return: True on success, else exception\n\n        :Example: activate_devices(device_list=[\"Group Device 1\"])\n        \"\"\"\n        result = False\n        if device_list:\n            for deviceName in device_list:\n                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(True)\n            result = True\n        else:\n            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                deviceObj.Enabled.Single(True)\n            result = True\n        if result:\n            return True\n        else:\n            raise IxiaConfigException(\"Failed due to configuration issue\")\n\n    def deactivate_devices(self, device_list=None):\n        \"\"\"\n        API to deactivate a given set of devices\n        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'\n        :return: True on success, else exception\n\n        :Example: deactivate_devices(device_list=[\"Group Device 1\"])\n        \"\"\"\n        result = False\n        if device_list:\n            for deviceName in device_list:\n                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(False)\n            result = True\n        else:\n            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                deviceObj.Enabled.Single(False)\n            result = True\n        if result:\n            return True\n        else:\n            raise IxiaConfigException(\"Failed due to configuration issue\")\n\n    def get_module_port_status(self, chassis_to_check=None, port_list=None, check_ports=False):\n        \"\"\"\n        Checks the module and port group status of the current chassis\n        :param chassis_to_check: (str) Optional IP of the chassis to check (default is current)\n            e.g. '172.16.20.5'\n        :param port_list: (list) An optional list of ports to check (default is check all)\n            e.g. ['5/7', '5/8', '7/10']\n        :param check_ports: (bool) Toggles checking at the port level\n        :return: 172.16.20.5,\n\n        :Example: get_module_port_status(chassis_to_check = '10.1.1.1')\n        \"\"\"\n        result = False\n        if chassis_to_check is None:\n            chassis_final = self.ixNetwork.AvailableHardware.Chassis.find().Hostname\n        else:\n            chassis_final = [chassisObj.Hostname for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find() if\n                             chassisObj.Hostname == chassis_to_check]\n        if chassis_final:\n            statusDict = {}\n            chassisIP = str(chassis_final)\n            statusDict[chassisIP] = {}\n            result = True\n            try:\n                if check_ports:\n                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():\n                        chassisState = chassisObj.State\n                        statusDict[chassisIP][chassisState] = {}\n                        if chassisObj.Hostname == chassis_to_check:\n                            for cport in port_list:\n                                cslot, cinterface = cport.split('/')[0], cport.split('/')[1]\n                                for cardObj in chassisObj.Card.find():\n                                    slot = cardObj.CardId\n                                    if slot == int(cslot):\n                                        if slot not in statusDict[chassisIP][chassisState].keys():\n                                            statusDict[chassisIP][chassisState][slot] = {}\n                                        for portObj in cardObj.Port.find():\n                                            portId = portObj.PortId\n                                            if portId == int(cinterface):\n                                                portId = portObj.PortId\n                                                statusDict[chassisIP][chassisState][slot][portId] = {}\n                                                statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable\n                else:\n                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():\n                        chassisState = chassisObj.State\n                        statusDict[chassisIP][chassisState] = {}\n                        if chassisObj.Hostname == chassis_to_check:\n                            for cardObj in chassisObj.Card.find():\n                                slot = cardObj.CardId\n                                statusDict[chassisIP][chassisState][slot] = {}\n                                for portObj in cardObj.Port.find():\n                                    portId = portObj.PortId\n                                    statusDict[chassisIP][chassisState][slot][portId] = {}\n                                    statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable\n            except Exception as err:\n                raise CafyException.TgenClientError('Failed to retrieve module/port status: {}'.format(err))\n        if result:\n            return statusDict\n        else:\n            raise CafyException.InvalidValueError('No matching chassis found in {}'.format(chassis_to_check))\n\n    def create_ipv4_interface(self, router_id=None, ipv4_address=None, ipv4_gateway=None, ipv4_gateway_mac=None,\n                              ipv4_prefix_length=None):\n        \"\"\"\n        Creates Ipv4If object.\n        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be\n                configured.\n        :param ipv4_address: Mapping Ipv4If attribute - Address. Example: 105.1.0.2\n        :param ipv4_gateway: Mapping Ipv4If attribute - Gateway. IPv4 gateway address. Example: 104.1.0.1\n        :param ipv4_gateway_mac: Mapping Ipv4If attribute - GatewayMac. Gateway MAC address. Example: 00:00:00:00:00:01\n        :param ipv4_prefix_length: Mapping Ipv4If attribute - PrefixLength. IPv4 address prefix length. Range: 0 - 32\n        :return: Ipv4If object.\n        :Example: create_ipv6_interface(router_id='10.10.10.1',ipv4_address='10.10.1.1',\n                              ipv4_gateway='10.10.1.2', ipv4_gateway_mac='00:00:01:00:00:01',\n                              ipv4_prefix_length='24')\n        \"\"\"\n        result = False\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:\n                    result = True\n                    Ipv4Obj = deviceGroup.Ethernet.add().Ipv4.add()\n                    Ipv4Obj.Address.Increment(start_value=ipv4_address)\n                    Ipv4Obj.GatewayIp.Increment(start_value=ipv4_gateway)\n                    Ipv4Obj.ManualGatewayMac.Increment(start_value=ipv4_gateway_mac)\n                    Ipv4Obj.Prefix.Increment(start_value=ipv4_prefix_length)\n                    break\n        if result:\n            return Ipv4Obj\n        else:\n            raise IxiaOperationException(\"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n\n    def create_ipv6_interface(self, router_id, ipv6_address=None, ipv6_gateway=None, ipv6_gateway_mac=None,\n                              ipv6_prefix_length=None,ipv6_gateway_learning=None):\n        \"\"\"\n        Creates Ipv6If object.\n        :param router_id: Router ID of Device\n        :param ipv6_address: ipv6 address\n        :param ipv6_gateway: ipv6 gateway address\n        :param ipv6_gateway_mac: ipv6 gateway mac address\n        :param ipv6_prefix_length: ipv6 prefix length\n        :param ipv6_gateway_learning: ipv6 gateway learning mode\n                                    : for ixia Resolve gateway True|False, default is True.\n        :return: Ipv6If object.\n        :Example: create_ipv6_interface(router_id='10.10.10.1', ipv6_address='1000:0:0:1::1',\n                              ipv6_gateway='1000:0:0:1::2',ipv6_gateway_mac='00:00:10:00:00:10',\n                              ipv6_prefix_length='112',ipv6_gateway_learning=True)))\n        \"\"\"\n        result = False\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:\n                    result = True\n                    Ipv6Obj = deviceGroup.Ethernet.add().Ipv6.add()\n                    Ipv6Obj.Address.Increment(start_value=ipv6_address)\n                    Ipv6Obj.GatewayIp.Increment(start_value=ipv6_gateway)\n                    Ipv6Obj.ManualGatewayMac.Increment(start_value=ipv6_gateway_mac)\n                    Ipv6Obj.Prefix.Increment(start_value=ipv6_prefix_length)\n                    Ipv6Obj.ResolveGateway.Single(ipv6_gateway_learning)\n                    break\n        if result:\n            return Ipv6Obj\n        else:\n            raise IxiaOperationException(\"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n\n    def delete_network_groups(self, devices, network_groups, nested_device=None):\n        \"\"\"\n        Deletes network groups\n        :param devices: List of device names\n        :param network_groups: List of network group names\n        :param nested_device: Nested device name\n        :return: True on success\n        \"\"\"\n\n        for each_device in devices:\n            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)\n            if nested_device:\n                device_obj = device_obj.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n\n            for network_group in network_groups:\n                log.info(f\"remove network group: {network_group}\")\n                try:\n                    if device_obj.NetworkGroup.find(Name=network_group):\n                        device_obj.NetworkGroup.find(Name=network_group).remove()\n                except Exception as err:\n                    log.error(f\"Failed to remove network group: {network_group} with error:\\n {err}\")\n                    raise err\n\n    def _delete_protocol(self, device_obj, protocol_name):\n        \"\"\"\n        Deletes protocol\n        :param device_obj: Device object\n        :param protocol_name: Protocol name\n        :return: True on success\n        \"\"\"\n        loopback_protocol_dict = {'BgpIPv4EvpnEvi': 'BgpIpv4Peer', 'BgpIPv6EvpnEvi': 'BgpIpv6Peer'}\n        log.info(f\"remove protocol: {protocol_name}\")\n        try:\n            eval('device_obj' + '.Ethernet.find().' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n\n        try:\n            eval('device_obj' + '.' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n\n        try:\n            eval('device_obj' + '.Ethernet.find().Ipv4.find().' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n\n        try:\n            eval('device_obj' + '.Ethernet.find().Ipv6.find().' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n\n        try:\n            if protocol_name in loopback_protocol_dict.keys():\n                eval('device_obj' + '.Ipv4Loopback.find().' +\n                    loopback_protocol_dict[protocol_name] + '.find().' +\n                    protocol_name + '.find().' + 'remove()')\n            else:\n                eval('device_obj' + '.Ipv4Loopback.find().' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n\n        try:\n            if protocol_name in loopback_protocol_dict.keys():\n                eval('device_obj' + '.Ipv6Loopback.find().' + loopback_protocol_dict[protocol_name] + '.find().' +\n                    protocol_name + '.find().' + 'remove()')\n            else:\n                eval('device_obj' + '.Ipv6Loopback.find().' + protocol_name + '.find().' + 'remove()')\n        except:\n            pass\n        return True\n\n    def delete_protocols(self, devices, protocols, nested_device=None):\n        \"\"\"\n        Deletes protocol\n        :param devices: List of device names\n        :param protocols: List of protocol names\n        :param nested_device: Nested device name\n        :return: True on success\n        \"\"\"\n        protocolsList = {'isis': 'IsisL3', 'dhcpv4client': 'Dhcpv4client', 'dhcpv6client': 'Dhcpv6client',\n                        'pppoxclient': 'Pppoxclient', 'pppoxserver': 'Pppoxserver', 'mpls': 'Mpls',\n                        'dotonex': 'DotOneX', 'bfdv4interface': 'Bfdv4Interface', 'bgp': 'BgpIpv4Peer',\n                        'dhcpv4server': 'Dhcpv4server', 'igmp': 'IgmpHost', 'rsvp': 'RsvpteLsps',\n                        'rsvpteif': 'Rsvpteif', 'bgpevpn': 'BgpIPv4EvpnEvi', 'bgpv6evpn': 'BgpIPv6EvpnEvi',\n                        'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',\n                        'ldptargetedrouter': \"LdpTargetedRouter\",\n                        'ldpconnectedinterface': 'LdpConnectedInterface', 'ospfv2': 'Ospfv2',\n                        'bfdv6interface': 'Bfdv6Interface', 'bgpv6': 'BgpIpv6Peer', 'dhcpv6server': 'Dhcpv6server',\n                        'ldpbasicrouterv6': 'LdpBasicRouterV6', 'ldpv6connectedinterface': 'Ldpv6ConnectedInterface',\n                        'mld': 'MldHost', 'mldquerier': 'MldQuerier', 'pimv6interface': 'PimV6Interface',\n                        'ospfv3': 'Ospfv3','ipv4':'Ipv4','ipv6':'Ipv6'}\n\n        for protocol in protocols:\n            for each_device in devices:\n                device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device)\n                if nested_device:\n                    device_obj = device_obj.NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                self._delete_protocol(device_obj, protocolsList[protocol.lower()])\n\n        return True\n\n\n    def delete_emulated_device(self, router_id=None, **kwargs):\n        \"\"\"\n        Deletes emulated device Objects.\n        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be\n        configured.\n        :return: True on success\n        :Example: delete_emulated_device(router_id='10.10.10.1')\n        \"\"\"\n        result = False\n        device_name = kwargs.get(\"device_name\", None)\n        if isinstance(router_id, str):\n            router_id = [router_id]\n        if isinstance(device_name, str):\n            device_name = [device_name]\n        if router_id == None and device_name == None:\n            raise CafyException.TgenInvalidInputError('router_id or device name is a mandatory parameter.')\n        if device_name:\n            for dev in device_name:\n                for device in self.ixNetwork.Topology.find():\n                    try:\n                        if dev == device.DeviceGroup.find().Name:\n                            device.DeviceGroup.find().remove()\n                            result = True\n                            break\n                    except:\n                        pass\n\n        if router_id:\n            for each_id in router_id:\n                for device in self.ixNetwork.Topology.find():\n                    try:\n                        if each_id in device.DeviceGroup.find().RouterData.find().RouterId.Values:\n                            device.DeviceGroup.find().remove()\n                            result = True\n                            break\n                    except:\n                        pass\n        if result:\n            return True\n        else:\n            raise IxiaOperationException(f\"Given Router ID : {router_id} or device {device_name} is not found in the existing config\")\n\n    def create_dhcp_option(self,router_id,option_type,address_family,\n                           msg_type=['kDiscover', 'kRequest'],\n                           msg_type_list=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'],\n                           remove=False, **kwargs):\n        \"\"\"\n        Configures dhcpv4 or dhcpv6 options (TLV).\n        :param router_id: Name of Device group in which DHCP client is configured.\n        :param option_type: Option value (code).\n        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6.\n        :param msg_type: only applicable to dhcpv4. Includes the message option in 'kDiscover', 'kRequest', 'kDecline', 'kRelease'.\n            Default value for v4 client is ['kDiscover', 'kRequest']\n        :param msg_type_list: only applicable to dhcpv6. Possible values are 'kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'\n            Default value for v4 client is ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'']\n        :param remove: Enable or disable removal of option (TLV). Default is False.\n        :return: True on success.\n        :Example: create_dhcp_option(router_id=\"dhcp-v6-client\", option_type=['SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',\n                 'Identity Association for Prefix Delegation'], address_family=\"IPV6\", msg_type=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'], remove=True)\n        \"\"\"\n\n        v4Msg = ['kDiscover', 'kRequest', 'kDecline', 'kRelease', 'kInform']\n        v4Tlv = ['Subnet Mask', 'Time Offset', 'Router Address', 'Time Server', 'Name Server', 'Domain Name Server',\n                 'Log Server', 'Cookie Server', 'LPR Server', 'Impress Server', 'Resource Location Server', 'Host Name',\n                 'Boot File Size', 'Merit Dump File', 'Domain Name', 'Swap Server', 'Root Path', 'Extension Path',\n                 'IP Forwarding Enable/Disable', 'Non-Local Source Routing Enable/Disable', 'Policy Filter',\n                 'Maximum Datagram Reassembly Size', 'Default IP Time-to-live', 'Path MTU Aging Timeout',\n                 'Path MTU Plateau Table', 'Interface MTU Size', 'All Subnets are Local', 'Broadcast Address',\n                 'Perform Mask Discovery', 'Mask Supplier', 'Perform Router Discovery', 'Router Solicitation Address',\n                 'Static Route', 'Trailer Encapsulation', 'ARP Cache Timeout', 'Ethernet Encapsulation',\n                 'TCP Default TTL', 'TCP Keepalive Interval', 'TCP Keepalive Garbage',\n                 'Network Information Service Domain', 'Network Information Servers', 'Network Time Protocol Servers',\n                 'Vendor Specific Information', 'NetBIOS over TCP/IP Name Server',\n                 'NetBIOS over TCP/IP Datagram Distribution Server', 'NetBIOS over TCP/IP Node Type',\n                 'NetBIOS over TCP/IP Scope', 'X Window System Font Server', 'X Window System Display Manager',\n                 'Requested IP Address', 'IP Address Lease Time', 'Option Overload', 'DHCP Message Type',\n                 'Server Identifier', 'Parameter Request List', 'Message', 'Maximum DHCP Message Size',\n                 'Renewal (T1) Time Value', 'Renewal (T2) Time Value', 'Vendor Class Identifier', 'Client Identifier',\n                 'NetWare/IP Domain Name', 'NetWare/IP Information', 'Network Information Service+ Domain',\n                 'Network Information Service+ Servers', 'TFTP Server Name', 'Bootfile Name', 'Mobile IP Home Agent',\n                 'Simple Mail Transport Protocol (SMTP) Server', 'Post Office Protocol (POP3) Server',\n                 'Network News Transport Protocol (NNTP) Server', 'Default World Wide Web (WWW) Server',\n                 'Default Finger Server', 'Default Internet Relay Chat (IRC) Server', 'StreetTalk Server',\n                 'StreetTalk Directory Assistance (STDA) Server', 'User Class Information', 'SLP Directory Agent',\n                 'SLP Service Scope', 'Rapid Commit', 'DHCP Client FQDN', 'DHCP Relay Agent Information',\n                 'Authentication (RFC3118)']\n        v6Msg = ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind']\n        v6Tlv = ['Client Identifier', 'Client Identifier', 'Server Identifier',\n                 'Identity Association for Non-temporary Addresses', 'Identity Association for Temporary Addresses',\n                 'IA Address', 'Option Request', 'Preference', 'Elapsed Time', 'Relay Message', 'Authentication',\n                 'Server Unicast', 'Status Code', 'Rapid Commit', 'User Class', 'Vendor Class',\n                 'Vendor-specific Information', 'Interface-ID', 'Reconfigure Message', 'Reconfigure Accept',\n                 'SIP Servers Domain Name', 'SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',\n                 'Identity Association for Prefix Delegation', 'IA_PD Prefix',\n                 'Network Information Service (NIS) Servers', 'Network Information Service V2 (NIS+) Servers',\n                 'Network Information Service (NIS) Domain Name',\n                 'Network Information Service V2 (NIS+) Domain Name Option',\n                 'Simple Network Time Protocol (SNTP) Servers', 'Information Refresh Time',\n                 'Broadcast and Multicast Service Controller Domain Name',\n                 'Broadcast and Multicast Service Controller IPv6 Address', 'DHCP Civic Location',\n                 'Relay Agent Remote-ID', 'Relay Agent Subscriber-ID', 'Client FQDN', 'PANA Authentication Agent',\n                 'POSIX Timezone', 'Timezone Database', 'Relay Agent Echo Request', 'Query', 'Client Data',\n                 'Client Last Transaction Time', 'Relay Data', 'Client Link', 'MIPv6 Home Network ID FQDN',\n                 'MIPv6 Visited Home Network Information', 'LoST Server', 'CAPWAP AC', 'Relay-ID', 'MoS IPv6 Address',\n                 'MoS Domain Name List', 'NTP Server', 'Access Network Domain Name',\n                 'SIP User Agent Configuration Service Domains', 'Boot File Uniform Resource Locator',\n                 'Boot File Parameters', 'Client System Architecture Type', 'Client Network Interface Identifier',\n                 'Geographical Location', 'AFTR-Name', 'ERP Local Domain Name', 'Relay-Supplied DHCP Options',\n                 'Prefix Exclude', 'Virtual Subnet Selection', 'MIPv6 Identified Home Network Information',\n                 'MIPv6 Unrestricted Home Network Information', 'MIPv6 Home Network Prefix', 'MIPv6 Home Agent Address',\n                 'MIPv6 Home Agent FQDN', 'RDNSS Selection DHCPv6', 'Kerberos Principal Name', 'Kerberos Realm Name',\n                 'Kerberos Default Realm Name', 'Kerberos KDC']\n\n        if re.match(r'\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}', router_id):\n            raise IxiaConfigException('IXIA doesn\"t support IP v4/v6 address format. Please provide Device Group Name')\n        elif any(type(var) is not list for var in (option_type, msg_type_list, msg_type)):\n            raise IxiaOperationException('All these msg_type/msg_type_list/option_type arguments has to be in'\n                                         ' list format')\n        else:\n            if self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id):\n                if re.fullmatch('ipv4|v4', address_family, re.IGNORECASE):\n                    if set(option_type) - set(v4Tlv) or set(msg_type) - set(v4Msg):\n                        raise IxiaOperationException('DHCP v4 client supports the following message {0} and the '\n                                                     'following TLV {1}'.format(v4Msg, v4Tlv))\n                    else:\n                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find()\\\n                            .Dhcpv4client.find()\n                        tlvMessage = msg_type\n                elif re.fullmatch('ipv6|v6', address_family, re.IGNORECASE):\n                    if set(option_type) - set(v6Tlv) or set(msg_type_list) - set(v6Msg):\n                        raise IxiaOperationException('DHCP v6 client supports the following message {0} and the '\n                                                     'following TLV {1}'.format(v6Msg, v6Tlv))\n                    else:\n                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find().\\\n                            Dhcpv6client.find()\n                        tlvMessage = msg_type_list\n                else:\n                    raise IxiaOperationException('Given \"{}\" format is not supported for \"address_family\" argument. '\n                                                 'It accepts any one from the following ipv4/v4/ipv6/v6'.\n                                                 format(address_family))\n\n                if not dhcpObj:\n                    raise IxiaConfigException(\n                        'DHCP {} client is not configured in the \"{}\" devicegroup'.format(address_family, router_id))\n\n                if not remove:\n                    for tlv in option_type:\n                        dhcpObj.TlvProfile.find().Tlv.add(Name=tlv, IncludeInMessages=tlvMessage)\n                    return True\n                else:\n                    tlvnotconfigured = []\n                    for tlv in option_type:\n                        if dhcpObj.TlvProfile.find().Tlv.find(Name=tlv):\n                            dhcpObj.TlvProfile.find().Tlv.find(Name=tlv).remove()\n                        else:\n                            tlvnotconfigured.append(tlv)\n\n                    if tlvnotconfigured:\n                        self.log.info('The following TLV\"s {0} are not configured in the DHCP {1} Client'\n                                      .format(tlvnotconfigured, address_family))\n                    return True\n            else:\n                raise IxiaConfigException('Given device group \"{}\" doesn\"t exist.'.format(router_id))\n\n    def _get(self, handle, *args):\n        \"\"\"\n        Returns the value(s) of one or more object attributes.\n\n        If multiple arguments, this method returns a dictionary of argument\n        names mapped to the value returned by each argument.\n        Ex :{attrib_name:attrib_val, attrib_name:attrib_val, ..}\n\n        If a single argument is given, then the response is a list of values/string value\n        for that argument.\n\n        NOTE: If the string contains multiple substrings, then the\n        client will need to parse these.\n        :param handle: Handle that identifies object to get info for.\n        :param args: Zero or more attributes or relationships.\n        :return: Dictionary/list/string mapped to object attributes else raises exception.\n        \"\"\"\n        data = {}\n        try:\n            if args:\n                for arg in args:\n                    if self.bgp_devices != {} and handle in self.bgp_devices:\n                        bgpHandle = self.bgp_devices[handle]\n                        data[arg] = eval('bgpHandle.' + arg)\n                    if self.isis_devices != {} and handle in self.isis_devices:\n                        isisHandle = self.isis_devices[handle]\n                        data[arg] = eval('isisHandle.' + arg)\n                    if self.ldp_devices != {} and handle in self.ldp_devices:\n                        ldpHandle = self.ldp_devices[handle]\n                        data[arg] = eval('ldpHandle.' + arg)\n                    if self.ospf_devices != {} and handle in self.ospf_devices:\n                        ospfHandle = self.ospf_devices[handle]\n                        data[arg] = eval('ospfHandle.' + arg)\n        except:\n            raise IxiaOperationException(\n                'Invalid handle \"%s\". Please obtain the handle using create or get' % str(handle))\n        return data\n\n    def _get_emulated_devices(self):\n        \"\"\"\n        Get the list of Emulated Devices in configuration.\n\n        :return: list of emulated devices.\n        \"\"\"\n        log.debug('Fetch emulated devices from config')\n        try:\n            if self.ixNetwork.Topology.find().DeviceGroup.find():\n                self.emulated_devices = self.ixNetwork.Topology.find().DeviceGroup.find()\n            return self.emulated_devices\n        except:\n            raise IxiaOperationException(\"Device Config Not Found\")\n\n    def _get_bgp_config_for_emulated_devices(self):\n        \"\"\"\n        Get BGP routers in the configuration.\n\n        :return: Dictionary of BGP routers.\n        \"\"\"\n        log.info('Fetch BGP devices from config')\n        for device in self.emulated_devices:\n            try:\n                if device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():\n                    self.bgp_devices[\n                        device.Ethernet.find().Ipv4.find()] = device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()\n                    self._get_bgp_routes_for_emulated_device(device)\n            except:\n                pass\n            try:\n                if device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():\n                    self.bgp_devices[\n                        device.Ethernet.find().Ipv6.find()] = device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()\n                    self._get_bgp_routes_for_emulated_device(device)\n            except:\n                pass\n        return self.bgp_devices\n\n    def _get_bgp_routes_for_emulated_device(self, device, bgp_router_config=None):\n        \"\"\"\n        Get the BGP routes for a given device.\n\n        :param device: Emulated device name\n        :param bgp_router_config: BGP router config handle\n        :return:\n        \"\"\"\n        device_name = device.Name\n        try:\n            if device.NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find() or device.NetworkGroup.find().Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():\n                for ipv4PrefixPool in device.NetworkGroup.find().Ipv4PrefixPools.find():\n                    start_ip = ipv4PrefixPool.NetworkAddress.Values\n                    router_id = device.RouterData.find().RouterId.Values\n                    self.bgp_routes_startip_rid_v4[str(start_ip), str(router_id)] = ipv4PrefixPool\n                    self.bgp_routes_startip_device_name_v4[str(start_ip), device_name] = ipv4PrefixPool\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.href in device.href:\n                            for vportObj in self.ixNetwork.Vport.find():\n                                if vportObj.href in topology.Vports:\n                                    port_name = vportObj.Name\n                                    self.bgp_routes_startip_port_name_v4[port_name, str(start_ip)] = ipv4PrefixPool\n        except:\n            pass\n        try:\n            if device.NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find() or device.NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():\n                for ipv6PrefixPool in device.NetworkGroup.find().Ipv6PrefixPools.find():\n                    start_ip = ipv6PrefixPool.NetworkAddress.Values\n                    router_id = device.RouterData.find().RouterId.Values\n                    self.bgp_routes_startip_rid_v6[str(start_ip), str(router_id)] = ipv6PrefixPool\n                    self.bgp_routes_startip_device_name_v6[str(start_ip), device_name] = ipv6PrefixPool\n                    for topology in self.ixNetwork.Topology.find():\n                        if topology.href in device.href:\n                            for vportObj in self.ixNetwork.Vport.find():\n                                if vportObj.href in topology.Vports:\n                                    port_name = vportObj.Name\n                                    self.bgp_routes_startip_port_name_v6[port_name, str(start_ip)] = ipv6PrefixPool\n        except:\n            pass\n\n    def set_ipv4_traffic_ttl(self, traffic_item, ttl):\n        \"\"\"\n        setting the value of the TTL Value for the specified traffic items\n\n        :param traffic_item: (list/str) of Traffic items to set the TTL value from.\n        :param ttl: (list/str/int) of ttl values to be set\n        :return: return True on success else raises exception\n\n        :Example: set_ipv4_traffic_ttl(traffic_item= [\"Traffic Item 1\",\"Traffic Item 2\"],ttl = ['255','220'])\n                  set_ipv4_traffic_ttl(traffic_item= [\"Traffic Item 1\",\"Traffic Item 2\"],ttl = '255')\n                  set_ipv4_traffic_ttl(traffic_item= \"Traffic Item 1\",ttl = '255')\n                  set_ipv4_traffic_ttl(traffic_item= \"Traffic Item 1\",ttl = 255)\n        \"\"\"\n        self.log.info(\"Setting TTL for Traffic item\")\n        if type(traffic_item) != list:\n            traffic_item = [traffic_item]\n        for item in traffic_item:\n            item = item.replace('+', r'\\+').replace('*', r'\\*').replace('(',r'\\(').replace(')',r'\\)')\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():\n                try:\n                    configElement.Stack.find(DisplayName=\"IPv4\")\n                    fieldValue = configElement.Stack.find(StackTypeId='ipv4').Field.find(Name='ttl')\n                    fieldValue.ValueType = 'singleValue'\n                    if type(ttl) == int:\n                        ttl = str(ttl)\n                        fieldValue.SingleValue = ''.join(ttl)\n                    if type(ttl) == list:\n                        fieldValue.SingleValue = ttl[traffic_item.index(item)]\n                    if type(ttl) == str:\n                        fieldValue.SingleValue = ''.join(ttl)\n                except:\n                    self.log.info(\"IPV4 stack Not Available in %s\" % item)\n                    raise IxiaOperationException(\"IPV4 Stack Not Available in %s\" % item)\n        return True\n\n    def set_ipv6_traffic_hop_limit(self, traffic_item, hop_limit):\n        \"\"\"\n        setting the value of the Hop Limit Value for the specified traffic items\n\n        :param traffic_item: (list/str) of Traffic items to set the TTL value from.\n        :param hop_limit: (list/str/int) of hop_limit values to be set\n        :return: return True on success else raises exception\n\n        :Example: set_ipv6_traffic_hop_limit(traffic_item= [\"Traffic Item 1\",\"Traffic Item 2\"],hop_limit = ['255','220'])\n                  set_ipv6_traffic_hop_limit(traffic_item= [\"Traffic Item 1\",\"Traffic Item 2\"],hop_limit = '225')\n                  set_ipv6_traffic_hop_limit(traffic_item= \"Traffic Item 1\",hop_limit = '225')\n                  set_ipv6_traffic_hop_limit(traffic_item= \"Traffic Item 1\",hop_limit = 225)\n        \"\"\"\n        self.log.info(\"Setting Hop Limit for Traffic item\")\n        if type(traffic_item) != list:\n            traffic_item = [traffic_item]\n        for item in traffic_item:\n            item = item.replace('+', r'\\+').replace('*', r'\\*').replace('(',r'\\(').replace(')',r'\\)')\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():\n                try:\n                    configElement.Stack.find(DisplayName=\"IPv6\")\n                    fieldValue = configElement.Stack.find(StackTypeId='ipv6').Field.find(Name='hopLimit')\n                    fieldValue.ValueType = 'singleValue'\n                    if type(hop_limit) == int:\n                        hop_limit = str(hop_limit)\n                        fieldValue.SingleValue = ''.join(hop_limit)\n                    if type(hop_limit) == list:\n                        fieldValue.SingleValue = hop_limit[traffic_item.index(item)]\n                    if type(hop_limit) == str:\n                        fieldValue.SingleValue = ''.join(hop_limit)\n                except:\n                    self.log.info(\"IPV6 stack Not Available in %s\" % item)\n                    raise IxiaOperationException(\"IPV6 Stack Not Available in %s\" % item)\n        return True\n\n    def get_traffic_ethernet_vlan_priority(self, traffic_list):\n        \"\"\"\n        Gets the value of the Ethernet VLAN priority for the specified traffic items\n\n        :param traffic_list: A list of traffic items to get the VLAN priority values from.\n        :return: A dict of results containing the VLAN ID and VLAN priority value for the specified traffic items\n\n        :Example: get_traffic_ethernet_vlan_priority(traffic_list=[\"Traffic Item 1\"])\n        \"\"\"\n        self.log.info(\"Getting VLAN Priority For Traffic Items\")\n        results = {}\n        for trafficName in traffic_list:\n            vlanPriority = list()\n            try:\n                for vlanStack in self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').ConfigElement.find().Stack.find(StackTypeId='vlan'):\n                    vlanPriority.append({'vlan':vlanStack.Field.find(Name='vlan_id').SingleValue,'priority': vlanStack.Field.find(Name='vlan_user_priority').SingleValue})\n                results[trafficName] = vlanPriority\n            except:\n                self.log.info(\"Not able to find the %s in config\" % trafficName)\n                raise IxiaOperationException(\"Not able to find the %s in config\" % trafficName)\n        return results\n\n    def set_network_group_count(self, network_count, network_group, **kwargs):\n        \"\"\"\n        Set network group count of MAC Pools.\n\n        :param int network_count: Network count. Should be >=1.\n        :param str network_group: Network Group Name.\n        :param kwargs: Additional keyword arguments.\n            - nested_network_group (str): Network Group name at nested level, default is None.\n            - network_group_mac (str): MAC address to be set on NG, default is '10:00:00:00:00:00'.\n            - network_group_mac_step (str): MAC address to be incremented, default is '00:00:00:00:00:01'.\n            - mac1 (str): Custom type MAC address 1, default is '00:00:00:00:00:01'.\n            - mstep1 (int): Custom type MAC address step 1, default is 1.\n            - mac2 (str): Custom type MAC address 2, default is '00:00:00:00:00:01'.\n            - mstep2 (int): Custom type MAC address step 2, default is 1.\n            - network_group_vlan (int): VLAN start value, default is 1001.\n            - network_group_vlan_step (int): VLAN step value, default is 1.\n            - vlan1 (int): Custom VLAN1 increment value, default is 1.\n            - vstep1 (int): Custom VLAN1 step1, default is 1.\n            - vlan2 (int): Custom VLAN2 increment value, default is 1.\n            - vstep2 (int): Custom VLAN2 step2, default is 1.\n            - first_level_spoke_count (int): Custom first level spoke count, default is 1.\n\n        Example:\n            set_network_group_count(network_count = 5,network_group='Network Group 1')\n            set_network_group_count(network_count = 3,network_group='Network Group 1',network_group_mac = \"00:13:00:01:10:01\",\n            network_group_mac_step = \"00:00:00:00:00:00\",mac1 = '00:00:00:01:00:00',mstep1 = 4, mac2 = '00:00:00:00:00:01',\n            mstep2 = 5, network_group_vlan = 200, network_group_vlan_step = 3, vlan1 = 2,vstep1 = 1,vlan2 = 2,vstep2 = 2)\n        \"\"\"\n\n        self.log.info(\"Setting Network Group count and MAC and VLAN\")\n        nested_network_group = kwargs.get('nested_network_group', None)\n        network_group_mac = kwargs.get('network_group_mac', '10:00:00:00:00:00')\n        network_group_mac_step = kwargs.get('network_group_mac_step', '00:00:00:00:00:01')\n        mac1 = kwargs.get('mac1', '00:00:00:00:00:01')\n        mstep1 = kwargs.get('mstep1', 1)\n        mac2 = kwargs.get('mac2', '00:00:00:00:00:01')\n        mstep2 = kwargs.get('mstep2', 1)\n        network_group_vlan = kwargs.get('network_group_vlan', '1001')\n        network_group_vlan_step = kwargs.get('network_group_vlan_step', '0')\n        vlan1 = kwargs.get('vlan1', '0')\n        vstep1 = kwargs.get('vstep1', 1)\n        vlan2 = kwargs.get('vlan2', '1')\n        vstep2 = kwargs.get('vstep2', 1)\n        network_obj = None\n        first_level_spoke_count = kwargs.get('first_level_spoke_count',1)\n        try:\n            if network_group and nested_network_group is None:\n                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + network_group + '$')\n            elif network_group and nested_network_group:\n                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + network_group + '$').DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + nested_network_group + '$')\n            if network_obj:\n                network_obj.Multiplier = network_count\n            else:\n                self.log.error(f'Network Group Not Found - {network_group}')\n            if network_obj.MacPools.find():\n                network_obj.MacPools.find().Mac.Custom(start_value=network_group_mac, step_value=network_group_mac_step,\n                                                    increments=[(mac1, mstep1, [(mac2, mstep2, [])])])\n\n                network_obj.MacPools.find().Vlan.find().VlanId.Custom(start_value=network_group_vlan,\n                                                                    step_value=network_group_vlan_step,\n                                                                    increments=[(vlan1, vstep1, [(vlan2, vstep2, [])])])\n            if network_obj.NetworkTopology.find():\n                if network_obj.NetworkTopology.find().NetTopologyHubNSpoke.find():\n                    network_obj.NetworkTopology.find().NetTopologyHubNSpoke.find().NumberOfFirstLevelSpokes = first_level_spoke_count\n        except:\n            self.log.info(\"%s Not in config \" % network_group)\n            raise IxiaOperationException(\"%s Not in config \" % network_group)\n        return True\n\n    def create_ethernetII_interface(self, router_id=None, source_mac=None):\n\n        \"\"\"\n        Creates VlanIf object.\n        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be\n                configured.\n        :param source_mac: Mapping EthIIIf attribute - SourceMac. Example: 00:10:94:00:00:02\n        :return: EthIIIf object.\n\n        Example: create_ethernetII_interface(router_id=\"192.0.0.1\", source_mac=\"00:10:94:00:00:ff\")\n        \"\"\"\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:\n                    result = True\n                    EthObj = deviceGroup.Ethernet.find()\n                    if not EthObj:\n                        EthObj = deviceGroup.Ethernet.add()\n                    else:\n                        EthObj.Mac.Increment(start_value=source_mac)\n                    break\n\n        if result:\n            return EthObj\n        else:\n            raise IxiaOperationException(\"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n\n    def create_vlan_interface(self, router_id, vlan_id=None, id_step=None, vlan_priority=None):\n\n        \"\"\"\n        Creates VlanIf object.\n        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be\n                configured.\n        :param vlan_id: Mapping VlanIf attribute - VlanId. Range: 0 - 4095\n        :param id_step: Mapping VlanIf attribute - IdStep.\n        :param vlan_priority: Mapping VlanIf attribute - Priority. Range: 0 - 7\n        :return: VlanIf object.\n        Example: create_vlan_interface(router_id=\"192.0.0.1\", vlan_id=5, id_step=1, vlan_priority=2)\n        \"\"\"\n\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:\n                    result = True\n                    deviceGroup.Ethernet.find().UseVlans = True\n                    VlanObj = deviceGroup.Ethernet.find().Vlan.find()\n                    VlanObj.VlanId.Increment(start_value=vlan_id, step_value=id_step)\n                    VlanObj.Priority.Increment(start_value=vlan_priority)\n                    break\n\n        if result:\n            return VlanObj\n        else:\n            raise IxiaOperationException(\"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n\n    def set_emulated_device_basic_attributes(self,\n                                             router_id=None,\n                                             device_count=None,\n                                             enable_ping_response=None,\n                                             router_id_step=None,\n                                             ipv6_router_id=None,\n                                             ipv6_router_id_step=None,\n                                             emulated_device_name=None):\n\n        \"\"\"\n        Sets emulated device attributes.\n\n        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be configured.\n        :param device_count: Mapping emulated device attribute - DeviceCount.\n            Description: Number of devices in the device block.\n            Type: u32\n            Range: 1 - 0xFFFFFFFF\n        :param enable_ping_response: Mapping emulated device attribute - EnablePingResponse.\n            Description: Whether the emulated device will respond to ping.\n            Type: bool\n            Possible Values: TRUE - Respond to ping. FALSE - Do not respond to ping.\n        :param router_id_step: Mapping emulated device attribute - RouterIdStep.\n            Type: ip (Example: 0.0.0.1)\n        :param ipv6_router_id: Mapping emulated device attribute - Ipv6RouterId.\n            Type: ipv6 (Example: 2000::1)\n        :param ipv6_router_id_step: Mapping emulated device attribute - Ipv6RouterIdStep.\n            Type: ipv6 (Example: 0000::1)\n        :param emulated_device_name: Mapping emulated device attribute - Name.\n            Description: Emulated device name, Example: \"Device 1\"\n        :return: True on success\n\n        Example: set_emulated_device_basic_attributes(router_id=\"193.0.0.1\",\n                                             device_count=30,\n                                             enable_ping_response=True,\n                                             router_id_step=\"0.0.0.5\",\n                                             ipv6_router_id='150::0',\n                                             ipv6_router_id_step=2,\n                                             emulated_device_name=\"DG2\")\n        \"\"\"\n\n        result = False\n\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():\n                try:\n                    if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(\n                            Name=deviceGroup.Name).RouterData.find().RouterId.Values:\n                        devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroup.Name)\n                        if devicegroupObj:\n                            if emulated_device_name is not None:\n                                devicegroupObj.Name = emulated_device_name\n                            if device_count is not None:\n                                devicegroupObj.Multiplier = device_count\n                            if devicegroupObj.RouterData.find():\n                                devicegroupObj.RouterData.find().RouterId.Increment(step_value=router_id_step)\n                            else:\n                                raise IxiaConfigException(\n                                    \"No router data found on the given Router-ID '{}'\".format(router_id))\n                            result = True\n                except:\n                    pass\n        if result:\n            return True\n        else:\n            raise IxiaOperationException(\"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n\n    def create_dhcp_client(self, router_id, address_family, vlan1_id=None, vlan1_step=1, vlan2_id=None, vlan2_step=1,\n                           source_mac=None, dhcpv6_client_mode='iana', dhcpv6_duid_type='duid_llt'):\n\n        \"\"\"\n        Creates dhcp client (IPv4, IPv6).\n\n        :param router_id: Mandatory parameter. IXIA doesn't support IPv4 / IPv6 address format. Please input Device Group Name to which DHCP client has to be configured.\n        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6|.\\\n            IXIA doesn't support dual stack (IPv4v6)\n        :param vlan1_id: vlan ID in case of single tagged and SVLAN (Outer VLAN), in case of QinQ.\n            Parent Object: VlanIf\n            Range: 0 - 4095\n        :param vlan1_step: VLAN ID step value.\n            Parent Object: VlanIf\n        :param vlan2_id: CVLAN (Inner VLAN), in case of QinQ.\n            Parent Object: VlanIf\n            Range: 0 - 4095\n        :param vlan2_step: VLAN ID step value.\n            Parent Object: VlanIf\n        :param source_mac: Mapping EthiiIf attribute - SourceMac. Source MAC address. Example: 00:10:94:00:00:02\n        :param dhcpv6_client_mode: The type of client to emulate. Applicable to dhcpv6 only. possible values:\n            IANA - The client emulates DHCPv6. (default)\n            IATA - The client emulates DHCP PD.\n            IAPD - The client emulates DHCP PD.\n            IANA_IAPD - The client emulates DHCPv6 and DHCP PD.\n        :param dhcpv6_duid_type: DHCPv6 unique identifier type. possible values:\n            DUID_LLT    - Link-layer address plus time. (default)\n            DUID_EN     - Vendor-assigned unique ID based on enterprise number.\n            DUID_LL     - Link-layer address.\n        :return: True on success\n        Example: create_dhcp_client(router_id='DG1',\n                                    address_family='ipv4',\n                                    vlan1_id=2,\n                                    vlan1_step=1,\n                                    vlan2_id=3,\n                                    vlan2_step=1,\n                                    source_mac=\"00:10:94:00:00:02\",\n                                    dhcpv6_client_mode='iana',\n                                    dhcpv6_duid_type='duid_llt')\n        \"\"\"\n        result = False\n\n        if re.match(r'\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}', router_id):\n            raise IxiaConfigException('IXIA doesn\"t support IP v4/v6 address format for DHCP. Please provide Device'\n                                      ' Group Name')\n        else:\n            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')\n            if devicegroupObj:\n                result = True\n                if vlan1_id is None and vlan2_id or vlan1_id and vlan2_id:\n                    enableVlan = True\n                    TotalVlan = 2\n                elif vlan1_id and vlan2_id is None:\n                    enableVlan = True\n                    TotalVlan = 1\n                elif vlan1_id is None and vlan2_id is None:\n                    enableVlan = None\n                    TotalVlan = None\n                vlanId = [vlan1_id, vlan2_id]\n                vlanId = [0 if vId is None else vId for vId in vlanId]\n                vlanStep = [vlan1_step, vlan2_step]\n                EthObj = devicegroupObj.Ethernet.add(UseVlans=enableVlan, VlanCount=TotalVlan)\n                EthObj.Mac.Increment(start_value=source_mac)\n                if enableVlan:\n                    for vlanObj, id, step in zip(EthObj.Vlan.find(), vlanId, vlanStep):\n                        vlanObj.VlanId.Increment(start_value=id, step_value=step)\n                if re.search('ipv4|v4', address_family.lower()):\n                    dhcpObj = EthObj.Dhcpv4client.add()\n                elif re.search('ipv6|v6', address_family.lower()):\n                    dhcpObj = EthObj.Dhcpv6client.add()\n                    dhcpObj.Dhcp6IaType.Single(dhcpv6_client_mode.lower())\n                    dhcpObj.Dhcp6DuidType.Single(dhcpv6_duid_type.lower())\n\n        if result:\n            return result\n        else:\n            raise IxiaConfigException('No matching Device Group is found for the given name \"{}\"'.format(router_id))\n\n    def set_stream_ip_count(self, stream_name, src_or_dest, ip_count, version='ipv4', **kwargs):\n        \"\"\"\n        API to modify traffic items source and destination step count\n        :param stream_name: Traffic item name Ex : \"Traffic Item 1\"\n        :param src_or_dest: set IP count on src/dest/both EX: src\n        :param ip_count: IP count to set EX: 50\n        :param version: ipv4/6 EX: \"ipv4\"\n        :param kwargs: Supported step_value parameters as optional in kwargs.\n        :return: True on Success\n\n        :Example: tgnObj.set_stream_ip_count(stream_name=\"Traffic Item 1\",src_or_dest=\"src\",ip_count=50,version=\"ipv4\")\n        \"\"\"\n        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')\n        if not trafficItemObj:\n            raise IxiaConfigException(\"Traffic item not found\")\n        if trafficItemObj.TrafficType != 'raw':\n            raise IxiaConfigException(\"Traffic type should be raw\")\n        if version.lower() == 'ipv4':\n            version = \"IPv4\"\n        if version.lower() == 'ipv6':\n            version = \"IPv6\"\n        if src_or_dest.lower() in [\"src\", \"both\"]:\n            try:\n                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(\n                    DisplayName=\"Source Address\")\n                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[\n                    0] if field.ValueType == 'valueList' else field.StartValue]\n                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \\\n                    , str(start_address[0]), ip_count, str(start_address[0])\n                if kwargs['step_value']:\n                    field.StepValue = kwargs['step_value']\n            except:\n                pass\n        if src_or_dest.lower() in [\"dest\", \"both\"]:\n            try:\n                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(\n                    DisplayName=\"Destination Address\")\n                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[\n                    0] if field.ValueType == 'valueList' else field.StartValue]\n                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \\\n                    , str(start_address[0]), ip_count, str(start_address[0])\n                if kwargs['step_value']:\n                    field.StepValue = kwargs['step_value']\n            except:\n                pass\n        return True\n\n    def get_dynamic_ip_list_device(self, router_id, protocol='ipv4'):\n\n        \"\"\"\n        Returns a list of IP Address configured for a specific device\n\n        :param router_id: Mandatory parameter. Router ID of emulated device.\n        :param protocol: IP Protocol (ipv4|ipv6)\n\n        :return: A list of ip addresses for the emulated device.\n                e.g: ['10.0.0.1', '10.0.0.2', '10.0.0.3']\n\n        :Example: get_dynamic_ip_list_device(\"DG1\", 'ipv4')\n        \"\"\"\n        self.log.info(\"Getting Dynamic IP list of the devices\")\n        if re.match(r'\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}', router_id):\n            raise IxiaConfigException('IXIA doesn\"t support IP v4/v6 address format. Please provide Device Group Name')\n        elif protocol.lower() != 'ipv4' and protocol.lower() != 'ipv6':\n            raise IxiaConfigException(\"Unsupported IP type. Please use ipv4 or ipv6\")\n        else:\n            protocol = protocol[0].capitalize() + protocol[1:]\n            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')\n            if devicegroupObj:\n                try:\n                    ipObj = getattr(devicegroupObj.Ethernet.find(), protocol).find()\n                    deviceIp = ipObj.Address.Values\n                except:\n                    raise IxiaConfigException(\"{0} stack doesn't exist on given device group {1}.\".format(protocol, router_id))\n            else:\n                raise IxiaConfigException('Given device group \"{}\" doesn\"t exist.'.format(router_id))\n        return deviceIp\n\n    def set_invalid_ipv4(self, traffic_items, cfg_dict):\n        \"\"\"\n        API used to configure invalid IPv4 headers for a given list of streams\n\n        :param traffic_items: A str of list of traffic items whose headers will be changed\n        :param cfg_dict: A config dictionary containing the header values to be changed\n            src_addr (sourceAddr)\n            dst_addr (destAddr)\n            checksum (checksum)\n            header_length (ihl)\n            ttl (ttl)\n            version (version)\n            total_length (totalLength)\n            frag_offset (fragOffset)\n            options (options)\n            source_routing (loosesrcroute)\n            record_route (recordroute)\n            timestamp (timestamp)\n        :return: True on success, exception on failure\n        :Example: set_invalid_ipv4(['Traffic item'], {'src_addr':'100.1.1.1', 'dst_addr':'100.1.1.2', 'checksum':64, 'header_length':10, 'ttl':64, 'total_length':8,'frag_offset':10})\n        \"\"\"\n        self.log.info(\"Configuring invalid Ipv4 headers\")\n        for trafficItemName in traffic_items:\n            trafficItemName = trafficItemName.replace('+', r'\\+').replace('*', r'\\*')\n            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):\n                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType\n            else:\n                trafficType = None\n                raise IxiaConfigException(\"Traffic stream '%s' not found on the config\"%(trafficItemName))\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():\n                if trafficType.lower() == 'ipv4' or trafficType.lower() == 'raw':\n                    if configElement.Stack.find(DisplayName=\"IPv4\"):\n                        stackObj = configElement.Stack.find(DisplayName=\"IPv4\")\n                        if \"header_length\" in cfg_dict:\n                            field = stackObj.Field.find(DisplayName='Header Length')\n                            field.Auto, field.FieldValue, field.SingleValue = 'False', cfg_dict['header_length'], cfg_dict['header_length']\n                        if \"checksum\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'Auto', 'False')\n                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'SingleValue', cfg_dict['checksum'])\n                        if \"ttl\" in cfg_dict:\n                            setattr(stackObj.Field.find(Name='ttl'), 'SingleValue', cfg_dict['ttl'])\n                        if \"version\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Version'), 'SingleValue', cfg_dict['version'])\n                        if \"total_length\" in cfg_dict:\n                            setattr(stackObj.Field.find(Name='total_len'), 'Auto', 'False')\n                            setattr(stackObj.Field.find(Name='total_len'), 'SingleValue', cfg_dict['total_length'])\n                        if \"frag_offset\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Fragment offset'), 'SingleValue', cfg_dict['frag_offset'])\n                        if \"timestamp\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Timestamp'), 'SingleValue', cfg_dict['timestamp'])\n                    if trafficType.lower() == 'raw':\n                        if \"src_addr\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue', cfg_dict['src_addr'])\n                        if \"dst_addr\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue', cfg_dict['dst_addr'])\n\n    def set_invalid_ipv6(self, traffic_items, cfg_dict):\n        \"\"\"\n        API used to configure invalid IPv6 headers for a given list of streams\n\n        :param traffic_items: A str of list of traffic items whose headers will be changed\n        :param cfg_dict: A config dictionary containing the header values to be changed\n            src_addr (sourceAddr)\n            dst_addr (destAddr)\n            checksum (checksum)\n            ttl (hopLimit)\n            total_length (payloadLength)\n        :return: True on success, exception on failure\n        :Example: set_invalid_ipv6(['Traffic item 1'], {'checksum':74, 'ttl':84, 'total_length':8})\n        \"\"\"\n        self.log.info(\"Configuring invalid Ipv6 headers\")\n        for trafficItemName in traffic_items:\n            trafficItemName = trafficItemName.replace('+', r'\\+').replace('*', r'\\*')\n            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):\n                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType\n            else:\n                trafficType = None\n                raise IxiaConfigException(\"Traffic stream '%s' not found on the config\" % (trafficItemName))\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(\n                    Name='^' + trafficItemName + '$').ConfigElement.find():\n                if trafficType.lower() == 'ipv6' or trafficType.lower() == 'raw':\n                    if configElement.Stack.find(DisplayName=\"IPv6\"):\n                        stackObj = configElement.Stack.find(DisplayName=\"IPv6\")\n                        if \"checksum\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'Auto', 'False')\n                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'SingleValue',\n                                    cfg_dict['checksum'])\n                        if \"ttl\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Hop Limit'), 'SingleValue', cfg_dict['ttl'])\n                        if \"total_length\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'Auto', 'False')\n                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'SingleValue', cfg_dict['total_length'])\n                    if trafficType.lower() == 'raw':\n                        if \"src_addr\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue',\n                                    cfg_dict['src_addr'])\n                        if \"dst_addr\" in cfg_dict:\n                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue',\n                                    cfg_dict['dst_addr'])\n\n    def change_mld_source_list(self, device_list=None, mld_source_list=None, port_list=None,**kwargs):\n        \"\"\"\n        Modify MLD source Address\n        :param device_list: Device group name\n        :param mld_source_list: Mld source address\n        :param port_list: Ports\n        :return: True else raise exception\n        :Example: change_mld_source_list(device_list=[\"DG1\"],mld_source_list=[\"100::101:1\",\"200::200:2\",\"300::300:3\"], port_list=[\"Port1\",\"Port2\"])\n        \"\"\"\n        result = False\n        value_type = kwargs.get('value_type',None)\n        if mld_source_list:\n            sourceRange = len(mld_source_list)\n        else:\n            sourceRange = 1\n        if port_list:\n            for portName in port_list:\n                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):\n                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')\n                    for topoObj in self.ixNetwork.Topology.find():\n                        if vportObj.href in topoObj.Ports:\n                            portIndex = (topoObj.Ports).index(vportObj.href)\n                            if device_list and mld_source_list:\n                                for deviceGroupName in device_list:\n                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):\n                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')\n                                        if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                            for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                                mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange\n                                                sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values\n                                                indexList = []\n                                                for srcRange in range(0, sourceRange):\n                                                    indexList.append(portIndex)\n                                                    portIndex += 1\n                                                for ipIndex,sourceIp in zip(indexList,mld_source_list):\n                                                    sourceListValues[ipIndex] = sourceIp\n                                                    mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)\n                                    else:\n                                        log.info(\"The deviceGroup '%s' not configured under this port '%s'\"%(deviceGroupName,portName))\n                                result = True\n                            elif device_list is None and mld_source_list:\n                                for deviceGroupObj in topoObj.DeviceGroup.find():\n                                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange\n                                            sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values\n                                            indexList = []\n                                            for srcRange in range(0, sourceRange):\n                                                indexList.append(portIndex)\n                                                portIndex += 1\n                                            for ipIndex, sourceIp in zip(indexList, mld_source_list):\n                                                sourceListValues[ipIndex] = sourceIp\n                                            mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)\n                                        result = True\n                            else:\n                                raise IxiaConfigException(\"Failed due to device_list/mld_source_list parameter not passed\")\n        if device_list and port_list is None:\n            for deviceGroupName in device_list:\n                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):\n                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')\n                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():\n                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange\n                            if value_type == 'custom':\n                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ClearOverlays()\n                                increment_value = [(kwargs.get('step_value', '0:0:0:1::'), 3,[('0::0', kwargs.get('repeat_value', 1), [])])]\n                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Custom\\\n                                    (start_value=kwargs.get('start_value','0::0'),\n                                     step_value=kwargs.get('step_value','0:0:0:1::'),\n                                     increments=increment_value)\n                            else:\n                                mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=mld_source_list)\n                        result = True\n                else:\n                    log.info(\"The deviceGroup '%s' not configured\" %deviceGroupName)\n        if result:\n            return result\n        else:\n            raise IxiaConfigException(\"Failed to update MLD source Ip, Check Port List %s and Device Group %s configured on Ixia config\"%(port_list,device_list))\n\n    def change_igmp_source_list(self, device_list=None, igmp_source_list=None, port_list=None,**kwargs):\n        \"\"\"\n        Modify IGMP source Address\n        :param device_list: Device group name\n        :param igmp_source_list: Igmp source address\n        :param port_list: Ports\n        :return: True else raise exception\n        :Example: change_igmp_source_list(device_list=[\"DG1\"],igmp_source_list=[\"1.1.1.1\",\"2.2.2.2\",\"3.3.3.3\"], port_list=[\"Port1\",\"Port2\"])\n        \"\"\"\n        result = False\n        value_type = kwargs.get('value_type',None)\n        if igmp_source_list:\n            sourceRange = len(igmp_source_list)\n        else:\n            sourceRange = 1\n        if port_list:\n            for portName in port_list:\n                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):\n                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')\n                    for topoObj in self.ixNetwork.Topology.find():\n                        if vportObj.href in topoObj.Ports:\n                            portIndex = (topoObj.Ports).index(vportObj.href)\n                            if device_list and igmp_source_list:\n                                for deviceGroupName in device_list:\n                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):\n                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')\n                                        if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                            for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                                igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange\n                                                sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values\n                                                indexList = []\n                                                for srcRange in range(0, sourceRange):\n                                                    indexList.append(portIndex)\n                                                    portIndex += 1\n                                                for ipIndex,sourceIp in zip(indexList,igmp_source_list):\n                                                    sourceListValues[ipIndex] = sourceIp\n                                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)\n                                    else:\n                                        log.info(\"The deviceGroup '%s' not configured under this port '%s'\"%(deviceGroupName,portName))\n                                result = True\n                            elif device_list is None and igmp_source_list:\n                                for deviceGroupObj in topoObj.DeviceGroup.find():\n                                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange\n                                            sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values\n                                            indexList = []\n                                            for srcRange in range(0, sourceRange):\n                                                indexList.append(portIndex)\n                                                portIndex += 1\n                                            for ipIndex, sourceIp in zip(indexList, igmp_source_list):\n                                                sourceListValues[ipIndex] = sourceIp\n                                            igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)\n                                        result = True\n                            else:\n                                raise IxiaConfigException(\"Failed due to device_list/igmp_source_list parameter not passed\")\n        if device_list and port_list is None:\n            for deviceGroupName in device_list:\n                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):\n                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')\n                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():\n                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange\n                            if value_type == 'custom':\n                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ClearOverlays()\n                                increment_value = [(kwargs.get('step_value', '0.0.0.1'), 3,[('0.0.0.0', kwargs.get('repeat_value', 1), [])])]\n                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Custom\\\n                                    (start_value=kwargs.get('start_value', '0.0.0.0'),\n                                    step_value=kwargs.get('step_value', '0.0.0.1'),\n                                     increments=increment_value)\n                            else:\n                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=igmp_source_list)\n                        result = True\n                else:\n                    log.info(\"The deviceGroup '%s' not configured\" %deviceGroupName)\n        if result:\n            return result\n        else:\n            raise IxiaConfigException(\"Failed to update Igmp source Ip, Check Port List %s and Device Group %s configured on Ixia config\"%(port_list,device_list))\n\n\n    def get_ipv4_tos(self, traffic_item_list=None):\n        \"\"\"\n        Get IP priority set on traffic items\n        :param traffic_item_list: List of traffic items to fetch IP priority\n\n        :return: Dict of IP Priority configured in traffic item\n                 Raise exception if traffic item not found\n\n        :Example: get_ipv4_tos(traffic_item_list = ['Traffic Item 1','Traffic Item 2'])\n        \"\"\"\n        self.log.info(\"Checking Ipv4 TOS information is available in TrafficItem\")\n        result = dict()\n        tosDict = {'000 Routine': '00', '001 Priority': '20', '010 Immediate': '40', '011 Flash': '60', '100 Flash Override': '80', '101 CRITIC/ECP': 'A0', '110 Internetwork Control': 'C0', '111 Network Control': 'E0'}\n        classPHB = {'Precedence 1':'20', 'Precedence 2':'40', 'Precedence 3':'60', 'Precedence 4':'80', 'Precedence 5':'A0', 'Precedence 6':'C0', 'Precedence 7':'E0'}\n        if traffic_item_list == None:\n            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]\n        for trafficItemName in traffic_item_list:\n            trafficItemName = trafficItemName.replace('+', r'\\+').replace('*', r'\\*')\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():\n                for count, stackObj in enumerate(configElement.Stack.find(DisplayName=\"IPv4\"),start=1):\n                    if count == 1:\n                        key = 'Outer'\n                    if count == 2:\n                        key = 'Inner'\n                    if stackObj.Field.find(DisplayName=\"Precedence\").ActiveFieldChoice == True:\n                        key = key+'TOS'\n                        try:\n                            result.setdefault(trafficItemName, [] ).append({key:tosDict[stackObj.Field.find(DisplayName=\"Precedence\").FieldValue]})\n                        except:\n                            pass\n                    if stackObj.Field.find(DisplayName=\"Class selector PHB\").ActiveFieldChoice == True:\n                        key = key + 'Diff-serv'\n                        try:\n                            result.setdefault(trafficItemName, []).append({key: classPHB[stackObj.Field.find(DisplayName=\"Class selector PHB\").FieldValue]})\n                        except:\n                            pass\n                    if stackObj.Field.find(DisplayName=\"Raw priority\").ActiveFieldChoice == True:\n                        key = key + 'Raw Priority'\n                        try:\n                            result.setdefault(trafficItemName, []).append({key: stackObj.Field.find(DisplayName=\"Raw priority\").FieldValue})\n                        except:\n                            pass\n        return result\n\n    def config_device_twamp_client(self, router_id, ip_version='ipv4', add_test_session=True, **kwargs):\n\n        \"\"\"\n        Configure TWAMP Client on device\n\n        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.\n        :param ip_version: IPV4 or IPV6.\n        :param add_test_session: Add TWAMP Test Session by default and if TwampControlRange has to be configured then the attribute 'Count' is mandatory.\n        :param kwargs: Supported parameters as optional in kwargs with default values.\n        :return: TWAMP Client handle if configured else raise an exception.\n        Example:config_device_twamp_client(router_id= 'IP-4', ip_version='ipv4', add_test_session=True, ControlStartServerIp = '20.1.1.1', Count= 1)\n        \"\"\"\n\n        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',\n                      'ErrorEstimateMultiplier']\n        controlArg = ['ControlServerIpIncrement', 'ControlServerPort', 'ControlStartServerIp', 'Count', 'Enabled',\n                      'KeyId', 'Mode', 'ControlServerName', 'Secret']\n        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',\n                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',\n                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',\n                          'TypepDescriptor']\n\n        userArg = {key.lower(): value for key, value in kwargs.items()}\n        configOptions = {}\n        configControl = {}\n        configTestSession = {}\n\n        for ixnArg in optionsArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                configOptions[ixnArg] = userArg.pop(ixnArg.lower())\n\n        for ixnArg in controlArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                if ixnArg.lower() == 'ControlServerName'.lower():\n                    configControl['Name'] = userArg.pop(ixnArg.lower())\n                else:\n                    configControl[ixnArg] = userArg.pop(ixnArg.lower())\n\n        for ixnArg in testSessionArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                if ixnArg.lower() == 'TestSessionName'.lower():\n                    configTestSession['Name'] = userArg.pop(ixnArg.lower())\n                else:\n                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())\n\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            try:\n                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):\n                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(\n                        Name=router_id).TwampClient.add()\n                    self.ixNetwork.Vport.find().ProtocolStack.TwampOptions.add(**configOptions)\n                    if add_test_session:\n                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(\n                            Name=router_id).Range.add().TwampControlRange.add(**configControl)\n                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(\n                            Name=router_id).Range.add().TwampTestRange.add(**configTestSession)\n                else:\n                    return IxiaOperationException(\n                        \"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n            except:\n                pass\n\n    def config_device_twamp_server(self, router_id, ip_version='ipv4', **kwargs):\n\n        \"\"\"\n        Configure TWAMP Client on device\n\n        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.\n        :param ip_version: IPV4 or IPV6.\n        :param kwargs: Supported parameters as optional in kwargs with default values. 'Count & ReflectorPort' is mandatory.\n        :return: TWAMP Client handle if configured else raise an exception.\n        Example:config_device_twamp_server(router_id='IP-5', ip_version='ipv4', ControlPort = 2000, Count= 1, ReflectorPort = 13000)\n        \"\"\"\n\n        serverArg = ['ControlPort', 'Count', 'EnableAccessControl', 'Enabled', 'IterationCount', 'KeyId',\n                     'MaxTestSessions', 'Mode', 'Name', 'PermittedIp', 'PermittedIpIncrement', 'PermittedSenderPort',\n                     'ReflectorPort', 'Secret']\n        userArg = {key.lower(): value for key, value in kwargs.items()}\n        configServer = {}\n\n        for ixnArg in serverArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                configServer[ixnArg] = userArg.pop(ixnArg.lower())\n\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            try:\n                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):\n                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(\n                        Name=router_id).Range.add().TwampServerRange.add(**configServer)\n                else:\n                    return IxiaOperationException(\n                        \"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n            except:\n                pass\n\n    def get_stream_name(self, stream_handle):\n        \"\"\"\n        The function returns the Name of the traffic handle\n        :param stream_handle: Traffic stream handle\n        :return: Name of the traffic stream.\n        Example: get_stream_name(stream_handle = 'TrafficItemObj')\n        \"\"\"\n        return stream_handle.Name\n\n    def get_twamp_peer_ip(self, router_id=None):\n        \"\"\"\n        To fetch TWAMP peer IP and device IP of each TWAMP device in a dictonary.\n\n        :param router_id: TWAMP Client Router ID of which Peer IP and device IP details are fetched.\n        :return: Dictonary of TWAMP Client Router ID to device and peer IP of TWAMP Client.\n        Example: get_twamp_peer_ip(router_id = 'TWAMPControl-R9')\n        \"\"\"\n        twamp_peer_ip_dict = dict()\n        if not router_id:\n            device_list = []\n            control_list = []\n            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():\n                controlObj = RangeObj.TwampControlRange.find()\n                try:\n                    device_list.append(RangeObj.IpRange)\n                    control_list.append(controlObj)\n                except:\n                    pass\n        else:\n            device_list = []\n            control_list = []\n            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():\n                controlObj = RangeObj.TwampControlRange.find()\n                try:\n                    if controlObj.Name == router_id:\n                        device_list.append(RangeObj.IpRange)\n                        control_list.append(controlObj)\n                        break\n                except:\n                    pass\n        if not device_list:\n            if router_id:\n                raise CafyException.InvalidValueError('%s no such device' % router_id)\n            else:\n                raise CafyException.InvalidValueError('No devices in configuration')\n        for index in range(len(device_list)):\n            try:\n                twamp_peer_ip_dict[control_list[index].Name] = {}\n                twamp_peer_ip_dict[control_list[index].Name]['Device IP'] = device_list[index].IpAddress\n                twamp_peer_ip_dict[control_list[index].Name]['Peer IP'] = device_list[index].GatewayAddress\n            except:\n                pass\n        return twamp_peer_ip_dict\n\n    def get_mac_from_captured_packets(self, pcap_filename=None, pkt_mode=\"random\", pkt_num=None,\n                                      random_check_till_ip=5):\n        \"\"\"\n        Used to fetch source and destination MAC from the captured packet file.\n        :param pcap_filename: Pcap file name with location.\n        :param pkt_mode: options are \"random\" and \"fixed\", default: \"random\" .\n                         If set \"random\" - one randome packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,\n                            if the packet is IP packet, returns source and destination MAC.\n                            if the packet is ARP packet, another random packet is picked and process repeats for \"random_check_till_ip\" number of times.\n                         If set \"fixed\" - packet with packet number=\"pkt_num\" is used to fetch src and dst mac.\n        :param pkt_num: packet with packet number=\"pkt_num\" is used to fetch src and dst mac. Only when pkt_mode is \"fixed\"\n        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.\n        Example: get_mac_from_captured_packets(pcap_filename='sampledata1.pcap', pkt_mode=\"random\", pkt_num=None, random_check_till_ip=5)\n        \"\"\"\n        self.log.info('Getting MAC from Captured file')\n        ret_mac = {}\n        packets = []\n        if pcap_filename:\n            self.log.info(f'Fetching MAC addresses of the file {pcap_filename}')\n            try:\n                with open(dpkt.pcap.Reader(open(pcap_filename, 'rb'))) as pkt:\n                    packets.append(pkt)\n            except ValueError:\n                # Load packets from the .cap file\n                packets = rdpcap(pcap_filename)\n\n            if pkt_mode.lower() == \"random\":\n                for count in range(random_check_till_ip):\n                    log.info(\"try: %d\" % count)\n                    pkt_num = random.randrange(1, len(packets))\n                    try:\n                        # pylint: disable=no-member\n                        eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])\n                        if isinstance(eth.data, dpkt.ip.IP):\n                            ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)\n                            ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)\n                            break\n                    except IndexError:\n                        eth = packets[pkt_num]\n                        if Ether in eth:\n                            ret_mac['src_mac'] = eth[Ether].src\n                            ret_mac['dst_mac'] = eth[Ether].dst\n                            break\n                else:\n                    raise CafyException.TgenInvalidInputError(\n                        'No IP packet found after %s tries' % random_check_till_ip)\n            elif pkt_mode.lower() == \"fixed\":\n                if pkt_num:\n                    try:\n                        # pylint: disable=no-member\n                        eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])\n                        if not isinstance(eth.data, dpkt.ip.IP):\n                            raise CafyException.TgenInvalidInputError(f\"'\\'pkt_num\\' {pkt_num} is not an IP packet\")\n                        else:\n                            ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)\n                            ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)\n                    except IndexError:\n                        eth = packets[pkt_num]\n                        if Ether in eth:\n                            ret_mac['src_mac'] = eth[Ether].src\n                            ret_mac['dst_mac'] = eth[Ether].dst\n                else:\n                    raise CafyException.TgenInvalidInputError('\\'pkt_num\\' is must for pkt_mode = fixed')\n        else:\n            raise CafyException.TgenInvalidInputError('\\'pcap_filename\\' is a mandatory parameter.')\n        return ret_mac\n\n    def get_card_type(self, port):\n        \"\"\"\n        To fetch card type using port name.\n\n        :param port: Name/location of the port, whose card type is required.\n        :return: Card type. Ex: \"FX2-40G-Q2\"\n\n        :Example: get_card_type(\"7/5\")\n                  get_card_type(\"10.10.1.1/5/1\")\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        port = port.split(\"/\")\n        port[0] = port[1] if len(port) > 2 else port[0]\n        if self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$'):\n            cardObj = self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$')\n            if cardObj.Port.find(PortId='^' + port[1] + '$'):\n                card_type = cardObj.Description\n            else:\n                self.log.error('%s not a valid port name or location' % port[1])\n                card_type = None\n        return card_type\n\n    def set_invalid_mpls(self, traffic_items, cfg_dict):\n        \"\"\"\n        API used to configure invalid mpls headers for a given list of streams\n        :param traffic_items: A str of list of traffic items whose headers will be changed\n        :param cfg_dict: A config dictionary containing the header values to be changed\n            All values below should be strings:\n                label (label) - Label identifier to be used [0 - 1048575]\n                sbit (sBit) - Last label for a given stack [0/1]\n                exp (exp) - Experimental bits value [0 - 7]\n                ttl (ttl) - Time to live value  [0 - 255]\n                active (Active) - Sets the mpls status to active (true/false)\n        :return: True on success, exception on failure\n        :Example: set_invalid_mpls(['Traffic ipv4'], {'label':'111', 'sbit':'1', 'exp':7, 'ttl':84, 'active':True})\n        \"\"\"\n        result = False\n        self.log.info(\"Setting INVALID MPLS Headers in Traffic Item/Items\")\n        if type(traffic_items) is list and type(cfg_dict) is dict:\n            for trafficName in traffic_items:\n                try:\n                    for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():\n                        for mplsObj in configElement.Stack.find(StackTypeId='mpls'):\n                            labelObj, expObj, sbitObj, ttlObj = mplsObj.Field.find(\n                                Name='mpls_label_value'), mplsObj.Field.find(Name='mpls_exp'), mplsObj.Field.find(\n                                Name='mpls_bos'), mplsObj.Field.find(Name='mpls_ttl')\n                            labelObj.SingleValue = cfg_dict['label'] if 'label' in cfg_dict.keys() else None\n                            expObj.SingleValue = cfg_dict['exp'] if 'exp' in cfg_dict.keys() else None\n                            sbitObj.SingleValue = cfg_dict['sbit'] if 'sbit' in cfg_dict.keys() else None\n                            ttlObj.SingleValue = cfg_dict['ttl'] if 'ttl' in cfg_dict.keys() else None\n                            result = True\n                except:\n                    pass\n        else:\n            raise IxiaOperationException(\n                'Given object types of traffic_items {}, cfg_dict {} is not supported. Supported object types are traffic_items should be list and cfg_dict should be dict'.format(\n                    type(traffic_items), type(cfg_dict)))\n        if result:\n            return result\n        else:\n            raise IxiaConfigException('Either Streams or MPLS headers is not present')\n\n    def set_rsvp_tunnel(self, tunnel_type, router_id=None, **kwargs):\n        \"\"\"\n        Set RSVP tunnel attributes\n        :param router_id: Router ID of the device\n        :param tunnel_type: Ingress/Egress\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                tunnel_name: tunnel name from config\n                source_ip_address: IP address of the RSVP PATH message sender\n                source_ip_address_step: Source IP address step\n                destination_ip_address: Destination IP address of the RSVP PATH message\n                destination_ip_address_step: Destination IP address step\n                tunnel_count: Integer/String representing the new tunnel count\n                tunnel_id: tunnel identifier\n                tunnel_id_step: Tunnel ID step for incrementing Tunnel ID when TunnelCount is greater than one\n                lsp_count: Number of LSPs established within the tunnel. Lsp Count should be between 1 and 20\n                lsp_id: LSP ID\n                lsp_id_step: LSP ID step\n                ERO (Explicit Route Object) Configuration:\n                - enable_ero (bool): Optional. Set to True to enable ERO configuration.\n                - ero_count (int): Optional. Specifies the number of ERO hops.\n                \u2022 **ERO configuration will be applied only if at least one of `enable_ero=True` or `ero_count` is specified.**\n                \u2022 If neither is given, ERO IPs (ero<n>_ip) will be ignored.But if the configuration already has ERO enabled,\n                if its TRUE then IP's will be updated.\n                - ero<n>_ip (str): IP address for the nth ERO hop (e.g., ero1_ip, ero2_ip, etc.).\n                \n        :return: True if successfull else raises exception\n        :Example: set_rsvp_tunnel(router_id=\"192.0.0.1\",tunnel_type=\"Ingress\",tunnel_name=\"RSVP Tunnel\",source_ip_address=\"10.10.10.1\",source_ip_address_step=\"0.0.0.1\",destination_ip_address=\"11.11.11.1\",\n                    destination_ip_address_step=\"0.0.0.1\",tunnel_count=2,tunnel_id=11,tunnel_id_step=2,lsp_count=2,lsp_id=1,lsp_id_step=2)\n                set_rsvp_tunnel(router_id=\"192.0.0.1\",tunnel_type=\"Ingress\",tunnel_name=\"RSVP1\",enable_ero=True,ero_count=1,ero1_ip=\"192.168.1.1\")\n        \"\"\"\n        self.log.info('Setting RSVP Tunnel parameters')\n        tunnelName = kwargs.get('tunnel_name')\n        device_name = kwargs.get('device_name',None)\n        nested_device = kwargs.get('nested_device',None)\n        deviceObjDict = {}\n        result = False\n        if router_id:\n            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                if deviceGroupObj.RouterData.find():\n                    if router_id in deviceGroupObj.RouterData.find().RouterId.Values:\n                        deviceObjDict[router_id] = deviceGroupObj\n                    break\n        elif device_name and not nested_device:\n            for device_group_obj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name):\n                if device_group_obj.Ethernet.find():\n                    if device_group_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                        deviceObjDict[device_group_obj.Name] = device_group_obj\n                elif device_group_obj.Ipv4Loopback.find():\n                    if device_group_obj.Ipv4Loopback.find().RsvpteLsps.find():\n                        deviceObjDict[device_group_obj.Name] = device_group_obj\n        elif device_name and nested_device:\n            for device_group_obj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).NetworkGroup.find().\\\n                    DeviceGroup.find(Name=nested_device):\n                if device_group_obj.Ethernet.find():\n                    if device_group_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                        deviceObjDict[device_group_obj.Name] = device_group_obj\n                elif device_group_obj.Ipv4Loopback.find():\n                    if device_group_obj.Ipv4Loopback.find().RsvpteLsps.find():\n                        deviceObjDict[device_group_obj.Name] = device_group_obj\n        else:\n            try:\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    for ipv4Obj in deviceGroupObj.Ethernet.find().Ipv4.find():\n                        if ipv4Obj.RsvpteLsps.find():\n                            deviceObjDict[deviceGroupObj.Name] = deviceGroupObj\n            except:\n                pass\n        if deviceObjDict:\n            if tunnel_type.lower() == \"ingress\":\n                for key, deviceObj in deviceObjDict.items():\n                    if deviceObj.Ethernet.find():\n                        for rsvp_if_Obj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():\n                            rsvp_if_Obj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),\n                                                    step_value=kwargs.get('destination_ip_address_step', None))\n                    rsvpte_obj = []\n                    if deviceObj.Ethernet.find():\n                        rsvpte_obj.extend(deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find())\n                    elif deviceObj.Ipv4Loopback.find():\n                        rsvpte_obj.extend(deviceObj.Ipv4Loopback.find().RsvpteLsps.find())\n\n                    for rsvp_te_obj in rsvpte_obj:\n                        rsvp_te_obj.Name = tunnelName\n                        if rsvp_te_obj.RsvpP2mpIngressLsps and rsvp_te_obj.RsvpP2mpEgressLsps:\n                            if kwargs.get('tunnel_count'):\n                                rsvp_te_obj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', 1)\n                            if kwargs.get('lsp_count'):\n                                rsvp_te_obj.P2mpIngressLspCount = kwargs.get('lsp_count', 1)\n                            if kwargs.get('source_ip_address'):\n                                rsvp_te_obj.RsvpP2mpIngressLsps.SourceIpv4.Increment(\n                                    start_value=kwargs.get('source_ip_address', None),\n                                    step_value=kwargs.get('source_ip_address_step', None))\n                            if kwargs.get('tunnel_id') and not kwargs.get('tunnel_id_step'):\n                                rsvp_te_obj.RsvpP2mpIngressLsps.TunnelId.Single(kwargs.get('tunnel_id'))\n                            if kwargs.get('tunnel_id') and kwargs.get('tunnel_id_step'):\n                                rsvp_te_obj.RsvpP2mpIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', 1),\n                                                                            step_value=kwargs.get('tunnel_id_step', 1))\n                            if kwargs.get('lsp_id') and not kwargs.get('lsp_id_step'):\n                                rsvp_te_obj.RsvpP2mpIngressLsps.LspId.Single(kwargs.get('lsp_id'))\n                            if kwargs.get('lsp_id') and kwargs.get('lsp_id_step'):\n                                rsvp_te_obj.RsvpP2mpIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', 1),\n                                                                        step_value=kwargs.get('lsp_id_step', 1))\n                            if 'local_protection' in kwargs:\n                                local_protection = kwargs.get('local_protection', False)\n                                rsvp_te_obj.RsvpP2mpIngressLsps.LocalProtectionDesired.Single(local_protection)\n                            if 'label_recording' in kwargs:\n                                label_recording = kwargs.get('label_recording', False)\n                                rsvp_te_obj.RsvpP2mpIngressLsps.LabelRecordingDesired.Single(label_recording)\n                            if 'fast_reroute' in kwargs:\n                                fast_reroute = kwargs.get('fast_reroute', False)\n                                rsvp_te_obj.RsvpP2mpIngressLsps.EnableFastReroute.Single(fast_reroute)\n                            # Step 1: Detect if user passed any eroX_ip / eroX_as values\n                            ero_ip_keys = sorted([k for k in kwargs if k.startswith('ero') and k.endswith('_ip')])\n                            ero_as_keys = sorted([k for k in kwargs if k.startswith('ero') and k.endswith('_as')])\n                            ero_keys_present = bool(ero_ip_keys or ero_as_keys)\n\n                            # Step 2: Check if ERO is enabled in loaded config\n                            try:\n                                ero_enabled = rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Values[0]\n                            except Exception as err:\n                                ero_enabled = False\n                                self.log.warning(f'RSVP Ingress ERO Enable Failed with Error - {err}')\n\n                            # Step 3: Optional override if user passed 'enable_ero'\n                            if 'enable_ero' in kwargs:\n                                rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Single(kwargs['enable_ero'])\n                                ero_enabled = kwargs['enable_ero']  # update status based on override\n\n                            # Step 4: Handle ERO config logic\n                            if ero_keys_present:\n                                if not ero_enabled:\n                                    self.log.warning(\n                                        f\"[ERO WARNING] ERO sub-object values were provided, \"\n                                        f\"but ERO is disabled in the loaded config for tunnel '{rsvp_te_obj.Name}'. \"\n                                        f\"ERO configuration will be skipped.\"\n                                    )\n                                else:\n                                    # Auto-calculate how many ERO sub-objects were passed\n                                    ero_count_from_args = max(\n                                        [int(k[3:].split('_')[0]) for k in ero_ip_keys + ero_as_keys],\n                                        default=0\n                                    )\n                                    # Set ero_count (either from kwargs or auto)\n                                    if 'ero_count' in kwargs:\n                                        rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = kwargs.get('ero_count',\n                                                                                                          0)\n                                    else:\n                                        rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = ero_count_from_args\n                                # Apply ERO sub-objects\n                                ero_sub_objs = rsvp_te_obj.RsvpP2PIngressLsps.RsvpEROSubObjectsList.find()\n                                if not ero_sub_objs:\n                                    self.log.warning(f\"ERO is enabled and count is set,but no ERO sub-object exist for tunnel-'{rsvp_te_obj.Name}'\")\n                                else:\n                                    ero_dict = {\n                                        'ero' + str(index): ero_obj\n                                        for index, ero_obj in enumerate(ero_sub_objs, start=1)\n                                    }\n                                    for ero_name, ero_object in ero_dict.items():\n                                        if ero_name + '_ip' in kwargs:\n                                            ero_object.Type.Single('ip')\n                                            ero_object.Ip.Single(kwargs.get(ero_name + '_ip'))\n                                        if ero_name + '_as' in kwargs:\n                                            ero_object.Type.Single('as')\n                                            ero_object.AsNumber.Single(kwargs.get(ero_name + '_as'))\n                            result = True\n                        if rsvp_te_obj.RsvpP2PIngressLsps and rsvp_te_obj.RsvpP2PEgressLsps:\n                            if kwargs.get('lsp_count'):\n                                rsvp_te_obj.IngressP2PLsps = kwargs.get('lsp_count', 1)\n                            if kwargs.get('source_ip_address'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.SourceIp.Increment(\n                                    start_value=kwargs.get('source_ip_address', None),\n                                    step_value=kwargs.get('source_ip_address_step', None))\n                            if kwargs.get('tunnel_id') and not kwargs.get('tunnel_id_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.TunnelId.Single(kwargs.get('tunnel_id'))\n                            if kwargs.get('tunnel_id') and kwargs.get('tunnel_id_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', 1),\n                                                                        step_value=kwargs.get('tunnel_id_step', 1))\n                            if kwargs.get('lsp_id') and not kwargs.get('lsp_id_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.LspId.Single(kwargs.get('lsp_id'))\n                            if kwargs.get('lsp_id') and kwargs.get('lsp_id_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', 1),\n                                                                        step_value=kwargs.get('lsp_id_step', 1))\n                            if kwargs.get('remote_ip') and not kwargs.get('remote_ip_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Single(kwargs.get('remote_ip'))\n                            if kwargs.get('remote_ip') and kwargs.get('remote_ip_step'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Increment(start_value=kwargs.get('remote_ip', None),\n                                                                                  step_value=kwargs.get('remote_ip_step','0.0.0.1'))\n                            if kwargs.get('remote_ip') and kwargs.get('remote_ip_step') and kwargs.get('remote_ip_incr_count'):\n                                rsvp_te_obj.RsvpP2PIngressLsps.RemoteIp.Custom(start_value=kwargs.get('remote_ip', None),\n                                                                               step_value=kwargs.get('remote_ip_step','0.0.0.1'),\n                                                                               increments=[(kwargs.get('remote_ip_step','0.0.0.1'),\n                                                                                            kwargs.get('remote_ip_incr_count',1), [])])\n                            if kwargs.get('tag_id_type', None) == 'singleValue':\n                                rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Single(kwargs.get('tag_id_start', 1))\n                            elif kwargs.get('tag_id_type', None) == 'increment':\n                                rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Increment(\n                                    start_value=kwargs.get('tag_id_start', 1), step_value=kwargs.get('tag_id_step', 1))\n                            elif kwargs.get('tag_id_type', None) == 'custom':\n                                if kwargs.get('tag_id_repeat') == 1:\n                                    rsvp_te_obj.RsvpP2PIngressLsps.Tag.find().Id__.Custom(\n                                        start_value=kwargs.get('tag_id_start', 1), step_value=0,\n                                        increments=[(kwargs.get('tag_id_step', 1),\n                                                     kwargs.get('tag_id_len', kwargs.get('lsp_count', 1)), [])])\n                            if 'local_protection' in kwargs:\n                                local_protection = kwargs.get('local_protection', False)\n                                rsvp_te_obj.RsvpP2PIngressLsps.LocalProtectionDesired.Single(local_protection)\n                            if 'label_recording' in kwargs:\n                                label_recording = kwargs.get('label_recording', False)\n                                rsvp_te_obj.RsvpP2PIngressLsps.LabelRecordingDesired.Single(label_recording)\n                            if 'fast_reroute' in kwargs:\n                                fast_reroute = kwargs.get('fast_reroute', False)\n                                rsvp_te_obj.RsvpP2PIngressLsps.EnableFastReroute.Single(fast_reroute)\n                            if 'enable_ero' in kwargs:\n                                rsvp_te_obj.RsvpP2PIngressLsps.EnableEro.Single(kwargs.get('enable_ero'))\n                            if 'ero_count' in kwargs:\n                                rsvp_te_obj.RsvpP2PIngressLsps.NumberOfEroSubObjects = kwargs.get('ero_count', 0)\n                            result = True\n            elif tunnel_type.lower() == \"egress\":\n                for key, deviceObj in deviceObjDict.items():\n                    for rsvpIfObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():\n                        rsvpIfObj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),\n                                                step_value=kwargs.get('destination_ip_address_step', None))\n                    for rsvpTeObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                        rsvpTeObj.Name = tunnelName\n                        if rsvpTeObj.RsvpP2mpEgressLsps:\n                            rsvpTeObj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', None)\n                        result = True\n            else:\n                raise IxiaConfigException(\"Passed '%s' invalid Tunnel Type\" % tunnel_type)\n        else:\n            raise IxiaConfigException('Device with Router ID %s not available in the config' % router_id)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return result\n\n    def config_twamp_test_session(self, router_id=None, twamp_client_handle=None, **kwargs):\n        \"\"\"\n        Configure or Create a Test session either with TWAMP client device or its config handle\n        One of the argument is mandatory\n        :param router_id: TWAMP Client device's router id\n        :param twamp_client_handle: TWAMP config handler in Client device\n        :return: Raises exception on failure\n        Example:config_twamp_test_session('IP-6', twamp_client_handle=None,\n                                        TestSessionName = 'TWAMPTest-R15', ControlRangeName= 'TWAMPControl-R10',\n                                        TestSessionsCount= 1, SessionSenderPort= 2000,\n                                        SessionSenderPortIncrement= 1, SessionReflectorPort=4000,\n                                        SessionReflectorPortIncrement= 1,\n                                        NumberOfPackets=10, PacketsPerSecond=10, Timeout=30, PacketLength= 128,\n                                        PaddingWithZero= False,\n                                        TypepDescriptor= 0\n                                        )\n        \"\"\"\n        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',\n                      'ErrorEstimateMultiplier']\n        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',\n                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',\n                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',\n                          'TypepDescriptor']\n\n        userArg = {key.lower(): value for key, value in kwargs.items()}\n        configOptions = {}\n        configControl = {}\n        configTestSession = {}\n\n        for ixnArg in optionsArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                configOptions[ixnArg] = userArg.pop(ixnArg.lower())\n\n        for ixnArg in testSessionArg:\n            if re.search(ixnArg, str(userArg), re.IGNORECASE):\n                if ixnArg.lower() == 'TestSessionName'.lower():\n                    configTestSession['Name'] = userArg.pop(ixnArg.lower())\n                else:\n                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())\n\n        if router_id == None:\n            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')\n        else:\n            try:\n                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):\n                    self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(\n                        Name=router_id).Range.add().TwampTestRange.add(**configTestSession)\n                else:\n                    return IxiaOperationException(\n                        \"Given Router-ID '{}' is not found in the existing config\".format(router_id))\n            except:\n                pass\n\n    def set_protocol_stack_count(self, stack_count, device_name, ip_type=\"ipv4\", **kwargs):\n        \"\"\"\n        Modifying stack multiplier count for protocol stack.\n\n        :param stack_count: Integer/String representing stack multiplier\n        :param device_name: String devices name for whc stack multiplier need to be set\n        :param ip_type: String demonstrating the IP version ipv4/ipv6\n        :param kwargs:\n                nested_device : if nested device, Need to pass nested_device = True\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_protocol_stack_count(stack_count=10, device_name='Device Group 1')\n                  set_protocol_stack_count(stack_count=10, device_name='Device Group 1', nested_device=True)\n        \"\"\"\n        self.log.info(\"Setting Stack Count for Device Group:%s\" % (device_name))\n        nested_device = kwargs.get('nested_device', False)\n        if stack_count >= 1:\n            if nested_device:\n                if self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                        Name='^' + device_name + '$'):\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ipv4Loopback.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                    if ip_type.lower() == \"ipv6\":\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                else:\n                    raise IxiaConfigException(\"Device Group (%s) Not found in the config' % device_name\")\n            else:\n                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                    if ip_type.lower() == \"ipv6\":\n                        try:\n                            self.ixNetwork.Topology.find().DeviceGroup.find(\n                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count\n                        except:\n                            pass\n                else:\n                    raise IxiaConfigException(\"Device Group (%s) Not found in the config' % device_name\")\n        else:\n            raise CafyException.InvalidValueError('Stack count (%s) has to be greater than or equal to 1' % stack_count)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def _dhcp_action_control(self, router_id, command_action, type):\n        \"\"\"\n        internal function to perform dhcpv4/v6 commands.\n        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4/v6 client is configured.\n        :param command_action: Mandatory parameter. desired command action.\n            Possible choices: start/stop/restartdown/renew/rebind.\n        :param type: Perform on DHCPv4 or DHCPv6 client\n        :return: True on success.\n        \"\"\"\n        if re.match(r'\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}', router_id):\n            raise IxiaConfigException('IXIA doesn\"t support IP v4/v6 address format for DHCP. Please provide Device Group Name')\n        elif command_action not in ['start', 'stop', 'rebind', 'renew', 'abort', 'restartDown']:\n            raise IxiaConfigException('Only the following commands \"start/stop/restartDown/renew/rebind/abort\" can be '' performed on DHCP client.')\n        else:\n            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')\n            if devicegroupObj:\n                try:\n                    command_action = command_action[0].capitalize() + command_action[1:]\n                    dhcpv4Obj = getattr(devicegroupObj.Ethernet.find(), type).find()\n                    getattr(dhcpv4Obj, command_action)()\n                    result = True\n                except:\n                    raise IxiaConfigException('\"{}\" is not configured in the given device group \"{}\"'.format(type, router_id))\n            else:\n                raise IxiaConfigException('Given device group \"{}\" doesn\"t exist.'.format(router_id))\n        return result\n\n    def perform_dhcpv6_command(self, router_id, command_action):\n        \"\"\"\n        Performs dhcpv6 commands.\n        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv6 client is configured.\n        :param command_action: Mandatory parameter. desired command action.\n            Possible choices: start/stop/restartdown/renew/rebind.\n        :return: True on success.\n\n        :Example: perform_dhcpv6_command(\"DHCPv6 Client\", \"stop\")\n                  perform_dhcpv6_command(\"DHCPv6 Client\", \"start\")\n        \"\"\"\n        return self._dhcp_action_control(router_id, command_action, \"Dhcpv6client\")\n\n    def perform_dhcpv4_command(self, router_id, command_action):\n        \"\"\"\n        Performs dhcpv4 commands.\n        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4 client is configured.\n        :param command_action: Mandatory parameter. desired command action.\n            Possible choices: start/stop/restartdown/renew/rebind.\n        :return: True on success.\n\n        :Example: perform_dhcpv4_command(\"DHCPv4 Client\", \"stop\")\n                  perform_dhcpv4_command(\"DHCPv4 Client\", \"start\")\n        \"\"\"\n        return self._dhcp_action_control(router_id, command_action, \"Dhcpv4client\")\n\n    def modify_isis_hello_padding(self, port_list, action='enable'):\n        \"\"\"\n        To modify the hello padding settings of isis enabled devices.\n        :param port_list: List of port names, whose isis devices needs modification.\n        :param action: To enable or disable hello padding. Default: enable.\n        :return True on success else raise exception.\n\n        :Example: modify_isis_hello_padding([\"Ethernet - 001\"])\n                  modify_isis_hello_padding([\"Ethernet - 001\"],'disable')\n        \"\"\"\n        sup_dict = {'enable':True,'disable':False}\n        if not isinstance(port_list, list):\n            port_list = [port_list]\n        portNameList = []\n        for vport in self.ixNetwork.Vport.find():\n            if vport.AssignedTo.replace(\":\", \"/\") in port_list or vport.Name in port_list:\n                portNameList.append(vport.Name)\n        for portName in portNameList:\n            for topology in self.ixNetwork.Topology.find():\n                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:\n                    for device in topology.DeviceGroup.find():\n                        if device.IsisL3Router.find():\n                            device.IsisL3Router.find().EnableHelloPadding.Single(sup_dict[action])\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def perform_pppoe_action(self, router_id, action, address_family=\"dual_stack\"):\n\n        \"\"\"\n        The API retries to connect to PPPoX sessions\n        :param router_id: router id of emulated device\n        :param action: action to perform options: start|stop|RestartDown|openipcp|CloseIpcp|OpenIpv6cp|CloseIpv6cp\n        :param address_family: IpCp mode ipv4/ipv6/dual_stack\n        :return: True on success.\n\n        :Example: perform_pppoe_action(\"DG2\", \"start\", 'dual_stack')\n                 perform_pppoe_action(\"DG2\", \"stop\", 'dual_stack')\n        \"\"\"\n\n        result = False\n        if re.match(r'\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}', router_id):\n            raise IxiaConfigException('IXIA doesn\"t support IP v4/v6 address format. Please provide Device Group Name')\n        elif action.lower() not in ['start', 'stop', 'restartdown', 'connect', 'disconnect', 'retry', 'openipcp',\n                                    'closeipcp', 'openipv6cp', 'closeipv6cp']:\n            raise IxiaOperationException('IXIA supports only the following commands \"Start|Stop|RestartDown|openipcp|'\n                                         'CloseIpcp|OpenIpv6cp|CloseIpv6cp\" on PPPoE client.')\n        else:\n            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')\n            if devicegroupObj:\n                pppoxObj = devicegroupObj.Ethernet.find().Pppoxclient.find()\n                if pppoxObj:\n                    ncpType = pppoxObj.NcpType.Values\n                    if re.fullmatch(ncpType[0], address_family, re.IGNORECASE):\n                        if re.fullmatch('start|connect', action, re.IGNORECASE):\n                            pppoxObj.Start()\n                            result = True\n                        if re.fullmatch('stop|disconnect', action, re.IGNORECASE):\n                            pppoxObj.Stop()\n                            result = True\n                        if re.fullmatch('restartdown|retry', action, re.IGNORECASE):\n                            pppoxObj.RestartDown()\n                            result = True\n                        if ncpType[0].lower() == 'dual_stack' and action.lower() in ['openipcp', 'closeipcp', 'openipv6cp', 'closeipv6cp']:\n                            if re.fullmatch('openipcp', action, re.IGNORECASE):\n                                pppoxObj.OpenIpcp()\n                                result = True\n                            if re.fullmatch('closeipcp', action, re.IGNORECASE):\n                                pppoxObj.CloseIpcp()\n                                result = True\n                            if re.fullmatch('openipv6cp', action, re.IGNORECASE):\n                                pppoxObj.OpenIpv6cp()\n                                result = True\n                            if re.fullmatch('closeipv6cp', action, re.IGNORECASE):\n                                pppoxObj.CloseIpv6cp()\n                                result = True\n                    else:\n                        raise IxiaConfigException('PPPoE client is configured with \"{}\" NCP Type. Please change '\n                                                  'address_family value and call the API'.format(ncpType[0]))\n                else:\n                    raise IxiaConfigException('PppoxClient is not configured in the given device group \"{}\"'.format(router_id))\n            else:\n                raise IxiaConfigException('Given device group \"{}\" doesn\"t exist.'.format(router_id))\n        return result\n\n    def generate_license_details(self, chassis_ip, username='admin', password='admin', license_feature=None):\n        \"\"\"\n        API used to retrieve license details based on Ixia chassis\n        \"\"\"\n        USERNAME_PASSWORD = {'username': username, 'password': password}\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        JSON_USERNAME_PASS = json.dumps(USERNAME_PASSWORD)\n        auth_key_call = f\"https://{chassis_ip}/api/v1/auth/session\"\n\n        try:\n            api_response = requests.post(auth_key_call, data=JSON_USERNAME_PASS,\n                                         headers={'content-type': \"application/json\"}, verify=False, timeout=10)\n            api_response.raise_for_status()\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Authentication failed: {err}\")\n            return None\n\n        api_json = api_response.json()\n        api_key = api_json.get(\"apiKey\")\n        if not api_key:\n            self.log.error(f\"[{chassis_ip}] No API key returned during authentication.\")\n            return None\n\n        HEADERS = {\n            'x-api-key': api_key,\n            'content-type': \"application/json\"\n        }\n\n        for server_type in ['platform', 'ixnetworkweb']:\n            license_server_url = f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/\"\n            try:\n                license_server_response = requests.get(license_server_url, headers=HEADERS, verify=False, timeout=10)\n                if license_server_response.status_code == 200:\n                    break\n            except Exception as err:\n                self.log.debug(f\"{chassis_ip}] Failed to connect to {license_server_url}: {err}\")\n                continue\n        else:\n            self.log.error(f\"[{chassis_ip}] License Fetch failed for chassis/server.\")\n            return None\n\n        try:\n            server_id = license_server_response.json()[0]['id']\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Could not extract server ID: {err}\")\n            return None\n\n        license_retrieval_url = f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/operations/retrievecountedfeaturestats\"\n\n        try:\n            license_retrieval_response = requests.post(license_retrieval_url, headers=HEADERS, verify=False, timeout=10)\n            license_retrieval_response.raise_for_status()\n            id_json = license_retrieval_response.json()\n            license_id = id_json.get(\"id\")\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Failed to start license retrieval: {err}\")\n            return None\n\n        if not license_id:\n            self.log.error(f\"[{chassis_ip}] No async operation ID received.\")\n            return None\n\n        license_list_url = (\n            f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/\"\n            f\"operations/retrievecountedfeaturestats/{license_id}/result\"\n        )\n\n        max_retries = 30\n        wait_time = 1\n        for attempt in range(max_retries):\n            try:\n                license_list_response = requests.get(license_list_url, headers=HEADERS, verify=False, timeout=10)\n                status = license_list_response.status_code\n                data = license_list_response.json()\n\n                if status == 200 and isinstance(data, list):\n                    break\n                if isinstance(data, dict) and \"no async operation\" in str(data).lower():\n                    time.sleep(wait_time)\n                    wait_time = min(wait_time * 2, 5)\n                    continue\n                if status != 200 or \"error\" in str(data).lower():\n                    time.sleep(wait_time)\n                    continue\n\n            except Exception as err:\n                self.log.debug(f\"[{chassis_ip}] Attempt {attempt + 1}/{max_retries} failed: {err}\")\n                time.sleep(wait_time)\n                continue\n        else:\n            self.log.error(f\"[{chassis_ip}] Timed out waiting for license result after {max_retries} retries.\")\n            return None\n\n        license_data = license_list_response.json()\n        if not isinstance(license_data, list):\n            self.log.error(f\"[{chassis_ip}] Unexpected license data format: {license_data}\")\n            return None\n\n        if license_feature:\n            for lic in license_data:\n                if license_feature in lic.values():\n                    self.log.info(f\"Showing license count for {chassis_ip} and featureName {license_feature}.\\n {lic}\")\n                    return lic\n            self.log.warning(f\"License Feature Name given: '{license_feature}' not available on {chassis_ip}.\")\n            return False\n\n        self.log.info(f\"Showing license count for {chassis_ip}.\\n {json.dumps(license_data, indent=2)}\")\n        return license_data\n\n    def set_filtered_stream_results(self, port, protocol):\n        \"\"\"\n        This api created custom traffic view stats named \"ECN\" to capture eggress tracking of active traffic items\n        :param port: str RX port Ex : \"chassis/card/port\" \"10.10.10.1/1/5\"\n        :param protocol: ipv4 or ipv6, based on which filter to apply is selected\n\n        Example: set_filtered_stream_results(port=\"10.10.10.1/1/5\",protocol = 'ipv4')\n                 set_filtered_stream_results(port=\"10.10.10.1/1/6\",protocol = 'ipv6')\n        \"\"\"\n        streamList = self.get_active_streams()\n        trafficList = list()\n        for stream in streamList:\n            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream + '$').ConfigElement.find():\n                if protocol.lower() == \"ipv4\":\n                    if configElement.Stack.find(DisplayName=\"IPv4\"):\n                        trafficList.append(stream)\n                else:\n                    if configElement.Stack.find(DisplayName=\"IPv6\"):\n                        trafficList.append(stream)\n\n        self.disable_traffic_item()\n        self.enable_traffic_item(trafficList)\n\n        if self.ixNetwork.Traffic.State in ['stopped','stoppedWaitingForStats','unapplied']:\n            self.regenerate_traffic()\n            self._apply_traffic()\n\n        if self.ixNetwork.Statistics.View.find(Caption=\"ECN\"):\n            self.ixNetwork.Statistics.View.find(Caption=\"ECN\").remove()\n        self.ixNetwork.Statistics.View.add(Caption=\"ECN\", Type='layer23TrafficFlow', Visible=True, TreeViewNodeName=\"Views\\\\Custom Views\")\n        afil = self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').AvailableTrafficItemFilter.find()\n        fil = self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').Layer23TrafficFlowFilter.find()\n        port_fil = self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').AvailablePortFilter.find()\n        fil.update(AggregatedAcrossPorts=False, EgressLatencyBinDisplayOption=\"showEgressRows\", PortFilterIds=port_fil,\n                   TrafficItemFilterIds=afil)\n        traffic_fil = self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').Layer23TrafficFlowFilter.find()\n        tracking_fil = self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').AvailableTrackingFilter.find()\n        tracking_fil_list = list()\n        for i in range(0,2):\n            tracking_fil_list.append(tracking_fil[i].href)\n        enum = traffic_fil.EnumerationFilter\n        for elem in tracking_fil_list:\n            enum.add(SortDirection=None, TrackingFilterId=elem)\n        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').Statistic.find():\n            stats.Enabled = True\n        self.ixNetwork.Statistics.View.find(Caption='^' + \"ECN\" + '$').Enabled = True\n\n    def disable_filter_stream(self, port):\n        \"\"\"\n        This api removes the custom traffic view stats named \"ECN\"\n        :param port: str RX port Ex : \"chassis/card/port\" \"10.10.10.1/1/5\"\n\n        Example: disable_filter_stream(port=\"10.10.10.1/1/5\")\n                 disable_filter_stream(port=\"10.10.10.1/1/6\")\n        \"\"\"\n        self.log.info(\" Disabling tracking on traffic items \")\n        if self.ixNetwork.Statistics.View.find(Caption=\"ECN\"):\n            self.ixNetwork.Statistics.View.find(Caption=\"ECN\").remove()\n\n    def get_filtered_stream_results(self, port_number):\n        \"\"\"\n        Returns the traffic stats from custom traffic stats view named \"ECN\" which has egress tracking and traffic class tracking\n        :param port_number: str RX port Ex : \"chassis/card/port\" \"10.10.10.1/1/5\"\n        :return: Dictionary of filtered stream data\n\n        Example: get_filtered_stream_results(port_number=\"10.10.10.1/1/5\")\n                get_filtered_stream_results(port_number=\"10.10.10.1/1/5\")\n        \"\"\"\n        streamList = self.get_active_streams()\n        rxPort = self.get_port_name_from_location(port_number)\n        filteredResult = {}\n        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)\n        flowHeadersList = flowStats.ColumnHeaders\n        flowStatHeaderValues = []\n\n        customStats = StatViewAssistant(self.ixNetwork, 'ECN', LocalCsvStorage=CafyLog.work_dir)\n        customHeadersList = customStats.ColumnHeaders\n        customStatHeaderValues = []\n\n        # flowstats\n        for rowNumber, stat in enumerate(flowStats.Rows):\n            headerDict = {}\n            for column in flowHeadersList:\n                headerDict[column] = stat[column]\n            flowStatHeaderValues.append(headerDict)\n\n        #customstats\n        for rowNumber, stat in enumerate(customStats.Rows):\n            headerDict = {}\n            for column in customHeadersList:\n                headerDict[column] = stat[column]\n            customStatHeaderValues.append(headerDict)\n\n        # list to remove excess keys as per customer request\n        rem_list = ['First TimeStamp', 'Frames Delta', 'Last TimeStamp','Loss %','Packet Loss Duration (ms)','Rx Bytes','Rx Frame Rate','Rx Rate (Kbps)','Rx Rate (Mbps)',\n                    'Rx Rate (Bps)','Tx Frame Rate','Tx Frames','Tx L1 Rate (bps)','Tx Rate (Bps)','Tx Rate (Kbps)','Tx Rate (Mbps)']\n        # appending mandatory keys into 2nd and 3rd row of flow stats\n        add_list = ['IPv4 :Class selector PHB','IPv6 :Traffic Class','Traffic Item','Tx Port','Tx Rate (bps)','Rx Port']\n\n        # ECN bit from custom stats into ECN_dict\n        ECN_dict = dict()\n        for item in streamList:\n            for i in range(len(customStatHeaderValues) - 1):\n                if customStatHeaderValues[i]['Traffic Item'] == item:\n                    [customStatHeaderValues[i].pop(k) for k in rem_list if k in customStatHeaderValues[i].keys()]\n                    ECN_dict.setdefault(item, []).append(customStatHeaderValues[i])\n                    if (len(customStatHeaderValues)//len(streamList) )== 3:\n                        if customStatHeaderValues[i + 2]['Traffic Item'] == '':\n                            [customStatHeaderValues[i + 2].pop(k) for k in rem_list if k in customStatHeaderValues[i + 2].keys()]\n                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 2])\n                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':\n                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]\n                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])\n                    if (len(customStatHeaderValues)//len(streamList) )== 2:\n                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':\n                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]\n                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])\n\n        # filteredResult dict adding traffic item with flow statistics flow\n        if streamList:\n            for trafficItemName in streamList:\n                for trafficItemDict in flowStatHeaderValues:\n                    [trafficItemDict.pop(k) for k in rem_list if k in trafficItemDict.keys()]\n                    for key, value in trafficItemDict.items():\n                        if value == trafficItemName and trafficItemDict['Rx Port'] == rxPort:\n                            filteredResult.setdefault(trafficItemName, []).append(trafficItemDict)\n\n        # using add_list adding mandatory keys from 1st flow into 2nd n 3rd flow\n        for trafficName, flow in ECN_dict.items():\n            for key, value in filteredResult.items():\n                if key == trafficName:\n                    for (eachflow, eachvalue) in zip(flow, value):\n                        value[0]['Egress Tracking'] = eachflow['Egress Tracking']\n                    for count in range(1, len(flow)):\n                        filteredResult[trafficName].append(flow[count])\n                        for k in add_list:\n                            try:\n                                flow[count][k] = value[0][k]\n                            except:\n                                pass\n\n        for key, value in filteredResult.items():\n            #remove 1st dict as its not required wrt spirent\n            value.pop(0)\n            for flow in value:\n                for field in list(flow):\n                    if field == 'IPv6 :Traffic Class':\n                        try:\n                            flow['Traffic Class (int)'] = flow['Egress Tracking']\n                        except:pass\n                        del flow['IPv6 :Traffic Class']\n\n                    if field == 'IPv4 :Class selector PHB':\n                        flow['DSCP (int)'] = flow['IPv4 :Class selector PHB']\n                        del flow['IPv4 :Class selector PHB']\n\n                    if field == 'Egress Tracking':\n                        try:\n                            flow['ECN (bits)'] = bin(int(flow['Egress Tracking'], 16))[2:]\n                        except:\n                            flow['ECN (bits)'] = flow['Egress Tracking']\n                        del flow['Egress Tracking']\n\n                    if field == 'Rx L1 Rate (bps)':\n                        flow['Rx L1 Rate'] = int(float(flow['Rx L1 Rate (bps)']))\n                        del flow['Rx L1 Rate (bps)']\n                    if field == 'Rx Frames':\n                        flow['Rx Count'] = flow['Rx Frames']\n                        del flow['Rx Frames']\n                try:\n                    if flow['ECN (bits)'] == '0':\n                        flow.update({'ECN': 'Non-ECT'})\n                    elif flow['ECN (bits)'] == '1':\n                        flow.update({'ECN': 'ECT(1)'})\n                    elif flow['ECN (bits)'] == '10':\n                        flow.update({'ECN': 'ECT(0)'})\n                    elif flow['ECN (bits)'] == '11':\n                        flow.update({'ECN': 'CE'})\n                except:pass\n\n        for key, value in filteredResult.items():\n            filteredResult[key] = [ele for ele in ({key: val for key, val in sub.items() if val != ''} for sub in value) if ele]\n        return filteredResult\n\n    def add_network_group(self, device_name, protocol, **kwargs):\n        \"\"\"\n        API to add Network group for ISIS,OSPF and BGP protocols , Supports both ipv4 and ipv6 network groups\n\n        :param device_name: Name of the Device group on which the network routes to be added\n        :param protocol: protocol on which the network routes to be added. Ex: protocol='isis' or 'bgp' or 'ospf'\n        :param kwargs:\n                network_address_step: Network prefix step value\n                network_address_incr_step: Network IP address increment step Ex  Integer value for step value\n                network_group_multiplier: Network group multiplier Ex 1 or 2\n                v4_network_address_start: Ipv4 network address start value Ex '2.2.2.2'/['2.2.2.2']\n                v4_network_address_incr_step: ipv4 network address increment step Ex: '0.0.0.1'\n                v4_network_address_prefix_list: ipv4 network address prefix length Ex : [24, 32]\n                network_address_type: Network address type it can be List/Increment\n                network_group_name : Str Network group name\n                ip_type: String demonstrating the IP version\n                route_type: String demonstrating the Network Group version type\n        return True on success or raise exception\n\n        Examples:\n            1.tgnObj.add_network_group(device_name='Device1', protocol='ospf')\n\n            2.tgnObj.add_network_group(device_name='Device_isis', number_of_address = [10,20],protocol='isis',\n            network_group_multiplier= 2, prefix_type ='list',v4_network_address_start=['2.2.2.2', '3.3.3.3'],\n            v4_network_address_prefix_list=[32, 24],v4_network_address_incr_step='0.0.0.2',\n            network_address_step=[20, 30], network_address_type='list')\n        \"\"\"\n        v4_network_address_incr_step = kwargs.get('v4_network_address_incr_step', '0.0.0.1')\n        v4_network_address_start = kwargs.get('v4_network_address_start', None)\n        v4_network_address_prefix_list = kwargs.get('v4_network_address_prefix_list', None)\n        v6_network_address_start = kwargs.get('v6_network_address_start', None)\n        v6_network_address_prefix_list = kwargs.get('v6_network_address_prefix_list', None)\n        v6_network_address_incr_step = kwargs.get('v6_network_address_incr_step', '0:0:1::')\n        network_group_name = kwargs.get('network_group_name', None)\n        network_group_multiplier = kwargs.get('network_group_multiplier', 1)\n        prefix_type = kwargs.get('prefix_type', 'SingleValue')\n        number_of_address = kwargs.get('number_of_address', [1])\n        network_address_step = kwargs.get('network_address_step', [1])\n        ip_type = kwargs.get('ip_type', 'ipv4')\n        if ip_type.lower() == \"ipv4\":\n            route_type = kwargs.get('route_type', 'ipv4')\n        if ip_type.lower() == \"ipv6\":\n            route_type = kwargs.get('route_type', 'ipv6')\n\n        if kwargs.get('v6_network_address_start', None):\n            if type(kwargs['v6_network_address_start']) == str:\n                network_address_type = kwargs.get('network_address_type', 'increment')\n            elif type(kwargs['v6_network_address_start']) == list:\n                network_address_type = kwargs.get('network_address_type', 'list')\n        if kwargs.get('v4_network_address_start', None):\n            if type(kwargs['v4_network_address_start']) == str:\n                network_address_type = kwargs.get('network_address_type', 'increment')\n            elif type(kwargs['v4_network_address_start']) == list:\n                network_address_type = kwargs.get('network_address_type', 'list')\n        if kwargs.get('v4_network_address_start') == None and kwargs.get('v6_network_address_start') == None:\n            network_address_type = kwargs.get('network_address_type', 'increment')\n\n        protocolStatus = False\n        try:\n            networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name='^' + device_name + '$').NetworkGroup.add(Multiplier=network_group_multiplier,\n                                                            Name=network_group_name)\n        except:\n            raise IxiaConfigException(\"'%s' Device group not found to add Network Group\" % device_name)\n\n        # The protocol to which network group need to be connected\n        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')\n        if protocol.lower() == 'isis':\n            protocolObj = deviceObj.Ethernet.find().IsisL3.find()\n        elif protocol.lower() == 'ospf' and ip_type.lower() == 'ipv4':\n            protocolObj = deviceObj.Ethernet.find().Ipv4.find().Ospfv2.find()\n        elif protocol.lower() == 'bgp' and ip_type.lower() == 'ipv4':\n            protocolObj = deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()\n\n        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')\n        if protocol.lower() == 'ospf' and ip_type.lower() == 'ipv6':\n            protocolObj = deviceObj.Ethernet.find().Ipv6.find().Ospfv3.find()\n        if protocol.lower() == 'bgp' and ip_type.lower() == 'ipv6':\n            protocolObj = deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()\n\n        if route_type.lower() == \"ipv4\":\n            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(\n                Name=networkGroupObj.Name).Ipv4PrefixPools.add()\n        if route_type.lower() == \"ipv6\":\n            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(\n                Name=networkGroupObj.Name).Ipv6PrefixPools.add()\n        ipPool.Connector.find().ConnectedTo = protocolObj.href\n\n        # Verifying is protocol is present in the given device group\n        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name='^' + device_name + '$').NetworkGroup.find(\n            Name=networkGroupObj.Name):\n\n            if route_type.lower() == \"ipv4\":\n                ipPoolObj = networkObj.Ipv4PrefixPools.find()\n            if route_type.lower() == \"ipv6\":\n                ipPoolObj = networkObj.Ipv6PrefixPools.find()\n\n            if protocol.lower() == 'isis':\n                if ipPoolObj.IsisL3RouteProperty.find():\n                    protocolStatus = True\n            if protocol.lower() == 'ospf':\n                if route_type.lower() == \"ipv4\":\n                    if ipPoolObj.OspfRouteProperty.find():\n                        protocolStatus = True\n                if route_type.lower() == \"ipv6\":\n                    if ipPoolObj.Ospfv3RouteProperty.find():\n                        protocolStatus = True\n            if protocol.lower() == 'bgp':\n                if ipPoolObj.BgpIPRouteProperty.find():\n                    protocolStatus = True\n                if ipPoolObj.BgpV6IPRouteProperty.find():\n                    protocolStatus = True\n                if ipPoolObj.BgpL3VpnRouteProperty.find():\n                    protocolStatus = True\n                if ipPoolObj.BgpV6L3VpnRouteProperty.find():\n                    protocolStatus = True\n\n        # only if protocol is found go ahead and set the passed args\n        if protocolStatus:\n            if network_address_type.lower() == 'increment':\n                if route_type.lower() == \"ipv4\":\n                    ipPoolObj.NetworkAddress.Increment(start_value=v4_network_address_start,\n                                                    step_value=v4_network_address_incr_step)\n                if route_type.lower() == \"ipv6\":\n                    ipPoolObj.NetworkAddress.Increment(start_value=v6_network_address_start,\n                                                    step_value=v6_network_address_incr_step)\n            if network_address_type.lower() == 'list':\n                if route_type.lower() == \"ipv4\":\n                    ipPoolObj.NetworkAddress.ValueList(v4_network_address_start)\n                if route_type.lower() == \"ipv6\":\n                    ipPoolObj.NetworkAddress.ValueList(v6_network_address_start)\n            if prefix_type.lower() == 'list':\n                if route_type.lower() == \"ipv4\":\n                    ipPoolObj.PrefixLength.ValueList(v4_network_address_prefix_list)\n                if route_type.lower() == \"ipv6\":\n                    ipPoolObj.PrefixLength.ValueList(v6_network_address_prefix_list)\n            elif prefix_type.lower() == 'increment':\n                if route_type.lower() == \"ipv4\":\n                    ipPoolObj.PrefixLength.Increment(start_value=v4_network_address_prefix_list,step_value=1)\n                if route_type.lower() == \"ipv6\":\n                    ipPoolObj.PrefixLength.Increment(start_value=v6_network_address_prefix_list,step_value=1)\n            else:\n                if route_type.lower() == \"ipv4\":\n                    ipPoolObj.PrefixLength.Single(v4_network_address_prefix_list)\n                if route_type.lower() == \"ipv6\":\n                    ipPoolObj.PrefixLength.Single(v6_network_address_prefix_list)\n\n            if number_of_address is not None:\n                if isinstance(number_of_address, (int, str)):\n                    ipPoolObj.NumberOfAddressesAsy.Single(number_of_address)\n                else:\n                    ipPoolObj.NumberOfAddressesAsy.ValueList(number_of_address)\n\n            if network_address_step is not None:\n                if isinstance(network_address_step, (int, str)):\n                    ipPoolObj.PrefixAddrStep.Single(network_address_step)\n                else:\n                    ipPoolObj.PrefixAddrStep.ValueList(network_address_step)\n        else:\n            pass\n\n        self.log.info(\"Network Group added Successfully\")\n        return True\n\n    def change_port_transmit_mode(self, port=None, transmit_mode='interleaved'):\n        \"\"\"\n        API to change the port transmit mode\n        :param port: name of the port on which transmit mode to be changed.\n                    Ex: port = '1/1' or port = ['10.10.1.1/1/2']\n        :param transmit_mode: supported mode values - 'interleaved' , 'sequential'\n        return: True on successful\n\n        Example: tgnObj.change_port_transmit_mode(transmit_mode='sequential')\n                 tgnObj.change_port_transmit_mode(port=['1/1'], transmit_mode='sequential')\n                 tgnObj.change_port_transmit_mode(port='10.36.75.242/2/5', transmit_mode='sequential')\n                 tgnObj.change_port_transmit_mode(port=['10.36.75.242/2/6'], transmit_mode='interleaved')\n        \"\"\"\n        self.log.info('Changing the Port Transmit Mode')\n        if port:\n            if type(port) is str:\n                port = port.split(\",\")\n            portList = []\n            for vport in self.ixNetwork.Vport.find():\n                if vport.AssignedTo.replace(\":\", \"/\") in port or vport.Name in port:\n                    portList.append(vport)\n        else:\n            portList = self.get_list_ports()\n        for eachPort in portList:\n            eachPort.TxMode = transmit_mode\n        return True\n\n    def set_advance_sequencing(self, enable=True):\n        \"\"\"\n        Set or unset the Advance Sequencing to allow determination of re-order packets\n        :param enable: boolean, true to enable. false if you want to disable feature\n        :return: True if the operation is successful , False Otherwise\n        \"\"\"\n        try:\n            self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled = enable\n        except:\n            raise IxiaConfigException(\"Unable to change Advance Sequence Checking\")\n        return True\n\n    def verify_inorder_reorder_traffic(self):\n        \"\"\"\n        Verify no reordered packets on any traffic streams\n\n        :return: Print out table showing in-order packets and re-ordered packets with Status\n        \"\"\"\n        if not self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled:\n            raise IxiaConfigException(\"Advance Sequence Checking is not enabled\")\n        else:\n            try:\n                stats = self.get_stats(view_name='Traffic Item Statistics')\n\n            except:\n                raise IxiaConfigException(\"Unable to get Traffic Item Statistics\")\n            headers = [\"Traffic Item\", \"In Order Frames\", \"Reordered Frames\", \"Status\"]\n            data = []\n            item_headers = headers.copy()\n            stats_headers = set()\n            for one_obj in stats.values():\n                for head in one_obj.keys():\n                    stats_headers.add(head)\n            Inorder_flag = False\n            TX_Frames_flag = False\n            ReOrder_flag = False\n            for one_obj in stats.values():\n                for key, value in list(one_obj.items()):\n                    if key == \"Reordered Frames\" and int(value) > 0 :\n                        one_obj.update({'Status': 'Fail'})\n                        ReOrder_flag = True\n                        break\n                    elif key == \"Reordered Frames\" and int(value) == 0:\n                        one_obj.update({'Status': 'Pass'})\n                    if key ==\"Tx Frames\" and int(value) == 0:\n                        one_obj.update({'Status': 'Fail'})\n                        TX_Frames_flag = True\n                        break\n                    elif key ==\"In Order Frames\" and int(value) == 0:\n                        one_obj.update({'Status': 'Fail'})\n                        Inorder_flag = True\n                        break\n            for one_obj in stats.values():\n                one_data = []\n                for _head in item_headers:\n                    if _head in one_obj.keys():\n                        one_data.append(one_obj[_head])\n                    else:\n                        one_data.append('N/A')\n                data.append(one_data)\n            stats_tb = tabulate.tabulate(data,\n                                         headers=item_headers,\n                                         tablefmt='rst')\n\n            self.log.info('Traffic Item:\\n' + stats_tb)\n            if TX_Frames_flag:\n                raise IxiaConfigException(\"Tx Frames count is 0\")\n            elif Inorder_flag :\n                raise IxiaConfigException(\"In-Order Frames count is 0\")\n            elif ReOrder_flag:\n                raise IxiaConfigException(\"Re-Order Frames count is greater than 0\")\n            return stats_tb\n\n    def _set_ldp_network_group_options(self, poolHandle, routeCount, prefixIp=None, prefixlen=None, routerID=None):\n        \"\"\"\n        Set Route count and prefix based on Protocol handle.\n        :param poolHandle: PrefixPool Handle\n        :param routeCount: RouteCount to be updated\n        :param prefixIp: prefixIp as reference\n        :param prefixlen: prefixlen as reference\n        :param routerID: routerID as reference\n        :return:\n        \"\"\"\n        if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:\n            if prefixIp and routerID:\n                if prefixIp in poolHandle.NetworkAddress.Values:\n                    ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)\n                    valueList = poolHandle.NumberOfAddressesAsy.Values\n                    valueList[ipPrefixIndex] = routeCount\n                    poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)\n                    if prefixlen:\n                        valueList = poolHandle.PrefixLength.Values\n                        valueList[ipPrefixIndex] = prefixlen\n                        poolHandle.PrefixLength.ValueList(values=valueList)\n            elif routerID and prefixIp is None:\n                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n                    if deviceGroupObj.RouterData.find():\n                        if routerID in deviceGroupObj.RouterData.find().RouterId.Values:\n                            routerIDIndex = (deviceGroupObj.RouterData.find().RouterId.Values).index(routerID)\n                            valueList = poolHandle.NumberOfAddressesAsy.Values\n                            valueList[routerIDIndex] = routeCount\n                            poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)\n                            if prefixlen:\n                                valueList = poolHandle.PrefixLength.Values\n                                valueList[routerIDIndex] = prefixlen\n                                poolHandle.PrefixLength.ValueList(values=valueList)\n            else:\n                poolHandle.NumberOfAddressesAsy.Single(routeCount)\n                if prefixlen:\n                    poolHandle.PrefixLength.Single(prefixlen)\n        # This block for 8.50 version\n        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:\n            poolHandle.NumberOfAddresses = routeCount\n            if prefixlen:\n                poolHandle.PrefixLength.Single(prefixlen)\n\n    def _modify_ldp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix,\n                                router_id, **kwargs):\n        \"\"\"\n        Internal API to support setting route count and prefix length of BGP network group\n\n        :param network_group: Network Group for which Route Count should be modified\n        :param route_count: Route count\n        :param ip_type: ipv4 or ipv6\n        :param start_ip_prefix: start ip prefix as reference\n        :param prefix: prefix\n        :param router_id: router ID\n        :return: result\n        \"\"\"\n        protocolStatus = False\n        deviceGroupName = None\n        nested_network_group = kwargs.get('nested_network_group')\n        networkGroupNameList = []\n        for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():\n            if deviceGroupObj.RouterData.find():\n                for routerId in router_id:\n                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:\n                        deviceGroupName = deviceGroupObj.Name\n                        break\n        try:\n            if deviceGroupName:\n                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + deviceGroupName + '$').NetworkGroup.find():\n                    if network_group:\n                        if network_group in networkGroup.Name:\n                            networkGroupNameList.append(networkGroup.Name)\n                            break\n                    else:\n                        networkGroupNameList.append(networkGroup.Name)\n        except:\n            pass\n        if network_group:\n            try:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()\n                                        if network_group in networkObj.Name]\n            except:\n                pass\n        if nested_network_group and network_group:\n            try:\n                networkGroupNameList = [networkObj.Name for networkObj in\n                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()\n                                        if network_group in networkObj.Name]\n            except:\n                pass\n        if networkGroupNameList:\n            for networkGroupName in networkGroupNameList:\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + networkGroupName + '$')\n                if nested_network_group:\n                    try:\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + networkGroupName + '$')\n                    except:\n                        pass\n                if ip_type.lower() == \"ipv4\":\n                    for networkGroupObj in networkObj.Ipv4PrefixPools.find():\n                        if networkGroupObj.LdpFECProperty.find():\n                            protocolStatus = True\n                            networkObj.Enabled.Single(True)\n                            for routerId in router_id:\n                                self._set_ldp_network_group_options(networkGroupObj, route_count,\n                                                                    prefixIp=start_ip_prefix,\n                                                                    prefixlen=prefix, routerID=routerId)\n                if ip_type.lower() == \"ipv6\":\n                    for networkGroupObj in networkObj.Ipv6PrefixPools.find():\n                        if networkGroupObj.LdpIpv6FECProperty.find():\n                            networkObj.Enabled.Single(True)\n                            protocolStatus = True\n                            for routerId in router_id:\n                                self._set_ldp_network_group_options(networkGroupObj, route_count,\n                                                                    prefixIp=start_ip_prefix,\n                                                                    prefixlen=prefix, routerID=routerId)\n        else:\n            raise IxiaConfigException(\"Router Id or network_group not found \")\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        if protocolStatus:\n            return protocolStatus\n        else:\n            raise IxiaConfigException(\"LDP protocol not configured or Configuration issue.\")\n\n    def set_ldp_route_count(self, route_count, ip_type=\"ipv4\", **kwargs):\n        \"\"\"\n        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.\n\n        :param route_count: Integer/String representing the new route count\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                router_id: Router ID of the device\n                route_block_name: route block name from config\n                start_ip: represents the first IP of the route block\n                prefix: Integer/String representing the new prefix\n                nested_network_group : if nested network group, Need to pass nested_network_group = True\n                                if nested_network_group is True 'route_block_name' is mandatory\n        :return: True if the operation is successful, False otherwise\n\n        :Example: set_ldp_route_count(route_count=10, ports=[\"Ethernet - 001\"], network_group=\"Network Group 9\")\n        \"\"\"\n        network_group = kwargs.get('route_block_name')\n        if 'network_group' in kwargs:\n            network_group = kwargs.get('network_group')\n        self.log.info(\"Setting Ldp Route Count for route_block_name:%s\" % (network_group))\n        startIp = kwargs.get('start_ip')\n        prefixLength = kwargs.get('prefix')\n        routerId = kwargs.get('router_id')\n        if not isinstance(routerId, list):\n            routerId = [routerId]\n        nestedGroup = kwargs.get('nested_network_group', False)\n        if not network_group and routerId is None:\n            raise IxiaConfigException('Please pass either Network group/Router Id')\n        return self._modify_ldp_route_count(network_group, route_count, ip_type, start_ip_prefix=startIp,\n                                            prefix=prefixLength, router_id=routerId,\n                                            nested_network_group=nestedGroup)\n\n    def modify_vlan(self, device_name, port_list=None, vlan_id=1, **kwargs):\n        \"\"\"\n        Modifies device VLAN id and enable/disable vlan based on Device name or port name\n        :param device_name: device group name to set vlan id\n        :param port_list: list of port names - Ex: ['R1_T1_1']\n        :param vlan_id: VLAN ID to be set. Default value is 1\n        :param kwargs:\n                vlan_number: vlan ID need to be modified\n                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111\n                vlan_count : vlan number which need to be changes, defalut is 1\n                            Ex : vlan_count = 1, vlan ID 1 will be changed\n                                 vlan_count = 2, vlan ID 2 will be changed\n                vlan_step : Step to increment vlan_id, default 1\n                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'\n                enable_vlan : enable/disable vlan based on device_name\n                              Ex : enable_vlan = True, vlan is enabled on device_name\n                                   enable_vlan = False, vlan is disabled on device_name\n        :return: None\n        :Example: modify_vlan(device_name='V4_V6_SSM',port_list=['PortConfig1/2/3 TenGigE0/0/0/2_R1'],enable_vlan=True)\n                  modify_vlan(device_name='V4_V6_SM',port_list='PortConfig1/2/1 TenGigE0/0/0/0_R1', enable_vlan=True)\n        \"\"\"\n        self.log.info(\"Modifying vlan id based on device group name / port name\")\n        ethObj = None\n        try:\n            ethObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()\n            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')\n        except:\n            raise IxiaOperationException(\"Device Group not Found in the Ixia Configuration\")\n\n        port_index_list = []\n        if port_list:\n            if type(port_list) == list:\n                for port in port_list:\n                    for topology in self.ixNetwork.Topology.find():\n                        if self.ixNetwork.Vport.find(Name=port).href in topology.Vports:\n                            topologyObj = topology.href\n                            port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port).href))\n                            for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():\n                                if re.match(topologyObj + '/deviceGroup', ethernet.href):\n                                    ethObj = ethernet\n            elif type(port_list) == str:\n                for topology in self.ixNetwork.Topology.find():\n                    if self.ixNetwork.Vport.find(Name=port_list).href in topology.Vports:\n                        topologyObj = topology.href\n                        port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port_list).href))\n\n                        for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():\n                            if re.match(topologyObj + '/deviceGroup', ethernet.href):\n                                ethObj = ethernet\n\n        vlan_count = kwargs.get('vlan_count', 1)\n        vlan_number = kwargs.get('vlan_number', None)\n        if vlan_count:\n            vlanObj = ethObj.Vlan.find()[vlan_count - 1]\n        else:\n            vlanObj = ethObj.Vlan.find()[0]\n        vlanList = vlanObj.VlanId.Values\n        enableList = ethObj.EnableVlans.Values\n        if 'enable_vlan' in kwargs:\n            if 'device_id' in kwargs:\n                enableList[kwargs['device_id'] - 1] = kwargs['enable_vlan']\n                ethObj.EnableVlans.ValueList(enableList)\n            elif 'vlan_number' in kwargs:\n                vlan_index = vlanList.index(str(kwargs['vlan_number']))\n                enableList[vlan_index] = kwargs['enable_vlan']\n                ethObj.EnableVlans.ValueList(enableList)\n            else:\n                for port_index in port_index_list:\n                    if deviceObj.Multiplier > 1:\n                        count = 0\n                        if port_index == 0:\n                            count = port_index\n                            while count < deviceObj.Multiplier:\n                                enableList[count] = kwargs['enable_vlan']\n                                count += 1\n                            ethObj.EnableVlans.ValueList(enableList)\n                        else:\n                            index = port_index * deviceObj.Multiplier\n                            while (index < deviceObj.Multiplier * (port_index + 1)):\n                                enableList[index] = kwargs['enable_vlan']\n                                index += 1\n                            ethObj.EnableVlans.ValueList(enableList)\n                    else:\n                        enableList[port_index] = kwargs['enable_vlan']\n                        ethObj.EnableVlans.ValueList(enableList)\n        else:\n            enable_vlan = kwargs.get('enable_vlan', None)\n            try:\n                self.ixNetwork.Topology.find().DeviceGroup.find(\n                    Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)\n            except:\n                pass\n\n        if 'vlan_number' in kwargs or 'device_id' in kwargs:\n            if 'vlan_number' in kwargs:\n                vlan_index = vlanList.index(str(vlan_number))\n                vlanList[vlan_index] = str(vlan_id)\n                vlanObj.VlanId.ValueList(vlanList)\n            elif 'device_id' in kwargs:\n                vlan_index = kwargs['device_id'] - 1\n                vlanList[vlan_index] = str(vlan_id)\n                vlanObj.VlanId.ValueList(vlanList)\n        else:\n            vlan_direction = kwargs.get('vlan_direction', 'increment')\n            if vlan_direction.lower() == 'decrement':\n                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))\n            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n    def load_bgp_routes(self, file_name, network_group, overwrite=True):\n        \"\"\"\n        Adding start address and prefix from given CSV file into the BGP network group\n        :param file_name: csvFile with contains start address and prefix\n        :param network_group: Network group name to which route and prefix need to be added\n        :param overwrite: boolean flag, to overwrite or to concat to existing address pools, default value is True\n        :return: returns True on success\n        Example: load_bgp_routes(file_name = \"ipv4_routes.csv\",network_group = \"Network Group BGP\")\n                load_bgp_routes(file_name = \"ipv6_routes.csv\",network_group = \"Network Group BGP\", overwrite=False)\n        \"\"\"\n        log.info(\"Adding Route Prefix to %s\",network_group)\n        routeEntries = 0\n        originValuesDict = {\"igp\":\"i\", \"egp\":\"e\"}\n\n        networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                                    Name='^' + network_group + '$')\n        try:\n            poolObj =  networkGroupObj.Ipv4PrefixPools.find()\n            if poolObj.BgpIPRouteProperty.find():\n                bgpRouteObj = poolObj.BgpIPRouteProperty.find()\n            if poolObj.BgpV6IPRouteProperty.find():\n                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()\n            if poolObj.BgpL3VpnRouteProperty.find():\n                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()\n            if poolObj.BgpV6L3VpnRouteProperty.find():\n                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()\n            ip_type = \"ipv4\"\n        except Exception as e:\n            poolObj =  networkGroupObj.Ipv6PrefixPools.find()\n            if poolObj.BgpIPRouteProperty.find():\n                bgpRouteObj = poolObj.BgpIPRouteProperty.find()\n            if poolObj.BgpV6IPRouteProperty.find():\n                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()\n            if poolObj.BgpL3VpnRouteProperty.find():\n                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()\n            if poolObj.BgpV6L3VpnRouteProperty.find():\n                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()\n            ip_type = \"ipv6\"\n\n        networkPrefixValues = poolObj.PrefixLength.Values\n        networkAddrValues = poolObj.NetworkAddress.Values\n        aspath = bgpRouteObj.AsPathASString\n        Med = bgpRouteObj.MultiExitDiscriminator.Values\n        LocalPref = bgpRouteObj.LocalPreference.Values\n        weight = bgpRouteObj.Weight.Values\n        origin = bgpRouteObj.Origin.Values\n\n        outputfile = CafyLog.work_dir + '/' + \"output.csv\"\n        existingDetails = []\n\n        if overwrite == False:\n            routeEntries += bgpRouteObj.Count\n            for addr, prefix, asstr, med, pref, weight, org in zip(networkAddrValues, networkPrefixValues, aspath, Med, LocalPref, weight, origin):\n                entry = []\n                entry.append(originValuesDict[org]) #first cell\n                entry.append(addr +'/' + prefix) #add/prefix\n                if ip_type == \"ipv4\":\n                    entry.append(\"0.0.0.0\") #next hop\n                else:\n                    entry.append(\"1.1.1.1\")\n\n                entry.append(med) #med\n                entry.append(pref) #local  pref\n                entry.append(weight) #wegith\n                entry.append(asstr) #as path\n                entry.append(originValuesDict[org])\n                existingDetails.append(entry)\n\n        with open(file_name, 'r') as csvinput:\n            with open(outputfile, 'w') as csvoutput:\n                writer = csv.writer(csvoutput, lineterminator='\\n')\n                reader = csv.reader(csvinput)\n                row = next(reader)\n                for row in reader:\n                    rowEntry = []\n                    rowEntry.append(\"i\") # firs cell\n                    rowEntry.append(row[0] + '/' + row[1]) #address/prefix\n                    if len(row) <= 2:\n                        if ip_type == \"ipv4\":\n                            rowEntry.append(\"0.0.0.0\") #next hop\n                        else:\n                            rowEntry.append(\"1.1.1.1\")\n                        rowEntry.extend([\"0\", \"0\", \"0\", \"{1}\"])\n                    else:\n                        try:\n                            rowEntry.append(row[2]) # next hop\n                            rowEntry.append(row[3]) #med\n                            rowEntry.append(row[4]) #local pref\n                            rowEntry.append(row[5]) #wegith\n                            rowEntry.append(row[6]) #as path\n                        except Exception as e:\n                            pass\n                    rowEntry.append(\"i\") #as path\n                    routeEntries +=1\n                    existingDetails.extend([rowEntry])\n                writer.writerows(existingDetails)\n\n        try:\n            # To mitigate UDF error repeating the last route entry\n            prime_check = False\n            if routeEntries > 1000000:\n                for i in range(2, int(routeEntries ** 0.5) + 1):\n                    if routeEntries % i == 0:\n                        break\n                else:\n                    prime_check = True\n\n            if prime_check and routeEntries > 1000000 or routeEntries == 1399997:\n                routeEntries += 1\n                with open(outputfile, 'a', newline='') as output:\n                    writer_object = csv.writer(output)\n                    writer_object.writerows([existingDetails[-1]])\n\n            bgpRouteObj.ImportBgpRoutes(Arg2='roundRobin', Arg3=True, Arg4='overwriteTestersAddress',\n                                                Arg5='csv',Arg6=(Files(outputfile, local_file=True)),Arg7=routeEntries)\n            networkGroupObj.Multiplier = routeEntries\n            self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        except Exception as e:\n            raise IxiaConfigException(\"Network Group '%s' not found on the config\" % (network_group))\n        return True\n\n    def get_device_protocol_status(self, protocols=None, devices=None):\n        \"\"\"\n        This api returns the protocol status (up | down | Not started) based of protocol or devices\n        :param protocols: List of protocols to fetch status\n        :param devices: List of device names\n        :return:True on success otherwise return False\n\n        Example: get_device_protocol_status(protocols = [\"isis\",\"bgp\"], devices = ['Device ISIS 1','BGP Router 3'])\n                 get_device_protocol_status(protocols = [\"isis\",\"ospf\"])\n                 get_device_protocol_status()\n        \"\"\"\n        self.log.info(\" Getting protocol status info \")\n        resultDict = dict()\n        if devices is None:\n            devices = self.get_device_names()\n        protocolsList = {'isis': 'IsisL3', 'bgp': 'BgpIpv4Peer',\n                         'igmp': 'IgmpHost', 'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',\n                         'ospfv2': 'Ospfv2', 'bgpv6': 'BgpIpv6Peer', 'ldpbasicrouterv6': 'LdpBasicRouterV6',\n                         'pimv4interface': 'PimV4Interface',\n                         'mld': 'MldHost', 'mldquerier': 'MldQuerier',\n                         'pimv6interface': 'PimV6Interface', 'ospfv3': 'Ospfv3'}\n        if protocols:\n            for protocol in protocols:\n                for eachDevice in devices:\n                    eachDevice = eachDevice.replace('+', r'\\+').replace('*', r'\\*')\n                    if protocol.lower() in protocolsList:\n                        if protocol.lower() in [\"isis\"]:\n                            try:\n                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().' +\n                                        protocolsList[protocol.lower()] + '.find()'):\n                                    if 'false' not in (list(set(\n                                            eval(\n                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().' +\n                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):\n                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().' +\n                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})\n                            except:\n                                pass\n                        if protocol.lower() in [\"bgp\", \"igmp\", \"igmpquerier\", \"ldpbasicrouter\", \"pimv4interface\",\n                                                \"ospfv2\"]:\n                            try:\n                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv4.find().' +\n                                        protocolsList[protocol.lower()] + '.find()'):\n                                    if 'false' not in (list(set(\n                                            eval(\n                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv4.find().' +\n                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):\n                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv4.find().' +\n                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})\n                            except:\n                                pass\n                        if protocol.lower() in [\"bgpv6\", \"ldpbasicrouterv6\", \"mld\", \"mldquerier\", \"pimv6interface\",\n                                                \"ospfv3\"]:\n                            try:\n                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv6.find().' +\n                                        protocolsList[protocol.lower()] + '.find()'):\n                                    if 'false' not in (list(set(\n                                            eval(\n                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv6.find().' +\n                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):\n                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv6.find().' +\n                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})\n                            except:\n                                pass\n        else:\n            for key, protocol in protocolsList.items():\n                for eachDevice in devices:\n                    eachDevice = eachDevice.replace('+', r'\\+').replace('*', r'\\*')\n                    if key in [\"isis\"]:\n                        try:\n                            if 'down' in list(set(eval(\n                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().' + protocol + '.find().SessionStatus'))):\n                                if 'false' not in (list(set(\n                                        eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().' + protocol + '.find().Active.Values')))):\n                                    resultDict.setdefault(key, []).append(eachDevice)\n                        except:\n                            pass\n                    if key in [\"bgp\", \"igmp\", \"igmpquerier\", \"ldpbasicrouter\", \"pimv4interface\", \"ospfv2\"]:\n                        try:\n                            if 'down' in list(set(eval(\n                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv4.find().' + protocol + '.find().SessionStatus'))):\n                                if 'false' not in (list(set(\n                                        eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv4.find().' + protocol + '.find().Active.Values')))):\n                                    resultDict.setdefault(key, []).append(eachDevice)\n                        except:\n                            pass\n                    if key in [\"bgpv6\", \"ldpbasicrouterv6\", \"mld\", \"mldquerier\", \"pimv6interface\", \"ospfv3\"]:\n                        try:\n                            if 'down' in list(set(eval(\n                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv6.find().' + protocol + '.find().SessionStatus'))):\n                                if 'false' not in (list(set(\n                                        eval(\n                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name=\"' + eachDevice + '\").Ethernet.find().Ipv6.find().' + protocol + '.find().Active.Values')))):\n                                    resultDict.setdefault(key, []).append(eachDevice)\n                        except:\n                            pass\n        return resultDict\n\n    def add_new_bgp_route_block(self, device, ip_type='ipv4', **kwargs):\n        \"\"\"\n        Add a bgp route block/prefix to an existing device\n\n        :param device: device on which route block to be added\n        :param ip_type: 'ipv4' or 'ipv6'(default value is 'ipv4')\n        :param route_start: starting IP of route block\n        :param route_prefix: Route prefix\n        :param route_count: Number of routes\n        :param route_prefix_step: Route prefix step to increment\n        :return: True on success, exception on failure\n        ex: tgn.add_new_bgp_route_block(device='Router 1',route_start='150.0.0.1',route_count='5', route_prefix_step='2', route_prefix='24')\n        \"\"\"\n\n        if ip_type.lower() == 'ipv6':\n            network_address_start = kwargs.get('route_start', '2000::1')\n            network_address_prefix_list = kwargs.get('route_prefix', '64')\n            network_address_count = kwargs.get('route_count', '1')\n            network_address_prefix_step = kwargs.get('route_prefix_step', '1')\n            network_address_incr_step = kwargs.get('route_address_incr', '::1')\n            route_prefix_type = kwargs.get('route_prefix_type','singleValue')\n            network_group_name = kwargs.get('network_group_name', None)\n            self.add_network_group(device_name=device, protocol='bgp',\n                                ip_type='ipv6',\n                                v6_network_address_start=network_address_start,\n                                v6_network_address_prefix_list=network_address_prefix_list,\n                                v6_network_address_incr_step=network_address_incr_step,\n                                number_of_address=network_address_count,\n                                network_address_step=network_address_prefix_step,\n                                prefix_type=route_prefix_type,\n                                network_group_name= network_group_name)\n        else:\n            network_address_start = kwargs.get('route_start', '192.0.1.0')\n            network_address_prefix_list = kwargs.get('route_prefix', '24')\n            network_address_count = kwargs.get('route_count', '1')\n            network_address_prefix_step = kwargs.get('route_prefix_step', '1')\n            network_address_incr_step = kwargs.get('route_address_incr', '0.0.0.1')\n            route_prefix_type = kwargs.get('route_prefix_type', 'singleValue')\n            network_group_name= kwargs.get('network_group_name', None)\n            self.add_network_group(device_name=device, protocol='bgp',\n                                ip_type='ipv4',\n                                v4_network_address_start=network_address_start,\n                                v4_network_address_prefix_list=network_address_prefix_list,\n                                v4_network_address_incr_step=network_address_incr_step,\n                                number_of_address=network_address_count,\n                                network_address_step=network_address_prefix_step,\n                                prefix_type=route_prefix_type,\n                                network_group_name= network_group_name)\n        return True\n\n    def config_pim_group_member(self, device_name, ip_version, group_name=None, **kwargs):\n        \"\"\"\n        Configures PIM group-membership\n        :param device_name: Name of the Device\n        :param ip_version: ipv4/ipv6\n        :param group_name: Name of the IPv4/Ipv6 Multicast group\n        :param kwargs: Optional arguments\n        :param pim_rp_ipv4: Rendezvous Point Router (RPR) IPv4 address\n        :param pim_rp_ipv6: Rendezvous Point Router (RPR) IPv6 address\n        :param pim_group_type: STARG/SG/STARSTARRP\n        :param pimv4_join_src: Start IPv6 address of Join source range\n        :param pimv4_prefix_length: prefix length of Join source IPv4 address\n        :param pimv6_join_src: Start IPv6 address of Join source range\n        :param pimv6_prefix_length: prefix length of Join source IPv6 address\n        :return: True on successful configuration\n        Example: tgn.config_pim_group_member(device_name='Device 1', ip_version = 'ipv4',\n                                             pim_group_type='STARG', enable_prune=True)\n        \"\"\"\n\n        if ip_version.lower() == 'ipv4':\n            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \\\n                Ipv4.find().PimV4Interface.find()\n            self.config_multicast_group(ip_version='ipv4', device_name=device_name,\n                                        protocol='pimv4',\n                                        group_name=group_name,\n                                        start_ip=kwargs.get('pimv4_join_src', '192.0.1.0'),\n                                        step='0.0.0.1',\n                                        prefix=kwargs.get('pimv4_prefix_length', 24))\n        else:\n            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \\\n                Ipv6.find().PimV6Interface.find()\n            self.config_multicast_group(ip_version='ipv6', device_name=pimDevice.Name,\n                                        protocol='pimv6',\n                                        group_name=group_name,\n                                        start_ip=kwargs.get('pimv6_join_src', '::2'),\n                                        step='::1',\n                                        prefix=kwargs.get('pimv6_prefix_length', 64))\n\n        return True\n\n    def modify_streamblock_params(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        Function NA for IXIA as these streamblock params are not applicable for IXIA\n\n        Allows user to modify Streamblock parameters\n        :param traffic_item_list: List of Traffic item for which modification is required\n        :param cfg_dict: params that requires to be modified\n            cfg_dict={'Allow_InvalidHeaders': False, 'enable_stream_generation': True, 'Enable_FcsErrorInsertion': False}\n            Allow_InvalidHeaders (DefaultValue=False)\n            Enable_FcsErrorInsertion (DefaultValue=False)\n            Insert_Fcs (DefaultValue=True)\n            enable_stream_generation (DefaultValue=True)\n            enable_highSpeed_analysis (DefaultValue=True)\n        :return: True if successful else raise Exception\n        \"\"\"\n        pass\n\n    def set_ipv4_traffic_destip(self, traffic_item, dest_ip):\n        \"\"\"\n        Allows user to insert/change modifier for IPv4 Dest IP or its value alone at runtime\n        :param traffic_item: List of stream names whose traffic class value to be changed\n        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list\n        :return: Returns True in case no exceptions\n        \"\"\"\n        self.log.info(\"Modifying IPv4 Destination Address\")\n        if type(traffic_item) is str:\n            traffic_item = [traffic_item]\n        for eachTi in traffic_item:\n            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)\n            if not trafficItem:\n                raise IxiaConfigException(\"stream not found\")\n            configElement = trafficItem.ConfigElement.find()[0]\n            ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')\n            try:\n                if type(dest_ip) is str:\n                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = \"singleValue\"\n                    ipv4Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip\n                elif type(dest_ip) is list:\n                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = \"valueList\"\n                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip\n                else:\n                    self.log.error(\"Invalid Destination IP address %\" % dest_ip)\n            except:\n                raise IxiaConfigException(\"IPv4 destination address modification failed\")\n        return True\n\n    def set_ipv6_traffic_destip(self, traffic_item, dest_ip):\n        \"\"\"\n        Allows user to insert/change modifier for IPv6 Dest IP or its value alone at runtime\n        :param traffic_item: List of stream names whose traffic class value to be changed\n        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list\n        :return: Returns True in case no exceptions\n        \"\"\"\n        self.log.info(\"Modifying IPv6 Destination Address\")\n        if type(traffic_item) is str:\n            traffic_item = [traffic_item]\n        for eachTi in traffic_item:\n            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)\n            if not trafficItem:\n                raise IxiaConfigException(\"stream not found\")\n            configElement = trafficItem.ConfigElement.find()[0]\n            ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')\n            try:\n                if type(dest_ip) is str:\n                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = \"singleValue\"\n                    ipv6Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip\n                elif type(dest_ip) is list:\n                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = \"valueList\"\n                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip\n                else:\n                    self.log.error(\"Invalid Destination IP address %\" % dest_ip)\n            except:\n                raise IxiaConfigException(\"IPv6 destination address modification failed\")\n        return True\n\n    def _update_field_values(self, field_entry, field_value):\n        \"\"\"\n        This API takes the field_entry from traffic item stack and\n        set values from field_value. This is a generic API to set/update protocol's stack field\n        :param field_entry: Stack field object from traffic item\n        :param field_value: value to be copied into stack field object.\n                           This handles values of singlevalue/increment/valueList\n        \"\"\"\n        try:\n            if isinstance(field_value, dict):\n                field_entry.Auto = False\n                if 'start' in field_value:\n                    field_entry.ValueType = 'increment'\n                    field_entry.StartValue = field_value['start']\n                if 'min' in field_value:\n                    field_entry.ValueType = 'repeatableRandomRange'\n                    field_entry.MinValue = field_value['min']\n                if 'max' in field_value:\n                    field_entry.MaxValue = field_value['max']\n                if 'seed' in field_value:\n                    field_entry.Seed = field_value['seed']\n                if 'step' in field_value:\n                    field_entry.StepValue = field_value['step']\n                else:\n                    field_entry.StepValue = 1\n                if 'count' in field_value:\n                    field_entry.CountValue = field_value['count']\n                else:\n                    field_entry.CountValue = 1\n                if 'type' in field_value:\n                    if field_value['type'] == 'random':\n                        field_entry.ValueType = 'nonRepeatableRandom'\n                        field_entry.RandomMask = 65535\n                    if field_value['type'] == 'randomBitMask':\n                        field_entry.ValueType = 'random'\n                        field_entry.RandomMask = 65535\n            elif isinstance(field_value, (str, int)):\n                # process single value\n                field_entry.Auto = False\n                field_entry.ValueType = 'singleValue'\n                field_entry.SingleValue = field_value\n            elif isinstance(field_value, list):\n                # process value list\n                field_entry.Auto = False\n                field_entry.ValueType = 'valueList'\n                field_entry.ValueList = field_value\n            result = True\n        except:\n            result = False\n        return result\n\n    def _config_udp_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update udp stack fields under traffic item.\n        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        if 'src_port_value' in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"UDP-Source-Port\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    udp_src_port = cfg_dict['src_port_value']\n                    result = self._update_field_values(fieldValue[index - 1], udp_src_port)\n        if \"dest_port_value\" in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"UDP-Dest-Port\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    udp_dest_port = cfg_dict['dest_port_value']\n                    result = self._update_field_values(fieldValue[index - 1], udp_dest_port)\n        if \"udp_header_len\" in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"UDP-Length\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    udp_hdr_len = cfg_dict['udp_header_len']\n                    result = self._update_field_values(fieldValue[index - 1], udp_hdr_len)\n        if \"udp_checksum\" in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"UDP-Checksum\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    udp_checksum = cfg_dict['udp_checksum']\n                    result = self._update_field_values(fieldValue[index - 1], udp_checksum)\n        return result\n\n    def _config_tcp_fields(self, cfg_dict, config_element):\n        \"\"\"\n        API to set/update tcp stack fields under traffic item.\n        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated\n        :param config_element: is the config_element object obtained from traffic item object\n        \"\"\"\n        tcp_ip_options = {'mss': 'maximumSegmentSize'}\n        if 'src_port_value' in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"TCP-Source-Port\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_src_port = cfg_dict['src_port_value']\n                    result = self._update_field_values(field_value[index - 1], tcp_src_port)\n        if \"dest_port_value\" in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"TCP-Dest-Port\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_dest_port = cfg_dict['dest_port_value']\n                    result = self._update_field_values(field_value[index - 1], tcp_dest_port)\n        if \"tcp_data_offset\" in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"Data Offset\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_dataoffset = cfg_dict['tcp_data_offset']\n                    result = self._update_field_values(field_value[index - 1], tcp_dataoffset)\n        if \"tcp_options\" in cfg_dict.keys():\n            try:\n                if cfg_dict['tcp_options']['option'] == 'mss':\n                    field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[\n                        cfg_dict['tcp_options']['option']] + '.kind'\n                    field_value_obj = config_element.Stack.find().Field.find(FieldTypeId=field_type_id)[\n                        cfg_dict['header_index'] - 1]\n                    if cfg_dict['tcp_options']['action'] == 'enable':\n                        field_value_obj.OptionalEnabled = True\n                        result = True\n                        if \"tcp_mss_data\" in cfg_dict.keys():\n                            field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[\n                                cfg_dict['tcp_options']['option']] + '.data'\n                            field_value = config_element.Stack.find().Field.find(FieldTypeId=field_type_id)\n                            for index in range(1, len(field_value) + 1):\n                                if index == cfg_dict['header_index']:\n                                    tcp_mss_value = cfg_dict['tcp_mss_data']\n                                    result = self._update_field_values(field_value[index - 1], tcp_mss_value)\n                    else:\n                        field_value_obj.OptionalEnabled = False\n                        result = True\n                else:\n                    self.log.warning('Please share proper TCP Option')\n                    result = False\n            except:\n                result = False\n                self.log.error('TCP option update failed')\n        if \"tcp_checksum\" in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"TCP-Checksum\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_data_checksum = cfg_dict['tcp_checksum']\n                    result = self._update_field_values(field_value[index - 1], tcp_data_checksum)\n        if \"tcp_control_bit\" in cfg_dict.keys():\n            for key, value in cfg_dict[\"tcp_control_bit\"].items():\n                if config_element.Stack.find().Field.find(DisplayName=key):\n                    field_value = config_element.Stack.find().Field.find(DisplayName=key)\n                    for index in range(1, len(field_value) + 1):\n                        if index == cfg_dict['header_index']:\n                            result = self._update_field_values(field_value[index - 1], value)\n                else:\n                    self.log.error(f'Invalid TCP Control Bit {key}')\n                    result = False\n        if \"tcp_ecn\" in cfg_dict.keys():\n            for key, value in cfg_dict[\"tcp_ecn\"].items():\n                if config_element.Stack.find().Field.find(DisplayName=key):\n                    field_value = config_element.Stack.find().Field.find(DisplayName=key)\n                    for index in range(1, len(field_value) + 1):\n                        if index == cfg_dict['header_index']:\n                            result = self._update_field_values(field_value[index - 1], value)\n                else:\n                    self.log.error(f'Invalid TCP Control Bit {key}')\n                    result = False\n        if 'tcp_window' in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"Window\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_window = cfg_dict['tcp_window']\n                    result = self._update_field_values(field_value[index - 1], tcp_window)\n        if 'tcp_urgent_pointer' in cfg_dict.keys():\n            field_value = config_element.Stack.find().Field.find(DisplayName=\"Urgent Pointer\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    tcp_urgent_pointer = cfg_dict['tcp_urgent_pointer']\n                    result = self._update_field_values(field_value[index - 1], tcp_urgent_pointer)\n        return result\n\n    def _config_mpls_fields(self, cfg_dict, configElement):\n        \"\"\"\n        Internal Method to Configure MPLS stack under traffic item\n        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated\n        :param configElement:  Traffic Item Config Element\n         \"\"\"\n        if 'mpls_ttl' in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"Time To Live\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    mpls_ttl = cfg_dict['mpls_ttl']\n                    result = self._update_field_values(fieldValue[index - 1], mpls_ttl)\n        if 'mpls_label_value' in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"Label Value\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    mpls_label_value = cfg_dict['mpls_label_value']\n                    result = self._update_field_values(fieldValue[index - 1], mpls_label_value)\n        if 'mpls_exp' in cfg_dict.keys():\n            fieldValue = configElement.Stack.find().Field.find(DisplayName=\"MPLS Exp\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    mpls_exp = cfg_dict['mpls_exp']\n                    result = self._update_field_values(fieldValue[index - 1], mpls_exp)\n        return result\n\n    def _config_ipv4_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update ipv4 stack fields under traffic item.\n        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        ip_options_dict = {'nop': 'nop', 'security': 'security.type', 'lsrr': 'lsrr.type', 'pointer': 'pointer',\n                           'route': 'routeData', 'ssrr': 'ssrr.type',\n                           'record': 'recordRoute.type', 'streamId': 'streamId.type', 'timestamp': 'timestamp.type',\n                           'endOptions': 'last', 'raValue': 'routerAlert.type'}\n        header_index = cfg_dict['header_index']\n\n        if 'ipv4_tot_len' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name=\"total_len\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_tot_len = cfg_dict['ipv4_tot_len']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_tot_len)\n        if 'ipv4_more_fragements' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name=\"^fragment_flag$\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_mf = cfg_dict['ipv4_more_fragements']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_mf)\n        if 'ipv4_fragement_offset' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name=\"fragment_offset\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_fo = cfg_dict['ipv4_fragement_offset']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_fo)\n        if 'ipv4_modify_version' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name='version')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_ver = cfg_dict['ipv4_modify_version']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_ver)\n        if 'ipv4_src_address' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name='source_ip')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_src_ip = cfg_dict['ipv4_src_address']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_src_ip)\n        if 'ipv4_dst_address' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV4\")\n            fieldValue = stack.find().Field.find(Name='dest_ip')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_dst_ip = cfg_dict['ipv4_dst_address']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_dst_ip)\n        if 'ipv4_header_checksum' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPv4\")\n            fieldValue = stack.find().Field.find(Name='^checksum$')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_checksum = cfg_dict['ipv4_header_checksum']\n                    result = self._update_field_values(fieldValue[index - 1], ipv4_checksum)\n        if 'ttl' in cfg_dict.keys():\n            stack = configElement.find().Stack.find(DisplayName=\"IPv4\")\n            field_value = stack.Field.find(Name='^ttl$')\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv4_ttl = cfg_dict['ttl']\n                    result = self._update_field_values(field_value[index - 1], ipv4_ttl)\n        if 'ipv4_protocol' in cfg_dict.keys():\n            header_index = cfg_dict['header_index']\n            stack = configElement.Stack.find(DisplayName=\"IPv4\")\n            field_value = stack.Field.find(Name='^protocol$')[header_index - 1]\n            if cfg_dict['ipv4_protocol'].upper() == 'AUTO':\n                field_value.Auto = True\n            else:\n                field_value.Auto = False\n                field_value.ValueType = 'singleValue'\n                field_value.FieldValue = cfg_dict['ipv4_protocol']\n            result = True\n        if 'ipv4_ip_options' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPv4\")\n            ip_option = cfg_dict['ipv4_ip_options']\n            try:\n                field_type_id = 'ipv4.header.options.nextOption.option.' + ip_options_dict[ip_option['option']]\n                ip_obj = stack.Field.find(FieldTypeId=field_type_id)[header_index - 1]\n                if ip_option['action'] == 'enable':\n                    ip_obj.OptionalEnabled = True\n                else:\n                    ip_obj.OptionalEnabled = False\n                result = True\n            except:\n                result = False\n                raise IxiaOperationException(\"IP options update failed\")\n        if 'ipv4_last_fragment' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName='IPv4')\n            field_value = stack.Field.find(Name='^last_fragment_flag$')[header_index - 1]\n            try:\n                field_value.ValueType = 'singleValue'\n                field_value.FieldValue = cfg_dict['ipv4_last_fragment']\n                result = True\n            except:\n                result = False\n                self.log.error(\"IPv4 Last Fragment update failed\")\n\n        return result\n\n    def _config_ipv6_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update ipv4 stack fields under traffic item.\n        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        ipv6NextHeader_dict = {\n            \"HOPOPT\": 0, \"ICMP\": 1, \"IGMP\": 2, \"GGP\": 3, \"IP\": 4, \"ST\": 5, \"TCP\": 6, \"CBT\": 7, \"EGP\": 8, \"IGP\": 9,\n            \"BBN-RCC-MON\": 10, \"NVP-II\": 11, \"PUP\": 12, \"ARGUS\": 13, \"EMCON\": 14, \"XNET\": 15, \"CHAOS\": 16, \"UDP\": 17,\n            \"MUX\": 18, \"DCN-MEAS\": 19, \"HMP\": 20, \"PRM\": 21, \"XNS-IDP\": 22, \"TRUNK-1\": 23, \"TRUNK-2\": 24, \"LEAF-1\": 25,\n            \"LEAF-2\": 26, \"RDP\": 27, \"IRTP\": 28, \"ISO-TP4\": 29, \"NETBLT\": 30, \"MFE-NSP\": 31, \"MERIT-INP\": 32, \"SEP\": 33,\n            \"3PC\": 34, \"IDPR\": 35, \"XTP\": 36, \"DDP\": 37, \"IDPR-CMTP\": 38, \"TP++\": 39, \"IL\": 40, \"IPv6\": 41, \"SDRP\": 42,\n            \"IPv6-Route\": 43, \"IPv6-Frag\": 44, \"IDRP\": 45, \"RSVP\": 46, \"GRE\": 47, \"MHRP\": 48, \"BNA\": 49, \"ESP\": 50,\n            \"AH\": 51, \"I-NLSP\": 52, \"SWIPE\": 53, \"NARP\": 54, \"MOBILE\": 55, \"TLSP\": 56, \"SKIP\": 57, \"IPv6-ICMP\": 58,\n            \"IPv6-NoNxt\": 59, \"IPv6-Opts\": 60, \"Any host internal protocol\": 61, \"CFTP\": 62, \"Any local network\": 63,\n            \"SAT-EXPAK\": 64, \"KRYPTOLAN\": 65, \"RVD\": 66, \"IPPC\": 67, \"Any distributed file system\": 68, \"SAT-MON\": 69,\n            \"VISA\": 70, \"IPCV\": 71, \"CPNX\": 72, \"CPHB\": 73, \"WSN\": 74, \"PVP\": 75, \"BR-SAT-MON\": 76, \"SUN-ND\": 77,\n            \"WB-MON\": 78, \"WB-EXPAK\": 79, \"ISO-IP\": 80, \"VMTP\": 81, \"SECURE-VMTP\": 82, \"VINES\": 83, \"TTP\": 84,\n            \"NSFNET-IGP\": 85, \"DGP\": 86, \"TCF\": 87, \"EIGRP\": 88, \"OSPFIGP\": 89, \"Sprite-RPC\": 90, \"LARP\": 91, \"MTP\": 92,\n            \"AX.25\": 93, \"IPIP\": 94, \"MICP\": 95, \"SCC-SP\": 96, \"ETHERIP\": 97, \"ENCAP\": 98, \"Any private encryption\": 99,\n            \"GMTP\": 100, \"IFMP\": 101, \"PNNI\": 102, \"PIM\": 103, \"ARIS\": 104, \"SCPS\": 105, \"QNX\": 106, \"A/N\": 107,\n            \"IPComp\": 108, \"SNP\": 109, \"Compaq-Peer\": 110, \"IPX-in-IP\": 111, \"VRRP\": 112, \"PGM\": 113,\n            \"Any 0-hop protocol\": 114, \"L2TP\": 115, \"DDX\": 116, \"IATP\": 117, \"STP\": 118, \"SRP\": 119, \"UTI\": 120,\n            \"SMP\": 121, \"SM\": 122, \"PTP\": 123, \"ISIS over IPv4\": 124, \"FIRE\": 125, \"CRTP\": 126, \"CRUDP\": 127,\n            \"SSCOPMCE\": 128, \"IPLT\": 129, \"SPS\": 130, \"PIPE\": 131, \"SCTP\": 132, \"FC\": 133, \"RSVP-E2E-IGNORE\": 134,\n            \"Mobility Header\": 135, \"UDPLite\": 136, \"MPLS-in-IP\": 137}\n        if 'ipv6_version' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"version\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_version = cfg_dict['ipv6_version']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_version)\n        if 'ipv6_traffic_class' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"trafficClass\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_traffic_class = cfg_dict['ipv6_traffic_class']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_traffic_class)\n        if 'ipv6_flow_label' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"flowLabel\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_flow_label = cfg_dict['ipv6_flow_label']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_flow_label)\n        if 'ipv6_payload_len' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"payloadLength\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_payload_len = cfg_dict['ipv6_payload_len']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_payload_len)\n        if 'ipv6_next_header' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"nextHeader\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    if cfg_dict['ipv6_next_header'] in ipv6NextHeader_dict:\n                        ipv6_next_header = ipv6NextHeader_dict[cfg_dict['ipv6_next_header']]\n                        result = self._update_field_values(fieldValue[index - 1], ipv6_next_header)\n        if 'ipv6_hop_limit' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name=\"hopLimit\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_hop_limit = cfg_dict['ipv6_hop_limit']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_hop_limit)\n        if 'ipv6_src_address' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name='source_ip')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_src_ip = cfg_dict['ipv6_src_address']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_src_ip)\n        if 'ipv6_dst_address' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName=\"IPV6\")\n            fieldValue = stack.find().Field.find(Name='dest_ip')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_dst_ip = cfg_dict['ipv6_dst_address']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_dst_ip)\n        return result\n\n    def _config_ipv6_routing_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update ipv6 routing header stack fields under traffic item.\n        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        header_index = cfg_dict['header_index']\n        if 'ipv6_routing_next_header' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Routing Header' + '$')\n            field_value = stack.Field.find(Name='next_header')[header_index - 1]\n            try:\n                if cfg_dict['ipv6_routing_next_header'].upper() == 'AUTO':\n                    field_value.Auto = True\n                else:\n                    field_value.Auto = False\n                    field_value.ValueType = 'singleValue'\n                    field_value.FieldValue = cfg_dict['ipv6_routing_next_header']\n            except:\n                self.log.info('IPv6 Routing Next header modification failed')\n\n        return True\n\n    def _config_ipv6_authentication_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update ipv6 authentication header stack fields under traffic item.\n        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        header_index = cfg_dict['header_index']\n        if 'ipv6_auth_next_header' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Authentication Header' + '$')\n            field_value = stack.Field.find(Name='next_header')[header_index - 1]\n            try:\n                if cfg_dict['ipv6_auth_next_header'].upper() == 'AUTO':\n                    field_value.Auto = True\n                else:\n                    field_value.Auto = False\n                    field_value.ValueType = 'singleValue'\n                    field_value.FieldValue = cfg_dict['ipv6_auth_next_header']\n            except:\n                self.log.info('IPv6 Authentication Next header modification failed')\n        return True\n\n    def _config_ipv6_fragment_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update ipv4 stack fields under traffic item.\n        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        header_index = cfg_dict['header_index']\n        if 'ipv6_fragment_offset' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')\n            fieldValue = stack.Field.find(Name='fragment_offset')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    ipv6_fragment_offset = cfg_dict['ipv6_fragment_offset']\n                    result = self._update_field_values(fieldValue[index - 1], ipv6_fragment_offset)\n        if 'ipv6_more_fragments' in cfg_dict.keys():\n            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')\n            field_value = stack.Field.find(Name='More Fragments')[header_index - 1]\n        try:\n            field_value.ValueType = 'singleValue'\n            field_value.FieldValue = cfg_dict['ipv6_more_fragments']\n        except:\n            self.log.error('IPv6 More Fragments field modification failed')\n        return True\n\n    def _config_igmp_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update igmp stack fields under traffic item.\n        :param cfg_dict: The igmp params and their respective values that\n                        needs to be set/updated.Ex : igmp_version ,igmp_type,igmp_unused,igmp_checksum,igmp_group_address\n        :param configElement: It is the configElement object obtained from traffic item object\n        \"\"\"\n        stack = configElement.Stack.find(DisplayName=\"IGMP\")\n        if cfg_dict['protocol_name'] == 'igmpv1':\n            stack = configElement.Stack.find(DisplayName=\"IGMPv1\")\n        if cfg_dict['protocol_name'] == 'igmpv2':\n            stack = configElement.Stack.find(DisplayName=\"IGMPv2\")\n        if cfg_dict['protocol_name'] == 'igmpv3q':\n            stack = configElement.Stack.find(DisplayName=\"IGMPv3 Membership Query\")\n        if cfg_dict['protocol_name'] == 'igmpv3r':\n            stack = configElement.Stack.find(DisplayName=\"IGMPv3 Membership Report\")\n\n        if 'igmp_version' in cfg_dict.keys():\n            fieldValue = stack.Field.find(Name=\"version1\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    igmp_version = cfg_dict['igmp_version']\n                    result = self._update_field_values(fieldValue[index - 1], igmp_version)\n        if 'igmp_type' in cfg_dict.keys():\n            fieldValue = stack.Field.find(Name=\"type1\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    igmp_type = cfg_dict['igmp_type']\n                    result = self._update_field_values(fieldValue[index - 1], igmp_type)\n        if 'igmp_unused' in cfg_dict.keys():\n            fieldValue = stack.Field.find(Name='unused')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    igmp_unused = cfg_dict['igmp_unused']\n                    result = self._update_field_values(fieldValue[index - 1], igmp_unused)\n        if 'igmp_checksum' in cfg_dict.keys():\n            fieldValue = stack.Field.find(Name='checksum')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    igmp_checksum = cfg_dict['igmp_checksum']\n                    result = self._update_field_values(fieldValue[index - 1], igmp_checksum)\n        if 'igmp_group_address' in cfg_dict.keys():\n            fieldValue = stack.Field.find(Name='group_address')\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    igmp_group_address = cfg_dict['igmp_group_address']\n                    result = self._update_field_values(fieldValue[index - 1], igmp_group_address)\n        return result\n\n    def _config_icmp_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update icmp stack fields under traffic item.\n        :param cfg_dict: The icmp params and their respective values that\n                        needs to be set/updated.Ex : icmp_message_type ,icmp_code_option\n                        protocol_name will be below icmp types\n        :param configElement: It is the configElement object obtained from traffic item object\n        \"\"\"\n        icmp_msg_dict = {3: 'Dest. Unreachable', 4: 'Src. Quench', 5: 'Redirect Message', 11: 'Time Exceeded',\n                         12: 'Parameter Problem', 0: 'Echo reply', 8: 'Echo message', 13: 'TimeStamp message',\n                         14: 'TimeStamp reply', 15: 'Information Request', 16: 'Information Reply'}\n        icmp_code_dict = {'dest_unreachable': 'Dest. Unreachable code options', 'src_quench': 'Src. Quench option',\n                          'info_request': 'Info Request option',\n                          'info_response': 'Info Response option', 'time_exceeded': 'Time Exceeded option',\n                          'redirect_msg': 'Redirect Message option'}\n        icmp_code_sub_dict = {'net_unreach': 'Net unreachable', 'host_unreach': 'Host unreachable',\n                              'protocol_unreach': 'Protocol unreachable',\n                              'port_unreach': 'Port unreachable', 'fragment_needed': 'Fragmentation needed and DF set',\n                              'source_fail': 'Source route failed',\n                              'ttl_exceeded': 'TTL exceeded in transit',\n                              'fragment_reassembly': 'Fragment reassembly time exceeded',\n                              'redirect_nw': 'Redirect datagrams for network',\n                              'redirect_host': 'Redirect datagrams for the Host',\n                              'redirect_tos_nw': 'Redirect datagrams for the TOS and network',\n                              'redirect_tos_host': 'Redirect datagrams for the TOS and host'}\n        unused_type_dict = {'unused_type3': 'opt1', 'unused_type4': 'opt2', 'unused_type11': 'opt3',\n                            'unused_next_field': 'unsd'}\n        header_index = cfg_dict['header_index']\n        if 'icmp_message_type' in cfg_dict.keys():\n            if cfg_dict['icmp_message_type'] in icmp_msg_dict:\n                icmp_msg = cfg_dict['icmp_message_type']\n                if (icmp_msg == 3 or icmp_msg == 4 or icmp_msg == 5 or icmp_msg == 11 or icmp_msg == 12):\n                    stack = configElement.Stack.find(StackTypeId=\"^icmpv1$\")\n                else:\n                    stack = configElement.Stack.find(StackTypeId=\"^icmpv2$\")\n                field_value = stack.Field.find(Name=\"msg_type\")[header_index - 1]\n                field_value.FieldValue = icmp_msg_dict[icmp_msg]\n                result = True\n        if 'icmp_code_options' in cfg_dict.keys():\n            if cfg_dict['icmp_code_options'] in icmp_code_dict:\n                stack = configElement.Stack.find(StackTypeId=\"^icmpv1$\")\n                field_value = stack.Field.find(DisplayName=icmp_code_dict[cfg_dict['icmp_code_options']])[header_index - 1]\n                field_value.ActiveFieldChoice = True\n                result = True\n        if 'icmp_code_sub_options' in cfg_dict.keys():\n            icmpSubOption = cfg_dict['icmp_code_sub_options']\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv1$\")\n            if icmpSubOption == 'net_unreach' or icmpSubOption == 'host_unreach' or icmpSubOption == 'protocol_unreach' or icmpSubOption == 'port_unreach' or icmpSubOption == 'fragment_needed' or icmpSubOption == 'source_fail':\n                field_value = stack.Field.find(DisplayName=icmp_code_dict['dest_unreachable'])[header_index - 1]\n            elif icmpSubOption == 'ttl_exceeded' or icmpSubOption == 'fragment_reassembly':\n                field_value = stack.Field.find(DisplayName=icmp_code_dict['time_exceeded'])[header_index - 1]\n            elif icmpSubOption == 'redirect_nw' or icmpSubOption == 'redirect_host' or icmpSubOption == 'redirect_tos_nw' or icmpSubOption == 'redirect_tos_host':\n                field_value = stack.Field.find(DisplayName=icmp_code_dict['redirect_msg'])[header_index - 1]\n            try:\n                field_value.ActiveFieldChoice = True\n                field_value.ValueType = 'singleValue'\n                field_value.FieldValue = icmp_code_sub_dict[icmpSubOption]\n                result = True\n            except Exception as err:\n                raise IxiaConfigException('ICMP Code options updation failed with {}'.format(err))\n        if 'icmp_code_value' in cfg_dict.keys():\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv2$\")\n            field_value = stack.Field.find(Name=\"Code\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    icmp_code = cfg_dict['icmp_code_value']\n                    result = self._update_field_values(field_value[index - 1], icmp_code)\n        if 'icmp_identifier' in cfg_dict.keys():\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv2$\")\n            field_value = stack.Field.find(Name=\"^id_fier$\")\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    icmp_identifier = cfg_dict['icmp_identifier']\n                    result = self._update_field_values(field_value[index - 1], icmp_identifier)\n        if 'icmp_unused_type' in cfg_dict.keys():\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv1$\")\n            field_value = stack.Field.find(Name='^' + unused_type_dict[cfg_dict['icmp_unused_type']] + '$')\n            field_value[header_index - 1].ActiveFieldChoice = True\n            if 'icmp_unused_code' in cfg_dict.keys():\n                for index in range(1, len(field_value) + 1):\n                    if index == cfg_dict['header_index']:\n                        icmp_unused_code = cfg_dict['icmp_unused_code']\n                        result = self._update_field_values(field_value[index - 1], icmp_unused_code)\n        return result\n\n    def _config_icmpv6_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update icmpv6 stack fields under traffic item.\n        :param cfg_dict: The icmp params and their respective values that\n                        needs to be set/updated.Ex : icmpv6_message_type ,icmpv6_code_option\n                        protocol_name will be below icmp types\n        :param configElement: It is the configElement object obtained from traffic item object\n        \"\"\"\n        icmpv6_msg_dict = {1: 'destinationUnreachableMessage.mesageType',2:'packetTooBigMessage.messageType',\n                           3: 'timeExceededMessage.messageType',4:'parameterProblemMessage.messageType',\n                           128: 'echoRequestMessage.messageType',129:'echoReplyMessage.messageType'}\n        icmpv6_code_dict = {'hop_limit':'Hop limit exceeded in transit','fragment_reassembly':'Fragment reassembly time exceeded',\n                            'erroneous_header':'Erroneous header field encountered',\n                            'unrecognized_header':'Unrecognized Next Header type encountered',\n                            'unrecognized_ipv6':'Unrecognized IPv6 option encountered','no_route':'No route to destination',\n                            'commun_prohibited':'Communication with destination administratively prohibited',\n                            'not_assigned':'Not assigned','add_unreachable':'Address unreachable',\n                            'port_unreachable':'Port unreachable'}\n        header_index = cfg_dict['header_index']\n\n        if 'icmpv6_message_type' in cfg_dict.keys():\n            if cfg_dict['icmpv6_message_type'] in icmpv6_msg_dict:\n                stack = configElement.Stack.find(StackTypeId=\"^icmpv6$\")\n                fieldTypeId = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[\n                    cfg_dict['icmpv6_message_type']]\n                field_value = stack.Field.find(FieldTypeId=fieldTypeId)[header_index - 1]\n                field_value.ActiveFieldChoice = True\n                result = True\n        if 'icmpv6_code_options' in cfg_dict.keys():\n            if 'icmpv6_message_type' in cfg_dict.keys():\n                stack = configElement.Stack.find(StackTypeId=\"^icmpv6$\")\n                if cfg_dict['icmpv6_code_options'] in icmpv6_code_dict:\n                    field_value = None\n                    if cfg_dict['icmpv6_message_type'] == 3:\n                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.timeExceededMessage.code')[header_index - 1]\n                    elif cfg_dict['icmpv6_message_type'] == 4:\n                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.parameterProblemMessage.code')[header_index - 1]\n                    elif cfg_dict['icmpv6_message_type'] == 1:\n                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.destinationUnreachableMessage.code')[header_index - 1]\n                    else:\n                        self.log.error('Please select valid message type to update code option')\n                    if field_value:\n                        try:\n                            field_value.FieldValue = icmpv6_code_dict[cfg_dict['icmpv6_code_options']]\n                            result = True\n                        except Exception as err:\n                            raise IxiaConfigException(\n                                'Invalid Code Type for given message type: exception raised {}'.format(err))\n                else:\n                    result = False\n                    self.log.error('Please share valid ICMPv6 code option')\n            else:\n                result = False\n                self.log.error('Please select message type to update code option')\n        if 'icmpv6_code' in cfg_dict.keys():\n            field_type_id = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[cfg_dict['icmpv6_message_type']]\n            field_type_id = field_type_id.replace('messageType', 'code')\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv6$\")\n            field_value = stack.Field.find(FieldTypeId=field_type_id)\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    icmpv6_code = cfg_dict['icmpv6_code']\n                    result = self._update_field_values(field_value[index - 1], icmpv6_code)\n        if 'icmpv6_mtu' in cfg_dict.keys():\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv6$\")\n            if cfg_dict['icmpv6_message_type'] == 2:\n                field_value = stack.Field.find(\n                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.packetTooBigMessage.maximumTransmissionUnit')\n                for index in range(1, len(field_value) + 1):\n                    if index == cfg_dict['header_index']:\n                        icmpv6_mtu = cfg_dict['icmpv6_mtu']\n                        result = self._update_field_values(field_value[index - 1], icmpv6_mtu)\n            else:\n                self.log.error('MTU value is only supported for Packet Too Big Message Type')\n        if 'icmpv6_identifier' in cfg_dict.keys():\n            stack = configElement.Stack.find(StackTypeId=\"^icmpv6$\")\n            if cfg_dict['icmpv6_message_type'] == 128:\n                field_value = stack.Field.find(\n                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoRequestMessage.identifier')\n                for index in range(1, len(field_value) + 1):\n                    if index == cfg_dict['header_index']:\n                        icmpv6_identifier = cfg_dict['icmpv6_identifier']\n                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)\n            elif cfg_dict['icmpv6_message_type'] == 129:\n                field_value = stack.Field.find(\n                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoReplyMessage.identifier')\n                for index in range(1, len(field_value) + 1):\n                    if index == cfg_dict['header_index']:\n                        icmpv6_identifier = cfg_dict['icmpv6_identifier']\n                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)\n            else:\n                self.log.error('Identifier value is only supported for Echo Request(128) or Echo Response(129) Message Types')\n        return result\n\n    def _config_vlan_fields(self, cfg_dict, configElement):\n        \"\"\"\n        API to set/update vlan stack fields under traffic item.\n        :param cfg_dict: takes the vlan params and their respective values that needs to be set/updated\n        :param configElement: is the configElement object obtained from traffic item object\n        \"\"\"\n        stack = configElement.Stack.find(DisplayName=\"VLAN\")\n        if 'vlan_id' in cfg_dict.keys():\n            fieldValue = stack.find().Field.find(Name=\"vlan_id\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    vlan_id = cfg_dict['vlan_id']\n                    result = self._update_field_values(fieldValue[index - 1], vlan_id)\n        if 'vlan_priority' in cfg_dict.keys():\n            fieldValue = stack.find().Field.find(Name=\"vlan_user_priority\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    vlan_priority = cfg_dict['vlan_priority']\n                    result = self._update_field_values(fieldValue[index - 1], vlan_priority)\n        if 'vlan_cfi' in cfg_dict.keys():\n            fieldValue = stack.find().Field.find(Name=\"vlan_cfi\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    vlan_cfi = cfg_dict['vlan_cfi']\n                    result = self._update_field_values(fieldValue[index - 1], vlan_cfi)\n        if 'vlan_protocol' in cfg_dict.keys():\n            fieldValue = stack.find().Field.find(Name=\"vlan_tag_type\")\n            for index in range(1, len(fieldValue) + 1):\n                if index == cfg_dict['header_index']:\n                    vlan_protocol_id = cfg_dict['vlan_protocol']\n                    result = self._update_field_values(fieldValue[index - 1], vlan_protocol_id)\n        return result\n\n    def _config_custom_fields(self, cfg_dict, config_element):\n        \"\"\"\n        API to set/update custom stack fields under traffic item.\n        :param cfg_dict: takes the custom params and their respective values that needs to be set/updated\n                         Ex:custom_length,custom_data\n        :param config_element: is the config element object obtained from traffic item object\n        \"\"\"\n        stack = config_element.Stack.find(DisplayName=\"Custom\")\n        if 'custom_length' in cfg_dict.keys():\n            field_value = stack.Field.find(Name='^' + 'Length' + '$')\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    custom_len = cfg_dict['custom_length']\n                    result = self._update_field_values(field_value[index - 1], custom_len)\n        if 'custom_data' in cfg_dict.keys():\n            field_value = stack.Field.find(Name='^' + 'Data' + '$')\n            for index in range(1, len(field_value) + 1):\n                if index == cfg_dict['header_index']:\n                    custom_data_value = cfg_dict['custom_data']\n                    result = self._update_field_values(field_value[index - 1], custom_data_value)\n        return result\n\n    def modify_packet_stream_header(self, cfg_dict, traffic_item_list=None):\n        \"\"\"\n        API to modify Traffic item protocol headers like TCP,UDP,IGMPv1,IGMPv2\n        :param cfg_dict: A dictionary containing header items whose value needs to modify\n        :param traffic_item_list: List of traffic items\n        :return True on success otherwise return False\n        Ex : modify_packet_stream_header(traffic_item_list=['T1'], cfg_dict={'protocol_name': 'udp','header_index':1,'src_port_value': 30,\n                                         'dest_port_value': 60}))\n        \"\"\"\n        self.log.info('Modifying traffic item header')\n        result = False\n        if type(traffic_item_list) != list:\n            log.info('Invalid traffic_items_list type. Please use list')\n        # \u2018header_index\u2019 by default need to consider it as 1.\n        if 'header_index' not in cfg_dict:\n            cfg_dict['header_index'] = 1\n        else:\n            cfg_dict['header_index'] = cfg_dict['header_index'] + 1\n        for trafficItemName in traffic_item_list:\n            trafficItemName = trafficItemName.replace('+', r'\\+').replace('*', r'\\*')\n            trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$')\n            if not trafficItemObj:\n                raise IxiaConfigException(\"Traffic item not found\")\n            for configElement in trafficItemObj.ConfigElement.find():\n                if cfg_dict[\"protocol_name\"] == 'udp':\n                    result = self._config_udp_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'tcp':\n                    result = self._config_tcp_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'mpls':\n                    result = self._config_mpls_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'ipv4':\n                    result = self._config_ipv4_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'ipv6':\n                    result = self._config_ipv6_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'custom':\n                    result = self._config_custom_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'igmp':\n                    result = self._config_igmp_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'vlan':\n                    result = self._config_vlan_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'icmp':\n                    result = self._config_icmp_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'icmpv6':\n                    result = self._config_icmpv6_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'ipv6Routing':\n                    result = self._config_ipv6_routing_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'ipv6Auth':\n                    result = self._config_ipv6_authentication_fields(cfg_dict, configElement)\n                elif cfg_dict[\"protocol_name\"] == 'ipv6Fragment':\n                    result = self._config_ipv6_fragment_fields(cfg_dict, configElement)\n        return result\n\n    def inject_traffic_error(self,traffic_item=None, crc_error=\"goodCrc\", disparity_error=False):\n        \"\"\"\n        API to inject CRC, disparity errors for traffic items\n\n        :param traffic_item: Name of traffic item on which to inject error\n        :param crc_error: To inject CRC error, Supported values - \"badCrc\" , \"goodCrc\"\n        :param disparity_error: To inject disparity error if True\n        :return True: On success\n\n        Examples: inject_traffic_error(traffic_item=[\"ipv4\"], crc_error=\"badCrc\")\n                  inject_traffic_error(traffic_item=[\"ipv4\"], crc_error=\"goodCrc\")\n                  inject_traffic_error(traffic_item=[\"ipv4\",\"ipv6\"], disparity_error=True)\n        \"\"\"\n        if traffic_item:\n            for eachTi in traffic_item:\n                if self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi):\n                    trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)\n                    trafficItemObj.ConfigElement.find().Crc = crc_error\n                    trafficItemObj.ConfigElement.find().EnableDisparityError = disparity_error\n                else:\n                    self.log.error(\"Traffic Item not found\")\n        else:\n            for eachTi in self.ixNetwork.Traffic.TrafficItem.find():\n                eachTi.ConfigElement.find().Crc = crc_error\n                eachTi.ConfigElement.find().EnableDisparityError = disparity_error\n        return True\n\n    def modify_ignore_link_status(self, status, port_list=None):\n        \"\"\"\n        Enable or disable ignore link status for a given set of ports. Not applicable to Ixia\n\n        :param port_list: (list) The port(s) to configure\n            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']\n        :param status: (str) enable or disable ignore link status\n            e.g. 'enable', 'disable'\n        :return: True on success, exception otherwise\n        \"\"\"\n        if status == 'enable':\n            status = True\n        if status == 'disable':\n            status = False\n        if port_list:\n            self.log.info(f'Modifying the ignore link status for the following ports: {port_list}')\n            for vport in self.ixNetwork.Vport.find():\n                if vport.AssignedTo.replace(\":\", \"/\") in port_list:\n                    vport.TransmitIgnoreLinkStatus = status\n        else:\n            self.log.info('Port list not specified - modifying the ignore link status on all ports...')\n            for port in self.ixNetwork.Vport.find():\n                port.TransmitIgnoreLinkStatus = status\n        return True\n\n    def create_dhcpv6_pd_host(self, host_router_id=None, cpe_router_id=None, source_mac=None, hosts_per_cpe=1):\n        \"\"\"\n        Configures dhcpv6 PD host and home gateway link between CPE and host.\n        Host gets IPv6 address from prefix delegated to CPE.\n\n        This API is\tNot applicable to ixia.\n\n        :param host_router_id: Mandatory parameter. Router ID of host emulated device on which command needs to be performed.\n        :param cpe_router_id: Mandatory parameter. Router ID of CPE emulated device on which command needs to be performed.\n        :param source_mac: source mac\n        :param hosts_per_cpe: host count per CPE.\n        :return: True on success\n        \"\"\"\n        pass\n\n    def add_device_wizard(self, port, protocols, new_config, **kwargs):\n        \"\"\"\n        API to create number of devices via wizard. Not applicable to Ixia.\n        :param port: port string\n        :param protocols: Protocols to be enabled eg: IGMP/MLD/PIM\n        :param new_config: True if you want to clear the config else False\n        :param kwargs: Optional arguments\n        :param l3_type: IPV4/IPV6/IPV4V6\n        :param count: Number of routers to create per port/VLAN.\n        :param count_block_per_port: Count block per port\n        :param count_per_block: Count per block\n        :param block_mode: Single device/Block of many devices\n        :param router_id: Router Id.\n        :param ipv6_router_id: IPv6 Router Id\n        :param duplicate_name_resolution: How duplicate device names are handled.\n        :param device_name: Template string for defining device names\n        :param block_index: Starting device block index.\n        :param Role: Role to assign to the devices (Host/Router)\n        # VLAN\n        :param vlan_count: VLANs per port\n        :param vlan_id: VLAN ID\n        :param vlan_id_step: VLAN ID step value\n        :param vlan_repeat_mode: How VLAN IDs are repeated.\n        :param vlan_priority: VLAN priority.\n        :param vlan_tpid: Tag protocol identifier.\n        # IPV4\n        :param ipv4_addr: IPv4 address.\n        :param ipv4_addr_step: IPv4 address step value.\n        :param ipv4_gateway: IPv4 gateway address.\n        :param ipv4_gateway_step: IPv4 gateway address step value.\n        :param ipv4_prefix_length: IPv4 address prefix length.\n        :param ipv4_tos: TOS value used in the IP header.\n        :param ipv4_tos_type: Formatting of the TOS value.\n        # IPV6\n        :param ipv6_addr: IPv6 address value\n        :param ipv6_addr_step: IPv6 address step value\n        :param ipv6_addr_type: Type of IPv6 address\n        :param ipv6_gateway: IPv6 gateway address\n        :param ipv6_gateway_step: IPv6 gateway address step\n        :param ipv6_prefix_length: IPv6 address prefix length\n        :param ipv6_traffic_class: Traffic Class\n        # IGMP\n        :param igmp_version: IGMP_V1/IGMP_V2/IGMP_V3.\n        :param delete_igmp_existing_group: YES/NO. Whether to delete the existing IGMP group in the system\n        :param igmp_dev_grp_mapping: Mapp b/w device and subscribed multicast group\n        :param igmp_start_group_addr: IPv4 multicast group address.\n        :param igmp_step_per_port: IPv4 multicast group step.\n        :param igmp_group_count: Number of multicast groups to subscribe to.\n        :param igmp_filter_mode: Mode for specifying filtered sources.\n        :param igmp_filter_sources: Explicit set of sources from which multicast group is interested\n        :param igmp_src_addr: Multicast source IPv4 address\n        :param igmp_src_step: Step for the multicast source address\n        :param igmp_src_prefix: Multicast source IPv4 prefix length\n        :param igmp_src_count: Number of multicast sources\n        # MLD\n        :param mld_version: MLD_V1/MLD_V2\n        :param delete_mld_existing_group: YES/NO. Whether to delete the existing MLD group in the system\n        :param mld_dev_grp_mapping: Mapp b/w device and subscribed multicast group\n        :param mld_group_count: Number of multicast groups to subscribe to.\n        :param mld_start_addr: IPv6 multicast group address.\n        :param mld_addr_step: IPv4 multicast group step.\n        :param mld_filter_mode: Mode for specifying filtered sources.\n        :param mld_filter_sources: Explicit set of sources from which multicast group is interested\n        :param mld_src_addr: Multicast source IPv6 address\n        :param mld_src_step: Step for the multicast source address\n        :param mld_src_prefix: Multicast source IPv6 prefix length\n        :param mld_src_count: Number of multicast sources\n        # PIM\n        :param pim_version: IP version to be used for communication with the neighbor.\n        :param pim_mode: Emulated router's PIM mode.\n        :param pim_dr_priority: Designated Router priority of this router.\n\n        Example:\n              add_device_wizard(port_list=['10.66.236.41/1/1', '10.66.236.41/1/2'],\n              protocols=['IGMP', 'MLD', 'PIM'], l3_type = 'IPV4V6', vlan_count = 250, vlan_id = 30,\n              igmp_version='IGMP_V3', igmp_group_count=20, igmp_filter_mode='INCLUDE', igmp_filter_sources = 'CUSTOM',\n              mld_version = 'MLD_V2', mld_group_count = 40, mld_filter_mode = 'INCLUDE', mld_filter_sources = 'CUSTOM',\n              pim_mode = 'SSM', pim_version = 'IPV6')\n        \"\"\"\n        pass\n\n    def set_invalid_l2_eth(self, traffic_items, cfg_dict):\n        \"\"\"\n        API used to configure invalid L2 ethernet headers for a given list of streams. Not applicable to Ixia.\n\n        :param traffic_items: A str of list of traffic items whose headers will be changed\n        :param cfg_dict: A config dictionary containing the header values to be changed\n        \"\"\"\n        pass\n\n    def modify_network_group_address_count(self,network_group=None, ip_type=None, address_count=1,**kwargs):\n        \"\"\"\n        This API is used for modifying the Network group address count\n        :param network_group:Network Group name to modify group address Count\n        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'\n        :param address_count: Group Address Count for IPv4/IPv6\n        :param kwargs: Optional arguments\n                        nested_network_group: If nested network group to be modified\n        :return: True on success otherwise raise exception\n        \"\"\"\n        nested_network_group = kwargs.get('nested_network_group',None)\n        if ip_type==None:\n            ip_type='ipv4'\n        self.log.info(\"Changing Group address count for Network Group\")\n        # Modify Group address count for Network Group\n        if network_group and nested_network_group:\n            if ip_type.lower()=='ipv4':\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\\\n                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()\n            else:\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\\\n                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()\n            if isinstance(address_count, dict):\n                cfg_dict = address_count\n                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))\n            elif isinstance(address_count, int):\n                networkObj.NumberOfAddressesAsy.Single(address_count)\n            elif isinstance(address_count, list):\n                networkObj.NumberOfAddressesAsy.ValueList(address_count)\n        elif network_group:\n            if ip_type.lower()=='ipv4':\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\\\n                    Ipv4PrefixPools.find()\n            else:\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\\\n                    Ipv6PrefixPools.find()\n            if isinstance(address_count, dict):\n                cfg_dict = address_count\n                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))\n            elif isinstance(address_count, int):\n                networkObj.NumberOfAddressesAsy.Single(address_count)\n            elif isinstance(address_count, list):\n                networkObj.NumberOfAddressesAsy.ValueList(address_count)\n        elif network_group == None:\n            for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                if ip_type.lower()=='ipv4':\n                    try:\n                        networkObj = networkGroup.Ipv4PrefixPools.find()\n                    except:\n                        self.log.warning(\"Network Group does not have IPv4 Block\")\n                else:\n                    try:\n                        networkObj = networkGroup.Ipv6PrefixPools.find()\n                    except:\n                        self.log.warning(\"Network Group does not have IPv6 Block\")\n                if networkObj:\n                    if isinstance(address_count, dict):\n                        cfg_dict = address_count\n                        networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),\n                                                                  step_value=cfg_dict.get('step', 1))\n                    elif isinstance(address_count, int):\n                        networkObj.NumberOfAddressesAsy.Single(address_count)\n                    elif isinstance(address_count, list):\n                        networkObj.NumberOfAddressesAsy.ValueList(address_count)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        self.log.info(\"Network Group address count added Successfully\")\n        return True\n\n    def modify_ldp_params(self, config_dict, device_name=None):\n        \"\"\"\n        This API is responsible for updating LDP parameters\n        :param config_dict: configuration details to get updated under LDP stack\n        :param device_name: Optional, device_name under which LDP device is configured.\n        :return: True on success otherwise raise exception\n        \"\"\"\n        if device_name == None:\n            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find().LdpBasicRouter.find()\n        else:\n            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').LdpBasicRouter.find()\n\n        if len(ldpObjs) == 0:\n            raise IxiaConfigException(\"No LDP devices found\")\n        if len(ldpObjs.LdpLeafRangeV4) > 0:\n            for ldpObj in ldpObjs:\n                try:\n                    if 'lsp_count_per_root' in config_dict:\n                        lspCountRootObj = ldpObj.LdpLeafRangeV4.LspCountPerRoot\n                        if isinstance(config_dict['lsp_count_per_root'], dict):\n                            cfg_dict = config_dict['lsp_count_per_root']\n                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),\n                                                      step_value=cfg_dict.get('step', 1))\n                        elif isinstance(config_dict['lsp_count_per_root'], int):\n                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])\n                        elif isinstance(config_dict['lsp_count_per_root'], list):\n                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])\n                    if 'lable_start' in config_dict:\n                        lblStartValObj = ldpObj.LdpLeafRangeV4.LabelValueStart\n                        if isinstance(config_dict['lable_start'], dict):\n                            cfg_dict = config_dict['lable_start']\n                            lblStartValObj.Increment(start_value=cfg_dict.get('start', 10001),\n                                                     step_value=cfg_dict.get('step', 1))\n                        elif isinstance(config_dict['lable_start'], int):\n                            lblStartValObj.Single(config_dict['lable_start'])\n                        elif isinstance(config_dict['lable_start'], list):\n                            lblStartValObj.ValueList(config_dict['lable_start'])\n                    if 'lable_step' in config_dict:\n                        lblStepValObj = ldpObj.LdpLeafRangeV4.LabelValueStep\n                        if isinstance(config_dict['lable_step'], dict):\n                            cfg_dict = config_dict['lable_step']\n                            lblStepValObj.Increment(start_value=cfg_dict.get('start', 1),\n                                                    step_value=cfg_dict.get('step', 1))\n                        elif isinstance(config_dict['lable_step'], int):\n                            lblStepValObj.Single(config_dict['lable_step'])\n                        elif isinstance(config_dict['lable_step'], list):\n                            lblStepValObj.ValueList(config_dict['lable_step'])\n                except:\n                    pass\n        if len(ldpObjs.LdpRootRangeV4) > 0:\n            for ldpObj in ldpObjs:\n                try:\n                    if 'lsp_count_per_root' in config_dict:\n                        lspCountRootObj = ldpObj.LdpRootRangeV4.LspCountPerRoot\n                        if isinstance(config_dict['lsp_count_per_root'], dict):\n                            cfg_dict = config_dict['lsp_count_per_root']\n                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),\n                                                      step_value=cfg_dict.get('step', 1))\n                        elif isinstance(config_dict['lsp_count_per_root'], int):\n                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])\n                        elif isinstance(config_dict['lsp_count_per_root'], list):\n                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])\n                except:\n                    pass\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def modify_bgpmVpn_sender(self, config_dict, device_name, ip_version=\"ipv4\", nested=False):\n        \"\"\"\n        This API is to update values from sender-side for given bgp mVPN device\n        :param config_dict: configuration details to get updated under bgp mVPN sender-side\n        :param device_name: Name of the device group\n        :param ip_version: supported values \"ipv4\" or \"ipv6\"\n        :param nested: True if device group is nested. Default False\n        :return: True on success otherwise raise exception\n        \"\"\"\n        if nested == True:\n            if ip_version == \"ipv4\":\n                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \\\n                    BgpMVpnSenderSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \\\n                        BgpMVpnSenderSitesIpv6.find()\n            else:\n                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv6 pools\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \\\n                    BgpMVpnSenderSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \\\n                        BgpMVpnSenderSitesIpv6.find()\n        else:\n            if ip_version == \"ipv4\":\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv6.find()\n            else:\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv6.find()\n\n        if len(networkObjs) == 0:\n            raise IxiaConfigException(\"No devices found to update BgpMVpnSenderSites\")\n        for senderSiteObj in networkObjs:\n            if 'group_address_count' in config_dict:\n                grpAddrCountObj = senderSiteObj.GroupAddressCount\n                if isinstance(config_dict['group_address_count'], dict):\n                    cfg_dict = config_dict['group_address_count']\n                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),\n                                              step_value=cfg_dict.get('step', 1))\n                elif isinstance(config_dict['group_address_count'], int):\n                    grpAddrCountObj.Single(config_dict['group_address_count'])\n                elif isinstance(config_dict['group_address_count'], list):\n                    grpAddrCountObj.ValueList(config_dict['group_address_count'])\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def modify_bgpmVpn_receiver(self, config_dict, device_name, ip_version=\"ipv4\", nested=False):\n        \"\"\"\n        This API is responsible to update values from receiver-side for given bgp mVPN device\n        :param config_dict: configuration details to get updated under bgp mVPN sender-side\n        :param device_name: Name of the device group\n        :param ip_version: supported values \"ipv4\" or \"ipv6\"\n        :param nested: True if device group is nested. Default False\n        :return: True on success otherwise raise exception\n        \"\"\"\n        if nested == True:\n            if ip_version == \"ipv4\":\n                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \\\n                    BgpMVpnReceiverSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \\\n                        BgpMVpnReceiverSitesIpv6.find()\n            else:\n                # Check if BgpMVpnReceiverSitesIpv6 exists under ipv4 pools\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \\\n                    BgpMVpnReceiverSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \\\n                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \\\n                        BgpMVpnReceiverSitesIpv6.find()\n        else:\n            if ip_version == \"ipv4\":\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()\n            else:\n                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()\n                if len(networkObjs) == 0:\n                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \\\n                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()\n        if len(networkObjs) == 0:\n            raise IxiaConfigException(\"No devices found to update BgpMVpnReceiverSites\")\n        for receiverSiteObj in networkObjs:\n            if 'group_address_count' in config_dict:\n                grpAddrCountObj = receiverSiteObj.GroupAddressCount\n                if isinstance(config_dict['group_address_count'], dict):\n                    cfg_dict = config_dict['group_address_count']\n                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),\n                                              step_value=cfg_dict.get('step', 1))\n                elif isinstance(config_dict['group_address_count'], int):\n                    grpAddrCountObj.Single(config_dict['group_address_count'])\n                elif isinstance(config_dict['group_address_count'], list):\n                    grpAddrCountObj.ValueList(config_dict['group_address_count'])\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def add_igmp_mld_group_member(self, device_name, protocol, group_name, **kwargs):\n        \"\"\"\n        API to configure igmp/mld group membership and source list on top of existing membership\n        :param device_name: Device name for which extra IGMP/MLD membership needs to be added\n        :param protocol: igmp or mld\n        :param group_name: Multicast Group Name required to configure as mld group membership\n        :param kwargs: Optional kwargs\n        :param deviceGroupMapping: mapping between device and subscribed multicast group (MANY_TO_MANY/ONE_TO_ONE/ROUND_ROBIN)\n        :param filterMode: mode for the associated multicast groups and sources (EXCLUE/INCLUDE)\n        :param SourceList: sources are list or range of addresses (TRUE/FALSE)\n        :param userDefinedSources: Controls the use of user-defined multicast sources (TRUE/FALSE)\n        :param source_ipv6: Start IPv6address list\n        :param valueType: 'range' or 'list'\n        :param addrIncr: Network address increment\n        :param networkCount: Number of networks\n        :param prefixLength: IPv6address prefix length\n        :return: True on successful configuration\n        Ex: tgn.add_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1'),\n        user_defined_sources=True, device_group_mapping='MANY_TO_MANY', filter_mode='INCLUDE', source_ip='1.0.0.11',\n        addr_increment=1, network_count=10, prefix_length=24, source_list=False)\n        \"\"\"\n        result = False\n        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)) == 0:\n            raise IxiaConfigException(\"No device found with give name\", device_name)\n        if protocol.lower() not in ['igmp', 'mld']:\n            raise IxiaConfigException(\"Invalid protocol specified, only igmp and mld are allowed!\")\n        if 'filterMode' in kwargs:\n            if kwargs.get('filterMode').lower() == \"include\":\n                source_mode = 'include'\n            elif kwargs.get('filterMode').lower() == 'exclude':\n                source_mode = 'exclude'\n\n        source_list = kwargs.get('source_list', False)\n        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)\n        if protocol.lower() == 'igmp':\n            self.log.info(\"Configuring IGMP Group Member '{}' on '{}'\".format(group_name, device_name))\n            sourceIP = kwargs.get('source_ip', '192.0.1.0')\n            valueType = kwargs.get('value_type', 'range')\n            addrIncr = kwargs.get('addr_increment', '0.0.0.1')\n            networkCount = kwargs.get('network_count', 1)\n            prefixLength = kwargs.get('prefix_length', 32)\n            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)\n            if len(igmpObj) == 0:\n                raise IxiaConfigException(\"Invalid igmp group name specified\")\n            if 'filterMode' in kwargs:\n                srcModeObj = igmpObj.IgmpMcastIPv4GroupList.SourceMode\n                srcModeObj.Single(source_mode)\n            igmpObj.IgmpMcastIPv4GroupList.Active.Single(True)\n            if source_list == True:\n                result = self.change_igmp_source_list(device_list=[device_name], igmp_source_list=sourceIP)\n            elif source_list == False:\n                try:\n                    igmpObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Increment(\n                        start_value = sourceIP, step_value = addrIncr)\n                except:\n                    result = False\n            if result == False:\n                raise IxiaConfigException(\"IGMP source address updation failed\")\n        elif protocol.lower() == 'mld':\n            sourceIP = kwargs.get('source_ipv6', '2000::1')\n            valueType = kwargs.get('value_type', 'range')\n            addrIncr = kwargs.get('addr_increment', '::1')\n            networkCount = kwargs.get('network_count', 1)\n            prefixLength = kwargs.get('prefix_length', 128)\n            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)\n            if len(mldObj) == 0:\n                raise IxiaConfigException(\"Invalid mld group name specified\")\n            if 'filterMode' in kwargs:\n                srcModeObj = mldObj.MldMcastIPv6GroupList.SourceMode\n                srcModeObj.Single(source_mode)\n            mldObj.MldMcastIPv6GroupList.Active.Single(True)\n            if source_list == True:\n                result = self.change_mld_source_list(device_list=[device_name], mld_source_list=sourceIP)\n            elif source_list == False:\n                try:\n                    mldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Increment(\n                        start_value = sourceIP, step_value = addrIncr)\n                except:\n                    result = False\n            if result == False:\n                raise IxiaConfigException(\"MLD source address updation failed\")\n        return True\n\n    def delete_igmp_mld_group_member(self, device_name, protocol, group_name):\n        \"\"\"\n        Allows user to Delete IGMP/MLD Group membership\n        :param device_name: Device name for which IGMP/MLD membership needs to be deleted\n        :param protocol: 'igmp' or 'mld'\n        :param group_name: Mcast group name for which membership needs to be deleted\n        :return: True on Success\n        Example: tgn.delete_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1')\n        \"\"\"\n        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')) == 0:\n            raise IxiaConfigException(\"No device found with give name\", device_name)\n        if protocol.lower() not in ['igmp', 'mld']:\n            raise IxiaConfigException(\"Invalid protocol specified, only igmp and mld are allowed!\")\n\n        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)\n        if protocol.lower() == 'igmp':\n            self.log.info(\"Deleting IGMP Group Member '{}' on '{}'\".format(group_name, device_name))\n            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)\n            if len(igmpObj) == 0:\n                raise IxiaConfigException(\"Invalid igmp group name specified\")\n            igmpObj.IgmpMcastIPv4GroupList.Active.Single(False)\n        elif protocol.lower() == 'mld':\n            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name='^' + group_name + '$')\n            if len(mldObj) == 0:\n                raise IxiaConfigException(\"Invalid mld group name specified\")\n            mldObj.MldMcastIPv6GroupList.Active.Single(False)\n\n    def start_stop_link_fault(self, port, faultmode='LOCAL', action=True):\n        \"\"\"\n        Insert(stop/start) LOCAL/REMOTE Link Fault.\n\n        :param port: port name or port handle or\n                     interface name from Json file.\n        :param faultmode: CHOICES LOCAL/REMOTE link fault.\n        :param action: CHOICES True(start link fault)/False(Stop link fault)\n        :return True\n        \"\"\"\n        cardTypeList = ['atlasFourHundredGigLan', 'atm', 'ethernet', 'ethernetImpairment', 'ethernetvm',\n                        'fc', 'fortyGigLan', 'hundredGigLan', 'krakenFourHundredGigLan', 'novusHundredGigLan',\n                        'novusTenGigLan', 'pos', 'tenFortyHundredGigLan', 'tenGigLan', 'tenGigWan',\n                        'aresOneFourHundredGigLan']\n        cardType = self.ixNetwork.Vport.find(Name=port).Type\n        vport = self.ixNetwork.Vport.find(Name=port)\n        if cardType in cardTypeList:\n            cardType = cardType[0].upper() + cardType[1:]\n\n        cardObj = eval('vport.L1Config.' + cardType)\n\n        if 'TypeAOrderedSets' not in dir(cardObj) or 'TypeBOrderedSets' not in dir(cardObj) or 'StartErrorInsertion' in dir(cardObj):\n            self.log.error('card is Not supported for error insertion')\n            return False\n\n        if faultmode == \"LOCAL\":\n            if 'TypeAOrderedSets' in dir(cardObj):\n                cardObj.TypeAOrderedSets = \"localFault\"\n            if 'TypeBOrderedSets' in dir(cardObj):\n                cardObj.TypeBOrderedSets = \"localFault\"\n            if 'StartErrorInsertion' in dir(cardObj):\n                if action == True:\n                    cardObj.StartErrorInsertion = True\n                else:\n                    cardObj.StartErrorInsertion = False\n            return True\n        elif faultmode == \"REMOTE\":\n            if 'TypeAOrderedSets' in dir(cardObj):\n                cardObj.TypeAOrderedSets = \"remoteFault\"\n            if 'TypeBOrderedSets' in dir(cardObj):\n                cardObj.TypeBOrderedSets = \"remoteFault\"\n            if 'StartErrorInsertion' in dir(cardObj):\n                if action == True:\n                    cardObj.StartErrorInsertion = True\n                else:\n                    cardObj.StartErrorInsertion = False\n            return True\n        return False\n\n    def set_invalid_netio(self, traffic_items, cfg_dict):\n        \"\"\"\n        API used to configure invalid NetIO headers for a given list of streams. This API is not applicable to ixia\n\n        :param traffic_items: A str of list of traffic items whose headers will be changed\n        :param cfg_dict: A config dictionary containing the header values to be changed\n        \"\"\"\n        pass\n\n    def config_traffic_options(self, **kwargs):\n        \"\"\"\n        API to configure Global options related to Traffic generation available in Settings. This API is not applicable to ixia\n        :param kwargs: Spirent specific Traffic Option parameters\n        delete_inactive_streams_from_mem: to manage inactive stream block memory usage on test modules (True/False)\n        enable_global_analyzer_preload: Indicate if all streamblocks analyzer preload flag will be set to (True/False)\n        enable_txqueue_full_retrymode: Determines if transmit is retried when the queue is full on Virtual ports (True/False)\n        exclude_ethernet_fcs: Exclude the last 4 bytes of the packet from pcap file when generating stream block (True/False)\n        smoothen_random_length: Indicate if smoothen random length distribution per port is generated (True/False)\n        traffic_start_interval: Delay in units of 64 microseconds between start of port transmissions\n        traffic_start_interval_unit: The traffic start interval unit (UNITOF64US/UNITOF500NS)\n        traffic_start_mode: Controls how the ports start sending traffic (ASYNCHRONOUS/SYNCHRONOUS)\n        traffic_streamid_startindex: The first StreamID start index to use (1-65535)\n        unique_randomlength_seed_perport: Indicate if unique random seeds are created on all ports (True/False)\n        :return: True if successful else raise Exception\n        :Example: tgn.config_traffic_options(DeleteInactiveStreamsFromMemory = delete_inactive_streams_from_mem, TrafficStartInterval = traffic_start_interval)\n        \"\"\"\n        pass\n\n    def create_subs_dynamic_view(self, ip_type=\"ipv4\"):\n        \"\"\"\n        Create and subscribe to a dynamic view (Similar to creating user defined views on GUI). This API is not applicable to ixia\n        :param ip_type: To select IPv4/IPv6 src/dest address while creating the view.\n\n        :return: None\n        \"\"\"\n        pass\n\n    def unsubsribe_dynamic_view(self, drv):\n        \"\"\"\n        Unsubscribe from previously created dynamic view. This API is not applicable to ixia\n        (User-defined view on GUI).\n        :param drv: Dynamic result view object created during subscribe.\n        :return: None\n        \"\"\"\n        pass\n\n    def port_laser_on_off(self, ports=None, operation=\"on\"):\n        \"\"\"\n        API to Turn Laser On/Off of given port\n\n        :param ports: List of name of ports\n        :param operation: operation to be set on port \"on\"/\"off\"\n\n        Examples: port_laser_on_off(ports=[\"Ethernet - 001\"],operation=\"off\")\n                  port_laser_on_off(ports=[\"Ethernet - 001\", \"Ethernet - 002\"],operation=\"on\")\n        \"\"\"\n        res = \"\"\n        if ports is None:\n            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]\n\n        for vport_name in ports:\n            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')\n            if vport:\n                portType = vport.Type\n                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)\n                portObj = getattr(vport.L1Config, capitalizedCardType)\n                res = res + f\"{vport_name} Laser: {operation}\\n\"\n                if operation.lower() == \"off\":\n                    try:\n                        portObj.LaserOn = False\n                        self.log.info(res)\n                    except:\n                        self.log.info(\n                            'card type not supported to perform laser operation for port : {}'.format(vport_name))\n                elif operation.lower() == \"on\":\n                    try:\n                        portObj.LaserOn = True\n                        self.log.info(res)\n                    except:\n                        self.log.info(\n                            'card type not supported to perform laser operation for port : {}'.format(vport_name))\n            else:\n                self.log.info('port : {} not available in the config'.format(vport_name))\n\n    def port_insert_local_fault(self, ports=None, source_value='localFault', dest_value='remoteFault', **kwargs):\n        \"\"\"\n        API to Insert L1 local/remote fauls and then initiate their transmission\n\n        :param ports: List of name of ports\n        :param source_value: str 'localFault'/'remoteFault'\n        :param dest_value: str 'localFault'/'remoteFault'\n        :param kwargs:\n                    send_sets_mode: str \"typeAOnly\"/\"typeBOnly\"\n                    wait_interval : sleep time default 0\n                    repetition : Number of time opertaion to be repeated Ex : 5\n\n\n        Examples: port_insert_local_fault(ports=[\"Ethernet - 001\"], source_value='localFault', dest_value='remoteFault',\n                                           send_sets_mode=\"typeAOnly\")\n                   port_insert_local_fault(ports=[\"Ethernet - 001\"], source_value='remoteFault', dest_value='localFault',\n                                            send_sets_mode=\"typeBOnly\")\n                  port_insert_local_fault(ports=[\"Ethernet - 001\"], source_value='remoteFault', dest_value='localFault',\n                                            send_sets_mode=\"alternate\", wait_interval = 5 ,  repetition = 3)\n        \"\"\"\n        send_sets_mode = kwargs.get(\"send_sets_mode\")\n        wait_interval = kwargs.get(\"wait_interval\", 0)\n        repetition = kwargs.get(\"repetition\", 1)\n\n        if ports is None:\n            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]\n\n        for vport_name in ports:\n            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')\n            if vport:\n                portType = vport.Type\n                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)\n                vp = getattr(vport.L1Config, capitalizedCardType)\n\n                while repetition != 0:\n                    try:\n                        # localFault | remoteFault\n                        vp.TypeAOrderedSets = source_value\n                        vp.TypeBOrderedSets = dest_value\n\n                        # alternate | typeAOnly | typeBOnly\n                        vp.SendSetsMode = send_sets_mode\n\n                        vp.StartErrorInsertion = True\n                        self.log.info('Local Faults applied for port : {}'.format(vport_name))\n                    except:\n                        self.log.info(\n                            'card type not supported to perform laser operation for port : {}'.format(vport_name))\n                    time.sleep(wait_interval)\n                    repetition -= 1\n            else:\n                self.log.info('port : {} not available in the config'.format(vport_name))\n\n    def port_clock_source_faults(self, ports=None, loopback_mode=\"none\", **kwargs):\n        \"\"\"\n        Inserting clock faults bases on loopback modes\n\n        :param ports: List of name of ports\n        :param loopback_mode: Str loopback mode to be set Ex : \"none\"/\"lineLoopback\"/\"internalLoopback\"\n        :param kwargs:\n                    wait_interval : (int) sleep time default 0\n                    repetition : (int) Number of time opertaion to be repeated Ex : 5\n\n        Examples: port_clock_source_faults(ports=[\"Ethernet - 001\"], loopback_mode= \"internalLoopback\", wait_interval=5, repetition=2)\n                  port_clock_source_faults(ports=[\"Ethernet - 001\"], loopback_mode=\"lineLoopback\" )\n        \"\"\"\n\n        wait_interval = kwargs.get(\"wait_interval\", 1)\n        repetition = kwargs.get(\"repetition\", 1)\n\n        if ports is None:\n            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]\n\n        for vport_name in ports:\n            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')\n            if vport:\n                portType = vport.Type\n                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)\n                portObj = getattr(vport.L1Config, capitalizedCardType)\n\n                while repetition != 0:\n                    portObj.LoopbackMode = loopback_mode\n                    self.log.info(f\"Loopback mode: {portObj.LoopbackMode}\")\n                    time.sleep(wait_interval)\n                    repetition -= 1\n            else:\n                self.log.info('port : {} not available in the config'.format(vport_name))\n\n    def port_send_undersize_packets(self, traffic_item_name=None, **kwargs):\n        \"\"\"\n        Sending frames with modified attributes for frame size, crc\n        :param traffic_item_name: str Name of the traffic item Ex: \"Traffic_ipv4\"\n        :param kwargs:\n                undersize: undersize frame to be set or not True/False\n                desired_frame_size : Frame size to be set on traffic item\n                runt: True/False\n                crc : Treu/False\n                wait_interval : (int) sleep time default 0\n                repetition : (int) Number of times operation to be repeated Ex : 5\n\n        Examples: port_send_undersize_packets(traffic_item_name=[\"Traffic_item_1\"], crc=True, desired_frame_size=128)\n                  port_send_undersize_packets(traffic_item_name=[Traffic_item_1], runt=True, desired_frame_size=45,wait_interval = 5, repetition = 2 )\n        \"\"\"\n        wait_interval = kwargs.get(\"wait_interval\", 0)\n        repetition = kwargs.get(\"repetition\", 1)\n\n        if traffic_item_name is None:\n            traffic_item_name = self.get_traffic_items()\n\n        undersize = kwargs.get(\"undersize\", False)\n        runt = kwargs.get(\"runt\", False)\n        crc = kwargs.get(\"crc\", False)\n        desired_frame_size = kwargs.get(\"desired_frame_size\", \"128\")\n\n        for traffic_item in traffic_item_name:\n            # Get the config element:\n            configElement = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$').ConfigElement.find()[\n                0]\n            while repetition != 0:\n                if configElement:\n                    if undersize:\n                        configElement.FrameSize.FixedSize = desired_frame_size\n\n                    if runt or crc:\n                        configElement.FrameSize.FixedSize = desired_frame_size\n                        configElement.Crc = 'goodCrc'\n\n                    self.log.info('Attributes modified in traffic item {}'.format(traffic_item))\n                    self.regenerate_traffic()\n                else:\n                    self.log.info('traffic item {} not available in the config / not supported'.format(traffic_item))\n                time.sleep(wait_interval)\n                repetition -= 1\n\n    def enable_network_group(self, network_group_list, enable=True, **kwargs):\n        \"\"\"\n        Enable/Disable NetworkGroup(s) or specific routes under a DeviceGroup/NetworkGroup.\n\n        :param network_group_list:\n            - If mode == 'group': list of NetworkGroup names to enable/disable\n            - If mode == 'routes': list of route indexes (e.g. [1, 2, 3])\n        :param enable: True or False\n        :param kwargs:\n            -  mode: 'group' or 'routes'\n            - device_group_name: required if mode == 'routes'\n            - network_group_name: alternative if mode == 'routes'\n        Examples:\n        enable_network_group(network_group_list=['Network Group 2','Network Group 12'])\n        enable_network_group(network_group_list=[1, 3, 5], mode='routes', device_group_name='NG_PEER_1_IPv6')\n        enable_network_group(network_group_list=[1, 3, 10], enable= False, mode='routes', network_group_name='Network Group 11')\n        \"\"\"\n        self.log.debug(\"Enable/Disable NetworkGroups by names or route indexes\")\n        mode = kwargs.get('mode','group')\n        device_group_name = kwargs.get('device_group_name')\n        network_group_name = kwargs.get('network_group_name')\n\n        if enable:\n            enable = 'true'\n        if not enable:\n            enable = 'false'\n\n        try:\n            if mode == 'group':\n                if not network_group_list:\n                    raise Exception(\"No NetworkGroup names provided for mode='group'\")\n                for network_group in network_group_list:\n                    if not isinstance(network_group, str):\n                        raise Exception(f\"Expected string name in network_group_list, got '{network_group}' of type {type(network_group)}\")\n\n                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + network_group + '$')\n                    if not network_obj:\n                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + network_group + '$')\n                    if not network_obj:\n                        raise Exception(f\"NetworkGroup '{network_group}' not found.\")\n                    network_obj.Enabled.Single(enable)\n                    self.log.info(f\"{'Enabled' if enable == 'true' else 'Disabled'} NetworkGroup '{network_group}'\")\n                self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                return True\n\n            elif mode == 'routes':\n                if not network_group_list:\n                    raise Exception(\"No route indexes provided for mode='routes'\")\n                if not device_group_name and not network_group_name:\n                    raise Exception(\"Must provide either 'device_group_name' or 'network_group_name' for mode='routes'\")\n\n                if device_group_name:\n                    target_device_group = None\n                    for topology in self.ixNetwork.Topology.find():\n                        device_groups = topology.DeviceGroup.find(Name='^' + device_group_name + '$')\n                        if device_groups:\n                            target_device_group = device_groups\n                            break\n                        nested_device_groups = topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(\n                            Name='^' + device_group_name + '$')\n                        if nested_device_groups:\n                            target_device_group = nested_device_groups\n                            break\n                    if not target_device_group:\n                        raise Exception(f\"DeviceGroup '{device_group_name}' not found.\")\n\n                    for network_group_obj in target_device_group.NetworkGroup.find():\n                        total = network_group_obj.Multiplier\n                        values = list(network_group_obj.Enabled.Values or ['false'] * total)\n                        for i in network_group_list:\n                            if 1 <= i <= total:\n                                values[i - 1] = enable\n                            else:\n                                raise Exception(f\"Index {i} out of range for NetworkGroup '{network_group_obj.Name}' (1-{total})\")\n                        network_group_obj.Enabled.ValueList(values)\n                        self.log.info(f\"Set Enabled={enable} for indexes {network_group_list} in NetworkGroup '{network_group_obj.Name}' \"\n                                      f\"under DeviceGroup '{device_group_name}'\")\n                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                    return True\n\n                elif network_group_name:\n                    network_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + network_group_name + '$')\n                    if not network_objs:\n                        network_objs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + network_group_name + '$')\n                    if not network_objs:\n                        raise Exception(f\"NetworkGroup '{network_group_name}' not found.\")\n\n                    for network_obj in network_objs:\n                        total = network_obj.Multiplier\n                        values = list(network_obj.Enabled.Values or ['false'] * total)\n                        for i in network_group_list:\n                            if 1 <= i <= total:\n                                values[i - 1] = enable\n                            else:\n                                raise Exception(f\"Index {i} out of range for NetworkGroup '{network_group_name}' (1-{total})\")\n                        network_obj.Enabled.ValueList(values)\n                        self.log.info(f\"Set Enabled={enable} for indexes {network_group_list} in NetworkGroup '{network_group_name}'\")\n                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                    return True\n            else:\n                raise Exception(f\"Invalid mode: {mode}. Expected 'group' or 'routes'.\")\n        except Exception as err:\n            raise Exception(f\"Failed to enable/disable: {err}\")\n\n    def set_bgp_vrf_stack_multiplier(self, stack_count, device_name, ip_type = \"ipv4\", **kwargs):\n        \"\"\"\n        Set device count\n        :param stack_count: Stack Multiplier count Should be >=1\n        :param device_name: List of Device Group Name\n        :param ip_type: String demonstrating the IP version\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                nested_device: For IXIA Device name if device count of nested DG to be set\n                                And for nested device device_name param in mandatory\n        :return: True if successful\n                raise exception if router id not found in Ixia\n\n        :Example:\n                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1')\n                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')\n       \"\"\"\n        nested_device = kwargs.get('nested_device')\n        if stack_count >= 1:\n            if nested_device is None:\n                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')\n                if deviceObj:\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count\n                        except:\n                            raise IxiaConfigException(\"Changing the element in a started Protocol is not permitted \")\n                    if ip_type.lower() == \"ipv6\":\n                        try:\n                            deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count\n                        except:\n                            raise IxiaConfigException(\"Changing the element in a started Protocol is not permitted \")\n                else:\n                    raise IxiaConfigException(\"Device Group (%s) Not found in the config' % device_name\")\n            if nested_device:\n                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                if deviceObj:\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            deviceObj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count\n                        except:\n                            raise IxiaConfigException(\"Changing the element in a started Protocol is not permitted \")\n                    if ip_type.lower() == \"ipv6\":\n                        try:\n                            deviceObj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count\n                        except:\n                            raise IxiaConfigException(\"Changing the element in a started Protocol is not permitted \")\n                else:\n                    raise IxiaConfigException(\"Device Group (%s) Not found in the config' % nested_device\")\n        else:\n            raise CafyException.InvalidValueError('Device count (%s) has to be greater than or equal to 1' % stack_count)\n        return True\n\n    def set_isis_sr_mpls(self, device_list=None, active='True'):\n        \"\"\"\n        Setting ISIS SR MPLS\n\n        :param device_list: list of device e.g. [\"Device_Group_1\"]\n        :param active: operation to be set for SR MPLS Ex : 'True'/'False'\n        :return: True on success else raises exception\n\n        :Example: set_isis_sr_mpls(device_list=[\"Device_Group_1\"], operation='True')\n        \"\"\"\n        if device_list is None:\n            device_list = self.get_device_names()\n        self.log.info('Setting SR MPLS')\n        for device in device_list:\n            device = device.replace('+', r'\\+').replace('*', r'\\*')\n            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n            if deviceObj.IsisL3Router.find():\n                try:\n                    deviceObj.IsisL3Router.find().EnableSR = active\n                except:\n                    self.log.info('Could not set SR MPLS operation on device : {}'.format(device))\n            else:\n                self.log.info('Device/Protocol not avalible : {} '.format(device))\n        return True\n\n    def set_isis_sid_label(self, network_group_list, ip_type=\"ipv4\", active='True', **kwargs):\n        \"\"\"\n        Enable/Disable the SID/Index/Label in ISIS Network Group\n\n        :param network_group_list: list of device e.g. [\"Network_Group_1\"]\n        :param ip_type: IP type  Ex : \"ipv4\"/\"ipv6\"\n        :param active: operation to be set for SR MPLS Ex : 'True'/'False'\n        :param kwargs :\n                        devices: List of device group names\n                        address_list: List of start Address of Network Group\n\n        :return: True on success else raises exception\n\n        :Example: set_isis_sid_label(network_group_list=[\"Network_Group_1\"], active='True')\n                  set_isis_sid_label(network_group_list=[\"Network_Group_v6\"], ip_type = \"ipv6\", active='False')\n                  set_isis_sid_label(network_group_list=[\"Network Group 1\"], ip_type = \"ipv4\", active='True' ,devices=[\"R1-main\"], address_list = [\"131.0.1.1\"])\n        \"\"\"\n        self.log.info('Setting ISIS SID/Index/Label ')\n        devices = kwargs.get(\"devices\", None)\n        address_list = kwargs.get(\"address_list\", None)\n        isis_prefix_sid_active = kwargs.get('isis_prefix_sid_active', True)\n\n        if devices and address_list:\n            for device in devices:\n                for ngroup in network_group_list:\n                    for startaddress in address_list:\n                        if ip_type.lower() == \"ipv4\":\n                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv4PrefixPools.find()\n                            address = networkObj.NetworkAddress.Values\n\n                        if ip_type.lower() == \"ipv6\":\n                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv6PrefixPools.find()\n                            address = networkObj.NetworkAddress.Values\n                        if startaddress in address:\n                            ipIndex = address.index(startaddress)\n                            try:\n                                valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values\n                                valuesList[ipIndex] = active.lower()\n                                bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel\n                                bgpIpObj.ClearOverlays()\n                                bgpIpObj.ValueList(values=valuesList)\n                            except:\n                                pass\n\n        if devices and address_list == None:\n            for device in devices:\n                for ngroup in network_group_list:\n                    device = device.replace('+', r'\\+').replace('*', r'\\*')\n                    deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n                    if ip_type.lower() == \"ipv4\":\n                        try:\n                            deviceObj.NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv4PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(\n                                active)\n                            deviceObj.NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv4PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().Active.Single(\n                                isis_prefix_sid_active)\n                        except:\n                            pass\n                    if ip_type.lower() == \"ipv6\":\n                        try:\n                            deviceObj.NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv6PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(\n                                active)\n                            deviceObj.NetworkGroup.find(\n                                Name='^' + ngroup + '$').Ipv6PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().Active.Single(\n                                isis_prefix_sid_active)\n                        except:\n                            pass\n\n        if devices == None and address_list:\n            for ngroup in network_group_list:\n                for startaddress in address_list:\n                    if ip_type.lower() == \"ipv4\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + ngroup + '$').Ipv4PrefixPools.find()\n                        address = networkObj.NetworkAddress.Values\n\n                    if ip_type.lower() == \"ipv6\":\n                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                            Name='^' + ngroup + '$').Ipv6PrefixPools.find()\n                        address = networkObj.NetworkAddress.Values\n                    if startaddress in address:\n                        ipIndex = address.index(startaddress)\n                        try:\n                            valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values\n                            valuesList[ipIndex] = active.lower()\n                            bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel\n                            bgpIpObj.ClearOverlays()\n                            bgpIpObj.ValueList(values=valuesList)\n                        except:\n                            pass\n\n        # support for configureSIDIndexLabel not present in ixnetwork_restpy verion 1.0.45 so using REST API\n        if self.tgn_server_type == \"linux\":\n            api_key = self.test_platform.ApiKey\n            headers = {'content_type': 'application/json', 'x-api-key': api_key}\n            server_url = 'https://' + self.server_ip + ':' + str(self.port)\n            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n        else:\n            headers = {\"content_type\": \"application/json\"}\n            try:\n                server_url = 'http://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)\n            except:\n                server_url = 'https://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n\n        if devices == None and address_list == None:\n            for ngroup in network_group_list:\n                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + ngroup + '$')\n                if ip_type.lower() == \"ipv4\":\n                    try:\n                        isisL3Obj = networkObj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'\n                    except:\n                        pass\n                if ip_type.lower() == \"ipv6\":\n                    try:\n                        isisL3Obj = networkObj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'\n                    except:\n                        pass\n\n                if isisL3Obj:\n                    body = requests.get(server_url + isisL3Obj, headers=headers, verify=False)\n                    isisSid = server_url + body.json()['configureSIDIndexLabel'] + '/singleValue'\n                    data = {'value': active}\n                    requests.patch(isisSid, json=data, headers=headers, verify=False)\n                    isis_prefix_sid_active_state = server_url + body.json()['active'] + '/singleValue'\n                    data = {'value': isis_prefix_sid_active}\n                    requests.patch(isis_prefix_sid_active_state, json=data, headers=headers, verify=False)\n        return True\n\n    def modify_traffic_tx_rx_port(self,trafficList,rxPort=None, txPort=None):\n        \"\"\"\n        To modify Tx/Rx ports of traffic items\n        :param rxPort:Port Name has to be changed for Traffic Item in receiving side. Default: None.\n        :param txPort:Port Name has to be changed for Traffic Item in transmitting side. Default: None.\n        :param trafficList: Traffic Item to be changed\n        Examples:\n            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5'],rxPort=['10.39.70.2/3/7'],trafficList=['Traffic Item 1'])\n            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5','10.39.70.2/3/6'],rxPort=['10.39.70.2/3/7','10.39.70.2/3/8'],\n                                        trafficList=['Traffic Item 1','Traffic Item 2'])\n        \"\"\"\n        self.log.info(\"Modifying Tx and Rx ports of traffic item\")\n        if rxPort == None and txPort == None:\n            self.log.error('rxPort or txPort should be passed')\n        rxPortNamesList = []\n        txPortNamesList = []\n        if rxPort:\n            self.log.info(f'Modifying the Rx Port: {rxPort}')\n            for eachPort in rxPort:\n                if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', eachPort)):\n                    portUpdated = eachPort.replace(\"/\", \":\")\n                    rx_port_name = self.ixNetwork.Vport.find(AssignedTo='^'+portUpdated+'$').Name\n                    rxPortNamesList.append(rx_port_name)\n                    rxPort = rxPortNamesList\n        if txPort:\n            self.log.info(f'Modifying the Tx Port: {txPort}')\n            for eachPort in txPort:\n                if (re.search(r'\\d+.\\d+.\\d+.\\d+/\\d+/\\d+', eachPort)):\n                    portUpdated = eachPort.replace(\"/\", \":\")\n                    tx_port_name = self.ixNetwork.Vport.find(AssignedTo='^'+portUpdated+'$').Name\n                    txPortNamesList.append(tx_port_name)\n                    txPort = txPortNamesList\n        if trafficList:\n            traffic_list = trafficList\n            self.log.info(f'Modifying the Traffic Items: {traffic_list}')\n            for traffic_item in traffic_list:\n                traffic_item = re.escape(traffic_item)\n                traffic_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$')\n                if rxPort:\n                    try:\n                        rxPortDest = []\n                        for eachRxPort in rxPort:\n                            rxPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href\n                            rxPortDestStr = rxPortHref + '/protocols'\n                            rxPortDest.append(rxPortDestStr)\n                        endPointObj = traffic_obj.EndpointSet.find()\n                        endPointObj.Destinations = rxPortDest\n                    except:\n                        self.log.error('RxPort modification failed')\n                if txPort:\n                    try:\n                        txPortDest = []\n                        for eachRxPort in txPort:\n                            txPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href\n                            txPortDestStr = txPortHref + '/protocols'\n                            txPortDest.append(txPortDestStr)\n                        endPointObj = traffic_obj.EndpointSet.find()\n                        endPointObj.Sources = txPortDest\n                    except:\n                        self.log.error('TxPort modification failed')\n        return True\n\n    def duplicate_traffic_item(self, traffic_item=None, count=1, rename_traffic=None):\n        \"\"\"\n        API to duplicate traffic items\n\n        :param traffic_item: Name of traffic item which needs to be duplicated\n        :param count: Number of duplicates to be created\n        :param rename_traffic: Name of duplicated traffic item to be renamed\n        :return True: On success\n        Examples:\n            duplicate_traffic_item(traffic_item=['traffic(1)','traffic[2]','Traffic Item$'],count=1)\n-           duplicate_traffic_item(count=2)\n            duplicate_traffic_item(traffic_item='traffic(1)')\n            duplicate_traffic_item(rename_traffic='test_new', traffic_item=['test'])\n        \"\"\"\n        if isinstance(traffic_item, str):\n            traffic_item = [traffic_item]\n\n        if not traffic_item:\n            for trafficObj in self.ixNetwork.Traffic.TrafficItem.find():\n                trafficObj.Duplicate(arg2=count)\n            self.log.info('Duplicates are created for all traffic items {} times'.format(count))\n        else:\n            self.log.info(f'Duplicating Traffic Items - {traffic_item}')\n            for each_traffic in traffic_item:\n                trafficList = [trafficObj for trafficObj in self.ixNetwork.Traffic.TrafficItem.find() if\n                               (trafficObj.Name == each_traffic)]\n                if trafficList:\n                    trafficList[0].Duplicate(arg2=count)\n                    self.log.info(f'Duplicate item is created for {each_traffic} {count} times')\n                if rename_traffic:\n                    self.log.info(f'Renaming the Duplicated Traffic Item as - {rename_traffic}')\n                    each_traffic = re.escape(each_traffic + ' Copy (1)')\n                    new_name = self.ixNetwork.Traffic.TrafficItem.find(Name=f\"^{each_traffic}$\")\n                    new_name.Name = rename_traffic\n                else:\n                    self.log.error(f'{each_traffic} is not found')\n        self.regenerate_traffic()\n        return True\n\n    def set_igmp_mld_rate(self, device_type, rate, **kwargs):\n        \"\"\"\n        update join rate for IGMP/MLD device\n        :param device_type: igmp, mld\n        :param rate: rate to be configured\n        :param kwargs:\n        device_name: name of IGMP/MLD hosts\n        device_group_name : device group name\n        :return: True on success else raises exception\n        :Example: set_igmp_mld_rate(device_type='igmp', rate=4000)\n                  set_igmp_mld_rate(device_type='igmp', rate=3000, device_name='IGMP2')\n        \"\"\"\n        if device_type.lower() not in ['igmp', 'mld']:\n            raise Exception(\"Invalid device type\", device_type)\n        vport_dict = {}\n        device_name = kwargs.get('device_name', None)\n        device_group_name = kwargs.get('device_group_name', None)\n\n        if device_name is None and device_group_name is None:\n            # Set IGMP/MLD global values\n            rate_count = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Count\n            if isinstance(rate, int) or isinstance(rate, float):\n                rate = [rate] * rate_count\n            elif isinstance(rate, list):\n                if len(rate) != rate_count:\n                    raise Exception(f\"mismatch length between configured {rate_count} and provided {len(rate)}\")\n            if device_type.lower() == 'igmp':\n                self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList(values=rate)\n            else:\n                self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList(values=rate)\n        else:\n            if device_type.lower() == 'igmp':\n                host = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_group_name).Ethernet.find().Ipv4.find().\\\n                    IgmpHost.find(Name=device_name)\n                rate_values = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Values\n                row_names = self.ixNetwork.Globals.Topology.IgmpHost.RowNames\n                value_list = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList\n            elif device_type.lower() == 'mld':\n                host = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_group_name).Ethernet.find().Ipv6.find().\\\n                    MldHost.find(Name=device_name)\n                rate_values = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.Values\n                row_names = self.ixNetwork.Globals.Topology.MldHost.RowNames\n                value_list = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList\n            if len(host) == 0:\n                raise Exception(\"Host not found with device name\", device_name)\n            for row_name in row_names:\n                for vport in self.ixNetwork.Vport.find():\n                    if row_name == vport.Name:\n                        vport_dict[vport.href] = vport.Name\n            for topo_entry in self.ixNetwork.Topology.find():\n                if topo_entry.href in host.href:\n                    for port_name in topo_entry.Ports:\n                        port_index = row_names.index(vport_dict[port_name])\n                        rate_values[port_index] = rate\n                        value_list(values=rate_values)\n            return True\n\n    def _get_stream_ipv4_details(self, config_element):\n        \"\"\"\n        Gets the value of the IPv4 headers DF,MF,Protocol and IP options field for the specified traffic items\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing IPv4 field values for the specified streams\n        \"\"\"\n        self.log.info(\"Getting IPv4 Header details of Traffic Item\")\n        results = {}\n        ipv4_stack = config_element.find().Stack.find(StackTypeId='ipv4')\n        if ipv4_stack:\n            field_value = ipv4_stack.Field.find(Name='^' + 'fragment_flag' + '$')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv4_stack.Field.find(Name='last_fragment_flag')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv4_stack.Field.find(Name='source_ip')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv4_stack.Field.find(Name='dest_ip')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv4_stack.Field.find(Name='protocol')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n            for ip_option_obj in ipv4_stack.Field.find(FieldTypeId='ipv4.header.options.nextOption.option.'):\n                if ip_option_obj and ip_option_obj.ActiveFieldChoice:\n                    results.update({ip_option_obj.DisplayName: ip_option_obj.FieldValue})\n        else:\n            self.log.error('IPv4 Stack is not found in traffic item')\n        return results\n\n    def _get_stream_ipv6_details(self, config_element):\n        \"\"\"\n        Gets the value of the IPv6 headers Source IP,Destination IP and Next Header\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing IPv6 field values for the specified streams\n        \"\"\"\n        self.log.info(\"Getting IPv6 Header details of Traffic Item\")\n        results = {}\n        ipv6_stack = config_element.find().Stack.find(StackTypeId='ipv6')\n        if ipv6_stack:\n            field_value = ipv6_stack.Field.find(Name='source_ip')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv6_stack.Field.find(Name='dest_ip')\n            results.update({field_value.DisplayName: field_value.SingleValue})\n            field_value = ipv6_stack.Field.find(Name='nextHeader')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n        else:\n            self.log.error('IPv6 Stack is not found in traffic item')\n        return results\n\n    def _get_stream_icmp_details(self, header_name, config_element):\n        \"\"\"\n        Gets the value of the ICMP headers Message Type and Code Options\n        :param header_name: header Name for which details to be fetched\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing ICMP field values for the specified streams\n        \"\"\"\n        self.log.info(\"Getting ICMP Header details of Traffic Item\")\n        results = {}\n        icmp3_code_list = ['Dest. Unreachable code options', 'Src. Quench option', 'Info Request option',\n                         'Info Response option', 'Time Exceeded option', 'Redirect Message option']\n        if header_name.upper() == 'ICMP3':\n            icmp_stack = config_element.find().Stack.find(StackTypeId=\"^icmpv1$\")\n            if icmp_stack:\n                field_value = icmp_stack.Field.find(Name='msg_type')\n                results.update({field_value.DisplayName: field_value.FieldValue})\n                for icmp3code in icmp3_code_list:\n                    icmp3_code_obj = icmp_stack.Field.find(DisplayName=icmp3code)\n                    if icmp3_code_obj and icmp3_code_obj.ActiveFieldChoice:\n                        results.update({icmp3_code_obj.DisplayName: icmp3_code_obj.FieldValue})\n            else:\n                self.log.info('ICMP Msg Type 3,4,5,11,12 Stack is not found in traffic item')\n        if header_name.upper() == 'ICMP0':\n            icmp_stack = config_element.find().Stack.find(StackTypeId=\"^icmpv2$\")\n            if icmp_stack:\n                field_value = icmp_stack.Field.find(Name='msg_type')\n                results.update({field_value.DisplayName: field_value.FieldValue})\n                field_value = icmp_stack.Field.find(Name=\"Code\")\n                results.update({field_value.DisplayName: field_value.FieldValue})\n                field_value = icmp_stack.Field.find(Name=\"^id_fier$\")\n                results.update({field_value.DisplayName: field_value.FieldValue})\n            else:\n                self.log.error('ICMP Msg Type 0,8,13,14,15,16 Stack is not found in traffic item')\n        return results\n\n    def _get_stream_icmpv6_details(self, config_element):\n        \"\"\"\n        Gets the value of the ICMPv6 headers Message Type and Code Options\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing ICMPv6 field value for the specified streams\n        \"\"\"\n        self.log.info(\"Getting ICMPv6 Header details of Traffic Item\")\n        results = {}\n        icmpv6_stack = config_element.find().Stack.find(StackTypeId=\"^icmpv6$\")\n        if icmpv6_stack:\n            for icmpv6_msg_obj in icmpv6_stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.'):\n                if icmpv6_msg_obj.ActiveFieldChoice:\n                    results.update({icmpv6_msg_obj.DisplayName: icmpv6_msg_obj.FieldValue})\n        else:\n            self.log.error('ICMPv6 Stack is not found in traffic item')\n        return results\n\n    def _get_stream_tcp_details(self, config_element):\n        \"\"\"\n        Gets the value of the TCP header values\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing TCP field value for the specified streams\n        \"\"\"\n        self.log.info(\"Getting TCP Header details of Traffic Item\")\n        results = {}\n        tcp_stack = config_element.find().Stack.find(StackTypeId=\"^tcp$\")\n        if tcp_stack:\n            field_value = tcp_stack.Field.find(Name='tcp_src_prt')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n            field_value = tcp_stack.Field.find(Name='tcp_dst_prt')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n        else:\n            self.log.info('TCP Stack is not found in traffic item')\n        return results\n\n    def _get_stream_udp_details(self, config_element):\n        \"\"\"\n        Gets the value of the UDP header values\n        :param config_element: Config Element of traffic item\n        :return: A list of results containing UDP field value for the specified streams\n        \"\"\"\n        self.log.info(\"Getting UDP Header details of Traffic Item\")\n        results = {}\n        udp_stack = config_element.find().Stack.find(StackTypeId=\"^udp$\")\n        if udp_stack:\n            field_value = udp_stack.Field.find(Name='udp_src_prt')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n            field_value = udp_stack.Field.find(Name='udp_dst_prt')\n            results.update({field_value.DisplayName: field_value.FieldValue})\n        else:\n            self.log.info('UDP Stack is not found in traffic item')\n        return results\n\n    def _get_stream_header_list(self, config_element):\n        \"\"\"\n        Gets the value of all the traffic item headers configured\n        :param config_element: Config Element of traffic item\n        :return: A list of Traffic stream headers configured on the specified stream\n        \"\"\"\n        self.log.info(\"Getting Header details of Traffic Item\")\n        results = [header.DisplayName for header in config_element.Stack.find() if header]\n        return results\n\n    def get_traffic_stream_header(self, traffic_item, header_type_list, header_name_list):\n        \"\"\"\n        API to get Traffic item header contents like IPv4,IPv6,ICMPv4,ICMPv6\n        :param traffic_item: Traffic Item where header is present\n        :param header_name_list: header Name for which details to be fetched\n        :param header_type_list: header Type for which details to be fetched\n        :return True on success otherwise return False\n        Ex : get_traffic_stream_header(traffic_item='Traffic Item 1',header_name='ipv4','headerType'='ipv4'))\n        \"\"\"\n        self.log.info('Getting traffic item header details')\n        header_contents = {}\n        traffic_item_name = traffic_item.replace('+', r'\\+').replace('*', r'\\*')\n        traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item_name + '$')\n        if not traffic_item_obj:\n            raise IxiaConfigException(\"Traffic item not found\")\n        for config_element in traffic_item_obj.ConfigElement.find():\n            for header_name in header_name_list:\n                header_type = header_type_list[header_name_list.index(header_name)]\n                if header_type == 'all':\n                    result = self._get_stream_header_list(config_element)\n                elif header_type == 'ipv4':\n                    result = self._get_stream_ipv4_details(config_element)\n                elif header_type == 'ipv6':\n                    result = self._get_stream_ipv6_details(config_element)\n                elif header_type == 'icmp':\n                    result = self._get_stream_icmp_details(header_name, config_element)\n                elif header_type == 'icmpv6':\n                    result = self._get_stream_icmpv6_details(config_element)\n                elif header_type == 'tcp':\n                    result = self._get_stream_tcp_details(config_element)\n                elif header_type == 'udp':\n                    result = self._get_stream_udp_details(config_element)\n                header_contents.update({header_name: result})\n        return header_contents\n\n    def add_rocev2_header(self, traffic_item, destination_qp=None):\n        \"\"\"\n        API to add Rocev2 traffic header\n        :param traffic_item: List of Traffic Items to add Rocev2 header\n        :param destination_qp: Type of data to be passed in custom header like fixed,list,increment,random\n        :return True on success otherwise return False\n        Example:\n                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],\n                                  destination_qp={'random':{'min':'0x32','max':'ffffff','seed':'111','step':1,'count':100}})\n                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'increment':{'start':'0x16','step':2,'count':100}})\n                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'list':['0x32','0x16']})\n                add_rocev2_header(traffic_item=['Traffic Item 1'],destination_qp={'fixed':'0x64'})\n                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'fixed':'0x64'})\n        \"\"\"\n        if destination_qp is None:\n            destination_qp = {'fixed': 1}\n        self.log.info('Adding Rocev2 header')\n        for traffic in traffic_item:\n            self.add_stream_header(traffic, 'custom', 'custom')\n            self.add_stream_header(traffic, 'custom', 'custom')\n        self.modify_packet_stream_header(traffic_item_list=traffic_item, cfg_dict={'protocol_name': 'custom', 'custom_length': '40',\n                                                                                   'custom_data': '0x640f28403', 'header_index': 0})\n        if 'fixed' in destination_qp.keys():\n            custom_data = destination_qp['fixed']\n        elif 'increment' in destination_qp.keys():\n            custom_data = destination_qp['increment']\n        elif 'list' in destination_qp.keys():\n            custom_data = destination_qp['list']\n        elif 'random' in destination_qp.keys():\n            custom_data = destination_qp['random']\n        else:\n            raise IxiaConfigException('Invalid Destination QP value')\n        self.modify_packet_stream_header(traffic_item_list=traffic_item, cfg_dict={'protocol_name': 'custom', 'custom_length': '24',\n                                                                                   'custom_data': custom_data, 'header_index': 1})\n        self.log.info('Traffic Header Rocev2 added successfully with destination QP value')\n        return True\n\n    def set_bgp_high_scale_mode(self, bgp=\"v4\", active=True):\n        \"\"\"\n        Setting BGP High scale mode in Globals\n\n        :param bgp: BGP v4 or v6 Ex : 'v4'/'v6'\n        :param active: operation to be set for High Scale mode Ex : True/False\n        :return: True on success else raises exception\n\n        :Example: set_bgp_high_scale_mode(active=False)\n                  set_bgp_high_scale_mode(bgp=\"v6\", active=True)\n        \"\"\"\n        self.log.info('Setting BGP High Scale Mode')\n        if self.tgn_server_type == \"linux\":\n            api_key = self.test_platform.ApiKey\n            headers = {'content_type': 'application/json', 'x-api-key': api_key}\n            server_url = 'https://' + self.server_ip + ':' + str(self.port)\n            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n        else:\n            headers = {\"content_type\": \"application/json\"}\n            try:\n                server_url = 'http://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)\n            except:\n                server_url = 'https://' + self.server_ip + ':' + str(self.port)\n                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)\n\n        if bgp.lower() == \"v4\":\n            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv4Peer.href\n        if bgp.lower() == \"v6\":\n            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv6Peer.href\n\n        body = requests.get(server_url + bgp_obj, headers=headers, verify=False)\n        bgp_scale = server_url + body.json()['highScaleRouteMode'] + '/singleValue'\n        data = {'value': active}\n        requests.patch(bgp_scale, json=data, headers=headers, verify=False)\n\n    def change_ipv4_diff_serv(self, cfg_dict, traffic_item_list):\n        \"\"\"\n        Changes the Diff serv values in ipv4 stacks for a given set of traffic streams\n\n        :param cfg_dict: Dict including the data need to be modified\\n\n                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','singleValue', 'valueList',header_index \\n\n                'displayName' : 'default','classSelector','assuredForwarding','expeditedForwarding'\n                'valueType'   : 'singleValue','valueList'\n                Example: cfg_dict={'displayName':'classSelector','valueType':'singleValue','singleValue':'10'}\n        :param traffic_item_list: List of traffic Items name. \\n\n                Example: traffic_item_list=[\"Traffic Item 1\", \"Traffic Item 2\"]\n        :return: Returns True in case no exceptions\n        :Example: change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],\n                        cfg_dict={'displayName':'default','valueType':'singleValue','singleValue':'0'})\n                  change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],\n                  cfg_dict={'displayName':'classSelector','valueType':'valueList','valueList':[16,24],'header_index':2})\n        \"\"\"\n        self.log.info(\"Changing Diff Serv values in IPv4\")\n        if 'header_index' not in cfg_dict:\n            cfg_dict['header_index'] = 1\n        header_index = cfg_dict['header_index'] - 1\n        diff_serve_hop_dict = {'default': 'Default PHB', 'classSelector': 'Class selector PHB',\n                            'assuredForwarding': 'Assured forwarding PHB',\n                            'expeditedForwarding': 'Expedited forwarding PHB'}\n        if 'displayName' not in cfg_dict.keys():\n            class_list = [8,16,24,32,40,48,56]\n            if 'singleValue' in cfg_dict.keys():\n                diff_value = cfg_dict['singleValue']\n            else:\n                diff_value = cfg_dict['valueList'][0]\n\n            if diff_value == 0:\n                cfg_dict['displayName'] = 'default'\n            elif diff_value in class_list:\n                cfg_dict['displayName'] = 'classSelector'\n            elif diff_value == 46:\n                cfg_dict['displayName'] = 'expeditedForwarding'\n            else:\n                cfg_dict['displayName'] = 'assuredForwarding'\n        if 'reserved' not in cfg_dict.keys():\n            cfg_dict['reserved'] = '0'\n\n        for traffic_item_name in traffic_item_list:\n            traffic_item_modified = re.escape(traffic_item_name)\n            for config_element in self.ixNetwork.Traffic.TrafficItem.find(\n                    Name='^' + traffic_item_modified + '$').ConfigElement.find():\n                if config_element.Stack.find(DisplayName=\"IPv4\"):\n                    if cfg_dict['displayName'] in diff_serve_hop_dict.keys():\n                        try:\n                            stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")[header_index]\n                            field_value = stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']])\n                            field_value.ActiveFieldChoice = True\n                            field_value.ValueType = cfg_dict['valueType']\n                            if 'valueList' in cfg_dict['valueType']:\n                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),\n                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                        cfg_dict['valueList'])\n                            elif 'singleValue' in cfg_dict['valueType']:\n                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),\n                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],\n                                        cfg_dict['singleValue'])\n                        except Exception as err:\n                            raise IxiaConfigException(f\"Diff serv value update failed {err}\")\n                    else:\n                        self.log.error('Invalid Diff-Serv hop value')\n                    try:\n                        stack_obj = config_element.Stack.find(DisplayName=\"IPv4\")[header_index]\n                        field_value = stack_obj.Field.find(DisplayName='Reserved')\n                        self._update_field_values(field_value, cfg_dict['reserved'])\n                    except Exception as err:\n                        raise IxiaConfigException(f\"Reserved value update failed {err}\")\n                else:\n                    raise IxiaConfigException(f\"IPv4 stack is not configured in {traffic_item_name}\")\n        self.log.info('IPv4 Diff-Serv Values updated in Traffic Items')\n        return True\n\n    def get_traffic_frame_size(self, traffic_item_list=None):\n        \"\"\"\n        get the frame size of traffic.\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :return: True on success else raises exception.\n\n        :Example:\n            get_traffic_frame_size(traffic_item_list=['Traffic Item 1'])\n        \"\"\"\n        self.log.info(\"Getting Traffic Frame Size\")\n        cfg_dict=dict()\n        if traffic_item_list is None:\n            traffic_item_list = self.get_traffic_items()\n\n        for traffic_name in traffic_item_list:\n            traffic_name =  traffic_name.replace('+', r'\\+').replace('*', r'\\*')\n            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' +traffic_name+ '$'):\n                streams = traffic.ConfigElement.find()\n                for stream in streams:\n                    if stream.FrameSize.Type == \"fixed\":\n                        cfg_dict.setdefault(traffic_name, []).append({\"Frame Type\": stream.FrameSize.Type,\"Frame Size\":stream.FrameSize.FixedSize})\n                    elif stream.FrameSize.Type == \"increment\":\n                        cfg_dict.setdefault(traffic_name, []).append({\"Frame Type\": stream.FrameSize.Type,\"Start\":stream.FrameSize.IncrementFrom,\n                                                                      \"End\":stream.FrameSize.IncrementTo,\"Step\":stream.FrameSize.IncrementStep})\n                    elif stream.FrameSize.Type == \"random\":\n                        cfg_dict.setdefault(traffic_name, []).append({\"Frame Type\": stream.FrameSize.Type,\"Random Max\":stream.FrameSize.RandomMax,\n                                                                      \"Random Min\":stream.FrameSize.RandomMin})\n                    elif stream.FrameSize.Type in [\"presetDistribution\", \"weightedPairs\"]:\n                        cfg_dict.setdefault(traffic_name, []).append({\"Frame Type\": stream.FrameSize.Type,\n                                                                      \"weighted Range Pairs\":stream.FrameSize.WeightedRangePairs})\n        return cfg_dict\n\n    def get_traffic_rate(self, traffic_item_list=None):\n        \"\"\"\n        get the rate of traffic.\n\n        :param traffic_item_list: List of traffic Items name. All Items if it is None.\n        :return: True on success else raises exception.\n\n        :Example:\n            get_traffic_rate(traffic_item_list=['Traffic Item 1'])\n        \"\"\"\n        self.log.info(\"Getting Traffic Rate\")\n        rate_type_dict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',\n                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',\n                        'percentLineRate': 'lineRate'}\n        if traffic_item_list is None:\n            traffic_item_list = self.get_traffic_items()\n        cfg_dict = dict()\n        for traffic_name in traffic_item_list:\n            traffic_name = traffic_name.replace('+', r'\\+').replace('*', r'\\*')\n            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_name + '$'):\n                streams = traffic.ConfigElement.find()\n                for stream in streams:\n                    for frame_rate in stream.FrameRate:\n                        if frame_rate.Type == \"percentLineRate\":\n                            cfg_dict.setdefault(traffic_name, []).append({\"Rate Type\": rate_type_dict[frame_rate.Type],\n                                                                          \"Rate\": str(int(frame_rate.Rate))+\"%\"})\n                        else:\n                            cfg_dict.setdefault(traffic_name, []).append({\"Rate Type\":rate_type_dict[frame_rate.Type],\"Rate\":frame_rate.Rate})\n        return cfg_dict\n\n    def port_ownership(self):\n        \"\"\"\n        Function used to clear port ownership and take port ownership\n        Forcefully take port ownership of ports owned by other users and connect ports\n\n        :Example:\n            port_ownership()\n        \"\"\"\n        ports = self.ixNetwork.Vport.find()\n        if ports:\n            ports.ConnectPorts(arg2=True)\n        else:\n            self.log.error('No Ports Found or invalid configuration')\n\n    def set_bgp_next_hop(self, network_group, next_hop_type, **kwargs):\n        \"\"\"\n        Modifying Next Hop options for BGP protocol.\n        :param network_group: represents the network group\n        :param next_hop_type: String representing the next hop type(manaul,local_ip)\n        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.\n                nested_network_group : if nested network group, Need to pass nested_network_group = True\n                                if nested_network_group is True 'route_block_name' is mandatory\n                ip_type:String representing ip type (ipv4 or ipv6)\n                next_hop_ip_type: String representing the next hop ip type(ipv4 or ipv6)\n                next_hop_ipv4_adr,String representing next hop ipv4 address\n                next_hop_ipv6_adr,String representing next hop ipv6 address\n        :return: True if the operation is successful, False otherwise\n        :Example:\n            set_bgp_next_hop(network_group='Network Group 1',ip_type='ipv6',next_hop_type='manually',\n                            next_hop_ipv4_adr='12.24.56.79',next_hop_ipv6_adr='ef12::f23:3')\n        \"\"\"\n        ip_type = kwargs.get('ip_type', 'ipv4')\n        next_hop_ip_type = kwargs.get('next_hop_ip_type', 'ipv4')\n        next_hop_ipv4_adr = kwargs.get('next_hop_ipv4_adr', '0.0.0.0')\n        next_hop_ipv6_adr = kwargs.get('next_hop_ipv6_adr', '::')\n\n        self.log.info(f\"Setting Bgp Next hop  options for Network Group {network_group}\")\n\n        network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n            Name='^' + network_group + '$')\n\n        if network_group_obj:\n            return self._modify_bgp_next_hop_options(network_obj=network_group_obj, ip_option=ip_type,\n                                                     next_hop_option=next_hop_type,\n                                                     next_hop_ip_option=next_hop_ip_type,\n                                                     next_hop_ipv4_address=next_hop_ipv4_adr,\n                                                     next_hop_ipv6_address=next_hop_ipv6_adr)\n        else:\n            self.log.error(f\"BGP Network Group {network_group} Not Found\")\n\n    def _modify_bgp_next_hop_options(self, network_obj, ip_option, next_hop_option, next_hop_ip_option,\n                                     next_hop_ipv4_address,\n                                     next_hop_ipv6_address):\n        \"\"\"\n        This function is used internally\n        :param network_obj: Network Group Object\n        :param ip_option: IP type of Network group\n        :param next_hop_option: String representing the next hop type(manual,local_ip)\n        :param next_hop_ip_option: String representing the next hop ip type(ipv4 or ipv6)\n        :param next_hop_ipv4_address:next_hop_ipv4_adr,String representing next hop ipv4 address\n        :param next_hop_ipv6_address:next_hop_ipv6_adr,String representing next hop ipv6 address\n        \"\"\"\n        self.log.info(f\"Modifying Bgp Next hop options for Network Group {network_obj.Name}\")\n        next_hop_type_dict = {'manually': 'manual', 'local_ip': 'sameaslocalip'}\n        if ip_option.lower() == 'ipv4':\n            if network_obj.Ipv6PrefixPools.find():\n                bgp_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find()\n            elif network_obj.Ipv4PrefixPools.find():\n                bgp_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find()\n            else:\n                bgp_route_property_obj = None\n            if bgp_route_property_obj:\n                try:\n                    bgp_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])\n                    bgp_route_property_obj.NextHopIPType.Single(next_hop_ip_option)\n                    bgp_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)\n                    bgp_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)\n                except:\n                    self.log.error('Modification of BGP Next Hop options failed')\n            else:\n                self.log.error('BGP Network Route is not found in Topology')\n        else:\n            if network_obj.Ipv6PrefixPools.find():\n                bgp_v6_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()\n            elif network_obj.Ipv4PrefixPools.find():\n                bgp_v6_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()\n            else:\n                bgp_v6_route_property_obj = None\n            if bgp_v6_route_property_obj:\n                try:\n                    bgp_v6_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])\n                    bgp_v6_route_property_obj.NextHopIPType.Single(next_hop_ip_option)\n                    bgp_v6_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)\n                    bgp_v6_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)\n                except:\n                    self.log.error('Modification of BGP Next Hop options failed')\n            else:\n                self.log.error('BGP Network Route is not found in Topology')\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def modify_route_start_address(self, start_address, network_group=None, ip_type='ipv4', **kwargs):\n        \"\"\"\n        This API is used for modifying the Network group address count\n        :param start_address:Start address of the route to be set\n        :param network_group:Network Group name to modify group address Count\n        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'\n        :param kwargs: Optional arguments\n                        nested_network_group: nested network group name If nested network group to be modified\n                                              Ex : 'Network Group 1'\n        :return: True on success otherwise raise exception\n\n        :Example: modify_route_start_address(start_address = \"100.1.1.1\", nested_network_group = \"Network Group 1\")\n                  modify_route_start_address(start_address ={'start':\"100.1.1.1\",'step':'0.0.0.2'}, nested_network_group = \"Network Group 1\")\n                  modify_route_start_address(start_address =[\"10.1.1.1\",\"20.1.1.1\",\"30.1.1.1\"], nested_network_group = \"Network Group 1\")\n        \"\"\"\n        nested_network_group = kwargs.get('nested_network_group', None)\n        self.log.info(\"setting start address for Network Group \")\n        # Modify Group start address for Network Group\n        if network_group and nested_network_group:\n            if ip_type.lower() == 'ipv4':\n                try:\n                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + network_group + '$'). \\\n                        DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()\n                except:\n                    pass\n\n            else:\n                try:\n                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + network_group + '$'). \\\n                        DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()\n                except:\n                    pass\n\n            if isinstance(start_address, dict):\n                cfg_dict = start_address\n                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start'),\n                                                     step_value=cfg_dict.get('step', \"0.0.0.1\"))\n            elif isinstance(start_address, str):\n                network_obj.NetworkAddress.Single(start_address)\n            elif isinstance(start_address, list):\n                network_obj.NetworkAddress.ValueList(start_address)\n        elif network_group is None and nested_network_group:\n            if ip_type.lower() == 'ipv4':\n                try:\n                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()\n                except:\n                    pass\n            else:\n                try:\n                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(\n                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()\n                except:\n                    pass\n\n            if isinstance(start_address, dict):\n                cfg_dict = start_address\n                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),\n                                                     step_value=cfg_dict.get('step', 1))\n            elif isinstance(start_address, str):\n                network_obj.NetworkAddress.Single(start_address)\n            elif isinstance(start_address, list):\n                network_obj.NetworkAddress.ValueList(start_address)\n        elif network_group and nested_network_group is None:\n            if ip_type.lower() == 'ipv4':\n                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + network_group + '$').Ipv4PrefixPools.find()\n            else:\n                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(\n                    Name='^' + network_group + '$').Ipv6PrefixPools.find()\n            if isinstance(start_address, dict):\n                cfg_dict = start_address\n                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),\n                                                     step_value=cfg_dict.get('step', 1))\n            elif isinstance(start_address, str):\n                network_obj.NetworkAddress.Single(start_address)\n            elif isinstance(start_address, list):\n                network_obj.NetworkAddress.ValueList(start_address)\n\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        self.log.info(\"Network Group start address added Successfully\")\n        return True\n\n    def get_all_frame_headers(self, stream_name:str):\n        \"\"\"\n        This API returns Mac and Ethernet type of given traffic item\n        :param stream_name: Stream name where stream header details to be fetched\n        :return: Dict of headers frames with field values\n        :Example: get_all_frame_headers(stream_name='Traffic_1')\n        output: {'header_1_ethernetii': {'dstMac': '01:01:10:00:03:00', 'srcMac': '01:01:20:aa:00:cd', 'etherType': '800'},\n        'header_2_ipv4': {'version': '4', 'totalLength': '1500', 'identification': '0', 'fragOffset': '0', 'ttl': '64',\n        'protocol': 'IPv6', 'checksum': '0', 'sourceAddr': '10.10.33.60', 'destAddr': '25.66.82.31'},\n        'header_3_ipv6': {'version': '6', 'trafficClass': '0', 'flowLabel': '0', 'payloadLength': '1440',\n        'nextHeader': 'TCP', 'hopLimit': '64', 'sourceAddr': '120::2', 'destAddr': '140::4'},\n        'header_4_tcp': {'sourcePort': 'MSDP', 'destPort': 'LDP', 'ackNum': '0', 'offset': '5', 'reserved': '0',\n        'cwrBit': '0', 'ecnBit': '0', 'urgBit': '0', 'ackBit': '1', 'pshBit': '0', 'rstBit': '0', 'synBit': '1',\n        'finBit': '0', 'window': '0', 'checksum': '0', 'urgentPtr': '0'},\n        'header_5_udp': {'sourcePort': 'RIP', 'destPort': 'NTP'},\n        'header_6_gre': {'keyPresent': '0:No Key field', 'seqNumPresent': '0:No sequence number field',\n        'reserved0': '0', 'version': '0', 'protocolType': '8100'},\n        'header_7_vlan': {'vlanPriority': '1', 'vlanCfi': '0', 'vlanId': '6', 'vlanProtocol': '8100'}}\n        \"\"\"\n        self.log.info(f'Fetching headers from traffic stream: {stream_name}')\n\n        ethernet_field_dict = {'destinationAddress': 'dstMac', 'ether_type': 'etherType', 'sourceAddress': 'srcMac'}\n\n        ipv4_field_dict = {'checksum': 'checksum', 'dest_ip': 'destAddr', 'fragment_offset': 'fragOffset',\n                           'total_len': 'totalLength',\n                           'protocol': 'protocol', 'source_ip': 'sourceAddr', 'identification': 'identification',\n                           'ttl': 'ttl', 'version': 'version'}\n\n        gre_field_dict = {'sequence_present': 'seqNumPresent', 'key_present': 'keyPresent', 'reserved0': 'reserved0',\n                          'protocol': 'protocolType', 'version': 'version'}\n\n        tcp_field_dict = {'u_bit': 'urgBit', 'protocol': 'protocolType', 's_bit': 'synBit', 'r_bit': 'rstBit',\n                          'c_bit': 'cwrBit', 'p_bit': 'pshBit', 'a_bit': 'ackBit', 'f_bit': 'finBit', 'e_bit': 'ecnBit',\n                          'ack_num': 'ackNum', 'reserved': 'reserved', 'seqNum': 'seq_num', 'data_offset': 'offset',\n                          'tcp_src_prt': 'sourcePort', 'tcp_dst_prt': 'destPort',\n                          'tcp_window': 'window', 'tcp_checksum': 'checksum', 'urgent_ptr': 'urgentPtr'}\n\n        udp_field_dict = {'udp_src_prt': 'sourcePort', 'udp_dst_prt': 'destPort'}\n\n        ipv6_field_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit',\n                           'flowLabel': 'flowLabel', 'source_ip': 'sourceAddr', 'trafficClass': 'trafficClass',\n                           'version': 'version', 'dest_ip': 'destAddr',\n                           'nextHeader': 'nextHeader'}\n        vlan_field_dict = {'vlan_user_priority': 'vlanPriority', 'vlan_id': 'vlanId', 'vlan_cfi': 'vlanCfi',\n                           'vlan_tag_type': 'vlanProtocol'}\n\n        regex_dict = {'ethernet': ethernet_field_dict, 'ipv4$': ipv4_field_dict, 'ipv6$': ipv6_field_dict,\n                      'gre': gre_field_dict,\n                      'tcp': tcp_field_dict, 'udp': udp_field_dict, 'vlan$': vlan_field_dict}\n\n        header_contents = {}\n        field_dict = {}\n        stream_name = re.escape(stream_name)\n        stream_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{stream_name}$')\n        if not stream_item_obj:\n            raise IxiaConfigException(\"Traffic item not found\")\n\n        for index, stack in enumerate(stream_item_obj.ConfigElement.find().Stack.find(), start=1):\n            stack_name = 'header_' + str(index) + '_' + stack.DisplayName.lower().replace(' ', '')\n            header_contents.update({stack_name: {}})\n            for pattern in regex_dict.keys():\n                if re.search(pattern, stack_name):\n                    field_dict = regex_dict[pattern]\n                    break\n\n            if field_dict:\n                for field in stack.Field.find():\n                    if field.Name in field_dict.keys():\n                        header_contents[stack_name].update({field_dict[field.Name]: field.FieldValue})\n        return header_contents\n\n    def get_values_from_captured_packets(self, pcap_filename: AnyStr, header: str = 'ipv4', pkt_mode: str = \"random\",\n                                         pkt_num: int = None, random_check_till_ip: int = 5):\n        \"\"\"\n        Used to fetch source and destination IP and TCP MSS value from the captured packet file.\n        :param pcap_filename: Packet capture file name with location\n        :param header: IP header type Ex : \"ipv4\" or \"ipv6\"\n        :param pkt_mode: options are \"random\" and \"fixed\", default: \"random\"\n        If set \"random\" - one random packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,\n        If the packet is IP packet, returns source and destination MAC.\n        If the packet is ARP packet, another random packet is picked and process repeats for \"random_check_till_ip\" number of times\n        If set \"fixed\" - packet with packet number=\"pkt_num\" is used to fetch src and dst mac.\n        :param pkt_num: packet with packet number=\"pkt_num\" is used to fetch src and dst mac. Only when pkt_mode is \"fixed\"\n        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.\n\n        Example: output = get_values_from_captured_packets(pcap_filename='sampledata1.pcap')\n                 output : { 'dst_ip': '2303:d01:148::c001:201:48',\n                            'dst_mac': '00:12:01:00:00:01',\n                            'src_ip': '3303:d01:1122:404:6:200::',\n                            'src_mac': 'c4:b2:39:ec:35:34',\n                            'tcp_mss': '05a6'}\n        \"\"\"\n        ret_header_values = {}\n        packets = []\n        header = header.lower()\n        if pcap_filename:\n            with open(pcap_filename, 'rb') as pcap_file:\n                for _, pkt in dpkt.pcap.Reader(pcap_file):\n                    packets.append(pkt)\n            if pkt_mode.lower() == \"random\":\n                for count in range(random_check_till_ip):\n                    self.log.info(f'Try: {count}')\n                    pkt_num = random.randrange(1, len(packets))\n                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])\n                    ethernet = Ether(packets[int(pkt_num)])\n                    if isinstance(eth.data, dpkt.ip.IP) and header == \"ipv4\" or isinstance(eth.data, dpkt.ip6.IP6) and header == \"ipv6\":\n                        ret_header_values['src_mac'] = ethernet.src\n                        ret_header_values['dst_mac'] = ethernet.dst\n                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)\n                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)\n\n                        try:\n                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)\n                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)\n                        except:\n                            pass\n\n                        try:\n                            tcp_mss = '.'.join(f'{x: 02x}' for x in eth.data.data.opts).split(\".\")[-2::]\n                            if tcp_mss:\n                                ret_header_values['tcp_mss'] = \"\".join([str(item) for item in tcp_mss])\n                        except:\n                            pass\n                        break\n                    else:\n                        raise IxiaConfigException(f'No IP packet found after tries: {random_check_till_ip}')\n            elif pkt_mode.lower() == \"fixed\":\n                if pkt_num:\n                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])\n                    ethernet = Ether(packets[int(pkt_num)])\n                    if not isinstance(eth.data, dpkt.ip.IP) and header == \"ipv4\":\n                        raise CafyException.TgenInvalidInputError(f'Packet is not an IP packet: {pkt_num}')\n                    elif not isinstance(eth.data, dpkt.ip6.IP6) and header == \"ipv6\":\n                        raise CafyException.TgenInvalidInputError(f'Packet is not an IPv6 packet: {pkt_num}')\n                    else:\n                        ret_header_values['src_mac'] = ethernet.src\n                        ret_header_values['dst_mac'] = ethernet.dst\n                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)\n                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)\n                        try:\n                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)\n                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)\n                        except:\n                            pass\n                        try:\n                            tcp_mss = '.'.join(f'{x:02x}' for x in eth.data.data.opts).split(\".\")[-2::]\n                            if tcp_mss:\n                                ret_header_values['tcp_mss'] = \"\".join([str(item) for item in tcp_mss])\n                        except:\n                            pass\n                else:\n                    raise CafyException.TgenInvalidInputError(f'pkt_mode fixed is must for: {pkt_num}')\n        else:\n            raise CafyException.TgenInvalidInputError(f'mandatory parameter: {pcap_filename}')\n        return ret_header_values\n\n    def get_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None):\n        \"\"\"\n        The API returns the SRV6 OAM session status, My discriminator, Peer Discriminator,\n        TX Interval, Timeout multiplier, Reply source address and Session ID  for the given router ids\n\n        :param device_name: SRV6OAM device name\n        :param router_ids: List of router_ids\n        :return: Dictionary of router ids with their corresponding SRV6OAM session status\n\n        :Example: get_srv6_oam_parameters(device_name = \"PE1\",router_ids=['192.0.0.1','192.0.0.5'])\n        \"\"\"\n        router_id_status_mapping = dict()\n        self.log.info(f\"Getting SRV6OAM session status for device {device_name}\")\n\n        try:\n            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()\n        except:\n            self.log.error(\"Device Group Not Found\")\n\n        try:\n            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId\n            session_status_list =  ipv6_obj.Srv6Oam.find().SessionStatus\n            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values\n            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values\n            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values\n            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values\n            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values\n\n            if router_ids:\n                for router_id in router_ids:\n                    if router_id in router_id_list:\n                        router_id_index = router_id_list.index(router_id)\n                        value_dict = dict()\n                        value_dict.setdefault('session_status' , session_status_list[router_id_index])\n                        value_dict.setdefault('my_discriminator' , my_discriminator_list[router_id_index])\n                        value_dict.setdefault('peer_discriminator', peer_discriminator_list[router_id_index])\n                        value_dict.setdefault('tx_interval', tx_interval_list[router_id_index])\n                        value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[router_id_index])\n                        value_dict.setdefault('reply_source_address', reply_source_address_list[router_id_index])\n                        value_dict.setdefault('session_id', router_id_index + 1)\n                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)\n            else:\n                for index, router_id in enumerate(router_id_list):\n                    value_dict = dict()\n                    value_dict.setdefault('session_status', session_status_list[index])\n                    value_dict.setdefault('my_discriminator', my_discriminator_list[index])\n                    value_dict.setdefault('peer_discriminator', peer_discriminator_list[index])\n                    value_dict.setdefault('tx_interval', tx_interval_list[index])\n                    value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[index])\n                    value_dict.setdefault('reply_source_address', reply_source_address_list[index])\n                    value_dict.setdefault('session_id', index + 1)\n                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)\n        except:\n            self.log.error(\"Device Group or SRV6OAM config Not Found\")\n        return router_id_status_mapping\n\n    def set_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None,\n                                sbfd_initiator : Optional[List[str]] = None, my_discriminator: Optional[List[str]] = None,\n                                peer_discriminator: Optional[List[str]] = None, tx_interval: Optional[List[str]] = None,\n                                timeout_multiplier: Optional[List[str]] = None, reply_source_address: Optional[List[str]] = None,\n                                reply_source_address_mode: Optional[str] = None, reply_source_address_step: Optional[str] = None):\n        \"\"\"\n        The API sets the SRV6 OAM parameters like My discriminator, Peer Discriminator,\n        TX Interval, Timeout multiplier, Reply source address for the given router ids\n\n        :param device_name: SRV6OAM device name\n        :param router_ids: List of router_ids\n        :param sbfd_initiator: SRV6 OAM s-bfd_initiator to be enabled or disabled Ex : s-bfd_initiator = \"True\" or \"False\"\n        :param my_discriminator: SRV6 OAM my discriminator to be set on the device Ex : my_discriminator = [\"1000000\"]\n        :param peer_discriminator: SRV6 OAM peer discriminator to be set on the device Ex : peer_discriminator = [\"1999999\"]\n        :param tx_interval: SRV6 OAM tx interval to be set on the device Ex : tx_interval = [\"50\"]\n        :param timeout_multiplier: SRV6 OAM timeout multiplier to be set on the device Ex : timeout_multiplier = [\"3\"]\n        :param reply_source_address: SRV6 OAM reply source address to be set on the device Ex : reply_source_address = [\"5000:0:0:1:0:0:0:0\"]\n        :param reply_source_address_mode: SRV6 OAM reply source address mode type to be set Ex : reply_source_address = 'increment' or 'decrement'\n        :param reply_source_address_step: SRV6 OAM reply source address step to be set on the device Ex : reply_source_address = \"::0.0.0.1\"\n        :return: True on success else raises exception\n\n        :Example: set_srv6_oam_parameters(device_name = \"PE1\",router_ids = ['192.0.0.1','192.0.0.4','192.0.0.5'],\n                                           sbfd_initiator = ['True','False','True'],\n                                           my_discriminator = [\"100\",\"200\",\"300\"], peer_discriminator = [\"199\",\"299\",\"399\"],\n                                           tx_interval = [\"10\",\"20\",\"30\"], timeout_multiplier = [\"3\",\"6\",\"9\"],\n                                           reply_source_address = [\"1000:0:0:1:0:0:0:0\",\"2000:0:0:1:0:0:0:0\",\"3000:0:0:1:0:0:0:0\"])\n        \"\"\"\n        self.log.info(f\"Setting SRV6OAM session status for device {device_name}\")\n\n        try:\n            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()\n        except:\n            self.log.error(\"Device Group Not Found\")\n\n        if ipv6_obj.Srv6Oam.find():\n            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId\n            sbfd_initiator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Values\n            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values\n            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values\n            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values\n            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values\n            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values\n        else:\n            self.log.error(\"SRV6OAM config Not Found\")\n\n        if router_ids:\n            for index,router_id in enumerate(router_ids):\n                if router_id in router_id_list:\n                    router_id_index = router_id_list.index(router_id)\n                    if sbfd_initiator:\n                        sbfd_initiator_list[router_id_index] = sbfd_initiator[index].lower()\n                    if my_discriminator:\n                        my_discriminator_list[router_id_index] = my_discriminator[index]\n                    if peer_discriminator:\n                        peer_discriminator_list[router_id_index] = peer_discriminator[index]\n                    if tx_interval:\n                        tx_interval_list[router_id_index] = tx_interval[index]\n                    if timeout_multiplier:\n                        timeout_multiplier_list[router_id_index] = timeout_multiplier[index]\n                    if reply_source_address:\n                        reply_source_address_list[router_id_index] = reply_source_address[index]\n\n            if sbfd_initiator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.ValueList(\n                    values=sbfd_initiator_list)\n            if my_discriminator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.ValueList(\n                    values=my_discriminator_list)\n            if peer_discriminator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.ValueList(\n                    values=peer_discriminator_list)\n            if tx_interval:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.ValueList(values=tx_interval_list)\n            if timeout_multiplier:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.ValueList(\n                    values=timeout_multiplier_list)\n            if reply_source_address:\n                ipv6_obj.Srv6Oam.find().RxSrcAddr.ValueList(values=reply_source_address_list)\n        else:\n            if sbfd_initiator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Single(sbfd_initiator[0].lower())\n            if my_discriminator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Single(my_discriminator[0])\n            if peer_discriminator:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Single(peer_discriminator[0])\n            if tx_interval:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Single(tx_interval[0])\n            if timeout_multiplier:\n                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Single(timeout_multiplier[0])\n            if reply_source_address and reply_source_address_mode:\n                if reply_source_address_mode.lower() == 'increment':\n                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Increment(reply_source_address[0], reply_source_address_step)\n                elif reply_source_address_mode.lower() == 'decrement':\n                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Decrement(reply_source_address[0], reply_source_address_step)\n            if reply_source_address and not reply_source_address_mode:\n                ipv6_obj.Srv6Oam.find().RxSrcAddr.Single(reply_source_address[0])\n\n        Helper.sleep(5, msg='Waiting before applying the changes')\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)\n        return True\n\n    def _update_traffic_stream_frame_size(self, traffic_item_info: Dict, traffic_item, rate_type_dict: Dict):\n        \"\"\"\n        This is an internal API to update frame size for specific traffic item\n        :param traffic_item_info: config sent from user\n        :param traffic_item: traffic item restpy object\n        :param rate_type_dict: mapping dict to map rate type values\n        \"\"\"\n        try:\n            if traffic_item_info.get('type', None) in ['BITS_PER_SECOND', 'KILOBITS_PER_SECOND', 'MEGABITS_PER_SECOND',\n                                                       'BYTES_PER_SECOND', 'KILOBYTES_PER_SECOND',\n                                                       'MEGABYTES_PER_SECOND']:\n                traffic_item.ConfigElement.find().FrameRate.find().BitRateUnitsType = rate_type_dict[\n                    traffic_item_info['type']]\n\n                if traffic_item_info.get('rate', None):\n                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')\n\n                if traffic_item_info.get('type', None):\n                    traffic_item.ConfigElement.find().FrameRate.find().Type = 'bitsPerSecond'\n            else:\n                if traffic_item_info.get('rate', None):\n                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')\n                if traffic_item_info.get('type', None):\n                    traffic_item.ConfigElement.find().FrameRate.find().Type = rate_type_dict[\n                        traffic_item_info.get('type')]\n        except Exception as err_msg:\n            raise IxiaConfigException(f\"failed to set frame rate param. exited with error message {err_msg}\")\n\n    def modify_bulk_streams(self, cfg_dict: Dict):\n        \"\"\"\n        The API modifies frame rate (currently supported)\n        :param cfg_dict: dictionary of traffic streams along with its attributes and values to be modified\n\n        Examples:\n        cfg_dict = {'V4_SM_BSR_RP_R3_Src': {'rate': 100,'type':'FRAMES_PER_SECOND'}}\n        tgnObj.modify_bulk_streams(cfg_dict)\n\n        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'PERCENT_LINE_RATE'}}\n        tgnObj.modify_bulk_streams(cfg_dict)\n\n        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'BITS_PER_SECOND'}}\n        tgnObj.modify_bulk_streams(cfg_dict)\n        \"\"\"\n        if StubitUtil.is_stubit_playback():\n            log.info(f\"Stubit is in playback mode, skipping function {inspect.currentframe().f_code.co_name}\")\n            return\n\n        rate_type_dict = {'BITS_PER_SECOND': 'bitsPerSec', 'KILOBITS_PER_SECOND': 'kbitsPerSec',\n                          'MEGABITS_PER_SECOND': 'mbitsPerSec', 'BYTES_PER_SECOND': 'bytesPerSec',\n                          'KILOBYTES_PER_SECOND': 'kbytesPerSec', 'MEGABYTES_PER_SECOND': 'mbytesPerSec',\n                          'FRAMES_PER_SECOND': 'framesPerSecond', 'PERCENT_LINE_RATE': 'percentLineRate'}\n\n        cfg_list = [{key: value} for key, value in cfg_dict.items()]\n        for _, traffic_item_info in enumerate(cfg_list):\n            stream_name = list(traffic_item_info.keys())[0]\n            traffic_items = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name)\n            if len(traffic_items) == 0:\n                raise IxiaConfigException(\"invalid traffic stream name specified or traffic stream not found. exiting\")\n\n            with BatchUpdate(self.ixNetwork):\n                for _, traffic_item in enumerate(traffic_items):\n                    if traffic_item.Name == stream_name:\n                        config = list(traffic_item_info.values())[0]\n                        self._update_traffic_stream_frame_size(config, traffic_item, rate_type_dict)\n        return True\n\n    def save_config(self, file:str = None) -> str:\n        \"\"\"\n        This API exports the loaded config to specified JSON file\n        :param file: path name of the JSON file to be saved locally\n        :return: (str) filename with full path to which config is saved to\n        exception if error occurs\n        \"\"\"\n\n        if not file:\n            timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S')\n            file = os.path.join(CafyLog.work_dir, f\"tgnconfig-{timestamp}.json\")\n\n        if not file.endswith('.json'):\n            raise IxiaConfigException(\"Need JSON file name as part of user input\")\n\n        tgn_file_path = self.ixNetwork.Globals.ConfigFileName\n        if self.tgn_server_type == 'windows':\n            if '/' in tgn_file_path:\n                common_path = \"sdmStreamManager\\\\common\\\\\"\n                json_file = os.path.split(file)[1]\n                remote_file_path = os.path.split(tgn_file_path)[0].replace('IxNetwork', common_path) + json_file\n            elif '\\\\' in tgn_file_path:\n                tgn_file_path = tgn_file_path.replace(\"\\\\\", \"/\")\n                json_file = os.path.split(file)[1]\n                remote_file_path = os.path.split(tgn_file_path)[0] + \"/\" + json_file\n        elif self.tgn_server_type == 'linux':\n            common_path = \"sdmStreamManager/common/\"\n            json_file = os.path.split(file)[1]\n            remote_file_path = os.path.split(tgn_file_path)[0] + \"/\" + json_file\n\n        try:\n            self.ixNetwork.ResourceManager.ExportConfigFile([\"/descendant-or-self::*\"], True, \"json\", Files(json_file))\n            self.session.DownloadFile(remote_file_path, file)\n        except Exception as err_msg:\n            raise CafyException.TgenClientError(err_msg)\n\n        log.info(f'Configuration file {file} saved successfully.')\n        return file\n\n    def get_modifiers_count(self, traffic_item):\n        \"\"\"\n        Allows users to extract the Modifiers and its count in any field of Streamblock\n        :param traffic_item: Traffic Item Name (String type) for which modifiers and count is required\n        :return: Dictionary of Modifiers along with its respective count\n        \"\"\"\n        modifier_dict = {}\n        ethernet_field_dict = {'destinationAddress': 'dstMac', 'ether_type': 'etherType', 'sourceAddress': 'srcMac'}\n\n        ipv4_field_dict = {'checksum': 'checksum', 'dest_ip': 'destAddr', 'fragment_offset': 'fragOffset',\n                           'total_len': 'totalLength',\n                           'protocol': 'protocol', 'source_ip': 'sourceAddr', 'identification': 'identification',\n                           'ttl': 'ttl', 'version': 'version'}\n        ipv6_field_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit',\n                           'flowLabel': 'flowLabel', 'source_ip': 'sourceAddr', 'trafficClass': 'trafficClass',\n                           'version': 'version', 'dest_ip': 'destAddr',\n                           'nextHeader': 'nextHeader'}\n        tcp_field_dict = {'u_bit': 'urgBit', 'protocol': 'protocolType', 's_bit': 'synBit', 'r_bit': 'rstBit',\n                          'c_bit': 'cwrBit', 'p_bit': 'pshBit', 'a_bit': 'ackBit', 'f_bit': 'finBit', 'e_bit': 'ecnBit',\n                          'ack_num': 'ackNum', 'reserved': 'reserved', 'seqNum': 'seq_num', 'data_offset': 'offset',\n                          'tcp_src_prt': 'sourcePort', 'tcp_dst_prt': 'destPort',\n                          'tcp_window': 'window', 'tcp_checksum': 'checksum', 'urgent_ptr': 'urgentPtr'}\n        udp_field_dict = {'udp_src_prt': 'sourcePort', 'udp_dst_prt': 'destPort'}\n        mpls_field_dict = {'mpls_label_value': 'label', 'mpls_exp': 'exp', 'mpls_bos': 'sBit', 'mpls_ttl': 'ttl'}\n        gre_field_dict = {'sequence_present': 'seqNumPresent', 'key_present': 'keyPresent'}\n\n        regex_dict = {'ethernetii': ethernet_field_dict, 'ipv4': ipv4_field_dict, 'ipv6': ipv6_field_dict,\n                      'tcp': tcp_field_dict, 'udp': udp_field_dict, 'mpls': mpls_field_dict, 'gre': gre_field_dict}\n\n        traffic_item_modified = re.escape(traffic_item)\n        traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name=f'^{traffic_item_modified}$')\n        if not traffic_item_obj:\n            raise IxiaConfigException(\"Traffic Item not found\")\n\n        for stack in traffic_item_obj.ConfigElement.find().Stack.find():\n            stack_name = stack.DisplayName.lower().replace(' ', '')\n            stack_index=1\n            if stack_name in regex_dict.keys():\n                field_dict = regex_dict[stack_name]\n            else:\n                field_dict = {}\n\n            for stack_key in modifier_dict.keys():\n                if re.search(stack_name, stack_key):\n                    stack_index += 1\n\n            stack_name = stack_name + '_' + str(stack_index)\n            if field_dict:\n                for field in stack.Field.find():\n                    if field.ValueType in ('increment', 'decrement', 'random', 'repeatableRandomRange'):\n                        if field.Name in field_dict:\n                            modifier_dict.update({stack_name + '.' + field_dict[field.Name]: field.CountValue})\n        self.log.info(f\"Modified fields and its respective count for the Traffic Item: '{traffic_item}' is: {modifier_dict}\")\n        return modifier_dict\n\n    def change_port_aggregation_mode(self, port_list, port_mode=None):\n        \"\"\"\n        Allows users to modify Card mode of a chassis\n        :param port_list: List of ports on which port mode to be modified\n        :param port_mode:Mode to be set for port_list, if None port aggregate mode will set on HighStream of same speed\n        :return True on success otherwise return False\n        :Example:change_port_aggregation_mode(port_list=['10.39.65.236/2/3'], port_mode='1x100GE')\n        \"\"\"\n        self.log.info(f\"Changing port mode for ports: {port_list}\")\n        port_mode_dict = {'1x100GE': 'novusHundredGigNonFanOut', '4x25GE': 'novusFourByTwentyFiveGigNonFanOut',\n                          '1x40GE': 'novusOneByFortyGigNonFanOut', '4x10GE': 'novusFourByTenGigNonFanOut',\n                          '1x100GE_high': 'novusHundredGigNonFanOutHighStream',\n                          '4x25GE_high': 'novusFourByTwentyFiveGigNonFanOutHighStream',\n                          '1x40GE_high': 'novusOneByFortyGigNonFanOutHighStream',\n                          '4x10GE_high': 'novusFourByTenGigNonFanOutHighStream'}\n\n        port_aggregate_dict = {\n                          'novusHundredGigNonFanOut': 'novusHundredGigNonFanOutHighStream',\n                          'novusFourByTwentyFiveGigNonFanOut': 'novusFourByTwentyFiveGigNonFanOutHighStream',\n                          'novusOneByFortyGigNonFanOut': 'novusOneByFortyGigNonFanOutHighStream',\n                          'novusFourByTenGigNonFanOut': 'novusFourByTenGigNonFanOutHighStream'}\n\n        assigned_chassis = port_list[0].split(\"/\")[0]\n        connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find()]\n        if assigned_chassis not in connected_chassis_list:\n            self.connect_to_chassis([assigned_chassis])\n\n        for port in port_list:\n            assigned_card = port.split(\"/\")[1]\n            assigned_port = port.split(\"/\")[2]\n\n            try:\n                card_obj = self.ixNetwork.AvailableHardware.find().Chassis.find(Hostname=assigned_chassis).Card.find(CardId='^' + assigned_card + '$')\n                if not re.search(r'FAN\\D+\\d+', card_obj.Description, re.IGNORECASE):\n                    assigned_port = str(int(assigned_port) - 1)\n                if port_mode in port_mode_dict.keys():\n                    pattern = r\"\\b\" + re.escape('FAN+') + r\"\\b\"\n                    if re.search(pattern, card_obj.Description, re.IGNORECASE):\n                        port_url = card_obj.href + '/port/' + assigned_port\n                        for res_grp in card_obj.Aggregation.find():\n                            if port_url in res_grp.ResourcePorts:\n                                port_obj = res_grp\n                    else:\n                        port_url = card_obj.href + '/aggregation/' + assigned_port\n                        port_obj = card_obj.Aggregation.read(port_url)\n\n                    if port_mode_dict[port_mode] in port_obj.AvailableModes:\n                        port_obj.Mode = port_mode_dict[port_mode]\n                        self.log.info(f'Port mode modified for {port} successfully')\n                        result = True\n                    else:\n                        self.log.warning(f'{port_mode} is not supported for Port {port}')\n                        result = False\n                else:\n                    pattern = r\"\\b\" + re.escape('FAN+') + r\"\\b\"\n                    if re.search(pattern, card_obj.Description, re.IGNORECASE):\n                        port_url = card_obj.href + '/port/' + assigned_port\n                        for res_grp in card_obj.Aggregation.find():\n                            if port_url in res_grp.ResourcePorts:\n                                port_obj = res_grp\n                    else:\n                        port_url = card_obj.href + '/aggregation/' + assigned_port\n                        port_obj = card_obj.Aggregation.read(port_url)\n\n                    if port_obj.Mode in port_aggregate_dict.keys():\n                        port_obj.Mode = port_aggregate_dict[port_obj.Mode]\n                        result = True\n                        self.log.info(f'Port mode modified for {port} successfully')\n                    else:\n                        self.log.info(f'Port {port} is already in high stream mode')\n                        result = False\n\n            except:\n                self.log.error(f'Port mode is not supported {port}')\n                result = False\n        return result\n\n    def set_bgp_evi_count(self, devices, evi_count, ip_type='ipv4', nested_devices=None):\n        \"\"\"\n        API to set the BGP EVPN EVI Count\n        :param devices: List of devices for which EVI multiplier to be set\n        :param evi_count: EVI multiplier value\n        :param ip_type: IPv4/IPv6 - default is IPv4\n        :param nested_devices: List of nested devices where EVI multiplier to be set\n        :return: True on success otherwise return False\n        :Example: set_bgp_evi_count(devices=['SAP-VCP-EVPN','CSR-EVPN'],evi_count=400)\n        set_bgp_evi_count(devices='SAP-BL-Term-RAN',evi_count=100,ip_type='ipv6')\n        \"\"\"\n        self.log.info('Modifying BGP EVI Multiplier')\n        if isinstance(devices, str):\n            devices = [devices]\n        if isinstance(nested_devices,str):\n            nested_devices = [nested_devices]\n        if devices and nested_devices is None:\n            for device in devices:\n                device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n                if device_obj:\n                    try:\n                        if ip_type == 'ipv4':\n                            device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpEthernetSegmentV4.find().EvisCount = evi_count\n                        else:\n                            device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpEthernetSegmentV6.find().EvisCount = evi_count\n                    except:\n                        self.log.info(f'Multiplier Modification failed for {device_obj.Name}')\n                        return False\n                else:\n                    self.log.info(f'Device Group {device} is not found')\n                    return False\n        elif devices and nested_devices:\n            for device in devices:\n                for nested_device in nested_devices:\n                    device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(\n                        Name='^' + device + '$').NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')\n                    if device_obj:\n                        try:\n                            if ip_type == 'ipv4':\n                                device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpEthernetSegmentV4.find().EvisCount = evi_count\n                            else:\n                                device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpEthernetSegmentV6.find().EvisCount = evi_count\n                        except:\n                            self.log.info(f'Multiplier Modification failed for {device_obj.Name} ')\n                            return False\n                    else:\n                        self.log.info(f'Device Group {nested_device} in {device} is not found')\n                        return False\n        return True\n\n    def enable_bgp_evi(self, devices, enable=True, ip_type='ipv4'):\n        \"\"\"\n        API to enable the BGP Evpn EVI\n        :param devices: List of devices to be enabled\n        :param enable: True to Enable and False to disable EVI,default is True\n        :param ip_type: IPv4/IPv6,default value IPv4\n        :return: True on success otherwise return False\n        :Example: enable_bgp_evi(devices='SAP-VCP-EVPN')\n        enable_bgp_evi(devices=['SAP-VCP-EVPN','CSR-EVPN'],enable=False)\n        \"\"\"\n        self.log.info('Enable/Disable BGP EVI')\n        if isinstance(devices, str):\n            devices = [devices]\n        for device in devices:\n            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n            if device_obj:\n                try:\n                    if ip_type == 'ipv4':\n                        device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find().Active.Single(enable)\n                    else:\n                        device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find().Active.Single(enable)\n                except:\n                    self.log.info(f'Enable/Disable EVI failed for {device_obj.Name}')\n                    return False\n            else:\n                self.log.info(f'Device Group {device} not found')\n                return False\n        return True\n\n    def modify_bgp_evi_rd(self, devices, ip_type='ipv4', **kwargs):\n        \"\"\"\n        API to modify BGP EVPN RD\n        :param devices:List of devices for which RD values to be modified\n        :param ip_type:IPv4/IPv6,default value IPv4\n        :param kwargs:\n        rd_type :RD Types ip/as/as4,default is ip\n        auto_config_rd:Auto-Configure RD IP Addresses True/False,default is False\n        rd_ip: RD IP Addresses for RD device,default is 0.0.0.0\n        rd_as: RD AS Number of device,default is 100\n        rd_evi_start: RD EVI start value of device,default is 1\n        rd_evi_step: RD EVI step value of device,default is 1\n        :return:True on success otherwise return False\n        :Example: modify_bgp_evi_rd(devices=['SAP-VCP'],rd_type='as4',rd_evi_step=2,rd_ip='12.20.10.21',rd_evi_start=5,auto_config_rd=True,rd_as=40)\n        modify_bgp_evi_rd(devices='SAP-BL-Term-RAN',rd_type='as',rd_evi_step=2,ip_type='ipv6')\n        \"\"\"\n        self.log.info('Modifying BGP EVI RD values')\n        rd_type = kwargs.get('rd_type', 'ip')\n        auto_config_rd = kwargs.get('auto_config_rd', False)\n        rd_ip = kwargs.get('rd_ip', '0.0.0.0')\n        rd_as = kwargs.get('rd_as', 100)\n        rd_evi_start = kwargs.get('rd_evi_start', 1)\n        rd_evi_step = kwargs.get('rd_evi_step', 1)\n\n        if isinstance(devices, str):\n            devices = [devices]\n        for device in devices:\n            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n            if device_obj:\n                try:\n                    if ip_type == 'ipv4':\n                        rd_obj = device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find()\n                    else:\n                        rd_obj = device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find()\n\n                    rd_obj.RdType.Single(rd_type)\n                    rd_obj.RdIpAddress.Single(rd_ip)\n                    rd_obj.RdASNumber.Single(rd_as)\n                    rd_obj.AutoConfigureRdIpAddress.Single(auto_config_rd)\n                    rd_obj.RdEvi.Increment(rd_evi_start, rd_evi_step)\n                    self.log.info(f'BGP EVI RD values are modified successfully for {device_obj.Name}')\n                except:\n                    self.log.info(f'Modification of BGP EVI RD values failed for {device_obj.Name}')\n                    return False\n            else:\n                self.log.info(f'Device Group {device} not found')\n                return False\n        return True\n\n    def modify_bgp_evi_rt(self, devices, ip_type='ipv4', **kwargs):\n        \"\"\"\n        API to modify BGP EVPN RT\n        :param devices:List of devices for which RD values to be modified\n        :param ip_type:IPv4/IPv6,default value IPv4\n        :kwargs:\n        rt_kind:RT kind for which to be modified like import,l3_import,export and l3_export,default is import\n        rt_count:Number of RTs,default is 1\n        rt_type: RT Type for EVI like as/as4/ip,default is as\n        :Examples:modify_bgp_evi_rt(devices=['SAP-VCP-EVPN','CSR-EVPN'])\n        modify_bgp_evi_rt(devices=['SAP-VCP-EVPN','CSR-EVPN'],rt_count=2,rt_type='as4')\n        \"\"\"\n        self.log.info('Modifying BGP EVI RT values')\n        rt_kind = kwargs.get('rt_kind', 'export')\n        rt_count = kwargs.get('rt_count', 1)\n        rt_type = kwargs.get('rt_type', 'as')\n        rt_kind_dict = {'import': 'NumRtInImportRouteTargetList', 'export': 'NumRtInExportRouteTargetList',\n                        'l3_import': 'NumRtInL3vniImportRouteTargetList',\n                        'l3_export': 'NumRtInL3vniExportRouteTargetList'}\n        if isinstance(devices, str):\n            devices = [devices]\n        for device in devices:\n            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n            if device_obj:\n                try:\n                    if ip_type == 'ipv4':\n                        rt_obj = device_obj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIPv4EvpnEvi.find()\n                    else:\n                        rt_obj = device_obj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpIPv6EvpnEvi.find()\n\n                    if rt_kind in rt_kind_dict.keys():\n                        setattr(rt_obj, rt_kind_dict[rt_kind], rt_count)\n                        for each_rt_type in rt_obj.BgpExportRouteTargetList.find():\n                            each_rt_type.TargetType.Single(rt_type)\n                    else:\n                        self.log.info('Invalid RT Type')\n                except:\n                    self.log.info(f'Modification of BGP EVI RT attributes failed for {device_obj.Name}')\n                    return False\n            else:\n                self.log.info(f'Device Group {device} not found')\n                return False\n        return True\n\n    def get_stream_details(self, tgn_config_file: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        utility to parse ixia config in json format and get details about streams\n        1. flow type : L2 unicast, L2 mcast, L2 bcast, L3 ucast, L3 mcast, L3 bcast\n        2. encaps in the stream\n        3. flow rate : rate, rate_unit\n        4. packet size : imix/custom/fixed..\n\n        :param tgn_config_file: json file containing ixia config\n        :return : (dict) stream details\n        \"\"\"\n\n        try:\n            with open(tgn_config_file, \"r\") as inf:\n                stream_data = json.load(inf)\n        except Exception as error:\n            msg = f\"Could not parse file {tgn_config_file}. Error {str(error)}\"\n            log.error(msg)\n            raise CafyException.TgenInvalidInputError(msg) from error\n\n        stream_details = []\n        for traffic_item in stream_data[\"traffic\"][\"trafficItem\"]:\n            encap_list = []\n            temp_stream_details = {}\n            temp_stream_details[\"name\"] = traffic_item.get(\"name\", \"Unknown\")\n            for config_element in traffic_item[\"configElement\"]:\n                for encaps in config_element[\"stack\"]:\n                    xpath = encaps[\"xpath\"]\n                    encap_name = xpath.split(\" = \")[1].strip(\"'\").split(\"-\")[0]\n                    encap_list.append(encap_name)\n                    dest_addr_ip_version = None\n                    if encap_name.lower() == \"ipv4\":\n                        dest_addr_ip_version = \"ipv4\"\n                    elif encap_name.lower() == \"ipv6\":\n                        dest_addr_ip_version = \"ipv6\"\n                    elif encap_name.lower() == \"ethernet\":\n                        for field in encaps[\"field\"]:\n                            if \"ethernet.header.destinationaddress\" in field[\"xpath\"].lower():\n                                if \"valueType\" in field:\n                                    if field[\"valueType\"] in [\"increment\", \"decrement\"]:\n                                        temp_stream_details[\"l2_dest_addr\"] = field[\"startValue\"]\n                                        temp_stream_details[\"l2_dest_type\"] = Helper.get_addr_type_mac(field[\"startValue\"])\n                                    elif field[\"valueType\"] == \"valueList\":\n                                        temp_stream_details[\"l2_dest_addr\"] = \"mixed\"\n                                        temp_stream_details[\"l2_dest_type\"] = \"mixed\"\n                                    elif field[\"valueType\"] == \"repeatableRandomRange\":\n                                        temp_stream_details[\"l2_dest_addr\"] = field[\"minValue\"]\n                                        temp_stream_details[\"l2_dest_type\"] = Helper.get_addr_type_mac(field[\"minValue\"])\n                                else:\n                                    temp_stream_details[\"l2_dest_addr\"] = field[\"singleValue\"]\n                                    temp_stream_details[\"l2_dest_type\"] = Helper.get_addr_type_mac(field[\"singleValue\"])\n                    if dest_addr_ip_version:\n                        for field in encaps[\"field\"]:\n                            if \"dstip\" in field[\"xpath\"].lower():\n                                if field['singleValue'] not in [\"0.0.0.0\", \"0::0\"]:\n                                    dest_addr = field['singleValue']\n                                else:\n                                    value_type = field.get('valueType',\"fixed\")\n                                    if value_type.lower() in [\"increment\", \"decrement\"]:\n                                        dest_addr = field['startValue']\n                                    elif value_type.lower() == \"repeatableRandomRange\":\n                                        dest_addr = field['minValue']\n                                    elif value_type.lower() == \"valuelist\":\n                                        dest_addr = \"mixed\"\n                                temp_stream_details[\"l3_dst_addr\"] = dest_addr\n                                if dest_addr != \"mixed\":\n                                    temp_stream_details[\"l3_dst_addr_type\"] = Helper.get_addr_type_ipvx(dest_addr)\n                                else:\n                                    temp_stream_details[\"l3_dst_addr_type\"] = \"mixed\"\n\n                encap_list.remove(\"fcs\")\n                temp_stream_details[\"encap_list\"] = deepcopy(encap_list)\n                temp_stream_details[\"packet_size_info\"] = {}\n                psi = temp_stream_details[\"packet_size_info\"]\n                psi[\"mode\"] = config_element[\"frameSize\"].get(\"type\", \"fixed\")\n                temp_stream_details[\"traffic_rate_info\"] = {\n                    \"load\": config_element[\"frameRate\"][\"rate\"],\n                    \"load_unit\": config_element[\"frameRate\"].get(\"type\", \"linerate\")\n                }\n                psi[\"pkt_sizes\"] = []\n                psi[\"pkt_size_ratio\"] = []\n                if psi[\"mode\"].lower() == \"fixed\":\n                    psi[\"pkt_sizes\"].append(config_element[\"frameSize\"].get(\"fixedSize\", 64))\n                    psi[\"pkt_size_ratio\"].append(100)\n                elif psi[\"mode\"] in [\"increment\", \"random\"]:\n                    psi[\"pkt_sizes\"] = [\n                        config_element[\"frameSize\"][\"incrementFrom\"],\n                        config_element[\"frameSize\"][\"incrementTo\"],\n                        config_element[\"frameSize\"].get(\"incrementStep\", 1)\n                    ]\n                elif psi[\"mode\"] in [\"presetDistribution\", \"weightedPairs\"]:\n                    psi[\"mode\"] = config_element[\"frameSize\"][\"presetDistribution\"]\n                    while config_element[\"frameSize\"][\"weightedPairs\"]:\n                        psi[\"pkt_sizes\"].append(config_element[\"frameSize\"][\"weightedPairs\"].pop(0))\n                        psi[\"pkt_size_ratio\"].append(config_element[\"frameSize\"][\"weightedPairs\"].pop(0))\n                elif psi[\"mode\"].lower() == \"auto\":\n                    pass\n\n            stream_details.append(temp_stream_details)\n\n        return stream_details\n\n    def get_streamblock_preview(self, stream_name=None, count=None, startingindex=0):\n        \"\"\"\n        Retrieve the StreamBlock preview information and return a dictionary.\n        The preview data allows the user to know exactly what is being generated by a streamblock.\n\n        :param stream_name: List of Streamblock names. Default is \"all\"\n        :param count: Number of rows to preview\n        :param startingindex: Starting index (zero-based) of rows in the traffic path to preview.\n        :return: Dictionary of Streamblock of Flows containing IPv4/IPv6 Src/Dest address.\n        example: tgnObj.get_streamblock_preview(count = 2)\n                 tgnObj.get_streamblock_preview(stream_name = ['Traffic Item 2'],count = 2)\n                 tgnObj.get_streamblock_preview(stream_name = ['Traffic Item 1','Traffic Item 2'])\n        \"\"\"\n        if stream_name:\n            for traffic in stream_name:\n                trafficitems = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic + '$')\n        else:\n            trafficitems = self.ixNetwork.Traffic.TrafficItem.find()\n        result = {}\n        for trafficitem in trafficitems:\n            highlevelstream = trafficitem.HighLevelStream.find()\n            output = highlevelstream.PreviewFlowPackets(0, 0)\n            item_name = trafficitem.Name\n            traffic_result = {'numflows': 0}\n            flow = output.get('arg1')\n            traffic_result['numflows'] = flow\n            flow_data = {}\n            if flow >= 500:\n                count = 500\n            elif count is None:\n                count = flow\n            else:\n                count = count\n            for i in range(count):\n                output = highlevelstream.PreviewFlowPackets(i, 1)\n                packet_data = output['arg4'][0]\n                header_fields = output['arg3']\n                udp_source_port = None\n                tcp_source_port = None\n                tcp_dest_port = None\n                udp_dest_port = None\n                ipv4_source = None\n                ipv6_source = None\n                ipv4_dest = None\n                ipv6_dest = None\n                if 'UDP-Source-Port' in header_fields:\n                    udp_source_port = packet_data[header_fields.index('UDP-Source-Port')]\n                if 'UDP-Dest-Port' in header_fields:\n                    udp_dest_port = packet_data[header_fields.index('UDP-Dest-Port')]\n                if 'TCP-Source-Port' in header_fields:\n                    tcp_source_port = packet_data[header_fields.index('TCP-Source-Port')]\n                if 'TCP-Dest-Port' in header_fields:\n                    tcp_dest_port = packet_data[header_fields.index('TCP-Dest-Port')]\n                source = packet_data[output['arg3'].index('Source Address')]\n                dest = packet_data[output['arg3'].index('Destination Address')]\n                if source:\n                    if ipaddress.ip_address(source).version == 4:\n                        ipv4_source = source\n                    elif ipaddress.ip_address(source).version == 6:\n                        ipv6_source = source\n                if dest:\n                    if ipaddress.ip_address(dest).version == 4:\n                        ipv4_dest = dest\n                    elif ipaddress.ip_address(dest).version == 6:\n                        ipv6_dest = dest\n                packet_info = {}\n                if udp_source_port:\n                    packet_info['UdpSourceport'] = udp_source_port\n                if udp_dest_port:\n                    packet_info['UdpDestinationport'] = udp_dest_port\n                if tcp_source_port:\n                    packet_info['TcpSourceport'] = tcp_source_port\n                if tcp_dest_port:\n                    packet_info['TCPDestinationport'] = tcp_dest_port\n                if ipv4_source:\n                    packet_info['IPv4.Source'] = ipv4_source\n                if ipv6_source:\n                    packet_info['IPv6.Source'] = ipv6_source\n                if ipv4_dest:\n                    packet_info['IPv4.Destination'] = ipv4_dest\n                if ipv6_dest:\n                    packet_info['IPv6.Destination'] = ipv6_dest\n                if packet_info:\n                    flow_data[i + 1] = packet_info\n            result[item_name] = {'numflows': count}\n            result[item_name].update(flow_data)\n        return result\n\n    def start_topology(self, topo_name):\n        \"\"\"\n        API to start the devices , nested devices under the topology\n\n        :param topo_name: Name of the topology\n        :return: True if successful\n                raise exception if Topology not found in config\n        :Example: start_topology(['Topology 1','Topology 2'])\n                  start_topology('Topology 1')\n        \"\"\"\n        self.log.info(f\"Starting protocols on Topology {topo_name}\")\n        timeout = 180\n        result = False\n        if isinstance(topo_name, str):\n            topo_name = [topo_name]\n        for topo in topo_name:\n            try:\n                topo = re.escape(topo)\n                if self.ixNetwork.Topology.find(Name=topo):\n                    topo_obj = self.ixNetwork.Topology.find(Name=topo)\n                    topo_obj.Start()\n                    for _ in range(1, timeout):\n                        topo_obj = self.ixNetwork.Topology.find(Name=topo)\n                        if topo_obj.Status in ['started']:\n                            self.log.info(f\"All Devices Started Successfully under Topology: {topo}\")\n                            result = True\n                            break\n                        else:\n                            time.sleep(1)\n                    if not result:\n                        if topo_obj.Status in ['mixed']:\n                            self.log.info(\"Few Devices are not started Yet..\")\n                else:\n                    self.log.error(f'Topology: {topo} Not found')\n                    return False\n            except Exception as err:\n                raise IxiaConfigException(f'Start Topology failed due to Exception - {err}')\n        return True\n\n    def stop_topology(self, topo_name):\n        \"\"\"\n        API to stop the devices , nested devices under the topology\n\n        :param topo_name: Name of the topology\n        :return: True if successful\n                raise exception if Topology not found in config\n        :Example: stop_topology(['Topology 1','Topology 2'])\n                  stop_topology('Topology 3')\n        \"\"\"\n        self.log.info(f\"Stopping protocols on Topology {topo_name}\")\n        timeout = 180\n        result= False\n        if isinstance(topo_name, str):\n            topo_name = [topo_name]\n        for topo in topo_name:\n            try:\n                topo = re.escape(topo)\n                if self.ixNetwork.Topology.find(Name= topo):\n                    topo_obj = self.ixNetwork.Topology.find(Name=topo)\n                    topo_obj.Stop()\n                    for _ in range(1, timeout):\n                        topo_obj = self.ixNetwork.Topology.find(Name= topo)\n                        if topo_obj.Status in ['notStarted']:\n                            self.log.info(f\"All Devices Stopped Successfully under Topology: {topo}\")\n                            result = True\n                            break\n                        else:\n                            time.sleep(1)\n                    if not result:\n                        if topo_obj.Status in ['mixed']:\n                            self.log.info(\"Few Devices are not stopped Yet..\")\n                else:\n                    self.log.error(f'Topology: {topo} Not found')\n                    return False\n            except Exception as err:\n                raise IxiaConfigException(f'Stop Topology failed due to Exception - {err}')\n        return True\n\n    def modify_ip_arp_ns(self, arp_rate=200, arp_interval=200, arp_max=1000, ns_rate=200, ns_interval=1000, ns_max=400,\n                         resend_ns=True, resend_arp=True, **kwargs):\n        \"\"\"\n        Set ARP and Ns parameters\n\n        :param arp_rate:(int/str) arp rate per interval\n        :param arp_interval: arp interval (ms)\n        :param arp_max: max outstanding value\n        :param ns_rate: Ns rate per interval\n        :param ns_interval: Ns interval(ms)\n        :param ns_max: max outstanding value\n        :param resend_ns: resend ns after linkup (True/False)\n        :param resend_arp: resend arp after linkup (True/False)\n\n        :return: True if successful\n\n        :Example: tgnObj.modify_ip_arp_ns(arp_rate =100, arp_interval =300, arp_max= 500)\n                  tgnObj.modify_ip_arp_ns(ns_rate =100, ns_interval =300, ns_max= 500)\n        \"\"\"\n        self.log.info(f\"Modifying ARP per port Values as arp_rate: {arp_rate}, arp_interval: {arp_interval}, arp_max: {arp_max}\")\n        self.log.info(f\"Modifying NS per port Values as ns_rate: {ns_rate}, ns_interval: {ns_interval}, ns_max: {ns_max}\")\n        globals = self.ixNetwork.Globals.find().Topology.find()\n        if resend_arp:\n            globals.Ipv4.find().ReSendArpOnLinkUp.Single(resend_arp)\n        if resend_ns:\n            globals.Ipv6.find().ReSendNsOnLinkUp.Single(resend_ns)\n        if arp_rate or arp_interval or arp_max:\n            arp_obj = globals.Ipv4.find().ArpRate\n            self.log.info(\"Enabling Arp rate at port level\")\n            arp_obj.Enabled.Single(True)\n            if arp_rate:\n                arp_obj.Rate.Single(arp_rate)\n            if arp_interval:\n                arp_obj.Interval.Single(arp_interval)\n            if arp_max:\n                arp_obj.MaxOutstanding.Single(arp_max)\n        if ns_rate or ns_interval or ns_max:\n            ns_obj = globals.Ipv6.NsRate\n            self.log.info(\"Enabling NS rate at port level\")\n            ns_obj.Enabled.Single(True)\n            if ns_rate:\n                ns_obj.Rate.Single(ns_rate)\n            if ns_interval:\n                ns_obj.Interval.Single(ns_interval)\n            if ns_max:\n                ns_obj.MaxOutstanding.Single(ns_max)\n        return True\n\n    def enable_rsvp_tunnel(self, tunnel_type, device, **kwargs):\n        \"\"\"\n        Enable RSVP tunnel Ingress/Egress\n\n        :param device: Device Name\n        :param tunnel_type: Ingress/Egress\n        :param kwargs:\n        nested_device:  Nested device name\n        enable_rsvp: True/False to activate/deactivate rsvp\n\n        :return: True if successfull else raises exception\n        \n        :Example: enable_rsvp_tunnel(device = 'R2_T1_2',tunnel_type=\"Ingress\",nested_device = 'R2_T1_2_Tunnels',enable_rsvp = False)\n                  enable_rsvp_tunnel(device = 'R2_T1_2',tunnel_type=\"egress\")\n        \"\"\"\n        nested_device = kwargs.get('nested_device')\n        enable_rsvp = kwargs.get('enable_rsvp', True)\n        dev_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')\n        if not dev_obj:\n            raise IxiaConfigException (f\"Given Device: {device} is not found in the existing config\")\n        if device and not nested_device:\n            self.log.info(f\"Enable RSVP tunnel on {device}\")\n            if dev_obj.Ethernet.find().Ipv4.find():\n                if dev_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                    rsvp_if_obj = dev_obj.Ethernet.find().Ipv4.find().RsvpteLsps.find()\n            elif dev_obj.Ipv4Loopback.find():\n                if dev_obj.Ipv4Loopback.find().RsvpteLsps.find():\n                    rsvp_if_obj = dev_obj.Ipv4Loopback.find().RsvpteLsps.find()\n            if tunnel_type.lower() == \"ingress\":\n                tunnel_obj = rsvp_if_obj.RsvpP2PIngressLsps.find()\n            else:\n                tunnel_obj = rsvp_if_obj.RsvpP2PEgressLsps.find()\n            tunnel_obj.Active.Single(enable_rsvp)\n\n        elif device and nested_device:\n            self.log.info(f\"Enable RSVP tunnel on {device} and {nested_device}\")\n            if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$'):\n                if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find():\n                    if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                        rsvp_if_obj = dev_obj.NetworkGroup.find().DeviceGroup.find(\n                            Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find()\n                elif dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ipv4Loopback.find():\n                    if dev_obj.NetworkGroup.find().DeviceGroup.find(Name= '^' + nested_device + '$').Ipv4Loopback.find().RsvpteLsps.find():\n                        rsvp_if_obj = dev_obj.NetworkGroup.find().DeviceGroup.find(\n                            Name= '^' + nested_device + '$').Ipv4Loopback.find().RsvpteLsps.find()\n            elif dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$'):\n                if dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find():\n                    if dev_obj.DeviceGroup.find(Name= '^' + nested_device + '$').Ethernet.find().Ipv4.find().RsvpteLsps.find():\n                        rsvp_if_obj = dev_obj.DeviceGroup.find(\n                            Name=nested_device).Ethernet.find().Ipv4.find().RsvpteLsps.find()\n                elif dev_obj.DeviceGroup.find(Name=nested_device).Ipv4Loopback.find():\n                    if dev_obj.DeviceGroup.find(Name=nested_device).Ipv4Loopback.find().RsvpteLsps.find():\n                        rsvp_if_obj = dev_obj.DeviceGroup.find(\n                            Name=nested_device).Ipv4Loopback.find().RsvpteLsps.find()\n            else:\n                raise IxiaConfigException(f\"Given Device: {nested_device} is not found in the existing config\")\n            if tunnel_type.lower() == \"ingress\":\n                tunnel_obj = rsvp_if_obj.RsvpP2PIngressLsps.find()\n            else:\n                tunnel_obj = rsvp_if_obj.RsvpP2PEgressLsps.find()\n            tunnel_obj.Active.Single(enable_rsvp)\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n        return True\n\n    def get_bgp_routeblock_names(self, device=None, **kwargs):\n        \"\"\"\n        API to get BGP RouteBlock names along with StartIpList, PrefixLength, NetworkCount, Active for given device\n        :param device: String/List of the devices for which Routeblock params required\n        :return: Dictionary of Routeblock names along with corresponding values\n        Ex:- tgn.get_bgp_routeblock_names() or tgn.get_bgp_routeblock_names(device='Device 1')\n        \"\"\"\n        nested_ng = kwargs.get('nested_ng', None)\n        device_display = kwargs.get('device_display', False)\n        ipv4_route_block_handles = []\n        ipv6_route_block_handles = []\n        result_dict = {}\n        if not device:\n            for network_handle in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():\n                if network_handle.Ipv4PrefixPools.find():\n                    if network_handle.Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                        ipv4_route_block_handles.append(network_handle)\n                elif network_handle.Ipv6PrefixPools.find():\n                    if network_handle.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():\n                        ipv6_route_block_handles.append(network_handle)\n\n        else:\n            if isinstance(device, str):\n                device = [device]\n            for each in device:\n                device_handle = None\n                device_name = re.escape(each)\n                if self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name):\n                    device_handle = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)\n                else:\n                    device_object = self.ixNetwork.Topology.find().DeviceGroup.find()\n                    if device_object.NetworkGroup.find().DeviceGroup.find(Name=device_name):\n                        device_handle = device_object.NetworkGroup.find().DeviceGroup.find(Name=device_name)\n                if not device_handle:\n                    raise CafyException.TgenConfigMissingError(f\"Device {each} not present in configuration\")\n                for network_handle in device_handle.NetworkGroup.find():\n                    if network_handle.Ipv4PrefixPools.find():\n                        if network_handle.Ipv4PrefixPools.find().BgpIPRouteProperty.find():\n                            ipv4_route_block_handles.append(network_handle)\n                    if network_handle.Ipv6PrefixPools.find():\n                        if network_handle.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():\n                            ipv6_route_block_handles.append(network_handle)\n\n        if not ipv4_route_block_handles and not ipv6_route_block_handles:\n            raise CafyException.TgenConfigMissingError(\"No Routeblock exists in configuration\")\n        bgpipv4_dict = {}\n        if ipv4_route_block_handles:\n            for each in ipv4_route_block_handles:\n                bgpipv4_dict.update({each.Name: {}})\n                bgp_ipv4_route_obj = each.Ipv4PrefixPools.find()\n                if bgp_ipv4_route_obj:\n                    bgpipv4_dict[each.Name].update({'StartIpList': bgp_ipv4_route_obj.NetworkAddress.Values})\n                    bgpipv4_dict[each.Name].update({'PrefixLength': bgp_ipv4_route_obj.PrefixLength})\n                    bgpipv4_dict[each.Name].update(\n                        {'Active': bgp_ipv4_route_obj.BgpIPRouteProperty.find().Active})\n                    bgpipv4_dict[each.Name].update(\n                        {'PrefixIncrementPerRoute': bgp_ipv4_route_obj.PrefixAddrStep})\n                    bgpipv4_dict[each.Name].update({'RouteCount': bgp_ipv4_route_obj.NumberOfAddressesAsy.Values})\n\n        bgpipv6_dict = {}\n        if ipv6_route_block_handles:\n            for each in ipv6_route_block_handles:\n                bgpipv6_dict.update({each.Name: {}})\n                bgp_ipv6_route_obj = each.Ipv6PrefixPools.find()\n                if bgp_ipv6_route_obj:\n                    bgpipv6_dict[each.Name].update({'StartIpList': bgp_ipv6_route_obj.NetworkAddress.Values})\n                    bgpipv6_dict[each.Name].update({'PrefixLength': bgp_ipv6_route_obj.PrefixLength})\n                    bgpipv6_dict[each.Name].update(\n                        {'Active': bgp_ipv6_route_obj.BgpV6IPRouteProperty.find().Active})\n                    bgpipv6_dict[each.Name].update(\n                        {'PrefixIncrementPerRoute': bgp_ipv6_route_obj.PrefixAddrStep})\n                    bgpipv6_dict[each.Name].update({'RouteCount': bgp_ipv6_route_obj.NumberOfAddressesAsy.Values})\n\n        result_dict = {**bgpipv4_dict, **bgpipv6_dict}\n        if device_display:\n            if not nested_ng:\n                nested_ng = list(result_dict.keys())[0]\n            if nested_ng in result_dict:\n                route_detail_dict = {}\n                device_count = len(result_dict[nested_ng]['StartIpList'])\n                # prefix_values = self._process_bgp_routeblock_values(result_dict[nested_ng], 'PrefixLength',device_count)\n\n                prefix_values = (\n                    list(result_dict[nested_ng]['PrefixLength'].Values)\n                    if hasattr(result_dict[nested_ng]['PrefixLength'], \"Values\")\n                    else [str(result_dict[nested_ng]['PrefixLength'])] * device_count\n                                )\n\n                active_values = (\n                    list(result_dict[nested_ng]['Active'].Values)\n                    if hasattr(result_dict[nested_ng]['Active'], \"Values\")\n                    else [str(result_dict[nested_ng]['Active'])] * device_count\n                                )\n\n                increment_values = (\n                    list(result_dict[nested_ng]['PrefixIncrementPerRoute'].Values)\n                    if hasattr(result_dict[nested_ng]['PrefixIncrementPerRoute'], \"Values\")\n                    else [str(result_dict[nested_ng]['PrefixIncrementPerRoute'])] * device_count\n                                    )\n\n                route_count_list = self._process_bgp_routeblock_values(result_dict[nested_ng], 'RouteCount',\n                                                                       device_count)\n\n                for device in range(device_count):\n                    device_num = device+1\n                    route_detail_dict.update({device_num:{}})\n                    route_detail_dict[device_num].update({'StartIpList':[result_dict[nested_ng]['StartIpList'][device]]})\n                    route_detail_dict[device_num].update({'PrefixLength':prefix_values[device]})\n                    route_detail_dict[device_num].update({'Active':str(active_values[device])})\n                    route_detail_dict[device_num].update({'PrefixIncrementPerRoute':increment_values[device]})\n                    route_detail_dict[device_num].update({'RouteCount': route_count_list[device]})\n                    # route_detail_dict[device_num].update({'RouteCount': str(route_count_list[device])})\n                result_dict = route_detail_dict\n        return result_dict\n\n    def _process_bgp_routeblock_values(self, routeblock_info, key, device_count):\n        \"\"\"\n        It helps to process routeblock values\n        :param routeblock_info:routeblock info of Network Group\n        :param key:Parameters of BGP Routeblock\n        :param device_count:Device Count of Network Group\n        :return:field_values_list in form list\n        \"\"\"\n        routeblock_key_list = ['PrefixLength','Active','PrefixIncrementPerRoute']\n        field_value = routeblock_info[key]\n        if str(field_value).startswith('List'):\n            field_values_list = re.findall(r'\\d+|True|true|False|false', str(field_value))\n            if key in routeblock_key_list:\n                if not len(field_values_list) > 1:\n                    field_values_list = field_values_list * device_count\n            elif key == 'RouteCount':\n                field_values_list = field_values_list[1:]\n        elif str(field_value).startswith('Inc'):\n            start_value, step_value = re.findall(r'\\d+|True|False|true|false', str(field_value))\n            field_values_list = [int(start_value) + int(step_value) * device for device in range(device_count)]\n        else:\n            if key == 'RouteCount':\n                field_values_list = field_value\n            else:\n                field_values_list = [str(field_value)] * device_count\n        return field_values_list\n\n    def delete_routeblocks(self, protocol=None, routeblock_name=None):\n        \"\"\"\n            This API allows user to delete BGP Routeblocks\n\n            :param protocol: String of protocol bgp/isis/ospfv2/ospfv3/igmp/mld\n            :param routeblock_name: String/List of Routeblock Names which needs to be deleted\n            Ex:- tgn.delete_routeblocks(routeblock_name=['Routeblock1', 'Routeblock2', 'Routeblock3'])\n        \"\"\"\n\n        if not routeblock_name:\n            raise CafyException.InvalidValueError(\"No Routeblock name provided which is mandate\")\n        if isinstance(routeblock_name, str):\n            routeblock_name = [routeblock_name]\n        dev_obj = self.ixNetwork.Topology.find().DeviceGroup.find()\n        network_objs = [each.Name for each in dev_obj.NetworkGroup.find() if each]\n        for routeblock in routeblock_name:\n            if routeblock not in network_objs:\n                self.log.error(f'Network Group: {routeblock} Not found')\n        for device in dev_obj:\n            for routeblock in routeblock_name:\n                routeblock_modified = re.escape(routeblock)\n                network_obj = device.NetworkGroup.find(Name=routeblock_modified)\n                if network_obj:\n                    try:\n                        network_obj.remove()\n                        self.log.info(f\"{routeblock} Deleted succesfully\")\n                    except Exception as err:\n                        raise IxiaConfigException(f'Delete routeblock failed due to: {err}')\n\n    def get_rsvp_lsp_stats(self, tunnel_type='egress'):\n        \"\"\"\n        API to get RSVP-TE sessions UP count\n\n        :param tunnel_type: egress/ingress default its egress\n        :return: A dictionary of total egress/ingress lsp_up\n        :Example : tgnObj.get_rsvp_lsp_stats(tunnel_type='ingress')\n        \"\"\"\n        self.log.info(\"Getting stats values for rsvp\")\n        flow_stats = self.get_stats(view_name='RSVPTE-IF Per Port')\n        if flow_stats:\n            rsvpte_df = pd.DataFrame.from_dict(flow_stats, orient='index')\n            rsvpte_df.index = range(1, len(rsvpte_df) + 1)\n            rsvpte_df_columns = list(rsvpte_df.columns)\n            rsvp_stat_table = tabulate.tabulate(rsvpte_df, headers=rsvpte_df_columns, tablefmt=\"grid\")\n            self.log.info(f\"flow_stats: \\n{rsvp_stat_table}\")\n            output = {}\n            if tunnel_type.lower() == \"egress\":\n                egress_field_dict = {'Egress LSPs Up': 'total_egress_lsp_up',\n                                     'Egress SubLSPs Up': 'total_egress_sub_lsp_up',\n                                     'Session Flap Count': 'total_engress_flap_count', 'Paths Tx': 'egress_path_tx',\n                                     'Paths Rx': 'egress_path_rx',\n                                     'Path Tears Tx': 'egress_tears_tx', 'Path Tears Rx': 'egress_tears_rx',\n                                     'LSP Self Ping Received by Egress': 'egress_ping_received',\n                                     'LSP Self Ping Forwarded by Egress': 'egress_ping_forwarded'}\n                field_dict = egress_field_dict\n            else:\n                ingress_field_dict = {'Ingress LSPs Up': 'total_ingress_lsp_up',\n                                      'Ingress LSPs Configured': 'total_ingress_lsp_configured',\n                                      'Ingress SubLSPs Configured': 'total_ingress_sub_lsp_configured',\n                                      'Ingress SubLSPs Up': 'total_ingress_sub_lsp_up',\n                                      'Session Flap Count': 'total_ingress_flap_count', 'Paths Tx': 'ingress_path_tx',\n                                      'Paths Rx': 'ingress_path_rx',\n                                      'Path Tears Tx': 'ingress_tears_tx', 'Path Tears Rx': 'ingress_tears_rx',\n                                      'LSP Self Ping Sent from Ingress': 'ingress_ping_sent',\n                                      'LSP Self Ping Received by Ingress': 'ingress_ping_received'}\n                field_dict = ingress_field_dict\n\n            for field, value in field_dict.items():\n                ingress_df = rsvpte_df.astype({field: 'int'})\n                output[value] = int(ingress_df[field].sum())\n\n        return output\n\n    def get_port_status(self, port_list=None, reboot=False):\n        \"\"\"\n        Get port status information(Port, portStatus) for each port\n\n        :param port_list: list of ports (10.39.65.156/2/12)\n        :param reboot: Default reboot will be False. If user wants to reboot the port input will be reboot=True\n        :return: dict with port status\n\n        :Example: tgnObj.get_port_status(port_list = ['10.39.65.156/2/12','10.39.65.156/2/13'],reboot= True)\n        \"\"\"\n        link_status = {}\n        if port_list:\n            self.log.info(f\"Checking port status for {port_list}\")\n            for name in port_list:\n                assigned = name.replace('/', ':')\n                vport = self.ixNetwork.Vport.find(AssignedTo=assigned)\n                if vport:\n                    vport_state = vport.State\n                    vport_connectionstate = vport.ConnectionState\n                    vport_name = vport.AssignedTo.replace(':', '/')\n                    if vport.ConnectionState == 'unassigned':\n                        vport_name = vport.Name\n                    self.log.info(f\"Port : {vport_name}, State: {vport_state}, ConnectionStatus : {vport_connectionstate}\")\n                    if reboot:\n                        if vport.ConnectionState == 'connectedLinkDown':\n                            self.log.info(f\"Rebooting the port {vport_name}\")\n                            vport.ResetPortCpuAndFactoryDefault()\n                            time.sleep(2)\n                    link_status[vport_name] = vport_state\n                else:\n                    self.log.warning(f\"Port: {name} not found.\")\n        else:\n            self.log.info(\"Checking Port status for all available ports\")\n            for vport in self.ixNetwork.Vport.find():\n                vport_state = vport.State\n                vport_connectionstate = vport.ConnectionState\n                vport_name = vport.AssignedTo.replace(':', '/')\n                if vport.ConnectionState == 'unassigned':\n                    vport_name = vport.Name\n                self.log.info(f\"Port : {vport_name}, State: {vport_state}, ConnectionStatus : {vport_connectionstate}\")\n                if reboot:\n                    if vport.ConnectionState == 'connectedLinkDown':\n                        self.log.info(f\"Rebooting the port {vport_name}\")\n                        vport.ResetPortCpuAndFactoryDefault()\n                        time.sleep(2)\n                    link_status[vport_name] = vport_state\n                link_status[vport_name] = vport_state\n        return link_status\n    def copy_cert_files(self, device_name,  **kwargs):\n        \"\"\"\n            Copy and update files(.pem) for DotOneX\n\n            :param device_name: Device Group name\n            :return: True. raise exception if False/error\n\n            :Example: copy_cert_files(\"Device group 3\")\n                    copy_cert_files(\"Device Group 3\",private_key = 'client-key-private.pem')\n        \"\"\"\n        private_key = kwargs.get('private_key', 'client-key.pem')\n        certificate_file = kwargs.get('certificate_file', 'client.pem')\n        ca_certificate_file = kwargs.get('ca_certificate_file', 'ca.pem')\n        certificate_dir = kwargs.get('certificate_dir', self.ixNetwork.Globals.PersistencePath)\n        local_path = kwargs.get('local_path', CafyLog.work_dir)\n        server_type = kwargs.get('server_type', 'linux')\n        local_file_path = ''\n        device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().DotOneX.find()\n        if device_obj:\n            try:\n                if certificate_dir:\n                    path = self.ixNetwork.Globals.PersistencePath\n                    device_obj.CertDir.String(path)\n                if private_key:\n                    if server_type == 'windows':\n                        path = self.ixNetwork.Globals.PersistencePath + '\\\\' + private_key\n                    elif server_type == 'linux':\n                        path = self.ixNetwork.Globals.PersistencePath + '/' + private_key\n                    local_file_path = local_path + '/' + private_key\n                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)\n                    if upload_file['files'][0]['name'] == private_key:\n                        device_obj.PrivateKey.String(private_key)\n                        self.log.info(f\"{private_key} file copied successfully\")\n                    else:\n                        self.log.warning(f\"Failed to copy {private_key} file \")\n                if certificate_file:\n                    if server_type == 'windows':\n                        path = self.ixNetwork.Globals.PersistencePath + '\\\\' + certificate_file\n                    elif server_type == 'linux':\n                        path = self.ixNetwork.Globals.PersistencePath + '/' + certificate_file\n                    local_file_path = local_path + '/' + certificate_file\n                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)\n                    if upload_file['files'][0]['name'] == certificate_file:\n                        device_obj.PeerCert.String(certificate_file)\n                        self.log.info(f\"{certificate_file} file copied successfully\")\n                    else:\n                        self.log.warning(f\"Failed to copy {certificate_file} file \")\n                if ca_certificate_file:\n                    if server_type == 'windows':\n                        path = self.ixNetwork.Globals.PersistencePath + '\\\\' + ca_certificate_file\n                    elif server_type == 'linux':\n                        path = self.ixNetwork.Globals.PersistencePath + '/' + ca_certificate_file\n                    local_file_path = local_path + '/' + ca_certificate_file\n                    upload_file = self.session.UploadFile(local_file_path, remote_filename=path)\n                    if upload_file['files'][0]['name'] == ca_certificate_file:\n                        device_obj.CaCert.String(ca_certificate_file)\n                        self.log.info(f\"{ca_certificate_file} file copied successfully\")\n                    else:\n                        self.log.warning(f\"Failed to copy {ca_certificate_file} file \")\n\n            except Exception as err_msg:\n                self.log.error(f'copying files failed as: {err_msg}')\n        else:\n            self.log.error(f'Device Group {device_name} is not found')\n            return False\n        return True\n\n    def _get_protocol_stats(self):\n        \"\"\"\n        This is an internal API helps to get protocol stats info\n\n        return: port level protocol status\n        \"\"\"\n        self.log.info('Getting Protocol details during traffic failure')\n        protocol_info_list = ['Index', 'Protocol Type', 'Sessions Up', 'Sessions Down',\n                              'Sessions Not Started', 'Sessions Total']\n        protocol_status_dict = dict()\n\n        try:\n            protocol_summary = self.get_stats(view_name=\"Protocols Summary\")\n        except Exception as err_msg:\n            self.log.error(f'Protocols are not configured {err_msg}')\n            return False\n\n        if protocol_summary:\n            for _, proto_summary in protocol_summary.items():\n                protocol = proto_summary['Protocol Type']\n                protocol_status_dict.update({protocol: {}})\n                for protocol_info in protocol_info_list:\n                    if protocol_info in proto_summary.keys():\n                        protocol_status_dict[protocol].update({protocol_info: proto_summary[protocol_info]})\n        temp_summary = [protocol_summary[key] for key in protocol_summary]\n        extracted_summary = [{key: field[key] for key in field if key in protocol_info_list} for field in temp_summary]\n        summary_dataframe = pd.DataFrame(extracted_summary)\n        summary_dataframe.index = range(1, len(extracted_summary) + 1)\n        protocol_stat_table = tabulate.tabulate(summary_dataframe, headers=protocol_info_list, tablefmt=\"grid\")\n        self.log.info(f'\\n{protocol_stat_table}')\n        return protocol_stat_table\n\n    def _get_port_stats(self):\n        \"\"\"\n        This is an internal API helps to get port stats information\n\n            return: port status\n        \"\"\"\n        self.log.info('Getting Port details during traffic failure')\n        port_info_list = ['Index', 'Stat Name', 'Port Name', 'Line Speed', 'Link State']\n        port_status_dict = dict()\n\n        try:\n            port_stats = self.get_stats(view_name=\"Port Statistics\")\n        except Exception as err_msg:\n            self.log.error(f'Failed to fetch Port Statistics {err_msg}')\n            return False\n        if port_stats:\n            for _, port_stat in port_stats.items():\n                port_name = port_stat[\"Port Name\"]\n                port_status_dict.update({port_name: {}})\n                for port_info in port_info_list:\n                    if port_info in port_stat.keys():\n                        port_status_dict[port_name].update({port_info: port_stat[port_info]})\n            temp_stats = [port_stats[key] for key in port_stats]\n            extracted_summary = [{key: field[key] for key in field if key in port_info_list} for field in temp_stats]\n            summary_dataframe = pd.DataFrame(extracted_summary)\n            summary_dataframe.index = range(1, len(extracted_summary) + 1)\n            port_stat_table = tabulate.tabulate(summary_dataframe, headers=port_info_list, tablefmt=\"grid\")\n            self.log.info(f'\\n{port_stat_table}')\n        return port_status_dict\n\n    def _get_traffic_rate(self, result_dataset=None):\n        \"\"\"\n        Get tx/rx rate, l1rate, fps, count and rxduplicatecount for each streamblock\n\n        :param result_dataset: streamblock results' dataset\n        :return: tx/rx rate, l1rate, fps, count and rxduplicatecount streamblocks as a dict\n        \"\"\"\n        stream_rate_dict = {}\n        stats = self.get_stats(view_name=\"Traffic Item Statistics\")\n\n        for flow,value in stats.items():\n            stream_rate_dict[value['Traffic Item']] = value\n\n        for _, value in stream_rate_dict.items():\n            value.update({\"txrate\" : value['Tx Rate (bps)']})\n            value.update({\"txl1rate\": value['Tx L1 Rate (bps)']})\n            value.update({\"txfps\": value['Tx Frame Rate']})\n            value.update({\"txcount\": value['Tx Frames']})\n\n            value.update({\"rxrate\" : value['Rx Rate (bps)']})\n            value.update({\"rxl1rate\": value['Rx L1 Rate (bps)']})\n            value.update({\"rxfps\": value['Rx Frame Rate']})\n            value.update({\"rxcount\": value['Rx Frames']})\n\n        # list to remove excess keys as per customer request\n        rem_list = ['First TimeStamp', 'Frames Delta', 'Last TimeStamp', 'Loss %', 'Packet Loss Duration (ms)',\n                    'Rx Bytes', 'Rx Frame Rate', 'Rx Rate (Kbps)', 'Rx Rate (Mbps)','Traffic Item','Tx Rate (bps)',\n                    'Rx Rate (Bps)', 'Tx Frame Rate', 'Tx Frames', 'Tx L1 Rate (bps)', 'Tx Rate (Bps)',\n                    'Tx Rate (Kbps)', 'Tx Rate (Mbps)','Store-Forward Avg Latency (ns)','Store-Forward Max Latency (ns)',\n                    'Store-Forward Min Latency (ns)','Rx Frames','Rx Rate (bps)','Rx L1 Rate (bps)']\n        for _, flow in stream_rate_dict.items():\n            for key in rem_list:\n                if key in flow.keys():\n                    del flow[key]\n\n        return stream_rate_dict\n\n    def add_multiple_traffic_streams_scale(self, traffic_info=None, **kwargs):\n        \"\"\"\n        API to create traffic streams based on input. User can either pass csv file or can pass a dictionary with config parameters\n\n        :param traffic_info: dictionary with config details\n\n        Example 1: Below example creates multicast destination from ipv6 device group\n        traffic_info = [{'stream_name': 'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv6_mc',\n        'stream_type': 'Multicast', 'traffic_type': 'ipv6', 'stream_src': 'IPv6 Device Group 1',\n        'vlan': '', 'frame_size': '128',\n        'multicast_address': 'ff03::2', 'bi-directional': 'FALSE',\n        'Groupname(multicast) (Eg: ipv4Group1)': '', 'Increment(Multicast)(Eg: 3:1)': '255.255.255.255', 'txLoad(%)': '100',\n        'tolerance(%)': '', 'tcp_header': '', 'tcp_src_port': '', 'tcp_dst_port': '', 'udp_header': 'TRUE',\n        'udp_src_port': '2000', 'udp_dst_port': '3000', 'throughput(%)': '', 'tos': 220, 'raw_stream_ip_stack': ''}]\n        add_multiple_traffic_streams(traffic_info=traffic_info)\n        Return : True\n        \"\"\"\n        trafficitem_number = 1\n        cfg_dict = {}\n        scale_traffic = ScaleTraffic(ixnetwork=self.ixNetwork)\n        exists_traffic_item_count = scale_traffic.return_existing_trafficitem_count()\n        trafficitem_number += exists_traffic_item_count\n        factors = list(range(trafficitem_number, trafficitem_number + len(traffic_info)))\n        with ThreadPoolExecutor() as executor:\n            results = list(executor.map(scale_traffic.add_multiple_traffic_streams, traffic_info, factors))\n        self.ixNetwork.ResourceManager.ImportConfig(json.dumps(results), False)\n        for each_traffic in traffic_info:\n            if each_traffic.get('tos'):\n                traffic_item_list = [each_traffic[\"stream_name\"]]\n                if isinstance(each_traffic['tos'], list):\n                    cfg_dict = {'displayName': 'precedence', 'valueType': 'valueList',\n                                'valueList': each_traffic['tos']}\n                elif isinstance(each_traffic['tos'], str):\n                    cfg_dict = {'displayName': 'precedence', 'valueType': 'singleValue',\n                                'singleValue': each_traffic['tos']}\n                thread = threading.Thread(target=self.change_ipv4_tos, args=(cfg_dict, traffic_item_list,))\n                thread.start()\n                thread.join()\n            if each_traffic.get('ipv4_precedence_full_mesh'):\n                self.ixNetwork.Traffic.TrafficItem.find(\n                    Name=each_traffic[\"stream_name\"]).ConfigElement.find().Stack.find(DisplayName=\"IPv4\"). \\\n                    Field.find(DisplayName='Precedence').FullMesh = each_traffic['ipv4_precedence_full_mesh']\n        return True\n\n    def get_ip_stack_status(self, device_group_name=None, ip_version='ipv4', display_table=True):\n        \"\"\"\n        API to retrieve the IP stack status (Up/Down/Not Started) for devices in specified device group(s).\n\n        :param device_group_name: (str or list) Device group name(s) to filter on. If None, fetches all.\n        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.\n        :param display_table: (bool) If True, prints a formatted table to the console. Default is False.\n\n        :return: Table with device group, Total IPs, IP Version, Statuses\n\n        :Example:\n            tgnObj.get_ip_stack_status(device_group_name=\"@#Device Group 1$%\")\n            tgnObj.get_ip_stack_status(device_group_name=[\"Device Group 1\", \"Device Group 2\"])\n        \"\"\"\n        assert ip_version.lower() in ['ipv4', 'ipv6'], \"Invalid IP version. Use 'ipv4' or 'ipv6'.\"\n        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'\n\n        if isinstance(device_group_name, list):\n            pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'\n        elif isinstance(device_group_name, str):\n            pattern = re.escape(device_group_name)\n        else:\n            pattern = '.*'\n\n        result_summary = {}\n        try:\n            for topology in self.ixNetwork.Topology.find():\n                for device_grp in topology.DeviceGroup.find(Name=pattern):\n                    eth_list = device_grp.Ethernet.find()\n                    if not eth_list:\n                        self.log.warning(f\"No Ethernet found in device group '{device_grp.Name}'\")\n                        continue\n\n                    ip_status_map = {}\n                    status_counter = defaultdict(int)\n\n                    for eth in eth_list:\n                        ip_stacks = getattr(eth, stack_attr).find()\n                        for ip_stack in ip_stacks:\n                            for i, ip_addr in enumerate(ip_stack.Address.Values):\n                                status = ip_stack.SessionStatus[i] if i < len(ip_stack.SessionStatus) else 'unknown'\n                                norm = status.strip().lower()\n                                ip_status_map[ip_addr] = status\n                                status_counter[\n                                    'notstarted' if 'notstarted' in norm or 'not started' in norm else\n                                    'up' if 'up' in norm else\n                                    'down' if 'down' in norm else\n                                    'unknown'\n                                ] += 1\n\n                    result_summary[device_grp.Name] = {\n                        'total_ips': len(ip_status_map),\n                        'IP version': ip_version.lower(),\n                        'up': status_counter['up'],\n                        'down': status_counter['down'],\n                        'not started': status_counter['notstarted'],\n                        'unknown': status_counter['unknown'],\n                        'ip_status_map': ip_status_map\n                    }\n\n            if display_table and result_summary:\n                self.log.info(f\"\"\"\\n{tabulate.tabulate(\n                    [[device_grp, d['total_ips'], d['IP version'], d['up'], d['down'], d['not started']]\n                     for device_grp, d in result_summary.items()],\n                    headers=['Device Group', 'Total IPs', 'IP Version', 'Up', 'Down', 'Not Started'],tablefmt='grid')}\"\"\")\n\n        except Exception as err:\n            self.log.exception(f\"Unexpected error: {err}\")\n        return result_summary\n\n    def restart_ip_stack(self, device_group_name=None, ip_version='ipv4', max_retries=25):\n        \"\"\"\n        API that RestartDown all IPs that are in 'Down' or 'Not Started' state within the given device group(s).\n\n        :param device_group_name: str or list of device group names to \"restartDown\" the IPs\n        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.\n        :param max_retries: number of retries for the \"restartDown\"\n        \"\"\"\n        interval_sec, max_threads, chunk_size = 5, 10, 500\n        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'\n        assert ip_version.lower() in ['ipv4', 'ipv6'], \"Invalid IP version. Use 'ipv4' or 'ipv6'.\"\n\n        def _chunked(seq, size):\n            return (seq[i:i + size] for i in range(0, len(seq), size))\n\n        def _build_summary(stats):\n            return {\n                device_grp: {\n                    \"Total IPs\": d['total_ips'], \"IP Version\": ip_version,\n                    \"Up\": d['up'], \"Down\": d['down'], \"Not Started\": d['not started']\n                } for device_grp, d in stats.items()\n            }\n\n        stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n        restartable_ips = {\n            ip_addr: status for d in stats.values()\n            for ip_addr, status in d['ip_status_map'].items()\n            if status.strip().lower() in ['down', 'notstarted', 'not started']\n        }\n\n        if not restartable_ips:\n            self.log.success(f\"All {ip_version.upper()} IPs are already UP.\")\n            summary = _build_summary(stats)\n            return summary\n\n        count_down = sum(1 for s in restartable_ips.values() if s.strip().lower() == 'down')\n        count_notstarted = len(restartable_ips) - count_down\n        self.log.warning(f\"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED\")\n\n        if isinstance(device_group_name, list):\n            pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'\n        elif isinstance(device_group_name, str):\n            pattern = re.escape(device_group_name)\n        else:\n            pattern = '.*'\n\n        dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)\n        ip_stack_refs = {\n            ip_addr: ip_stack\n            for device_grp in dgs for eth in device_grp.Ethernet.find()\n            for ip_stack in getattr(eth, stack_attr).find()\n            for ip_addr in ip_stack.Address.Values\n            if ip_addr in restartable_ips\n        }\n\n        unique_stacks = list(set(ip_stack_refs.values()))\n        self.log.info(\"Checking for any ongoing protocol actions\")\n        restart_stack = lambda s: s.RestartDown()\n        # self.ixNetwork.Topology().find().protocolActionInProgress\n        \n\n        for attempt in range(1, max_retries + 1):\n            pdb.set_trace()\n            self.log.debug(f\"RETRY {attempt}/{max_retries}: Restarting {len(unique_stacks)} stacks...\")\n            for chunk in _chunked(unique_stacks, chunk_size):\n                with ThreadPoolExecutor(max_workers=max_threads) as executor:\n                    list(executor.map(restart_stack, chunk))\n                time.sleep(interval_sec)\n\n            updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n            all_status = {\n                ip_addr: status for d in updated.values() for ip_addr, status in d['ip_status_map'].items()\n            }\n            restartable_ips = {\n                ip_addr: s for ip_addr, s in restartable_ips.items()\n                if all_status.get(ip_addr, 'unknown').strip().lower() != 'up'\n            }\n\n            if not restartable_ips:\n                self.log.success(f\"All IPs are UP after '{attempt}' attempt(s).\")\n                break\n\n        summary = _build_summary(self.get_ip_stack_status(device_group_name, ip_version, display_table=True))\n\n        if restartable_ips:\n            self.log.fail(f\"{len(restartable_ips)} IPs remained DOWN or NOT STARTED after {max_retries} retries.\")\n        return summary\n\n    def modify_receive_ports(self, traffic_list=None, ports=None):\n        \"\"\"\n        This method allows you to modify receive ports under a streamblock.\n        :param traffic_list: List of the traffic streams to be modified\n        :param ports: list of Rx ports\n        :example: tgn.modify_receive_ports(traffic_list=['Stream1'],ports=['1/2','1/1'])\n        :return: True if successful\n        \"\"\"\n        if not traffic_list or not ports:\n            self.log.error(\"Both traffic_list and ports must be provided\")\n            return False\n\n        try:\n            vport_href_list = []\n            for port_name in ports:\n                vport_match = self.ixNetwork.Vport.find(Name=port_name)\n                if not vport_match:\n                    self.log.warning(f\"Port '{port_name}' not found in config, skipping\")\n                    continue\n                vport_href_list.append(vport_match.Protocols.find().href)\n\n            if not vport_href_list:\n                self.log.error(\"No valid RX ports found in config\")\n                return False\n\n            for ti_name in traffic_list:\n                ti_match = self.ixNetwork.Traffic.TrafficItem.find(Name=ti_name)\n                if not ti_match:\n                    self.log.warning(f\"Traffic Item '{ti_name}' not found, skipping\")\n                    continue\n\n                if ti_match[0].TrafficType != \"raw\":\n                    self.log.debug(f\"Traffic Item '{ti_name}' is not 'raw', skipping\")\n                    continue\n\n                for endpoint in ti_match[0].EndpointSet.find():\n                    self.log.info(f\"Updating RX ports for '{ti_name}' to {ports}\")\n                    endpoint.update(Destinations=vport_href_list)\n            self.ixNetwork.Traffic.Apply()\n            self.log.info(\"RX ports updated successfully for given traffic items\")\n            return True\n        except Exception as e:\n            self.log.error(f\"Failed to modify RX ports: {e}\")\n            return False\n\n    def rocve2_flow_config(self, enable=True, flow_group_name='all', burst_mode=\"continuous\", burst_count=1):\n        \"\"\"\n        Enable/disable RoCEv2 streams by flow group name(s) using BulkUpdateStreams.\n\n        :param enable: True/False to enable or disable\n        :param flow_group_name: 'all', a single stream name (str), or a list of flow group names\n        :param burst_mode: By default continuous, options - 'fixed'/'continuous'\n        :param burst_count: To set burst count (int)\n\n        Example: rocve2_flow_config(enable=True,flow_group_name=['RoCEv2 Flow Group 1','RoCEv2 Flow Group 2','RoCEv2 Flow3'],burst_mode='fixed')\n        \"\"\"\n        self.log.info(\"Configuring RoCEv2 Flow Groups Parameters\")\n\n        if enable == True and flow_group_name:\n            self.log.info(\"Globally Enabling RoCEv2\")\n            self.ixNetwork.Traffic.find().RoceV2Traffic.find().Enabled = enable\n\n        elif enable == False and flow_group_name == 'all':\n            self.log.info(\"Globally Disabling RoCEv2\")\n            self.ixNetwork.Traffic.find().RoceV2Traffic.find().Enabled = enable\n\n        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()\n        if flow_group_name == 'all':\n            rocve2_find_streams = rocev2.RoceV2Stream.find()\n\n        elif isinstance(flow_group_name, str):\n            rocve2_find_streams = rocev2.RoceV2Stream.find(Name='^' + flow_group_name + '$')\n\n        elif isinstance(flow_group_name, (list, tuple)):\n            all_streams = rocev2.RoceV2Stream.find()\n            rocve2_find_streams = [s for s in all_streams if s.Name in flow_group_name]\n\n        else:\n            raise ValueError(\"flow_group_name must be 'all', a string, or a list of strings\")\n\n        valid_modes = {\"continuous\", \"fixed\"}\n        if burst_mode not in valid_modes:\n            self.log.warning(f\"[RoCEv2] Invalid burst_mode '{burst_mode}' - defaulting to 'continuous'. Valid options: {valid_modes}\")\n            burst_mode = \"continuous\"\n\n        arg2_payload = []\n        for stream in rocve2_find_streams:\n            stream_id = int(stream.href.split('/')[-1])\n            arg2_payload.append({\"arg1\": stream_id,\"arg2\": enable,\"arg3\": burst_mode,\"arg4\": burst_count})\n\n        if arg2_payload:\n            rocev2.BulkUpdateStreams(Arg2=arg2_payload)\n            if flow_group_name == 'all':\n                self.log.info(f\"Successfully updated ALL flow groups count={len(rocve2_find_streams)}\"\n                              f\"to enable={enable}, mode={burst_mode}, burst={burst_count}\")\n\n            elif isinstance(flow_group_name, (list, tuple)):\n                self.log.info(f\"Successfully updated flow group(s) {flow_group_name} \"\n                              f\"to enable={enable}, mode={burst_mode}, burst={burst_count}\")\n\n            elif isinstance(flow_group_name, str):\n                self.log.info(f\"Successfully updated flow group [{flow_group_name}] \"\n                              f\"to enable={enable}, mode={burst_mode}, burst={burst_count}\")\n        else:\n            self.log.error(\"No streams matched the given flow_group_name\")\n        return True\n\n    def rocve2_port_config(self, tx_port_name='all', **kwargs):\n        \"\"\"\n        Configure RoCEv2 ports by tx port(s).\n\n        :param tx_port_name: by default 'all', a single port name (str), or a list of port names\n        :param kwargs: Optional arguments\n                inter_batch_value: change values of Inter Batch Period Value (int)\n                inter_batch_units: change values of Inter Batch Period Value | options: str(microseconds | milliseconds | nanoseconds | seconds)\n                target_rate: change Target Line Rate In Percent (int)\n                tx_ctrl: change Transmission Control mode | str(interBatchPeriod | targetLineRate)\n\n        Example: rocve2_port_config(tx_port_name=['D12-R1-FH-0/8/0/7','D12-R1-FH-0/8/0/6'],tx_ctrl='interBatchPeriod',target_rate='50')\n        \"\"\"\n        inter_batch_value = kwargs.get('inter_batch_value', None)\n        inter_batch_units = kwargs.get('inter_batch_units', None)\n        target_rate = kwargs.get('target_rate', None)\n        tx_ctrl = kwargs.get('tx_ctrl', None)\n\n        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()\n        self.log.info(\"Configuring RoCEv2 Tx Port Parameters\")\n\n        if tx_port_name == 'all':\n            rocve2_find_ports = rocev2.RoceV2PortConfig.find()\n\n        elif isinstance(tx_port_name, str):\n            rocve2_find_ports = rocev2.RoceV2PortConfig.find(TxPort='^' + tx_port_name + '$')\n\n        elif isinstance(tx_port_name, (list, tuple)):\n            all_ports = rocev2.RoceV2PortConfig.find()\n            rocve2_find_ports = [s for s in all_ports if s.TxPort in tx_port_name]\n        else:\n            raise ValueError(\"Tx_name must be 'all', a string, or a list of strings\")\n\n        for port in rocve2_find_ports:\n            if inter_batch_value is not None:\n                port.InterBatchPeriodValue = inter_batch_value\n            if inter_batch_units is not None:\n                port.InterBatchPeriodUnits = inter_batch_units\n            if target_rate is not None:\n                port.TargetLineRateInPercent = target_rate\n            if tx_ctrl is not None:\n                port.TxCtrlParam = tx_ctrl\n\n            self.log.info(f\"Updated RoCEv2 Port Config for {port.TxPort}\")\n        return True\n\n    def rocve2_start_traffic(self):\n        \"\"\"\n        Start RoCEv2 traffic for the enabled streams\n\n        Example: ApData.TGEN.rocve2_start_traffic()\n        \"\"\"\n        state = self.ixNetwork.Traffic.find().State\n        if state == 'unapplied':\n            self.log.info(\"Applying RoCEv2 Traffic changes\")\n            self.ixNetwork.Traffic.find().Apply()\n\n        self.ixNetwork.Traffic.find().Start()\n        self.log.info(\"Traffic Started for all enabled RoCEv2 flow groups\")\n        return True\n\n    def rocve2_stop_traffic(self):\n        \"\"\"\n        Stop RoCEv2 traffic for the running flow groups.\n\n        Example: ApData.TGEN.rocve2_start_traffic()\n        \"\"\"\n        self.ixNetwork.Traffic.find().Stop()\n        self.log.info(\"RoCEv2 Traffic has been stopped for all running flow groups\")\n        return True\n\n    def delete_ports(self, port_list='all'):\n        \"\"\"\n        Deletes list of ports if provided else all the ports in the session\n\n        :param port_list: List of ports to be remove from the session,Defualt is all\n        :return: True on success\n        :Example: delete_ports(port_list=['Ethernet - 001'])\n                  delete_ports(port_list=['2/7'])\n                  delete_ports(port_list=['10.39.65.156/2/7'])\n        \"\"\"\n        return self._delete_ports(port_list=port_list)\n\n    def _delete_ports(self, port_list='all'):\n        \"\"\"\n        Deletes list of ports if provided else all the ports in the session\n        Along with the ports the topology associated to the ports will also be deleted\n\n        :param port_list: List of ports to be remove from the session\n        :return: True on success\n        \"\"\"\n        port_to_topology_map = {}\n        all_topologies = self.ixNetwork.Topology.find()\n        for topology in all_topologies:\n            for port in topology.Ports:\n                port_to_topology_map[port] = topology\n        self.log.success(\"Port - Topology Map built.\")\n\n        deleted_topologies = set()\n        for vport_obj in self.ixNetwork.Vport.find():\n            if vport_obj.Name in port_list:\n                try:\n                    vport_href = vport_obj.href\n                    vport_name = vport_obj.Name\n                    self.log.info(f\"\\nProcessing port: '{vport_name}' (handle: {vport_href})\")\n\n                    # Find and delete the associated topology first.\n                    topology_to_delete = port_to_topology_map.get(vport_href)\n                    if topology_to_delete and topology_to_delete.Name not in deleted_topologies:\n                        topo_name = topology_to_delete.Name\n                        self.log.info(f\"Found associated topology: '{topo_name}'. Deleting it first...\")\n                        topology_to_delete.remove()\n                        deleted_topologies.add(topo_name)\n                        self.log.success(f\"Topology '{topo_name}' deleted.\")\n\n                    # delete the vport.\n                    self.log.info(f\"Deleting vPort: '{vport_name}'...\")\n                    vport_obj.remove()\n                    self.log.success(f\"vPort '{vport_name}' deleted.\")\n                except Exception as e:\n                    self.log.exception(f\"Error occurred processing a port: {e}\")\n        return True\n\n    def _is_connected(self,chassis_ip):\n        \"\"\"\n        Internal function used by chassis_connection_status to get chassis state\n\n        :param chassis_ip: Chassis information\n        :return: True if chassis connected in the session else False\n        \"\"\"\n        if self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + chassis_ip + '$'):\n            if self.ixNetwork.AvailableHardware.Chassis.find(Hostname='^' + chassis_ip + '$').State == 'ready':\n                self.log.info(f\"{chassis_ip} chassis is connected in the session\")\n                return True\n        else:\n            self.log.info(f\"{chassis_ip} chassis is not connected in the session\")\n            return False\n\n    def chassis_connection_status(self, chassis_ip):\n        \"\"\"\n        Get Boolean connected status of the specified chassis.\n\n        :param chassis_ip: Chassis information\n        :return: True if chassis connected in the session else False\n        \"\"\"\n        self.log.info(f\"Checking connection status of the Chassis {chassis_ip}\")\n        return self._is_connected(chassis_ip)\n\n    def set_port_mode(self, port_name,\n                      port_mode=\"starFourHundredGigLanFcoe\",\n                      ieee_mode=\"ieee802.1Qbb\",\n                      pfc_queue_group_size=\"4\",\n                      pfc_priority_map=None,\n                      enable_pfc_delay=False,\n                      delay_quanta=\"1\"):\n        \"\"\"\n        Set a vport's L1 settings to FCoE mode safely.\n\n        :param port_name: Name of the vport (string)\n        :param port_mode: port mode to be set\n        :param ieee_mode: port IEEE mode to be set\n        :param pfc_queue_group_size: Port Priority Group Size\n        :param pfc_priority_map: PFC Priority Group\n        :param enable_pfc_delay: PFC Delay\n        :param delay_quanta: PFC Delay Quanta\n\n        :Available Port Modes supported -\n                     - str(ethernet | ethernetvm | ethernetcm | novusmini | novusminipro | ethernetFcoe | atm | pos |\n                           tenGigLan | tenGigLanFcoe | fortyGigLan | fortyGigLanFcoe | tenGigWan | tenGigWanFcoe | hundredGigLan |\n                           hundredGigLanFcoe | tenFortyHundredGigLan | tenFortyHundredGigLanFcoe | fc | ethernetImpairment |\n                           novusHundredGigLan | novusHundredGigLanFcoe | novusTenGigLan | novusTenGigLanFcoe | krakenFourHundredGigLan |\n                           krakenFourHundredGigLanFcoe | aresOneFourHundredGigLan | aresOneFourHundredGigLanFcoe | uhdOneHundredGigLan |\n                           novus5GTenTwentyFiveGigLan | novus5GTenTwentyFiveGigLanFcoe | starFourHundredGigLan | starFourHundredGigLanFcoe |\n                           ravenEightHundredGigLan | ravenEightHundredGigLanFcoe | aresOneEightHundredGigLanQddC | aresOneEightHundredGigLanQddCFcoe |\n                           sertHundredGigLan | aresOneEightHundredGigLanOsfpC | aresOneEightHundredGigLanOsfpCFcoe | aresOneM | aresOneMFcoe)\n\n        :Example: set_port_mode(port_name=\"1/1\", port_mode= starFourHundredGigLanFcoe',pfc_queue_group_size=4,pfc_priority_map = [1,2,-1,4,1,2,3,4])\n\n        :return: True if successful, False otherwise\n        \"\"\"\n        try:\n            vport = self.ixNetwork.Vport.find(Name=f'^{re.escape(port_name)}$')\n            if len(vport) != 1:\n                self.log.error(f\"[{port_name}] Vport not found or not unique.\")\n                return False\n\n            vport_l1 = vport.L1Config.find()\n            if vport_l1.CurrentType != port_mode:\n                self.log.debug(f\"[{port_name}] Switching L1 CurrentType: {vport_l1.CurrentType} -> {port_mode}\")\n                vport_l1.update(CurrentType=port_mode)\n                vport_l1 = vport.L1Config.find()\n                if vport_l1.CurrentType != port_mode:\n                    self.log.error(f\"[{port_name}] Failed to set FCoE mode. Reported: {vport_l1.CurrentType}\")\n                    return False\n                self.log.info(f\"[{port_name}] L1 CurrentType set to {vport_l1.CurrentType}\")\n\n            type_name = vport_l1.CurrentType.replace(\"Fcoe\", \"\")\n            try:\n                type_node = getattr(vport_l1, type_name[0].upper() + type_name[1:]).find()\n                fcoe = type_node.Fcoe.find()\n            except AttributeError as err:\n                self.log.error(f\"[{port_name}] Could not resolve FCoE node under L1Config. {err}\")\n                return False\n\n            if ieee_mode == \"ieee802.1Qbb\":\n                try:\n                    fcoe.FlowControlType = ieee_mode\n                    fcoe.PfcQueueGroupSize = f\"pfcQueueGroupSize-{pfc_queue_group_size}\"\n                    fcoe.PfcQueueGroups = pfc_priority_map\n                    fcoe.EnablePFCPauseDelay = bool(enable_pfc_delay)\n                    fcoe.PfcPauseDelay = str(delay_quanta)\n                    self.log.info(f\"[{port_name}] Configured in {ieee_mode} with PFC fields applied.\")\n                except Exception as inner_e:\n                    self.log.error(f\"[{port_name}] Failed to apply PFC settings: {inner_e}\")\n                    return False\n            elif ieee_mode == \"ieee802.3x\":\n                try:\n                    fcoe.FlowControlType = ieee_mode\n                    self.log.info(f\"[{port_name}] Configured in {ieee_mode} (basic flow control, no PFC).\")\n                except Exception as inner_e:\n                    self.log.error(f\"[{port_name}] Failed to apply ieee802.3x flow control: {inner_e}\")\n                    return False\n            else:\n                self.log.error(\n                    f\"[{port_name}] Invalid ieee_mode '{ieee_mode}'. Must be 'ieee802.1Qbb' or 'ieee802.3x'.\")\n                return False\n            return True\n\n        except Exception as err:\n            self.log.exception(f\"[{port_name}] Error setting DCB: {err}\")\n            return False\n\n    def diagnostics_cleanup(self, server_ip, username, password):\n        \"\"\"\n        Cleans up diagnostics and log files on a remote IxNetwork API server.\n\n        Connects to the IxNetwork REST API server and triggers the Diagnostics > Cleanup\n        subsystem to remove logs and profiles older than 1 day. This helps reclaim disk space\n        and reset diagnostics for long-running or shared servers.\n\n        :param server_ip: IP address or hostname of the IxNetwork server.\n        :param username: Username for server authentication.\n        :param password: Password for server authentication.\n        :return: None\n        \"\"\"\n        self.log.info(f\"Connecting to IxNetwork server {server_ip} for cleanup...\")\n        try:\n            # Create a standalone RESTPy session\n            session = SessionAssistant(\n                IpAddress=server_ip,\n                UserName=username if username else \"admin\",\n                Password=password if password else \"admin\",\n                RestPort=11009,\n                SessionName=None,\n                ClearConfig=False)\n\n            ixnetwork = session.Ixnetwork\n            cleanup = ixnetwork.Globals.Diagnostics.Cleanup.find()\n\n            for each in cleanup:\n                each.ChassisDaysOld = 1\n                each.ClientDaysOld = 1\n                each.CleanupChassis = True\n                each.CleanupClient = True\n                each.ProfileAllprofiles = True\n                each.ProfileAes = True\n                each.ProfileHlapi = True\n                each.ProfileAnalyzer = True\n                each.ProfileQuicktests = True\n                each.ProfileImpairment = True\n                each.ProfileIxloadlite = True\n                each.ProfileMiddleware = True\n                each.ProfileStackmanager = True\n                each.ProfileStatviewerreporter = True\n\n            cleanup.CleanupLogs()\n            ixnetwork.Globals.Diagnostics.Cleanup.ClientDaysOld = 1\n            ixnetwork.Globals.Diagnostics.Cleanup.CleanupClient = True\n            ixnetwork.Globals.Diagnostics.Cleanup.ProfileAllprofiles = True\n            ixnetwork.Globals.Diagnostics.Cleanup.CleanupLogs()\n            self.log.success(f\"Cleanup completed on {server_ip}\")\n            # terminate the session\n            session.Session.remove()\n        except:\n            pass\n\n    def health_check(self, server_list={}, **kwargs):\n        \"\"\"\n        Performs a comprehensive health check across multiple IxNetwork API servers.\n\n        For each IxNetwork Web API server, the API:\n        - Authenticates and retrieves an API key.\n        - Fetches the current session dashboard and resource utilization (CPU, Memory, Disk).\n        - Optionally displays the dashboard and inactive session table.\n        - Triggers automatic cleanup if disk/memory usage exceed thresholds.\n\n        :param server_list: A list of IxNetwork servers, each containing: {\"ip\": \"<server_ip>\",\"username\": \"<username>\",\"password\": \"<password>\"}\n        :param kwargs:\n                show_dashboard: (kwarg) Boolean flag to display per-server session dashboard.\n                show_inactive: (kwarg) Boolean flag to list inactive sessions older than `max_days`.\n                cleanup_logs: (kwarg) Boolean flag to trigger diagnostics cleanup when thresholds exceed.\n                max_days: (kwarg) Integer threshold in days for session inactivity detection. Default = 2.\n                max_memory_usage: (kwarg) Integer max allowed memory usage in percent. Default = 70.\n                max_disk_usage: (kwarg) Integer max allowed disk usage in percent. Default = 100.\n\n        :Example: health_check(server_list=[{'ip':'10.1.2.3', 'username': 'test','password': '***'}], show_dashboard= True, show_inactive = True)\n                  health_check(server_list=[{\"ip\": \"10.6.74.5\", \"username\": \"admin\", \"password\": \"***\"}], show_dashboard=True, show_inactive=True,\n                  cleanup_logs=True, max_days=3, max_memory_usage=75, max_disk_usage=90)\n        :return: None\n        \"\"\"\n        # Toggle this flag to enable/disable dashboard output\n        show_dashboard = kwargs.get('show_dashboard', False)\n        show_inactive = kwargs.get('show_inactive', False)\n        cleanup_logs = kwargs.get(\"cleanup_logs\",False)\n        max_days = kwargs.get('max_days', 2)\n        max_memory_usage = kwargs.get('max_memory_usage', 70)\n        max_disk_usage = kwargs.get('max_disk_usage', 100)\n\n        def get_api_key(server_ip, creds):\n            \"\"\"\n            Authenticates to the IxNetwork Web API server and retrieves an API key.\n\n            :param server_ip: IxNetwork server IP or hostname.\n            :param creds: Dictionary with 'username' and 'password'.\n            :return: API key string if successful, None otherwise.\n            \"\"\"\n            url = f\"https://{server_ip}/api/v1/auth/session\"\n            headers = {\"content-type\": \"application/json\"}\n            try:\n                response = requests.post(url, data=json.dumps(creds), headers=headers, verify=False)\n                response.raise_for_status()\n                return response.json()[\"apiKey\"]\n            except Exception as err:\n                self.log.error(f\" Failed to authenticate to {self.server_ip}: {err}\")\n                return None\n\n        def get_dashboard(server_ip, api_key):\n            \"\"\"\n            Retrieves the IxNetwork Web API session dashboard summary.\n\n            :param server_ip: IxNetwork server IP or hostname.\n            :param api_key: Valid IxNetwork API key.\n            :return: List of active session details from the dashboard.\n            \"\"\"\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n            payload = {\n                \"arg1\": \"/api/v1/sessions/9999/ixnetworkglobals/currentuser\"\n            }\n            url = f\"https://{server_ip}/api/v1/sessions/9999/ixnetworkglobals/currentuser/operations/getsessiondashboardsummary\"\n\n            try:\n                response = requests.post(url, headers=headers, json=payload, verify=False, timeout=10)\n                response.raise_for_status()\n                return response.json().get(\"result\", [])\n            except Exception as err:\n                self.log.error(f\" Failed to fetch dashboard from {self.server_ip}: {err}\")\n                return False\n\n        def display_dashboard_table(dashboard, server_ip):\n            \"\"\"\n            Displays the IxNetwork session dashboard in a formatted table view.\n\n            :param dashboard: Dashboard data as a list of session dicts.\n            :param server_ip: Server IP where the dashboard was fetched from.\n            :return: None\n            \"\"\"\n            if not dashboard:\n                self.log.error(\"No session dashboard data available.\")\n                return False\n\n            headers = [\n                \"Session ID\", \"PID\", \"Login Name\", \"Config File Name\", \"Session Start Time\",\n                \"Session Status\", \"Protocol Status\", \"Protocol Detailed Status\", \"Traffic Status\", \"Age (Days)\"\n            ]\n\n            table = []\n            now = datetime.datetime.now()\n\n            for session in dashboard:\n                start_time_str = session.get(\"SessionStartTime\", \"\")\n                age_days = \"\"\n\n                if start_time_str:\n                    try:\n                        start_time = datetime.datetime.strptime(start_time_str, \"%m/%d/%Y %I:%M:%S %p\")\n                        age_days = (now - start_time).days\n                    except Exception:\n                        age_days = \"?\"\n\n                table.append([\n                    session.get(\"SessionId\"),\n                    session.get(\"Pid\"),\n                    session.get(\"LoginName\"),\n                    session.get(\"ConfigFileName\"),\n                    start_time_str,\n                    session.get(\"SessionStatus\"),\n                    session.get(\"ProtocolStatus\"),\n                    session.get(\"ProtocolDetailedStatus\"),\n                    session.get(\"TrafficStatus\"),\n                    age_days\n                ])\n\n            self.log.info(f\"IxNetwork Web API Server {server_ip} Session Dashboard:\")\n            self.log.info(f\"\\n {tabulate.tabulate(table, headers=headers, tablefmt='grid')}\")\n\n        def check_status(url,api_key):\n\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n\n            for _ in range(500):\n                response = requests.get(url,headers= headers, verify = False)\n                if response.json().get(\"state\") == \"SUCCESS\":\n                    break\n                else:\n                    time.sleep(2)\n                    continue\n\n        def create_temp_session(server_ip, api_key):\n            \"\"\"\n            Create a temporary IxNetwork Session to get session id.\n\n            :param server_ip: IxNetwork server IP or hostname.\n            :param api_key: Valid IxNetwork API key.\n            :return: Session ID.\n            \"\"\"\n\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n            payload = {\"applicationType\": \"ixnrest\", \"Name\": \"health_check_temp\"}\n\n            url = f\"https://{server_ip}/api/v1/sessions\"\n            try:\n                #create session\n                response1 = requests.post(url, headers=headers, data=json.dumps(payload), verify=False, timeout=10)\n                response1.raise_for_status()\n                id = response1.json()[\"id\"]\n\n            except Exception as err:\n                self.log.error(f\" Failed to create temp session on {server_ip}: {err}\")\n                return None\n            \n            payload2 = {\"applicationType\": \"ixnrest\"}\n            try:\n                #start session\n                url2 = f\"https://{server_ip}/api/v1/sessions/{id}/operations/start\"\n                response2 = requests.post(url2, headers=headers, data=json.dumps(payload2), verify=False, timeout=10)\n                response2.raise_for_status()\n\n            except Exception as err:\n                self.log.error(f\" Failed to start temp session on {id}: {err}\")\n                return None\n\n            get_url = response2.json().get(\"url\")\n            check_status(get_url, api_key)\n            return id\n\n        def delete_temp_session(server_ip, api_key, session_id):\n            \"\"\"\n            Deletes the temporary IxNetwork Session.\n\n            :param server_ip: IxNetwork server IP or hostname.\n            :param api_key: Valid IxNetwork API key.\n            :param session_id: Session ID of the session you want to delete.\n\n            \"\"\"\n\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n            payload2 = {\"applicationType\": \"ixnrest\"}\n\n            try:\n                #stop session\n                url2 = f\"https://{server_ip}/api/v1/sessions/{session_id}/operations/stop\"\n                response2 = requests.post(url2, headers=headers, data=json.dumps(payload2), verify=False, timeout=10)\n                response2.raise_for_status()\n\n            except Exception as err:\n                self.log.error(f\" Failed to start temp session on {id}: {err}\")\n                return None\n            \n            get_url = response2.json().get(\"url\")\n            check_status(get_url, api_key)\n\n            url = f\"https://{server_ip}/api/v1/sessions/{session_id}\"\n            try:\n            #delete session\n                requests.delete(url, headers=headers, verify=False, timeout=10)\n            except Exception as e:\n                raise e\n\n        def get_ixnetwork_version(server_ip,api_key,session_id):\n\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n\n            url = f\"https://{server_ip}/api/v1/sessions/{session_id}/ixnetwork/globals/\"\n\n            response = requests.get(url,headers= headers, verify = False)\n            version = response.json().get(\"protocolbuildNumber\") \n            return version\n\n        def get_resource_monitor(server_ip, api_key, session_id):\n            \"\"\"\n            Retrieves system resource statistics (Disk, CPU, Memory) for a given session.\n\n            :param server_ip: IxNetwork server IP or hostname.\n            :param api_key: Valid IxNetwork API key.\n            :param session_id: Active IxNetwork session ID.\n            :return: Dictionary containing system resource details.\n            \"\"\"\n            headers = {\n                \"content-type\": \"application/json\",\n                \"x-api-key\": api_key\n            }\n            payload = {\"arg1\": \"true\"}\n            url = f\"https://{server_ip}/api/v1/sessions/{session_id}/ixnetwork/operations/getsystemresources\"\n\n            try:\n                response = requests.post(url, headers=headers, json=payload, verify=False, timeout=10)\n                response.raise_for_status()\n                result = response.json().get(\"result\", {})\n\n                if isinstance(result, str):\n                    result = json.loads(result)\n\n                return {\n                    \"SystemDiskInfo\": result.get(\"SystemDiskInfo\", {}),\n                    \"SystemCPUUsage\": result.get(\"SystemCPUUsage\", {}),\n                    \"SystemMemoryInfo\": result.get(\"SystemMemoryInfo\", {})\n                }\n\n            except Exception as err:\n                self.log.warning(f\" Failed to fetch resource monitor from {server_ip}: {err}\")\n                return None\n\n        def collect_resource_summary(resource_data, server_ip, api_key, session_id):\n            \"\"\"\n            Formats raw resource monitor data into a summary table row.\n\n            :param resource_data: Dictionary returned by get_resource_monitor().\n            :param server_ip: Server IP corresponding to the resource data.\n            :return: List containing disk, CPU, and memory usage metrics.\n            \"\"\"\n            disk = resource_data.get(\"SystemDiskInfo\", {})\n            cpu = resource_data.get(\"SystemCPUUsage\", {})\n            memory = resource_data.get(\"SystemMemoryInfo\", {})\n            version = get_ixnetwork_version(server_ip, api_key, session_id)\n\n            return [\n                server_ip,\n                version,\n                disk.get(\"Total\", \"\"),\n                disk.get(\"Available\", \"\"),\n                disk.get(\"Used\", \"\"),\n                disk.get(\"Used%\", \"\"),\n                cpu.get(\"CPUUsage(%)\", \"\"),\n                memory.get(\"Total\", \"\"),\n                memory.get(\"Available\", \"\"),\n                memory.get(\"Used\", \"\"),\n                memory.get(\"Used%\", \"\")\n            ]\n\n        def calculate_session_age_days(start_time_str):\n            \"\"\"\n            Calculates the number of days since a session was started.\n\n            :param start_time_str: Session start time string (MM/DD/YYYY hh:mm:ss AM/PM).\n            :return: Integer representing session age in days, or None if invalid.\n            \"\"\"\n            try:\n                return (datetime.datetime.now() - datetime.datetime.strptime(start_time_str, \"%m/%d/%Y %I:%M:%S %p\")).days\n            except:\n                return None\n\n        def filter_inactive_old_sessions(dashboard):\n            \"\"\"\n            Filters inactive IxNetwork sessions older than `max_days`.\n\n            :param dashboard: Dashboard data as a list of session dicts.\n            :return: List of inactive session summaries exceeding max_days.\n            \"\"\"\n            filtered = []\n            for session in dashboard:\n                age_days = calculate_session_age_days(session.get(\"SessionStartTime\", \"\"))\n                if age_days is not None and age_days > max_days:\n                    if (session.get(\"SessionStatus\") == \"NOT STARTED\" and\n                            session.get(\"ProtocolStatus\") == \"STOPPED\" and\n                            session.get(\"TrafficStatus\") == \"UNAPPLIED\"):\n                        filtered.append({\n                            \"SessionId\": session.get(\"SessionId\"),\n                            \"ConfigFile\": session.get(\"ConfigFileName\"),\n                            \"StartTime\": session.get(\"SessionStartTime\"),\n                            \"AgeDays\": age_days\n                        })\n            return filtered\n\n        def show_old_inactive_table(server_ip, filtered_sessions):\n            \"\"\"\n            Displays a formatted table of old, inactive IxNetwork sessions.\n\n            :param server_ip: IxNetwork server IP.\n            :param filtered_sessions: List of filtered inactive session entries.\n            :return: None\n            \"\"\"\n            if not filtered_sessions:\n                self.log.info(f\"\ud83d\udd39 No inactive sessions older than {max_days} days on {server_ip}\")\n                return\n\n            headers = [\"Session ID\", \"Config Name\", \"Start Time\", \"Age (days)\"]\n            table = [\n                [s[\"SessionId\"], s[\"ConfigFile\"], s[\"StartTime\"], s[\"AgeDays\"]]\n                for s in filtered_sessions\n            ]\n\n            self.log.warning(f\" Inactive Sessions Older Than {max_days} Days on {server_ip}\")\n            self.log.info(f\"\\n{tabulate.tabulate(table, headers=headers, tablefmt='grid')}\")\n\n        final_table = []\n\n        for server in server_list:\n            server_ip = server[\"ip\"]\n            username = server[\"username\"]\n            password = server[\"password\"]\n\n            creds = {\n                \"username\": server[\"username\"],\n                \"password\": server[\"password\"]\n            }\n\n            self.log.info(f\"\\nConnecting to {server_ip}...\")\n            api_key = get_api_key(server_ip, creds)\n\n            if not api_key:\n                self.log.debug(f\"Skipping {server_ip} due to API key failure.\")\n                continue\n\n            dashboard = get_dashboard(server_ip, api_key)\n            if show_dashboard:\n                display_dashboard_table(dashboard, server_ip)\n\n            session_id = create_temp_session(server_ip, api_key)\n            if not session_id:\n                self.log.warning(f\"No valid session ID found on {server_ip}.\")\n                continue\n            \n            time.sleep(5)\n            resource_data = get_resource_monitor(server_ip, api_key, session_id)\n            if not resource_data:\n                continue\n\n            summary = collect_resource_summary(resource_data, server_ip, api_key, session_id)\n\n            try:\n                disk_used_percent = float(summary[5])\n                mem_used_percent = float(summary[10])\n\n                if disk_used_percent > max_disk_usage or mem_used_percent >= max_memory_usage:\n                    self.log.warning(f\" {server_ip} has high resource usage.\")\n                    if disk_used_percent > max_disk_usage:\n                        self.log.warning(f\"  Disk Usage is {disk_used_percent}%, performing cleanup.\")\n\n                    if mem_used_percent >= max_memory_usage:\n                        self.log.warning(f\"  Memory Usage is {mem_used_percent}%, consider removing inactive session.\")\n\n                    # if cleanup_logs:\n                    #     self.diagnostics_cleanup(server_ip, username, password)\n                    #     self.log.info(f\"Cleanup done on server ip = {server_ip}\")\n\n            except Exception as err:\n                self.log.warning(f\"Check failed for {server_ip}: {err}\")\n\n            final_table.append(summary)\n\n            if show_inactive:\n                filtered = filter_inactive_old_sessions(dashboard)\n                show_old_inactive_table(server_ip, filtered)\n        \n            delete_temp_session(server_ip, api_key, session_id)\n\n        if final_table:\n            self.log.info(\"\\n=======Resource Monitor Summary========\\n\")\n            headers = [\n                \"Server IP\", \"Version\",\n                \"Disk Total\", \"Disk Available\", \"Disk Used\", \"Disk Used%\",\n                \"CPU Usage (%)\",\n                \"Mem Total\", \"Mem Available\", \"Mem Used\", \"Mem Used%\"\n            ]\n            self.log.info(f\"\\n{tabulate.tabulate(final_table, headers=headers, tablefmt='grid')}\")\n        else:\n            self.log.info(\"No resource monitor summary data collected.\")\n\n    def start_arp_and_verify9(self,**kwargs):\n        \"\"\"\n        starts the ARP and verifies the ARP status\n\n        :return: true if successful else false if verify fails or exception in case error occurs\n\n        :Example: start_arp_and_verify()\n        \"\"\"\n        result_list = []\n        scale_arp = kwargs.get('scale_arp', False)\n        arp_retry = kwargs.get('arp_retry', 5)\n        retry_delay = kwargs.get('retry_delay', 20)\n        chunk_size = kwargs.get('chunk_size', 4000)\n\n        topology = self.ixNetwork.Topology.find()\n        with BatchFind(topology) as device_group:\n            topology.DeviceGroup.find()\n\n        device_obj_list = getattr(device_group.results, \"deviceGroup\")\n        try:\n            for device_obj in device_obj_list:\n                if scale_arp == True:\n                    self.log.info(f'Starting ARP in bulk on: {device_obj.Name}')\n                    ipv4_objs = []\n                    for eth in device_obj.Ethernet.find():\n                        ipv4_objs.extend(eth.Ipv4.find())\n                    if not ipv4_objs:\n                        self.log.warning(f'IPv4 block not found in {device_obj.Name}')\n                        result_list.append(False)\n                        continue\n\n                    for ipv4_obj in ipv4_objs:\n                        total_sessions = ipv4_obj.Count\n                        session_indices = list(range(1, total_sessions + 1))\n                        success = False\n                        for attempt in range(1, arp_retry + 1):\n                            try:\n                                for i in range(0, total_sessions, chunk_size):\n                                    chunk = session_indices[i:i + chunk_size]\n                                    self.log.info(f'{device_obj.Name}: Sending ARP for sessions {chunk[0]}-{chunk[-1]} (attempt {attempt})')\n                                    ipv4_obj.SendArp(SessionIndices=chunk)\n                                    time.sleep(5)  \n\n                                success = self.verify_arp_status(ipType='ipv4', device=device_obj.Name)\n                                if success:\n                                    break\n                                else:\n                                    self.log.warning(f'ARP verification failed on {device_obj.Name}, retry {attempt}')\n                                    time.sleep(retry_delay)\n                            except Exception as e:\n                                self.log.warning(f'ARP chunk send failed on {device_obj.Name} attempt {attempt}: {e}')\n                                time.sleep(retry_delay)\n                        result_list.append(success)\n\n                else:\n                    self.log.info(f'Starting Arp on: {device_obj.Name}')\n                    if device_obj.Ethernet.find().Ipv4.find():\n                        for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():\n                            obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))\n                            ipv4_obj.SendArp(SessionIndices=obj_count_list)\n                            result_list.append(self.verify_arp_status(device=device_obj.Name))\n                    else:\n                        self.log.info(f'IPv4 block not found in {device_obj.Name}')\n        except:\n            self.log.error(f'Device Group {device_obj.Name} is not started')\n\n        if not False in result_list:\n            result = True\n        else:\n            result = False\n        return result\n\n    def retrieve_per_prefix_frame_loss_new(self, ip_type=\"ipv4\", show_all=False, traffic_item_list=None):\n\n        prefixesLossDict = {}\n        all_traffic_items = self.get_traffic_items()\n\n        if not traffic_item_list:\n            traffic_item_list = self.get_active_streams()\n\n        dest_ip_hint = \"ipv4\" if ip_type.lower() == \"ipv4\" else \"ipv6\"\n        log.info(f\"Processing traffic items: {traffic_item_list}\")\n\n        trafficItemStats = StatViewAssistant(self.ixNetwork, \"Traffic Item Statistics\")\n        rowList = [i for i, stat in enumerate(trafficItemStats.Rows)\n                if stat[\"Traffic Item\"] in traffic_item_list]\n\n        for rowIndex in rowList:\n            prefixBaseStats = None\n            drill_opts = trafficItemStats.DrillDownOptions(rowIndex)\n\n            flat_opts = []\n            for opt in drill_opts:\n                if isinstance(opt, (list, tuple)):\n                    flat_opts.extend(opt)\n                else:\n                    flat_opts.append(opt)\n\n            for ddIndex, opt in enumerate(flat_opts[:5]):\n                try:\n                    prefixBaseStats = trafficItemStats.Drilldown(\n                        rowIndex, opt, trafficItemStats.TargetRowFilters()[rowIndex]\n                    )\n                    if prefixBaseStats and getattr(prefixBaseStats, \"Rows\", []):\n                        log.info(f\" Drilldown succeeded for \"\n                                f\"{trafficItemStats.Rows[rowIndex]['Traffic Item']} \"\n                                f\"at index {ddIndex} using option '{opt}'\")\n                        break\n                except Exception as e:\n                    log.warning(f\"Drilldown {ddIndex} failed: {e}\")\n                    time.sleep(3)\n\n            retry_count = 0\n            while (not prefixBaseStats or not prefixBaseStats.Rows) and retry_count < 3:\n                log.info(f\"Waiting for drilldown rows (attempt {retry_count + 1})...\")\n                time.sleep(5)\n                try:\n                    prefixBaseStats = trafficItemStats.Drilldown(\n                        rowIndex, flat_opts[0], trafficItemStats.TargetRowFilters()[rowIndex]\n                    )\n                except Exception:\n                    pass\n                retry_count += 1\n\n            if not prefixBaseStats or not getattr(prefixBaseStats, \"Rows\", []):\n                log.warning(f\"No drilldown rows returned for traffic item row {rowIndex}\")\n                continue\n\n            headers = prefixBaseStats.ColumnHeaders\n            log.info(f\"Available columns: {headers}\")\n\n            destType = next((c for c in headers\n                            if \"Destination\" in c and dest_ip_hint in c.lower()), None)\n            if not destType:\n                destType = next((c for c in headers if \"Destination\" in c), None)\n\n            lossCol = next((c for c in headers\n                            if \"Loss\" in c and \"Duration\" in c), None)\n            if not destType or not lossCol:\n                log.warning(f\"Could not find Destination or Loss Duration columns for {trafficItemStats.Rows[rowIndex]['Traffic Item']}\")\n                continue\n\n            for stat in getattr(prefixBaseStats, \"Rows\", []):\n                try:\n                    prefixIp = stat.get(destType) if hasattr(stat, \"get\") else stat[destType]\n                    lossDuration = stat.get(lossCol) if hasattr(stat, \"get\") else stat[lossCol]\n                    if show_all or float(lossDuration or 0) > 0:\n                        prefixesLossDict[prefixIp] = lossDuration\n                except Exception as e:\n                    log.warning(f\"Error parsing stat row: {e}\")\n\n        if prefixesLossDict:\n            log.info(f\" Collected {len(prefixesLossDict)} prefixes with loss data\")\n            return prefixesLossDict\n        else:\n            log.error(f\"No {ip_type} prefix data found \u2014 possible causes: \"\n                    f\"traffic stopped too early, loss columns unavailable, or view not yet generated.\")\n            raise IxiaConfigException(f\"No {ip_type} prefix data found (traffic stream not found or no loss columns)\")\n\n\n    def set_port_transmit_deviation2(self, port_list=None, deviation='enabled', deviation_value=0, **kwargs):\n        \"\"\"\n        Sets the transmit deviation type and value for a given set of ports\n\n        :param port_list: (list) The port(s) to configure\n            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']\n            Note - for IXIA all ports in the same group will be enabled/disabled regardless of port_list\n        :param deviation: (str) Selects whether transmit deviation is enabled or disabled\n            e.g. 'enabled', 'disabled'\n        :param deviation_value: (int/str): The desired PPM deviation value\n            e.g. 10, \"10\"\n        :param kwargs:\n                    wait_interval : (int) sleep time default 0\n                    repetition : (int) Number of time opertaion to be repeated Ex : 5\n                    operation : \"increment\"/\"decrement\" if \"decrement\" then negative deviation_value will be set EX : -10\n        :return: True on success, exception otherwise\n\n        :Example: set_port_transmit_deviation(deviation_value=10)\n                  set_port_transmit_deviation(deviation_value=10,operation=\"increment\",wait_interval=5, repetition=2)\n        \"\"\"\n\n        wait_interval = kwargs.get(\"wait_interval\", 0)\n        repetition = kwargs.get(\"repetition\", 1)\n        operation = kwargs.get(\"operation\", \"increment\")\n        max_workers = kwargs.get(\"thread_count\", 17)  \n\n        if operation == \"decrement\":\n            deviation_value = -deviation_value\n\n        cardTypeList = ['atlasFourHundredGigLan',\n                        'atm',\n                        'ethernet',\n                        'ethernetImpairment',\n                        'ethernetvm',\n                        'fc',\n                        'fortyGigLan',\n                        'hundredGigLan',\n                        'krakenFourHundredGigLan',\n                        'novusHundredGigLan',\n                        'novusTenGigLan',\n                        'pos',\n                        'tenFortyHundredGigLan',\n                        'tenGigLan',\n                        'tenGigWan',\n                        'aresOneFourHundredGigLan',\n                        'starFourHundredGigLan']\n\n        def _apply_ppm_on_port(port_identifier, port_type, card_type, deviation, deviation_value):\n            try:\n                if port_type == \"NAME\":\n                    card_obj = eval(f'self.ixNetwork.Vport.find(Name=port_identifier).L1Config.{card_type}')\n                else:\n                    card_obj = eval(f'self.ixNetwork.Vport.find(AssignedTo=port_identifier).L1Config.{card_type}')\n\n                card_obj.EnablePPM = (deviation.lower() == 'enabled')\n                card_obj.Ppm = deviation_value\n                status = \"Enabled\" if deviation.lower() == 'enabled' else \"Disabled\"\n                self.log.info(f\" On Port: {port_identifier} {status} deviation and value set to: {deviation_value}\")\n            except Exception as e:\n                self.log.error(f\" Failed to apply PPM on {port_identifier}: {e}\")\n\n        while repetition != 0:\n            vports = self.ixNetwork.Vport.find()\n            vports.ReleasePort()\n\n            target_ports = port_list or [vport.Name for vport in vports]\n\n            jobs = []\n            with ThreadPoolExecutor(max_workers=max_workers) as executor:\n                for port in target_ports:\n                    if re.search(r'\\d+\\.\\d+\\.\\d+\\.\\d+/\\d+/\\d+', port):\n                        port_ip = port.replace(\"/\", \":\")\n                        card_type = self.ixNetwork.Vport.find(AssignedTo=port_ip).Type\n                        port_type = \"IP\"\n                        port_identifier = port_ip\n                    else:\n                        card_type = self.ixNetwork.Vport.find(Name=port).Type\n                        port_type = \"NAME\"\n                        port_identifier = port\n\n                    if card_type not in cardTypeList:\n                        raise CafyException.InvalidValueError(f'Card type: {card_type} not found.')\n                    card_type = card_type[0].upper() + card_type[1:]\n\n                    jobs.append(executor.submit(_apply_ppm_on_port, port_identifier, port_type, card_type, deviation, deviation_value))\n\n                for f in as_completed(jobs):\n                    _ = f.result()\n\n            vports.ConnectPorts()\n            time.sleep(wait_interval)\n            repetition -= 1\n\n        return True\n\n    def set_auto_negotiate1(self, port_list=None, auto_negotiate=True, **kwargs):\n        \"\"\"\n        Function to set auto-negotiation of port speeds (threaded).\n\n        :param port_list: List of port names (optional)\n        :param auto_negotiate: True or False\n        :param kwargs:\n                     max_threads: Max number of parallel threads (default=5)\n\n        :Example: set_auto_negotiate(port_list=['port1'], auto_negotiate=False)\n        \"\"\"\n\n        max_workers = kwargs.get(\"max_workers\", 13)\n\n        def _set_port_negotiation(vport, port_name):\n\n            \"\"\"Internal helper to safely configure a single port.\"\"\"\n\n            port_type = vport.Type\n            capitalized_card_type = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), port_type, 1)\n            try:\n                port_obj = getattr(vport.L1Config, capitalized_card_type)\n                port_obj.update(AutoNegotiate=auto_negotiate)\n                self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {port_name}\")\n                return True\n            except TypeError:\n                port_obj = getattr(vport.L1Config, capitalized_card_type)\n                port_obj.update(EnableAutoNegotiation=auto_negotiate)\n                self.log.info(f\"auto negotiation is set to {auto_negotiate} on port: {port_name}\")\n                return True\n            except Exception as e:\n                self.log.info(f\"card type {capitalized_card_type} might not support auto negotiation for port: {port_name} ({e})\")\n                return False\n\n        vport_list = []\n\n        if port_list is None:\n            self.log.info(\"Setting Auto Negotiation of all available ports in the config\")\n            for vport in self.ixNetwork.Vport.find():\n                vport_list.append((vport, vport.Name))\n\n        else:\n            self.log.info(f\"Setting Auto Negotiation of ports - {port_list} in the config\")\n            for port in port_list:\n                if re.search(r'\\d+\\.\\d+\\.\\d+\\.\\d+/\\d+/\\d+', port):\n                    port_ref = port.replace(\"/\", \":\")\n                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + port_ref + '$')\n                else:\n                    vport = self.ixNetwork.Vport.find(Name='^' + port + '$')\n\n                if vport:\n                    vport_list.append((vport, port))\n                else:\n                    self.log.info(f\"port {port} not available in the config\")\n                    return False\n\n        with ThreadPoolExecutor(max_workers=min(max_workers, len(vport_list))) as executor:\n            futures = {executor.submit(_set_port_negotiation, vp, name): name for vp, name in vport_list}\n            results = [f.result() for f in as_completed(futures)]\n\n        if all(results):\n            self.log.info(\" Auto Negotiation configured successfully on all requested ports.\")\n            return True\n        else:\n            self.log.warning(\" Some ports failed to configure Auto Negotiation.\")\n            return False\n        \n    def generate_license_summary(self, chassis_ip, username='admin', password='admin', license_feature=None):\n        \"\"\"\n        API used to retrieve license details based on Ixia chassis\n        \"\"\"\n        USERNAME_PASSWORD = {'username': username, 'password': password}\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        JSON_USERNAME_PASS = json.dumps(USERNAME_PASSWORD)\n        auth_key_call = f\"https://{chassis_ip}/api/v1/auth/session\"\n\n        try:\n            api_response = requests.post(auth_key_call, data=JSON_USERNAME_PASS,\n                                         headers={'content-type': \"application/json\"}, verify=False, timeout=10)\n            api_response.raise_for_status()\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Authentication failed: {err}\")\n            return None\n\n        api_json = api_response.json()\n        api_key = api_json.get(\"apiKey\")\n        if not api_key:\n            self.log.error(f\"[{chassis_ip}] No API key returned during authentication.\")\n            return None\n\n        HEADERS = {\n            'x-api-key': api_key,\n            'content-type': \"application/json\"\n        }\n\n        for server_type in ['platform', 'ixnetworkweb']:\n            license_server_url = f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/\"\n            try:\n                license_server_response = requests.get(license_server_url, headers=HEADERS, verify=False, timeout=10)\n                if license_server_response.status_code == 200:\n                    break\n            except Exception as err:\n                self.log.debug(f\"{chassis_ip}] Failed to connect to {license_server_url}: {err}\")\n                continue\n        else:\n            self.log.error(f\"[{chassis_ip}] License Fetch failed for chassis/server.\")\n            return None\n\n        try:\n            server_id = license_server_response.json()[0]['id']\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Could not extract server ID: {err}\")\n            return None\n\n        license_retrieval_url = f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/operations/retrievelicenses\"\n\n        try:\n            license_retrieval_response = requests.post(license_retrieval_url, headers=HEADERS, verify=False, timeout=10)\n            license_retrieval_response.raise_for_status()\n            id_json = license_retrieval_response.json()\n            license_id = id_json.get(\"id\")\n        except Exception as err:\n            self.log.error(f\"[{chassis_ip}] Failed to start license retrieval: {err}\")\n            return None\n\n        if not license_id:\n            self.log.error(f\"[{chassis_ip}] No async operation ID received.\")\n            return None\n\n        license_list_url = (\n            f\"https://{chassis_ip}/{server_type}/api/v2/licensing/servers/{server_id}/\"\n            f\"operations/retrievelicenses/{license_id}/result\"\n        )\n\n        max_retries = 30\n        wait_time = 1\n        for attempt in range(max_retries):\n            try:\n                license_list_response = requests.get(license_list_url, headers=HEADERS, verify=False, timeout=10)\n                status = license_list_response.status_code\n                data = license_list_response.json()\n\n                if status == 200 and isinstance(data, list):\n                    break\n                if isinstance(data, dict) and \"no async operation\" in str(data).lower():\n                    time.sleep(wait_time)\n                    wait_time = min(wait_time * 2, 5)\n                    continue\n                if status != 200 or \"error\" in str(data).lower():\n                    time.sleep(wait_time)\n                    continue\n\n            except Exception as err:\n                self.log.debug(f\"[{chassis_ip}] Attempt {attempt + 1}/{max_retries} failed: {err}\")\n                time.sleep(wait_time)\n                continue\n        else:\n            self.log.error(f\"[{chassis_ip}] Timed out waiting for license result after {max_retries} retries.\")\n            return None\n\n        license_data = license_list_response.json()\n        if not isinstance(license_data, list):\n            self.log.error(f\"[{chassis_ip}] Unexpected license data format: {license_data}\")\n            return None\n\n        required_keys = [\n            \"activationCode\", \"isExpired\", \"daysLeftToExpire\",\n            \"quantity\", \"product\", \"description\", \"partNumber\",\n            \"expiryDate\",\"maintenanceDate\"\n        ]\n\n        filtered_data = []\n        for lic in license_data:\n            filtered_lic = {k: lic.get(k) for k in required_keys if k in lic}\n            filtered_data.append(filtered_lic)\n\n        if license_feature:\n            matched = []\n            for lic in license_data:\n                if \"featuresList\" in lic:\n                    for f in lic[\"featuresList\"]:\n                        if license_feature.lower() in f.get(\"name\", \"\").lower():\n                            matched.append({k: lic.get(k) for k in required_keys if k in lic})\n            if matched:\n                self.log.info(f\"[{chassis_ip}] Filtered license info for feature '{license_feature}':\\n{json.dumps(matched, indent=2)}\")\n                return matched\n            else:\n                self.log.warning(f\"[{chassis_ip}] License feature '{license_feature}' not found.\")\n                return False\n\n        self.log.info(f\"[{chassis_ip}] Filtered license info:\\n{json.dumps(filtered_data, indent=2)}\")\n        return filtered_data\n\n    def start_arp_on_streams_one(self, ports=()):\n        \"\"\"\n        Starts ARP on all the streams under specified ports\n\n        :param ports: port or list of ports Default all ports\n        :return: True on success\n        :Example: start_arp_on_streams()\n        \"\"\"\n        self.log.info(\"Starting ARP at stream level\")\n        traffic_items_port_dict = {}\n\n        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):\n                with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')\n                traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n                for traffic_item in traffic_item_list:\n                    stream_list = traffic_item.HighLevelStream.find()\n                    for count, stream in enumerate(stream_list):\n                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n                is_traffic_item = True\n            else:\n                self.log.warning('No Raw Traffic Streams in the configuration')\n                return False\n        else:\n            with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                self.ixNetwork.Traffic.TrafficItem.find()\n            is_traffic_item = False\n            traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n            for traffic_item in traffic_item_list:\n                stream_list = traffic_item.HighLevelStream.find()\n                for count, stream in enumerate(stream_list):\n                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n\n        vport_dest_mac_dict = {}\n        vports = [vport.href for vport in self.ixNetwork.Vport.find()]\n\n        def collect_one_mac_per_topology(vport):\n            try:\n                for topology in self.ixNetwork.Topology.find():\n                    if not topology.Ports:\n                        continue\n                    if topology.Ports[0] == vport:\n                        ipv4_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()\n                        for ipv4_block in ipv4_blocks:\n                            for mac in ipv4_block.ResolvedGatewayMac:\n                                if mac and mac != 'removePacket[Unresolved]':\n                                    return (vport, mac)\n                        ipv6_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()\n                        for ipv6_block in ipv6_blocks:\n                            for mac in ipv6_block.ResolvedGatewayMac:\n                                if mac and mac != 'removePacket[Unresolved]':\n                                    return (vport, mac)\n            except Exception as e:\n                self.log.warning(f'MAC address collection failed on {vport}: {e}')\n            return None\n\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            future_to_vport = {executor.submit(collect_one_mac_per_topology, v): v for v in vports}\n            for future in as_completed(future_to_vport):\n                result = future.result()\n                if result:\n                    vport_dest_mac_dict[result[0]] = result[1]\n\n        self.log.debug(f\"Resolved Gateway MACs per vPort: {vport_dest_mac_dict}\")\n\n        if not vport_dest_mac_dict:\n            self.log.error(\"No valid resolved gateway MACs found \u2014 IP stack might be down\")\n            return False\n\n        traffic_name_mac_mapping = {}\n        for traffic_item_name, flows in traffic_items_port_dict.items():\n            try:\n                unique_macs = set()\n                for flow in flows:\n                    mac = vport_dest_mac_dict.get(flow)\n                    if mac:\n                        unique_macs.add(mac)\n                if unique_macs:\n                    traffic_name_mac_mapping[traffic_item_name] = [list(unique_macs)[0]]\n                else:\n                    self.log.warning(f\"No MAC found for traffic item {traffic_item_name}\")\n            except Exception as e:\n                self.log.error(f\"MAC mapping failed for {traffic_item_name}: {e}\")\n\n        self.log.debug(f\"Final Traffic -> MAC Mapping: {traffic_name_mac_mapping}\")\n\n        for traffic_name, mac_list in traffic_name_mac_mapping.items():\n            traffic = re.escape(traffic_name)\n            mac_value = mac_list[0]\n            try:\n                self.log.debug(f\"Updating MAC for traffic item: {traffic_name} -> {mac_value}\")\n                if is_traffic_item:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').ConfigElement.find()\n                            for count, config_element in enumerate(config_element_list):\n                                if config_element.Stack.find(DisplayName='Ethernet II'):\n                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        existing_mac = None\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,\n                                                                                                         'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field,\n                                                                                                        'SingleValue',\n                                                                                                        None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                            skip = True\n                                        else:\n                                            try:\n                                                ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')\n                                                ipv4_field = None\n                                                if ipv4_stackobj and ipv4_stackobj.href:\n                                                    ipv4_field = ipv4_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')\n                                                ipv6_field = None\n                                                if ipv6_stackobj and ipv6_stackobj.href:\n                                                    ipv6_field = ipv6_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                for ip_field in [ipv4_field, ipv6_field]:\n                                                    if ip_field and ip_field.StartValue:\n                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:\n                                                            skip = True\n                                            except Exception:\n                                                pass\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})\")\n                                            continue\n\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n                else:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').HighLevelStream.find()\n                            for count, high_stream in enumerate(high_stream_list):\n                                if high_stream.Stack.find(DisplayName='Ethernet II'):\n                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field,\n                                                                                                         'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field,\n                                                                                                        'SingleValue',\n                                                                                                        None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                            skip = True\n                                        else:\n                                            try:\n\n                                                ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')\n                                                ipv4_field = None\n                                                if ipv4_stackobj and ipv4_stackobj.href:\n                                                    ipv4_field = ipv4_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')\n                                                ipv6_field = None\n                                                if ipv6_stackobj and ipv6_stackobj.href:\n                                                    ipv6_field = ipv6_stackobj.Field.find(\n                                                        DisplayName='Destination Address')\n\n                                                for ip_field in [ipv4_field, ipv6_field]:\n                                                    if ip_field and ip_field.StartValue:\n                                                        if ipaddress.ip_address(ip_field.StartValue).is_multicast:\n                                                            skip = True\n                                            except Exception:\n                                                pass\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac}) \")\n                                            continue\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n            except Exception as err_msg:\n                self.log.error(f'MAC Update failed in Traffic streams {traffic_name}: {err_msg}')\n\n        self.log.info('Starting ARP on Streams completed successfully')\n        return True\n\n    def rocev2_flow_config_txport(self, tx_port, enable = False, **kwargs):\n        \"\"\"\n        Enable/Disable all RoCEv2 flow groups by Tx Port .\n\n        :param tx_port: The port for which you want the flow groups to be disabled | A single  port(str) or a list of ports(list)\n        :param enable: True/False to enable or disable | Default(False)\n        :return: True on success\n\n        Example:\n            tgnObj.rocev2_flow_config_txport(tx_port=['Ethernet - 001','Ethernet - 002'], enable= True)\n            tgnObj.rocev2_flow_config_txport(tx_port='Ethernet - 002', enable= False)\n        \"\"\"\n\n        if enable == True:\n            action = 'Enabling'\n        else:\n            action = 'Disabling'\n\n        rocev2 = self.ixNetwork.Traffic.find().RoceV2Traffic.find()\n        \n        if not rocev2:\n            self.log.error(\"No RoCev2 traffic item found in the configuration\")\n            return False\n\n        if isinstance(tx_port, str):\n\n            if not self.ixNetwork.Vport.find(Name=f'^{re.escape(tx_port)}$' ):\n                raise ValueError(f\"No Tx Port with name {tx_port} found in config\")\n\n            self.log.info(f\"{action} all flow groups on Tx Port: {tx_port} \")\n            for flows in rocev2.RoceV2Stream.find(TxPort= f'^{re.escape(tx_port)}$'):\n                flows.Enabled = enable\n\n        if isinstance(tx_port, list):\n\n            for tx in tx_port:\n                if not self.ixNetwork.Vport.find(Name=f'^{re.escape(tx)}$' ):\n                    raise ValueError(f\"No Tx Port with name {tx} found in config\")\n                \n                self.log.info(f\"{action} all flow groups on Tx Port: {tx} \")\n                for flows in rocev2.RoceV2Stream.find(TxPort= f'^{re.escape(tx)}$'):\n                    flows.Enabled = enable\n\n        return True\n\n    def _link_local_restart1(self, device_groups):\n        \"\"\"\n        Check each IPv6 stack under all (or selected) topologies for 'removePacket[Unknown]'\n        in link-local address, and restart only that IPv6 instance.\n\n        If after RestartDown() the IPv6 link-local still shows 'Unknown', perform ipv6.Start().\n\n        :param topology_name: (str) Optional topology name to limit scope.\n        :param device_groups: (str | list) Optional device group name or list of names to target.\n        :return: Count of IPv6 instances restarted or started.\n        \"\"\"\n        restart_count = 0\n        retry_delay = 10\n\n        # Normalize device_groups input\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():\n            if device_groups and dg.Name not in device_groups:\n                continue\n\n            for eth in dg.Ethernet.find():\n                for ipv6 in eth.Ipv6.find():\n                    try:\n                        link_local_values = ipv6.LinkLocalAddress\n                    except Exception as err:\n                        self.log.error(f\" Failed to fetch LinkLocalAddress for {dg.Name}: {err}\")\n                        continue\n\n                    if any(\"Unknown\" in str(addr) for addr in link_local_values):\n                        self.log.warning(\n                            f\" Found 'Unknown' under {dg.Name}/{eth.Name}. Restarting IPv6...\"\n                        )\n                        try:\n                            ipv6.RestartDown()\n                            time.sleep(retry_delay)\n                            restart_count += 1\n\n                            # Recheck if IPv6 recovered\n                            link_local_values_after = ipv6.LinkLocalAddress\n                            if any(\"Unknown\" in str(addr) for addr in link_local_values_after):\n                                self.log.warning(\n                                    f\"IPv6 still showing 'Unknown' after RestartDown(). Trying Start()...\"\n                                )\n                                ipv6.Start()\n                                time.sleep(20)\n\n                        except Exception as err:\n                            self.log.error(\n                                f\" Failed to restart IPv6 for {dg.Name}/{eth.Name}: {err}\"\n                            )\n\n        if restart_count == 0:\n            self.log.info(\" No IPv6 interfaces found with '[Unknown]'.\")\n        else:\n            self.log.info(f\" Restarted/started {restart_count} IPv6 instance(s) with unknown link-local addresses.\")\n\n        return restart_count\n\n    def _restart_ipv6_if_unknown_dg2(self, device_groups=None, **kwargs):\n        \"\"\"\n        Check each IPv6 stack under all (or selected) device groups for 'removePacket[Unknown]'\n        in link-local address, and restart only those IPv6 address instances.\n\n        If after RestartDown() the IPv6 link-local still shows 'Unknown', perform ipv6.Start()\n        on that address instance.\n\n        :param device_groups: (str | list | None)\n            Optional device group name or list of names to target. If None, applies to all.\n        :return: Count of IPv6 addresses restarted or started.\n        :Example: tgnObj.restart_ipv6_if_unknown_dg2(device_group='Device Group 1')\n                  tgnObj.restart_ipv6_if_unknown_dg2()\n        \"\"\"\n        ipv6_restart_count = 0\n        retry_delay = 10\n        verify_delay = 15\n\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        for topo in self.ixNetwork.Topology.find():\n            for dg in topo.DeviceGroup.find():\n                if device_groups and dg.Name not in device_groups:\n                    continue\n\n                for eth in dg.Ethernet.find():\n                    for ipv6 in eth.Ipv6.find():\n                        try:\n                            link_local_values = list(ipv6.LinkLocalAddress)\n                        except Exception as err:\n                            self.log.error(f\" Failed to fetch LinkLocalAddress for {dg.Name}: {err}\")\n                            continue\n\n                        unknown_indices = [\n                            idx + 1 for idx, addr in enumerate(link_local_values) if \"Unknown\" in str(addr)\n                        ]\n                        if not unknown_indices:\n                            continue\n\n                        self.log.warning(\n                            f\"[{dg.Name}] Found 'Unknown' in {len(unknown_indices)} IPv6 instance(s). Restarting only those...\"\n                        )\n\n                        try:\n                            ipv6.RestartDown(SessionIndices=unknown_indices, async_operation= True)\n                            ipv6_restart_count += len(unknown_indices)\n                            time.sleep(retry_delay)\n\n                            link_local_after = list(ipv6.LinkLocalAddress)\n                            still_unknown = [\n                                idx + 1 for idx, addr in enumerate(link_local_after)\n                                if (idx + 1) in unknown_indices and \"Unknown\" in str(addr)\n                            ]\n\n                            if still_unknown:\n                                self.log.warning(\n                                    f\"[{dg.Name}/{eth.Name}] Still 'Unknown' after RestartDown. Trying Start() on {len(still_unknown)} instance(s)...\"\n                                )\n                                ipv6.Stop(SessionIndices=still_unknown,async_operation=True)\n                                time.sleep(10)\n                                ipv6.Start(SessionIndices=still_unknown, async_operation=True)\n                                ipv6_restart_count += len(still_unknown)\n                                time.sleep(verify_delay)\n\n                        except Exception as err:\n                            self.log.error(\n                                f\"[{dg.Name}] Failed to restart IPv6 for indices {unknown_indices}: {err}\"\n                            )\n\n        if ipv6_restart_count == 0:\n            self.log.info(\" No IPv6 addresses found with '[Unknown]'.\")\n        else:\n            self.log.info(\n                f\" Restarted/started {ipv6_restart_count} individual IPv6 address instance(s) with 'Unknown' link-local addresses.\"\n            )\n\n        return ipv6_restart_count\n\n\n    def start_arp_on_streams_one_mac(self, ports=(), mac_check=True):\n        \"\"\"\n        Starts ARP on all the streams under specified ports\n\n        :param ports: port or list of ports Default all ports\n        :param mac_check: bool, default True\n                        If False, skip multicast MAC/IP filtering logic and update all MACs\n        :return: True on success\n        :Example: start_arp_on_streams_one(mac_check=False)\n        \"\"\"\n        self.log.info(\"Starting ARP at stream level\")\n        traffic_items_port_dict = {}\n\n        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():\n            if self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw'):\n                with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                    self.ixNetwork.Traffic.TrafficItem.find(TrafficType='raw')\n                traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n                for traffic_item in traffic_item_list:\n                    stream_list = traffic_item.HighLevelStream.find()\n                    for count, stream in enumerate(stream_list):\n                        traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n                is_traffic_item = True\n            else:\n                self.log.warning('No Raw Traffic Streams in the configuration')\n                return False\n        else:\n            with BatchFind(self.ixNetwork.Traffic) as traffic_item:\n                self.ixNetwork.Traffic.TrafficItem.find()\n            is_traffic_item = False\n            traffic_item_list = getattr(traffic_item.results, 'trafficItem')\n            for traffic_item in traffic_item_list:\n                stream_list = traffic_item.HighLevelStream.find()\n                for count, stream in enumerate(stream_list):\n                    traffic_items_port_dict.setdefault(traffic_item.Name, []).append(stream.TxPortId)\n\n        vport_dest_mac_dict = {}\n        vports = [vport.href for vport in self.ixNetwork.Vport.find()]\n\n        def collect_one_mac_per_topology(vport):\n            try:\n                for topology in self.ixNetwork.Topology.find():\n                    if not topology.Ports:\n                        continue\n                    if topology.Ports[0] == vport:\n                        ipv4_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv4.find()\n                        for ipv4_block in ipv4_blocks:\n                            for mac in ipv4_block.ResolvedGatewayMac:\n                                if mac and mac != 'removePacket[Unresolved]':\n                                    return (vport, mac)\n                        ipv6_blocks = topology.DeviceGroup.find().Ethernet.find().Ipv6.find()\n                        for ipv6_block in ipv6_blocks:\n                            for mac in ipv6_block.ResolvedGatewayMac:\n                                if mac and mac != 'removePacket[Unresolved]':\n                                    return (vport, mac)\n            except Exception as e:\n                self.log.warning(f'MAC address collection failed on {vport}: {e}')\n            return None\n\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            future_to_vport = {executor.submit(collect_one_mac_per_topology, v): v for v in vports}\n            for future in as_completed(future_to_vport):\n                result = future.result()\n                if result:\n                    vport_dest_mac_dict[result[0]] = result[1]\n\n        self.log.debug(f\"Resolved Gateway MACs per vPort: {vport_dest_mac_dict}\")\n\n        if not vport_dest_mac_dict:\n            self.log.error(\"No valid resolved gateway MACs found \u2014 IP stack might be down\")\n            return False\n\n        traffic_name_mac_mapping = {}\n        for traffic_item_name, flows in traffic_items_port_dict.items():\n            try:\n                unique_macs = set()\n                for flow in flows:\n                    mac = vport_dest_mac_dict.get(flow)\n                    if mac:\n                        unique_macs.add(mac)\n                if unique_macs:\n                    traffic_name_mac_mapping[traffic_item_name] = [list(unique_macs)[0]]\n                else:\n                    self.log.warning(f\"No MAC found for traffic item {traffic_item_name}\")\n            except Exception as e:\n                self.log.error(f\"MAC mapping failed for {traffic_item_name}: {e}\")\n\n        self.log.debug(f\"Final Traffic -> MAC Mapping: {traffic_name_mac_mapping}\")\n\n        for traffic_name, mac_list in traffic_name_mac_mapping.items():\n            traffic = re.escape(traffic_name)\n            mac_value = mac_list[0]\n            try:\n                self.log.debug(f\"Updating MAC for traffic item: {traffic_name} -> {mac_value}\")\n                if is_traffic_item:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            config_element_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').ConfigElement.find()\n                            for count, config_element in enumerate(config_element_list):\n                                if config_element.Stack.find(DisplayName='Ethernet II'):\n                                    field = config_element.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        existing_mac = None\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field, 'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field, 'SingleValue', None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        # --- mac_check-controlled skip logic ---\n                                        if mac_check:\n                                            if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                                skip = True\n                                            else:\n                                                try:\n                                                    ipv4_stackobj = config_element.Stack.find(DisplayName='IPv4')\n                                                    ipv6_stackobj = config_element.Stack.find(DisplayName='IPv6')\n                                                    for stackobj in [ipv4_stackobj, ipv6_stackobj]:\n                                                        if stackobj and stackobj.href:\n                                                            field_obj = stackobj.Field.find(DisplayName='Destination Address')\n                                                            if field_obj and field_obj.StartValue:\n                                                                if ipaddress.ip_address(field_obj.StartValue).is_multicast:\n                                                                    skip = True\n                                                except Exception:\n                                                    pass\n                                        # --- end mac_check section ---\n\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})\")\n                                            continue\n\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n                else:\n                    with (BatchUpdate(self.ixNetwork)):\n                        for traffic_name in traffic_name_mac_mapping:\n                            traffic = re.escape(traffic_name)\n                            high_stream_list = self.ixNetwork.Traffic.TrafficItem.find(\n                                Name=f'^{traffic}$').HighLevelStream.find()\n                            for count, high_stream in enumerate(high_stream_list):\n                                if high_stream.Stack.find(DisplayName='Ethernet II'):\n                                    field = high_stream.Stack.find(DisplayName='Ethernet II').Field.find(\n                                        DisplayName='Destination MAC Address')\n                                    if len(traffic_name_mac_mapping[traffic_name]):\n                                        mac_to_set = traffic_name_mac_mapping[traffic_name][count]\n\n                                        skip = False\n                                        existing_mac = None\n                                        try:\n                                            if field.ValueType in ('increment', 'decrement') and hasattr(field, 'StartValue'):\n                                                existing_mac = field.StartValue\n                                            else:\n                                                existing_mac = getattr(field, 'Value', None) or getattr(field, 'SingleValue', None)\n                                        except Exception:\n                                            existing_mac = None\n\n                                        # --- mac_check-controlled skip logic ---\n                                        if mac_check:\n                                            if existing_mac and str(existing_mac).upper().startswith((\"01:00:5E\", \"33:33\")):\n                                                skip = True\n                                            else:\n                                                try:\n                                                    ipv4_stackobj = high_stream.Stack.find(DisplayName='IPv4')\n                                                    ipv6_stackobj = high_stream.Stack.find(DisplayName='IPv6')\n                                                    for stackobj in [ipv4_stackobj, ipv6_stackobj]:\n                                                        if stackobj and stackobj.href:\n                                                            field_obj = stackobj.Field.find(DisplayName='Destination Address')\n                                                            if field_obj and field_obj.StartValue:\n                                                                if ipaddress.ip_address(field_obj.StartValue).is_multicast:\n                                                                    skip = True\n                                                except Exception:\n                                                    pass\n                                        # --- end mac_check section ---\n\n                                        if skip:\n                                            self.log.info(\n                                                f\"Skipping multicast MAC/IP update for {traffic_name} (MAC={existing_mac})\")\n                                            continue\n\n                                        if field.ValueType in ('increment', 'decrement'):\n                                            field.StartValue = mac_to_set\n                                        else:\n                                            self._update_field_values(field, mac_to_set)\n            except Exception as err_msg:\n                self.log.error(f'MAC Update failed in Traffic streams {traffic_name}: {err_msg}')\n\n        self.log.info('Starting ARP on Streams completed successfully')\n        return True\n\n    def verify_arp_status1(self, ipType='ipv4', device=None, **kwargs):\n        \"\"\"\n        Verifies the ARP (IPv4) or ND (IPv6) status of all device groups.\n\n        If `scale_traffic=True`, only checks for 'resolveMacFailed' entries in SessionInfo\n        (for large-scale scenarios) instead of performing detailed per-IP verification.\n\n        :param ipType: 'ipv4' or 'ipv6'\n        :param device: Device Group name or list of names\n        :param scale_traffic: Boolean; enables faster ARP verification for scale traffic\n        :return: True if all resolved, False otherwise\n        \"\"\"\n\n        scaleConfig=kwargs.get(\"scaleConfig\",True)\n\n        self.log.info(f\"Verification of ARP started (type={ipType}, scale_traffic={scaleConfig})\")\n\n        if isinstance(device, str):\n            device = [device]\n        \n        unresolved_list = []\n        device_notstarted_list = []\n        unresolved_arp_list = []\n        gateway_ip_list = []\n        timeout = 20\n        result = True\n        ip_type = ipType.lower()\n\n        if device:\n            device_obj_list = [\n                dg for dg in self.ixNetwork.Topology.find().DeviceGroup.find()\n                if dg.Name in device\n            ]\n        else:\n            topology = self.ixNetwork.Topology.find()\n            if topology:\n                with BatchFind(topology) as device_group:\n                    self.ixNetwork.Topology.find().DeviceGroup.find()\n                device_obj_list = getattr(device_group.results, 'deviceGroup', [])\n            else:\n                self.log.warning(\"Topology not found in the config.\")\n                return result\n\n        if not device_obj_list:\n            msg = f'Device Group \"{device}\" not found'\n            raise IxiaOperationException(msg)\n\n        for device_obj in device_obj_list:\n            for counter in range(0, timeout, 2):\n                if device_obj.Status == 'notStarted':\n                    device_notstarted_list.append(device_obj.Name)\n                if counter < timeout and device_obj.Status == 'starting':\n                    time.sleep(2)\n                    continue\n                if counter < timeout and device_obj.Status in ['started', 'mixed']:\n                    break\n                if counter == timeout and device_obj.Status not in ['started', 'mixed']:\n                    msg = f'Device Group failed to come up: {device_obj.Name}'\n                    raise IxiaOperationException(msg)\n                \n        if device_notstarted_list:\n            self.log.warning(f'Device Group(s) {set(device_notstarted_list)}  not started')\n\n        for device_obj in device_obj_list:\n            with BatchFind(device_obj) as ip_obj_list:\n                eval('device_obj.Ethernet.find().' + ip_type[0].upper() + ip_type[1:] + '.find()')\n\n            if device_obj.Status == 'notStarted':\n                self.log.info(f'[SKIP] Device {device_obj.Name} is not started')\n                continue\n\n            try:\n                ip_obj_list = getattr(ip_obj_list.results, ip_type)\n            except:\n                ip_obj_list = []\n                self.log.info(f'{ip_type} block not configured in device {device_obj.Name}')\n                continue\n            \n            # pdb.set_trace()\n            if scaleConfig:\n                total_failed = 0\n                failed_ip_list = []\n                failed_gw_list = []\n\n                def process_ip_obj(ip_obj):\n                    \"\"\"Process one IPv4/IPv6 object .\"\"\"\n                    local_failed_ips = []\n                    local_failed_gws = []\n                    session_info = getattr(ip_obj, \"ResolvedGatewayMac\", [])\n                    if not session_info:\n                        return (0, local_failed_ips, local_failed_gws)\n\n                    failed_indices = [i for i, s in enumerate(session_info) if s == \"removePacket[Unresolved]\"]\n                    if not failed_indices:\n                        return (0, local_failed_ips, local_failed_gws)\n\n                    addr_values = getattr(ip_obj.Address, \"Values\", [])\n                    gw_values = getattr(ip_obj.GatewayIp, \"Values\", [])\n\n                    for i in failed_indices:\n                        if i < len(addr_values):\n                            local_failed_ips.append(addr_values[i])\n                        if i < len(gw_values):\n                            local_failed_gws.append(gw_values[i])\n\n                    return (len(failed_indices), local_failed_ips, local_failed_gws)\n\n                with ThreadPoolExecutor(max_workers=50) as executor:\n                    future_to_ip = {executor.submit(process_ip_obj, ip_obj): ip_obj for ip_obj in ip_obj_list}\n                    for future in as_completed(future_to_ip):\n                        count, ips, gws = future.result()\n                        total_failed += count\n                        failed_ip_list.extend(ips)\n                        failed_gw_list.extend(gws)\n\n                if total_failed > 0:\n                    self.log.warning(\n                        f\"[{device_obj.Name}] Found {total_failed} IP(s) with MAC resolution failed (scale traffic).\"\n                    )\n                    sample_count = len(failed_ip_list)\n                    self.log.debug(\n                        f\"[{device_obj.Name}] Example failed entries: \"\n                        f\"{list(zip(failed_ip_list[:sample_count], failed_gw_list[:sample_count]))}\"\n                    )\n                else:\n                    self.log.info(f\"[{device_obj.Name}] ARP Verification passed for scale traffic.\")\n                continue\n\n            unresolved_mac = False\n            for ip_obj in ip_obj_list:\n                for index, each_state in enumerate(ip_obj.SessionStatus):\n                    if each_state != \"up\":\n                        unresolved_arp_list.append(ip_obj.Address.Values[index])\n                        gateway_ip_list.append(ip_obj.GatewayIp.Values[index])\n                        unresolved_mac = True\n\n            if unresolved_mac:\n                # self.log.info(f'ARP Verification Failed for {ip_type} in \"{device_obj.Name}\"')\n                unresolved_list.append(device_obj.Name)\n        \n        if unresolved_list:\n            self.log.info(f'ARP Verification Failed for {ip_type} in \"{unresolved_list}\"')\n\n        if not scaleConfig and unresolved_arp_list:\n            self.log.warning(\n                f\"\\nFailed to Resolve ARP: srcIp: {unresolved_arp_list}, \\ngateway: {gateway_ip_list}\"\n            )\n            result = False\n        elif not scaleConfig and result:\n            self.log.info(f\"ARP Verification Successful for {ip_type}\")\n\n        return result\n\n    def _wait_for_protocol_action_complete(self, timeout=120, interval=2, operation_name=None, progress_log_gap=180):\n        \"\"\"\n        Wait until IxNetwork finishes all protocol actions (like ARP, StartAll, etc.).\n        Raises an exception if it exceeds the timeout.\n        Automatically detects which API called it unless an operation_name is provided.\n\n        :param timeout: Max seconds to wait before raising timeout error.\n        :param interval: Polling interval in seconds.\n        :param operation_name: Optional label for which API is waiting.\n        :param progress_log_gap: Minimum seconds between progress log messages.\n        \"\"\"\n\n        if operation_name is None:\n            operation_name = inspect.stack()[1].function\n\n        start_time = time.time()\n        last_log_time = 0\n\n        while time.time() - start_time < timeout:\n            try:\n                in_progress = self.ixNetwork.Globals.Topology.ProtocolActionsInProgress\n                if not in_progress or len(in_progress) == 0:\n                    elapsed = round(time.time() - start_time, 1)\n                    self.log.debug(f\"[{operation_name}] Protocol actions completed successfully in {elapsed}s.\")\n                    return True\n                \n\n                elapsed = round(time.time() - start_time, 1)\n                # pdb.set_trace()\n                if elapsed > 30:\n                    for elements in in_progress:\n                        # self.log.info(elements)\n                        # if elements.lower() in ['dhcp','scenario']:\n                        # if ['dhcp','scenario'] in elements.lower()\n                        if 'dhcp' in elements.lower() or 'scenario' in elements.lower():\n                            self.log.info(f\"{elements} still in progress, Skipping\")\n                            return True\n\n                if elapsed - last_log_time >= progress_log_gap:\n                    self.log.debug(f\"[{operation_name}] [{elapsed}s] Protocol action still in progress: {in_progress}\")\n                    last_log_time = elapsed\n\n            except Exception as e:\n                self.log.warning(f\"[{operation_name}] Could not fetch protocol action status: {e}\")\n\n            time.sleep(interval)\n\n        msg = f\"[{operation_name}] Protocol action did not complete within {timeout}s. Operation timed out.\"\n        self.log.error(msg)\n        raise IxiaOperationException(msg)\n\n    def verify_arp_status2(self, ipType='ipv4', device=None):\n        \"\"\"\n        Verifies the ARP/ND status of all device groups on the TGN session.\n        Uses threading (50 workers) to check unresolved IPs faster.\n        \"\"\"\n        self.log.info(f\"Verification of ARP started (type={ipType})\")\n        ip_type = ipType.lower()\n        unresolved_arp_list = []\n        gateway_ip_list = []\n        timeout = 20\n        result = True\n\n        if isinstance(device, str):\n            device = [device]\n\n        if device:\n            device_obj_list = [\n                dg for dg in self.ixNetwork.Topology.find().DeviceGroup.find()\n                if dg.Name in device\n            ]\n        else:\n            topology = self.ixNetwork.Topology.find()\n            if topology:\n                with BatchFind(topology) as device_group:\n                    self.ixNetwork.Topology.find().DeviceGroup.find()\n                device_obj_list = getattr(device_group.results, 'deviceGroup')\n            else:\n                self.log.warning(\"Topology not found in the config\")\n                return True\n\n        if not device_obj_list:\n            raise IxiaOperationException(f'Device Group \"{device}\" not found')\n\n        for dg in device_obj_list:\n            for counter in range(0, timeout, 2):\n                if dg.Status == 'notStarted':\n                    self.log.warning(f'Device Group {dg.Name} is not started')\n                if counter < timeout and dg.Status == 'starting':\n                    time.sleep(2)\n                    continue\n                if dg.Status in ['started', 'mixed']:\n                    break\n                if counter == timeout and dg.Status not in ['started', 'mixed']:\n                    raise IxiaOperationException(f\"Device Group failed to come up: {dg.Name}\")\n\n        for device_obj in device_obj_list:\n            local_failed_ips = []\n            local_failed_gws = []\n            total_failed = 0\n\n            with BatchFind(device_obj) as ip_obj_list:\n                eval(f\"device_obj.Ethernet.find().{ip_type.capitalize()}.find()\")\n\n            try:\n                ip_obj_list = getattr(ip_obj_list.results, ip_type)\n            except AttributeError:\n                self.log.info(f'{ip_type} block not configured in {device_obj.Name}')\n                continue\n\n            # --- Worker for each IP object ---\n            def process_ip_obj(ip_obj):\n                local_ips, local_gws = [], []\n                session_status = getattr(ip_obj, \"ResolvedGatewayMac\", [])\n                if not session_status:\n                    return 0, local_ips, local_gws\n\n                failed_indices = [i for i, s in enumerate(session_status) if s == \"removePacket[Unresolved]\"]\n                if not failed_indices:\n                    return 0, local_ips, local_gws\n\n                addr_values = getattr(ip_obj.Address, \"Values\", [])\n                gw_values = getattr(ip_obj.GatewayIp, \"Values\", [])\n\n                for i in failed_indices:\n                    if i < len(addr_values):\n                        local_ips.append(addr_values[i])\n                    if i < len(gw_values):\n                        local_gws.append(gw_values[i])\n\n                return len(failed_indices), local_ips, local_gws\n\n            with ThreadPoolExecutor(max_workers=50) as executor:\n                futures = {executor.submit(process_ip_obj, ip_obj): ip_obj for ip_obj in ip_obj_list}\n                for future in as_completed(futures):\n                    count, ips, gws = future.result()\n                    total_failed += count\n                    local_failed_ips.extend(ips)\n                    local_failed_gws.extend(gws)\n\n            if total_failed > 0:\n                self.log.warning(f\"[{device_obj.Name}] Found {total_failed} {ip_type} instance(s) unresolved.\")\n                sample_count =  len(local_failed_ips)\n                self.log.info(\n                    f\"[{device_obj.Name}] Unresolved entries - \"\n                    f\"\\nIP Addresses : {local_failed_ips[:sample_count]},\" \n                    f\"\\nGateway IP Addresses : {local_failed_gws[:sample_count]}\"\n                )\n                unresolved_arp_list.extend(local_failed_ips)\n                gateway_ip_list.extend(local_failed_gws)\n            else:\n                self.log.info(f\"[{device_obj.Name}] ARP Verification passed.\")\n\n        if unresolved_arp_list:\n            total = len(unresolved_arp_list)\n            self.log.warning(f\"[{device_obj.Name}]ARP Verification Failed: {total} unresolved entries \")\n\n    def start_arp_and_verify_global(self, **kwargs):\n        \"\"\"\n        Starts the ARP/ND process and verifies the ARP status.\n\n        Automatically waits for protocol actions (like SendArpGlobal)\n        to complete using _wait_for_protocol_action_complete().\n        \"\"\"\n        \n        ip_type = kwargs.get(\"ip_type\", \"ipv4\")\n        timeout = kwargs.get(\"timeout\", 240) \n        result_list = []\n\n        topology = self.ixNetwork.Topology.find()\n        with BatchFind(topology) as device_group:\n            topology.DeviceGroup.find()\n\n        device_obj_list = getattr(device_group.results, \"deviceGroup\", [])\n        if not device_obj_list:\n            self.log.warning(\"No device groups found in topology.\")\n            return False\n\n        try:\n            for device_obj in device_obj_list:\n                self.log.info(f\"Starting ARP on: {device_obj.Name}\")\n\n                if ip_type == \"ipv4\":\n                    device_obj.SendArpGlobal()\n                elif ip_type == \"ipv6\":\n                    device_obj.SendNsGlobal()\n                else:\n                    raise IxiaOperationException(\"Invalid ip_type: use 'ipv4' or 'ipv6'\")\n\n                self.log.debug(f\"Waiting for ARP/NS action to complete on {device_obj.Name}...\")\n                self._wait_for_protocol_action_complete(timeout=timeout)\n\n                result = self.verify_arp_status2(ipType=ip_type, device=device_obj.Name)\n                result_list.append(result)\n\n        except Exception as e:\n            self.log.error(f\"Error during ARP process on {device_obj.Name}: {e}\")\n            return False\n\n        if all(result_list):\n            self.log.info(f\"ARP Verification Successful for all device groups ({ip_type})\")\n            return True\n        else:\n            self.log.warning(f\"One or more ARP verifications failed for {ip_type}\")\n            return False\n\n    def start_arp_and_verify_global1(self, **kwargs):\n        \"\"\"\n        Starts the ARP/ND process and verifies the ARP status.\n\n        Automatically waits for protocol actions (like SendArpGlobal)\n        to complete using _wait_for_protocol_action_complete().\n        \"\"\"\n        \n        ip_type = kwargs.get(\"ip_type\", \"ipv4\")\n        timeout = kwargs.get(\"timeout\", 240) \n        result_list = []\n\n        topology = self.ixNetwork.Topology.find()\n        with BatchFind(topology) as device_group:\n            topology.DeviceGroup.find()\n\n        device_obj_list = getattr(device_group.results, \"deviceGroup\", [])\n        if not device_obj_list:\n            self.log.warning(\"No device groups found in topology.\")\n            return False\n\n        try:\n            for device_obj in device_obj_list:\n                self.log.info(f\"Starting ARP on: {device_obj.Name}\")\n\n                if ip_type == \"ipv4\":\n                    if device_obj.Ethernet.find().Ipv4.find():\n                        for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():\n                            obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))\n                            ipv4_obj.SendArp(SessionIndices=obj_count_list)\n                elif ip_type == \"ipv6\":\n                    if device_obj.Ethernet.find().Ipv6.find():\n                        for ipv6_obj in device_obj.Ethernet.find().Ipv6.find():\n                            obj_count_list = list(range(1, ipv6_obj.Count + 1, 1))\n                            ipv6_obj.SendArp(SessionIndices=obj_count_list)\n                else:\n                    raise IxiaOperationException(\"Invalid ip_type: use 'ipv4' or 'ipv6'\")\n\n                self.log.debug(f\"Waiting for ARP/NS action to complete on {device_obj.Name}...\")\n                self._wait_for_protocol_action_complete(timeout=timeout)\n\n                result = self.verify_arp_status2(ipType=ip_type, device=device_obj.Name)\n                result_list.append(result)\n\n        except Exception as e:\n            self.log.error(f\"Error during ARP process on {device_obj.Name}: {e}\")\n            return False\n\n        if all(result_list):\n            self.log.info(f\"ARP Verification Successful for all device groups ({ip_type})\")\n            return True\n        else:\n            self.log.warning(f\"One or more ARP verifications failed for {ip_type}\")\n            return False\n\n    def fetch_unresolved(self,device_group):\n\n        dg = self.ixNetwork.Topology.find().DeviceGroup.find(Name = device_group)\n\n        count = 0\n        sessioninfo = dg.Ethernet.find().Ipv4.find().SessionInfo\n        for i in sessioninfo:\n            if i == 'resolveMacFailed':\n                count = count +1\n        print(count)\n\n    def _link_local_restart3(self, device_groups=None):\n\n        restart_count = 0\n        self.log.info(\"Checking for any 'Unknown' Local link address in the configuration\")\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():\n            if device_groups and dg.Name not in device_groups:\n                continue\n\n            for eth in dg.Ethernet.find():\n                for ipv6 in eth.Ipv6.find():\n                    try:\n                        \n                        link_local_vals = list(ipv6.LinkLocalAddress)\n                        state_list = list(ipv6.SessionStatus)\n                    except:\n                        continue\n\n                    # pdb.set_trace()\n                    unknown_indices = []\n                    for idx, ll_value in enumerate(link_local_vals, start=1):\n                        if \"removePacket[Unknown]\" in str(ll_value):\n                            state = state_list[idx-1].strip().lower()\n                            if state == \"notstarted\":\n                                unknown_indices.append(idx)\n\n                    if not unknown_indices:\n                        continue\n\n                    self.log.warning(\n                        f\"[{dg.Name}/{eth.Name}] LinkLocal='Unknown' at indices {unknown_indices}. Performing Stop/Start...\"\n                    )\n\n                    restart_count += len(unknown_indices)\n\n                    retry = 0\n                    while retry < 3:\n                        retry += 1\n\n                        try:\n                            ipv6.Stop(SessionIndices=unknown_indices)\n                            self._wait_for_protocol_action_complete(timeout=180)\n                        except Exception as e:\n                            self.log.error(f\"Stop failed for {dg.Name}/{eth.Name} indices {unknown_indices}: {e}\")\n                            break\n\n                        try:\n                            ipv6.Start(SessionIndices=unknown_indices)\n                            self._wait_for_protocol_action_complete(timeout=180)\n                        except Exception as e:\n                            self.log.error(f\"Start failed for {dg.Name}/{eth.Name} indices {unknown_indices}: {e}\")\n                            break\n\n                        \n                        \n                        link_local_vals_after = list(ipv6.LinkLocalAddress)\n                        pdb.set_trace()\n                        self.log.info(link_local_vals_after)\n\n\n                        still_unknown = [\n                            i for i in unknown_indices\n                            if \"Unknown\" in str(link_local_vals_after[i-1])\n                        ]\n\n                        if not still_unknown:\n                            self.log.info(\n                                f\"[{dg.Name}/{eth.Name}] Link-local recovered on indices {unknown_indices}\"\n                            )\n                            break\n\n                        self.log.warning(\n                            f\"[{dg.Name}/{eth.Name}] Still Unknown after retry {retry}: {still_unknown}\"\n                        )\n                        unknown_indices = still_unknown\n\n                    else:\n                        self.log.warning(\n                            f\"[{dg.Name}/{eth.Name}] Could not clear Unknown after retries: {unknown_indices}\"\n                        )\n\n        if restart_count == 0:\n            self.log.info(\"No IPv6 link-local 'Unknown' entries requiring action.\")\n        else:\n            self.log.info(f\"Restarted {restart_count} IPv6 instances with Unknown link-local.\")\n\n        return restart_count\n\n    def _link_local_restart(self, device_groups=None):\n\n        restart_count = 0\n        self.log.info(\"Checking for any 'Unknown' link-local IPv6 entries\")\n\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        topo = self.ixNetwork.Topology.find()\n        if not topo:\n            self.log.error(\"No topology found\")\n            return 0\n\n        dg_list = topo.DeviceGroup.find()\n        if device_groups:\n            dg_list = [dg for dg in dg_list if dg.Name in device_groups]\n\n        ipv6_info = []\n\n        for dg in dg_list:\n            with BatchFind(dg) as finder:\n                dg.Ethernet.find().Ipv6.find()\n            eth_list = getattr(finder.results, 'ethernet')\n\n            if not eth_list:\n                continue\n\n            for eth in eth_list:\n                for ipv6 in eth.Ipv6.find():\n                    ipv6_info.append((dg, eth, ipv6))\n\n        def inspect_ipv6(entry):\n\n            dg, eth, ipv6 = entry\n            try:\n                ll = list(ipv6.LinkLocalAddress)\n                ss = list(ipv6.SessionStatus)\n            except:\n                return None\n\n            unknown = []\n            for idx, val in enumerate(ll, start=1):\n                if \"Unresolved\" in str(val) and ss[idx - 1].lower() == \"down\":\n                    unknown.append(idx)\n\n            \n            if unknown:\n                return (dg, eth, ipv6, unknown)\n            return False\n\n        results = []\n        with ThreadPoolExecutor(max_workers=50) as pool:\n            for res in pool.map(inspect_ipv6, ipv6_info):\n                if res:\n                    results.append(res)\n\n        for dg, eth, ipv6, indices in results:\n            self.log.warning(f\"[{dg.Name}/{eth.Name}] Unknown Link Local @index : {indices}\")\n\n            restart_count += len(indices)\n\n            retry = 0\n            while retry < 3:\n                retry += 1\n\n                try:\n                    ipv6.Stop(SessionIndices=indices)\n                    self.log.debug(\"Action: Stop() in progress\")\n                    self._wait_for_protocol_action_complete(timeout=180)\n                except Exception as e:\n                    self.log.error(f\"Stop failed {dg.Name}/{eth.Name}: {e}\")\n                    break\n\n                try:\n                    ipv6.Start(SessionIndices=indices)\n                    self.log.debug(\"Action: Start() in progress\")\n                    self._wait_for_protocol_action_complete(timeout=180)\n                except Exception as e:\n                    self.log.error(f\"Start failed {dg.Name}/{eth.Name}: {e}\")\n                    break\n\n                time.sleep(10)\n                \n                ipv6 = eth.Ipv6.find()\n                after = list(ipv6.LinkLocalAddress)\n\n                still = [i for i in indices if \"Unresolved\" in str(after[i - 1])]\n                if not still:\n                    self.log.success(f\"[{dg.Name}/{eth.Name}] Recovered on {indices}\")\n                    break\n\n                self.log.warning(f\"[{dg.Name}/{eth.Name}] Still Unknown after retry {retry}: {still}\")\n                indices = still\n\n            else:\n                self.log.warning(f\"[{dg.Name}/{eth.Name}] Could not clear Unknown: {indices}\")\n\n        if restart_count == 0:\n            self.log.info(\"No IPv6 link-local Unknown entries requiring action.\")\n            return True\n        else:\n            self.log.info(f\"Restarted {restart_count} IPv6 instances with Unknown link-local.\")\n            return False\n\n    def restart_ip_stack1(self, device_group_name=None, ip_version='ipv4', max_retries=25,**kwargs):\n        \"\"\"\n        API that RestartDown all IPs that are in 'Down' or 'Not Started' state within the given device group(s).\n\n        :param device_group_name: str or list of device group names to \"restartDown\" the IPs\n        :param ip_version: (str) IP stack version to check; 'ipv4' or 'ipv6'. Default is 'ipv4'.\n        :param max_retries: number of retries for the \"restartDown\"\n        \"\"\"\n        ipv6_unknown = kwargs.get('ipv6_unknown', False)\n        interval_sec, max_threads, chunk_size = 5, 10, 500\n        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'\n        assert ip_version.lower() in ['ipv4', 'ipv6'], \"Invalid IP version. Use 'ipv4' or 'ipv6'.\"\n\n\n        if ipv6_unknown == True:\n\n            self._link_local_restart()\n\n        else:\n            def _chunked(seq, size):\n                return (seq[i:i + size] for i in range(0, len(seq), size))\n\n            def _build_summary(stats):\n                return {\n                    device_grp: {\n                        \"Total IPs\": d['total_ips'], \"IP Version\": ip_version,\n                        \"Up\": d['up'], \"Down\": d['down'], \"Not Started\": d['not started']\n                                } for device_grp, d in stats.items()}\n\n            stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n            # restartable_ips = {\n            #     ip_addr: status for d in stats.values()\n            #     for ip_addr, status in d['ip_status_map'].items()\n            #     if status.strip().lower() in ['down', 'notstarted', 'not started']}\n\n            # NEW: Restart only DGs that actually have bad IPs\n            restart_dgs = {}\n\n            for dg_name, d in stats.items():\n                bad_ips = [\n                    ip for ip, status in d['ip_status_map'].items()\n                    if status.strip().lower() in ('down', 'notstarted', 'not started')\n                ]\n\n                if bad_ips:\n                    restart_dgs[dg_name] = {\n                                                \"bad_ips\": bad_ips\n                                            }\n\n\n\n            if not restart_dgs:\n                self.log.success(f\"All {ip_version.upper()} IPs are already UP.\")\n                summary = _build_summary(stats)\n                return summary\n\n            # count_down = sum(1 for s in restartable_ips.values() if s.strip().lower() == 'down')\n            # count_notstarted = len(restartable_ips) - count_down\n            # self.log.warning(f\"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED\")\n            count_down = sum(\n                1\n                for d in restart_dgs.values()\n                for ip in d[\"bad_ips\"]\n                if stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower() == 'down'\n            )\n            count_notstarted = sum(\n                1\n                for d in restart_dgs.values()\n                for ip in d[\"bad_ips\"]\n                if stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower() != 'down'\n            )\n\n            self.log.warning(f\"{count_down} IPs are DOWN and {count_notstarted} NOT STARTED\")\n\n\n            if isinstance(device_group_name, list):\n                pattern = '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'\n            elif isinstance(device_group_name, str):\n                pattern = re.escape(device_group_name)\n            else:\n                pattern = '.*'\n\n            dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)\n            # ip_stack_refs = {\n            #     ip_addr: ip_stack\n            #     for device_grp in dgs for eth in device_grp.Ethernet.find()\n            #     for ip_stack in getattr(eth, stack_attr).find()\n            #     for ip_addr in ip_stack.Address.Values\n            #     if ip_addr in restartable_ips\n            # }\n            ip_stack_refs = {}\n\n            for device_grp in dgs:\n                dg_name = device_grp.Name\n                if dg_name not in restart_dgs:\n                    continue  # skip UP device groups\n\n                bad_ips = set(restart_dgs[dg_name][\"bad_ips\"])\n\n                for eth in device_grp.Ethernet.find():\n                    for ip_stack in getattr(eth, stack_attr).find():\n                        for ip_addr in ip_stack.Address.Values:\n                            if ip_addr in bad_ips:\n                                ip_stack_refs.setdefault(ip_stack, []).append(ip_addr)\n\n\n            self.log.info(\"Checking for any ongoing protocol actions\")\n            self._wait_for_protocol_action_complete()\n            restart_stack = lambda s: s.RestartDown()\n            self._wait_for_protocol_action_complete(timeout=240, operation_name=\"RestartDown\")\n\n            \n\n            for attempt in range(1, max_retries + 1):\n                # pdb.set_trace()\n                pdb.set_trace()\n                unique_stacks = list(ip_stack_refs.keys())\n                stack_to_ips = ip_stack_refs   # Already grouped\n\n                # Log detailed info\n                # pdb.set_trace()\n                self.log.info(\"RestartDown Details (Attempt %s):\" % attempt)\n                for stack, ip_list in stack_to_ips.items():\n                    try:\n                        dg_name = stack.parent.parent.Name  # IP -> Ethernet -> DeviceGroup\n                    except:\n                        dg_name = \"<unknown>\"\n\n                    self.log.info(\n                        f\"  DeviceGroup: {dg_name}, Stack: {stack.href}, \"\n                        f\"IP Count: {len(ip_list)}, IPs: {ip_list[:5]}{' ...' if len(ip_list) > 5 else ''}\"\n                    )\n                # self.log.debug(f\"RETRY {attempt}/{max_retries}: Restarting {len(unique_stacks)} stacks...\")\n                for chunk in _chunked(unique_stacks, chunk_size):\n                    with ThreadPoolExecutor(max_workers=max_threads) as executor:\n                        list(executor.map(restart_stack, chunk))\n\n                    self.log.debug(\"Waiting for RestartDown action(s) to complete...\")\n                    try:\n                        self._wait_for_protocol_action_complete(timeout=240, operation_name=\"RestartDown\")\n                    except IxiaOperationException as e:\n                        self.log.warning(f\"RestartDown operation timed out after 240s: {e}\")\n\n                    time.sleep(interval_sec)\n\n                updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n\n                # restartable_ips = {\n                #     ip_addr: status\n                #     for d in updated.values()\n                #     for ip_addr, status in d['ip_status_map'].items()\n                #     if status.strip().lower() in ['down', 'notstarted', 'not started', 'unknown']\n                # }\n                ip_stack_refs = {}\n\n                for device_grp in dgs:\n                    dg_name = device_grp.Name\n                    if dg_name not in restart_dgs:\n                        continue\n\n                    bad_ips = set(restart_dgs[dg_name][\"bad_ips\"])\n\n                    for eth in device_grp.Ethernet.find():\n                        for ip_stack in getattr(eth, stack_attr).find():\n                            for ip_addr in ip_stack.Address.Values:\n                                if ip_addr in bad_ips:\n                                    ip_stack_refs.setdefault(ip_stack, []).append(ip_addr)\n\n                restart_dgs = {}   # <\u2500\u2500 CRITICAL FIX\n\n                for dg_name, d in updated.items():\n                    bad_ips = [\n                        ip for ip, status in d['ip_status_map'].items()\n                        if status.strip().lower() in ('down', 'notstarted', 'not started', 'unknown')\n                    ]\n                    if bad_ips:\n                        restart_dgs[dg_name] = {\"bad_ips\": bad_ips}\n\n\n\n                if not restart_dgs:\n                    self.log.success(f\"All IPs are UP after '{attempt}' attempt(s)\")\n                    break\n\n\n            summary = _build_summary(self.get_ip_stack_status(device_group_name, ip_version, display_table=True))\n\n            if restart_dgs:\n                self.log.fail(f\"{len(restart_dgs)} IPs remained DOWN or NOT STARTED after {max_retries} retries. \\n{summary}\")\n                return summary\n        \n            if not restart_dgs:\n                self.log.success(f\"All IPs are UP after '{attempt}' attempt(s). \\n{summary}\")\n                return True\n\n\n    def _restart_ipv6_indices(self, ipv6, indices, dg_name, eth_name):\n        \"\"\"\n        Performs only STOP / START on the given IPv6 session indices.\n        No verification here. Verification is done by the caller.\n        \"\"\"\n\n        try:\n            self.log.info(f\"[{dg_name}/{eth_name}] STOP -> indices {indices}\")\n            ipv6.Stop(SessionIndices=indices)\n            self._wait_for_protocol_action_complete(timeout=180)\n        except Exception as e:\n            self.log.error(\n                f\"[{dg_name}/{eth.Name}] Stop failed for indices {indices}: {e}\"\n            )\n            return False\n\n        try:\n            self.log.info(f\"[{dg_name}/{eth_name}] START -> indices {indices}\")\n            ipv6.Start(SessionIndices=indices)\n            self._wait_for_protocol_action_complete(timeout=180)\n        except Exception as e:\n            self.log.error(\n                f\"[{dg_name}/{eth.Name}] Start failed for indices {indices}: {e}\"\n            )\n            return False\n\n        return True\n\n    def _link_local_restart4(self, device_groups=None):\n\n        restart_count = 0\n        max_cycles = 3\n\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        self.log.info(\"Checking for any 'Unknown' IPv6 link-local addresses\")\n\n        for dg in self.ixNetwork.Topology.find().DeviceGroup.find():\n            if device_groups and dg.Name not in device_groups:\n                continue\n\n            for eth in dg.Ethernet.find():\n                for ipv6 in eth.Ipv6.find():\n\n                    try:\n                        link_local_vals = list(ipv6.LinkLocalAddress)\n                        state_list = list(ipv6.SessionStatus)\n                    except:\n                        continue\n\n                    unknown_indices = [\n                        idx for idx, ll in enumerate(link_local_vals, start=1)\n                        if \"removePacket[Unknown]\" in str(ll)\n                        and state_list[idx-1].strip().lower() == \"notstarted\"\n                    ]\n\n                    if not unknown_indices:\n                        continue\n\n                    restart_count += len(unknown_indices)\n                    self.log.warning(\n                        f\"[{dg.Name}/{eth.Name}] Unknown detected at {unknown_indices}.\"\n                    )\n\n                    # =========================================================\n                    #   MAIN LOOP: helper start/stop \u2192 verify \u2192 repeat\n                    # =========================================================\n                    remaining = unknown_indices[:]\n\n                    for cycle in range(1, max_cycles+1):\n\n                        self.log.info(\n                            f\"[{dg.Name}/{eth.Name}] Cycle {cycle}: running stop/start on {remaining}\"\n                        )\n\n                        ok = self._restart_ipv6_indices(\n                            ipv6, remaining, dg.Name, eth.Name\n                        )\n                        time.sleep(60)\n\n                        if not ok:\n                            break  # cannot proceed\n\n                        # ---- VERIFY HERE (not inside helper) ----\n                        ipv6 = eth.Ipv6.find()\n                        link_after = list(ipv6.LinkLocalAddress)\n                        self.log.debug(link_after)\n\n                        pdb.set_trace()\n                        still_unknown = [\n                            i for i in remaining\n                            if \"Unknown\" in str(link_after[i-1])\n                        ]\n\n                        if not still_unknown:\n                            self.log.info(\n                                f\"[{dg.Name}/{eth.Name}] Recovered: {remaining}\"\n                            )\n                            break\n\n                        self.log.warning(\n                            f\"[{dg.Name}/{eth.Name}] After cycle {cycle} still unknown: {still_unknown}\"\n                        )\n\n                        remaining = still_unknown[:]\n\n                    # After max cycles\n                    if remaining:\n                        self.log.error(\n                            f\"[{dg.Name}/{eth.Name}] Could not fix after {max_cycles} cycles: {remaining}\"\n                        )\n\n        self.log.info(f\"Restarted {restart_count} IPv6 instances with Unknown link-local.\")\n        return restart_count\n\n    def rocev2_config_device(self):\n\n\n        ibmtu = self.ixNetwork \\\n        .Topology.find() \\\n        .DeviceGroup.find() \\\n        .Ethernet.find() \\\n        .Ipv4.find() \\\n        .Rocev2.find() \\\n        .IbMTU\n\n        pdb.set_trace()\n        print(ibmtu.AvailablePatterns)\n\n    def set_rocev2_ib_mtu(self, ib_mtu, device_groups=None, ip_type = 'ipv4'):\n        \"\"\"\n        Set IB MTU for all or selected RoCEv2 stacks.\n\n        :param ib_mtu: MTU value as int (1024, 2048, 4096, etc.)\n        :param device_groups: str or list of DG names. If None, apply to all.\n        :param ip_type: for which IP type to modify IBMtu | 'ipv4' or 'ipv6'\n        :return: True on success\n        \"\"\"\n\n        valid_mtu = [1024, 2048, 4096]\n        if ib_mtu not in valid_mtu:\n            raise ValueError(f\"Invalid IB MTU {ib_mtu}. Allowed: {valid_mtu}\")\n\n        if isinstance(device_groups, str):\n            device_groups = [device_groups]\n\n        topo = self.ixNetwork.Topology.find()\n\n        if not topo:\n            self.log.error(\"No topology found.\")\n            return False\n\n        dg_list = topo.DeviceGroup.find()\n\n        final_dg_list = []\n        if device_groups:\n            for pattern in device_groups:\n                matched = topo.DeviceGroup.find(Name=f'^{re.escape(pattern)}$')\n                final_dg_list.extend(matched)\n        else:\n            final_dg_list = topo.DeviceGroup.find()\n\n        if not dg_list:\n            self.log.warning(\"No matching device groups found.\")\n            return False\n\n        updated_count = 0\n\n        for dg in final_dg_list:\n            for eth in dg.Ethernet.find():\n\n                # IPv4\n                if ip_type == 'ipv4':\n                    for ipv4 in eth.Ipv4.find():\n                        roc = ipv4.Rocev2.find()\n                        if roc:\n                            for r in roc:\n                                try:\n                                    r.IbMTU.Single(ib_mtu)\n                                    updated_count += 1\n                                    self.log.info(f\"Set IBMTU={ib_mtu} on {dg.Name}/{eth.Name}/RoCEv2\")\n                                except Exception as e:\n                                    self.log.error(f\"Failed RoCEv2 IPv4 MTU update @ {dg.Name}: {e}\")\n\n                if ip_type == 'ipv6':\n                    for ipv6 in eth.Ipv6.find():\n                        roc = ipv6.Roce6v2.find()\n                        if roc:\n                            for r in roc:\n                                try:\n                                    r.IbMTU.Single(ib_mtu)\n                                    updated_count += 1\n                                    self.log.info(f\"Set IBMTU={ib_mtu} on {dg.Name}/{eth.Name}/RoCEv2-\")\n                                except Exception as e:\n                                    self.log.error(f\"Failed RoCEv6 MTU update @ {dg.Name}: {e}\")\n\n        if updated_count == 0:\n            self.log.warning(\"No RoCEv2 stacks found to update.\")\n            return False\n\n\n        self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n\n        self.log.success(f\"Updated IB MTU={ib_mtu} on {updated_count} RoCEv2 stacks.\")\n        return True\n\n    def add_device2(self,\n                   port_list=None,\n                   ipv4_address_start=None,\n                   ipv6_address_start=None,\n                   igmp_group_start=None,\n                   mld_group_start=None,\n                   new_config=False,\n                   **kwargs):\n        \"\"\"\n        Add new device to topology\n\n        Mandatory Args:\n\n        :param port_list: List of physical port name,Format of physical port name: 'chassisIP'/'card'/'port', 'card'/'port'\n        :param ipv4_address_start: The starting address for ipv4 devices\n        :param ipv6_address_start: The starting address for ipv6 devices\n        :param igmp_group_start: The starting group for igmp devices\n        :param mld_group_start: The starting group for mld devices\n        :param new_config: True if you want to wipe out the old config, False to use the existing one\n\n        Optional Args:\n\n        :param assign_to_physical_port: CHOICES True, False. Default True\n                True: Asign physical port to the vport created\n                False: Create vport only\n        :param port_name_list: CHOICES None, list of string. Default None\n                None: use format 'card'/'port'\n        :param device_name: Name of the device group name to be created\n        :param interface_no_vlan_count: CHOICES integer. Default is 1 for main interface\n        :param interface_vlan_disable: CHOICES integer - 0,1. To enable/disable Vlan. Default is 0\n        :param vlan_count: CHOICES integer. Number of vlan per device. Default 1\n        :param vlan_id_count: CHOICES 0, integer. Number of vlan per port.\n        :param vlan_id_start: CHOICES List RANGE 0 - 4096.\n                Default None for no change, Example: [<outer vlan start id>,<inner vlan start id>]\n        :param vlan_id_step: CHOICES integer. Default 0\n        :param vlan_id_port_step: CHOICES integer. Default 0\n        :param vlan_id_sequence_length: CHOICES integer.\n        :param vlan_id_repeat_value: CHOICES integer.\n        :param vlan_id_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param vlan_id_step_enable: CHOICE bool.\n        :param vlan_priority_start: CHOICES integer, list RANGE 0 - 7. Default 0\n        :param vlan_priority_step: CHOICES integer. Default 0\n        :param vlan_priority_port_step: CHOICES integer. Default 0\n        :param vlan_priority_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param vlan_priority_step_enable: CHOICES bool.\n        :param vlan_priority_sequence_length: CHOICES integer.\n        :param vlan_priority_repeat_value: CHOICES integer.\n        :param vlan_tpid: CHOICES '0x8100', '0x88a8', '0x9100', '0x9200', '0x9300'\n        :param ipv4_address_start: IPv4 address for first interface\n        :param ipv4_address_step: IPv4 address for step\n        :param ipv4_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_address_prefix: CHOICES integer\n        :param ipv4_address_port_step: CHOICES 'disabled', IPv4 address\n        :param ipv4_address_repeat_value(int): repeat value Ex: 1\n        :param ipv4_address_sequence_length: CHOICES integer\n        :param ipv4_gateway_start: IPv4 address for first interface gateway\n        :param ipv4_gateway_step: IPv4 address for step\n        :param ipv4_gateway_port_step: CHOICES 'disabled', IPv4 address\n        :param ipv4_port_step_enable: CHOICES bool.\n        :param ipv4_gateway_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_gateway_repeat_value (int): repeat value Ex: 1\n        :param ipv4_gateway_sequence_length: CHOICES integer\n        :param ipv4_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv4_address_repeat_increment (str): Ex: \"0.0.0.1\"\n        :param ipv4_gateway_repeat_increment (str): Ex: \"0.0.0.1\"\n        :param ipv4_routerid = '192.0.0.1'\n        :param ipv4_routerid_step = 2\n        :param ipv6_address_repeat_increment (str): Ex: \"0::1\"\n        :param ipv6_gateway_repeat_increment (str): Ex: \"0::1\"\n        :param ipv6_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv6_address_start: IPv6 address for first interface\n        :param ipv6_address_step: IPv6 address for step\n        :param ipv6_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param ipv6_address_prefix: CHOICES integer\n        :param ipv6_address_repeat_value(int): repeat value Ex: 1\n        :param ipv6_address_sequence_length: CHOICES integer\n        :param ipv6_address_port_step: CHOICES 'disabled', IPv6 address\n        :param ipv6_gateway_start: IPv6 address for first interface gateway\n        :param ipv6_gateway_step: IPv6 address for step\n        :param ipv6_gateway_port_step: CHOICES 'disabled', IPv6 address\n        :param ipv6_port_step_enable: CHOICES bool.\n        :param ipv6_gateway_repeat_value(int): repeat value Ex: 1\n        :param ipv6_gateway_sequence_length: CHOICES integer\n        :param ipv6_gateway_direction: CHOICES 'increment', 'decrement'\n        :param ipv6_routerid: '192.0.0.1'\n        :param ipv6_routerid_step: 2\n        :param igmp_version: CHOICES string/list. 'version1','version2','version3'\n        :param igmp_num_of_group_range: CHOICES integer\n        :param igmp_group_start: IPv4 multicast address.Default None for no configure igmp\n        :param igmp_group_step: IPv4 address. Default '0.0.0.1'\n        :param igmp_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param igmp_group_port_step: CHOICES 'disable', 'enable', IPv4 address\n        :param igmp_group_port_step_enable: CHOICES 'disable', 'enable'\n        :param igmp_group_address_count: CHOICES integer.\n        :param igmp_group_address_increment: CHOICES IPv4 address\n        :param igmp_group_repeat_value(int): repeat value Ex: 1\n        :param igmp_group_sequence_length: CHOICES integer.\n        :param igmp_source_mode: CHOICES 'include', 'exclude'\n        :param igmp_num_source_range: CHOICES integer\n        :param igmp_source_start: IPv4 address\n        :param igmp_source_step: IPv4 address. Default '0.0.0.1'\n        :param igmp_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param igmp_source_port_step: CHOICES 'disabled', IPv4 address\n        :param igmp_source_port_step_enable: CHOICES 'disabled','enabled'\n        :param igmp_source_addree_increment: IPv4 address\n        :param igmp_source_address_count: CHOICES integer\n        :param igmp_source_repeat_value(int): repeat value Ex: 1\n        :param igmp_source_sequence_length: CHOICES integer\n        :param igmp_rate_interval: rate to be configured\n        :param mld_version: CHOICES string/list. 'version1','version2'\n        :param mld_num_of group_range: CHOICES integer\n        :param mld_group_start: IPv6 multicast address, Default None for no configure mld\n        :param mld_group_step: IPv6 address. Default '::1'\n        :param mld_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param mld_group_port_step: CHOICES 'disabled', IPv6 address\n        :param mld_group_port_step_enable: CHOICES 'disabled', 'enabled'\n        :param mld_group_address_count: CHOICES integer\n        :param mld_group_address_increment: CHOICE IPv6 address\n        :param mld_group_repeat_value(int): repeat value Ex: 1\n        :param mld_group_sequence_length: CHOICES integer\n        :param mld_source_mode: CHOICES 'include', 'exclude'\n        :param mld_num_source_range: CHOICES integer\n        :param mld_source_start: IPv6 address\n        :param mld_source_step: IPv6 address. Default '::1'\n        :param mld_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'\n        :param mld_source_port_step: CHOICES 'disabled', IPv6 address\n        :param mld_source_port_step_enable: CHOICES 'disabled','enabled'\n        :param mld_source_address_increment: IPv6 address\n        :param mld_source_address_count: CHOICES integer\n        :param mld_source_repeat_value(int): repeat value Ex: 1\n        :param mld_source_sequence_length: CHOICES integer\n        :param mld_rate_interval: rate to be configured\n        :param multiple_ports_per_topo: CHOICES bool\n        :return: device_obj dictionary {'vport':<obj>, 'ipv4':<obj>....}\n\n        #Create device BGP config\n        :param bgp_v4_active = True,\n        :param bgp_v4_dut = '100.1.0.2',\n        :param bgp_v4_dut_ip_address = '100.1.0.2',\n        :param bgp_v4_2_byte_as = 100,\n        :param bgp_v4_type = 'external'\n        :param bgp_v4_enable_4_byte_as = 'True',\n        :param bgp_v4_4_byte_as = 66000,\n        :param bgp_v4_hold_time_interval = 60,\n        :param bgp_v4_keep_alive_interval = 20,\n        :param bgp_v4_configure_keep_alive_timer = True,\n        :param bgp_v4_enable_graceful_restart = True,\n        :param bgp_v4_route_count = 5,\n        :param bgp_v4_route_start ='11.11.11.1',\n        :param bgp_v4_route_prefix = 28,\n        :param bgp_v4_route_prefix_step = 2,\n        :param bgp_v4_route_active = True,\n        :param bgp_v4_route_segment_type = 'assetconfederation',\n        :param bgp_v4_ttl =32,\n        :param bgp_v4_authentication = 'md5',\n        :param bgp_v4_password = 'ixia1',\n        :param bgp_v4_minimum_label =20\n        :param bgp_v4_aspath = 200\n        :param bgp_v4_asnum_stepvalue = 2\n\n        #Create device BGPv6 config\n        :param bgp_v6_active=True,\n        :param bgp_v6_dut='2000:1:1:1::1',\n        :param bgp_v6_dut_ip_address='2000:1:1:1::1',\n        :param bgp_v6_type: 'external',\n        :param bgp_v6_enable_2_byte_as = 100,\n        :param bgp_v6_enable_4_byte_as=True,\n        :param bgp_v6_4_byte_as=66000,\n        :param bgp_v6_hold_time_interval=60,\n        :param bgp_v6_keep_alive_interval=20,\n        :param bgp_v6_configure_keep_alive_timer=True,\n        :param bgp_v6_enable_graceful_restart=True,\n        :param bgp_v6_route_count=10,\n        :param bgp_v6_route_start='2000:1:1:1::1',\n        :param bgp_v6_route_prefix = 28,\n        :param bgp_v6_route_prefix_step = 2,\n        :param bgp_v6_route_active=True,\n        :param bgp_v6_route_segment_type='assetconfederation',\n        :param bgp_v6_ttl=32,\n        :param bgp_v6_authentication='md5',\n        :param bgp_v6_password='ixia1',\n        :param bgp_v6_minimum_label = 20\n        :param bgp_v6_aspath = 200\n        :param bgp_v6_asnum_stepvalue = 2\n\n\n        :Example: add_device(port_list= [\"10.39.60.2/1/1\"])\n        \"\"\"\n        self.log.info(\"Adding New Device to the Topology\")\n        disable_diag_log = kwargs.get('disable_diag_log', False)\n        self.disable_diag_log = disable_diag_log\n        self.disable_trace_log = kwargs.get('disable_trace_log', True)\n        device_obj = kwargs.get('device_obj', {})\n        port_name_list = kwargs.get('port_name_list', None)\n        assign_to_physical_port = kwargs.get('assign_to_physical_port', True)\n        interface_no_vlan_count = kwargs.get('interface_no_vlan_count', 1)\n        interface_vlan_disable = kwargs.get('interface_vlan_disable', 0)\n        vlan_id_count = kwargs.get('vlan_id_count', 0)\n        igmp_rate_interval = kwargs.get('igmp_rate_interval', 0)\n        mld_rate_interval = kwargs.get('mld_rate_interval', 0)\n        device_name = kwargs.get('device_name', None)\n        devicegroup_name = kwargs.get('devicegroup_name', None)\n        forceTakePortOwnership = True\n        existingDeviceObj = None\n        testPorts = []\n        vportList = []\n        if self.update_license == False and new_config == True:\n            self._new_session(self.user_name, self.session_name, kill_existing=True)\n        if new_config:\n            self.ixNetwork.NewConfig()\n        if not new_config:\n            vportData = [(vportConnect.AssignedTo).replace(':', '/') for vportConnect in self.get_list_ports()]\n            self._update_media_type()\n        else:\n            vportData = None\n        if kwargs.get('multiple_vports_topo', None):\n            port_list = [port_list]\n\n        if not port_list:\n            return True\n        \n        for port in port_list:\n\n            if kwargs.get('multiple_vports_topo', None):\n                for vport in port_list[0]:\n                    if vportData:\n                        if vportData:\n                            # vportInfo = [port[port.index('/') + 1:] for port in vportData]\n                            vportInfo = [port.replace(':', '/') for port in vportData]\n                        else:\n                            vportInfo = None\n                        if vportInfo:\n                            if vport in vportInfo:\n                                for portObj in self.ixNetwork.Vport.find():\n                                    portAssigned = (portObj.AssignedTo).replace(':', '/')\n                                    if vport == portAssigned[portAssigned.index('/') + 1:]:\n                                        portName = portObj.Name\n                                        device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)\n                                        break\n                                    existingDeviceObj = True\n                            else:\n                                self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,\n                                                    forceTakePortOwnership)\n                    else:\n                        self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,\n                                            forceTakePortOwnership)\n            else:\n                if 'vport' not in device_obj and existingDeviceObj is None:\n                    if port_name_list:\n                        if len(port_list) != len(port_name_list):\n                            msg = 'port name:%s do not match ports:%s' % (port_name_list, port_list)\n                            self.log.error(msg)\n                            raise CafyException.TgenConfigMissingError(msg)\n\n                    if vportData:\n\n                        # vportInfo = [port[port.index('/') + 1:] for port in vportData]\n                        vportInfo = [port.replace(':', '/') for port in vportData]\n                    else:\n                        vportInfo = None\n                    if vportInfo:\n                        temp_port = port\n                        port = port[port.index('/') + 1:]\n                        if port in vportInfo:\n                            for portObj in self.ixNetwork.Vport.find():\n                                assigned = (portObj.AssignedTo).replace(':', '/')\n                                if assigned == port: \n                                    portName = portObj.Name\n                                    device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)\n                                    break\n                            existingDeviceObj = True\n                        else:\n                            port = temp_port\n                            self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,\n                                                forceTakePortOwnership)\n                    else:\n                        self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,\n                                            forceTakePortOwnership)\n\n            if 'topology' not in device_obj:\n                topologyObj = None\n                if kwargs.get('multiple_vports_topo', None):\n                    port = port[0]\n                if vportData:\n                    vportInfo = [port.replace(':', '/') for port in vportData]\n                    if port in vportInfo:\n                        for topology in self.ixNetwork.Topology.find():\n                            for portObj in self.ixNetwork.Vport.find():\n                                # if port in (portObj.AssignedTo).replace(':', '/'):   - old\n                                portAssigned = (portObj.AssignedTo).replace(':', '/')\n                                if port == portAssigned[portAssigned.index('/') + 1:]:\n                                    portName = portObj.Name.replace('/', r'\\/').replace('(', r'\\(').replace(')', r'\\)') + '$'\n                                    break\n                            if self.ixNetwork.Vport.find(Name=portName).href in topology.Vports:\n                                device_obj['topology'] = topology\n                                topologyObj = True\n                                break\n                if not topologyObj:\n                    if vportList == []:\n                        for portObj in self.ixNetwork.Vport.find():\n                            if temp_port in (portObj.AssignedTo).replace(':', '/'):\n                                vportList.append(portObj.href)\n                    device_obj['topology'] = self.ixNetwork.Topology.add(Vports=vportList)\n\n            if 'interface_no_vlan_count' in kwargs:\n                multiplier = interface_no_vlan_count + vlan_id_count\n            elif 'interface_vlan_disable' in kwargs :\n                multiplier = interface_vlan_disable + vlan_id_count\n            elif vlan_id_count:\n                multiplier = vlan_id_count\n            else:\n                multiplier = 1\n            if 'devicegroup_name' not in kwargs:\n                kwargs['devicegroup_name'] = None\n            if 'device_name' in kwargs:\n                kwargs['devicegroup_name'] = kwargs['device_name']\n            if 'devicegroup' not in device_obj and existingDeviceObj is None:\n                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],\n                                                                                   Multiplier=multiplier)\n            else:\n                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],\n                                                                                   Multiplier=multiplier)\n            vlanIdKwargs = {key: kwargs[key] for key in kwargs if \"id\" in key and kwargs[key] != \"\"}\n            vlanPriorityKwargs = {key: kwargs[key] for key in kwargs if \"priority\" in key and kwargs[key] != \"\"}\n            if ('ethernet' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                device_obj['ethernet'] = device_obj['devicegroup'].Ethernet.add(Name=None,\n                                                                                VlanCount=kwargs.get('vlan_count',\n                                                                                                     None))\n                if kwargs.get('vlan_count', None) or kwargs.get('vlan_id_step', None):\n                    device_obj['ethernet'].UseVlans = True\n                if 'interface_no_vlan_count' in kwargs:\n                    valueList = ['false' if i <= interface_no_vlan_count else 'true' for i in\n                                 range(1, interface_no_vlan_count + vlan_id_count + 1)]\n                    device_obj['ethernet'].EnableVlans.ValueList(valueList)\n                if 'interface_vlan_disable' in kwargs:\n                    valueList = ['true'] * (interface_vlan_disable + vlan_id_count)\n                    if 0 <= interface_vlan_disable < len(valueList):\n                        valueList[interface_vlan_disable] = 'false'\n                    device_obj['ethernet'].EnableVlans.ValueList(valueList)\n                if 'vlan_id_start' in kwargs:\n                    vlanIdKwargs['vlan_id_direction'] = kwargs.get('vlan_id_direction', 'increment')\n                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanIdKwargs)\n                    vlanObj.config()\n                    self.log.info(\"Vlan Id Info configured successfully\")\n\n                if 'vlan_priority_start' in kwargs:\n                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanPriorityKwargs)\n                    vlanObj.config()\n                    self.log.info(\"Vlan Priority Info configured successfully\")\n\n            if 'ipv4_address_direction' not in kwargs and 'ipv4_address_step' in kwargs:\n                kwargs['ipv4_address_direction'] = 'increment'\n            if 'ipv4_gateway_direction' not in kwargs and 'ipv4_gateway_step' in kwargs:\n                kwargs['ipv4_gateway_direction'] = 'increment'\n            if 'ipv6_address_direction' not in kwargs and 'ipv6_address_step' in kwargs:\n                kwargs['ipv6_address_direction'] = 'increment'\n            if 'ipv6_gateway_direction' not in kwargs and 'ipv6_gateway_step' in kwargs:\n                kwargs['ipv6_gateway_direction'] = 'increment'\n            ipv4Kwargs = {key: kwargs[key] for key in kwargs if \"ipv4\" in key and kwargs[key] != \"\"}\n            ipv6Kwargs = {key: kwargs[key] for key in kwargs if \"ipv6\" in key and kwargs[key] != \"\"}\n            igmpKwargs = {key: kwargs[key] for key in kwargs if \"igmp\" in key and kwargs[key] != \"\"}\n            mldKwargs = {key: kwargs[key] for key in kwargs if \"mld\" in key and kwargs[key] != \"\"}\n            bgpv4Kwargs = {key: kwargs[key] for key in kwargs if \"bgp_v4\" in key and kwargs[key] != \"\"}\n            bgpv6Kwargs = {key: kwargs[key] for key in kwargs if \"bgp_v6\" in key and kwargs[key] != \"\"}\n\n            if ('ipv4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if ipv4_address_start:\n                    device_obj['ipv4'] = device_obj['ethernet'].Ipv4.add()\n                    ipv4Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],\n                                    ipv4_address_start=ipv4_address_start, **ipv4Kwargs)\n                    ipv4Obj.config()\n                    self.log.info(\"Ipv4 Info configured successfully\")\n\n            if ('ipv6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if ipv6_address_start:\n                    device_obj['ipv6'] = device_obj['ethernet'].Ipv6.add()\n                    ipv6Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],\n                                    ipv6_address_start=ipv6_address_start, **ipv6Kwargs)\n                    ipv6Obj.config()\n                    self.log.info(\"IPv6 Info configured successfully\")\n\n            # Create IGMP\n            if ('igmp' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if igmpKwargs:\n                    if 'ipv4' in device_obj:\n                        igmpObj = IGMP(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'],\n                                       igmp_group_start=igmp_group_start,\n                                       **igmpKwargs)\n                        igmpObj.config()\n                        self.log.info(\"Igmp Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv4 object not found\")\n                    if igmp_rate_interval:\n                        self.set_igmp_mld_rate(device_type='igmp', rate=igmp_rate_interval, device_group_name=devicegroup_name,\n                                               device_name=device_name)\n            # Create MLD\n            if ('mld' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if mldKwargs:\n                    if 'ipv6' in device_obj:\n                        mldObj = MLD(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], mld_group_start=mld_group_start,\n                                     **mldKwargs)\n                        mldObj.config()\n                        self.log.info(\"Mld Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv6 object not found\")\n                    if mld_rate_interval:\n                        self.set_igmp_mld_rate(device_type='mld', rate=mld_rate_interval, device_group_name=devicegroup_name,\n                                               device_name=device_name)\n            # Create BGPv4\n            if ('bgp_v4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if bgpv4Kwargs != {}:\n                    if 'ipv4' in device_obj:\n                        bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'], **bgpv4Kwargs)\n                        bgpv4Obj.config()\n                        self.log.info(\"BGPv4 Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv4 object not found\")\n            # Create BGPv6\n            if ('bgp_v6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:\n                if bgpv6Kwargs != {}:\n                    if 'ipv6' in device_obj:\n                        bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], **bgpv6Kwargs)\n                        bgpv6Obj.config()\n                        self.log.info(\"BGPv6 Info configured successfully\")\n                    else:\n                        raise IxiaConfigException(\"Ipv6 object not found\")\n\n            #Create ipv4 routerId\n            if kwargs.get('ipv4_routerid', None) != None:\n                router_obj = device_obj['devicegroup'].RouterData.find().RouterId\n                if kwargs.get('ipv4_router_step'):\n                    router_obj.Increment(start_value = kwargs.get('ipv4_routerid'),\n                                            step_value = '0.0.0.' + str(kwargs.get('ipv4_router_step')))\n                else:\n                    router_obj.Single(kwargs.get('ipv4_routerid'))\n\n            #Create ipv6 routerId\n            if kwargs.get('ipv6_routerid', None) != None:\n                router_obj = device_obj['devicegroup'].RouterData.find().RouterId\n                if kwargs.get('ipv6_router_step'):\n                    router_obj.Increment(start_value = kwargs.get('ipv6_routerid'),\n                                            step_value = '0.0.0.' + str(kwargs.get('ipv6_router_step')))\n                else:\n                    router_obj.Single(kwargs.get('ipv6_routerid'))\n\n            retryCount = 0\n            while True:\n                if retryCount == 10: break\n                try:\n                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()\n                    break\n                except:\n                    time.sleep(3)\n                    retryCount = retryCount + 1\n\n        if self.primary:\n            self.connect_to_chassis([self.primary])\n            connected_chassis_list = [chassis.Hostname for chassis in self.ixNetwork.AvailableHardware.Chassis.find() if\n                                      chassis.Hostname != self.primary]\n            if connected_chassis_list:\n                self.set_chassis_mode(primary=self.primary, secondary=connected_chassis_list)\n        return device_obj\n\n    def start_stop_rocev2_1(self, action = 'start',device_name = None,ip_type = 'ipv4'):\n        \"\"\"\n        Start or stop RoCEv2 protocol stacks.\n\n        :param action: Operation to perform on RoCEv2 protocol.\n                       Options: 'start' (default) or 'stop'.\n        :param device_name: DeviceGroup selection.\n                       - None (default): operate on all RoCEv2 stacks.\n                       - str: a single device group name.\n                       - list[str]: list of multiple device group names.\n        :param ip_type: IP protocol type under which RoCEv2 is configured.\n                       Options: 'ipv4' (default) or 'ipv6'.\n\n        Example:\n            # Start all RoCEv2 IPv4 stacks\n            ApData.TGEN.start_stop_rocev2(action='start')\n\n            # Stop only the RoCEv2 stack under device group 'DG1'\n            ApData.TGEN.start_stop_rocev2(action='stop', device_name='DG1')\n\n            # Start RoCEv2 on multiple device groups (IPv6)\n            ApData.TGEN.start_stop_rocev2(\n                action='start',\n                device_name=['DG1', 'DG2'],\n                ip_type='ipv6'\n            )\n        \"\"\"\n\n        \n        self.log.info(\"Initialising start/stop on RoCE Protocol\")\n        action = action.lower()\n        rocev_list = []\n\n        if device_name == None:\n            if ip_type.lower() == 'ipv4':\n                for roce_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Rocev2.find():\n                    rocev_list.append(roce_obj)\n            elif ip_type.lower() == 'ipv6':\n                for roce_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Roce6v2.find():\n                    rocev_list.append(roce_obj)\n            else:\n                raise ValueError(\"ip_type must be 'ipv4' or 'ipv6'\")\n            \n        else:\n            if isinstance(device_name,str):\n                device_name = [device_name]\n            else:\n                pass\n            for device in device_name:\n                if ip_type.lower()== 'ipv4':\n                    roce_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name  = f'^{re.escape(device)}$').Ethernet.find().Ipv4.find().Rocev2.find()\n                    rocev_list.append(roce_obj)\n                elif ip_type.lower()== 'ipv6':\n                    roce_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name  = f'^{re.escape(device)}$').Ethernet.find().Ipv6.find().Roce6v2.find()\n                    rocev_list.append(roce_obj)\n                else:\n                    raise ValueError(\"ip_type must be 'ipv4' or 'ipv6'\")\n\n        if not rocev_list:\n            raise RuntimeError(\"No RoCEv2 protocol stacks found matching input criteria.\")\n\n        for roce in rocev_list:\n            try:\n                self.log.info(f\"Performing {action.upper()} on RoCE Stack: {roce.Name}\")\n                roce.Start() if action == 'start' else roce.Stop()\n                self._wait_for_protocol_action_complete(operation_name=f'[RoCE {action.upper()}]',timeout = 500)\n            except Exception as e:\n                self.log.error(f\"Failed to {action} RoCE protocol on {roce.Name}: {e}\")\n                raise\n\n    def get_traffic_type(self, traffic_item = None):\n        \"\"\"\n        Fetch Traffic Item(s) type\n\n        :param traffic_item: Name of the traffic item | str or list.\n                             Default None, meaning all traffic items in the config\n        \n        return: Dict of traffic item name and type\n\n        Example: tgnObj.get_traffic_type(traffic_item=['Traffic Item 1','Traffic Item 2']\n                 tgnObj.get_traffic_type()\n\n        \"\"\"\n        \n        self.log.info(\"Fetching Traffic Item(s) type\")\n        traffic_obj = self.ixNetwork.Traffic.TrafficItem.find()\n        if not traffic_obj:\n            raise Exception(\"No traffic items configured\")\n\n        traffic_type = {}\n        if traffic_item == None:\n            for traffic in traffic_obj:\n                type = traffic.TrafficType\n                name = traffic.Name\n                traffic_type[name] = type\n        else:\n\n            if isinstance(traffic_item,str):\n                traffic_item = [traffic_item]\n            for traffic in traffic_item:\n                t_obj = self.ixNetwork.Traffic.TrafficItem.find(Name= f'^{re.escape(traffic)}$')\n                if not t_obj:\n                    raise Exception(f\"No such traffic item(s) found with Name : {traffic}\")\n                type = t_obj.TrafficType\n                traffic_type[traffic] = type\n        \n        return traffic_type\n\n    def start_stop_rocev2(self,action = 'start',ip_type = 'ipv4'):\n\n        rocev_list = []\n        if ip_type.lower() == 'ipv4':\n\n            for rocev2_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Rocev2.find():\n                rocev_list.append(rocev2_obj)\n            for rocev2_nest_obj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find().Rocev2.find():\n                rocev_list.append(rocev2_nest_obj)\n            for rocev2_dg_nest in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ipv4Loopback.find().Rocev2.find():\n                rocev_list.append(rocev2_dg_nest)\n\n        if ip_type.lower() == 'ipv6':\n\n            for rocev2_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Roce6v2.find():\n                rocev_list.append(rocev2_obj)\n            for rocev2_nest_obj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find().Roce6v2.find():\n                rocev_list.append(rocev2_nest_obj)\n            for rocev2_dg_nest in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ipv6Loopback.find().Roce6v2.find():\n                rocev_list.append(rocev2_dg_nest)\n\n        if not rocev_list:\n            raise RuntimeError(\"No RoCEv2 protocol stacks found matching input criteria.\")\n\n        for roce in rocev_list:\n            try:\n                self.log.info(f\"Performing {action.upper()} on RoCE Stack: {roce.Name}\")\n                # roce.Start() if action == 'start' else roce.Stop()\n                roce_name = roce.Name\n                self.log.info(roce_name)\n                self._wait_for_protocol_action_complete(operation_name=f'[RoCE {action.upper()}]',timeout = 500)\n            except Exception as e:\n                self.log.error(f\"Failed to {action} RoCE protocol on {roce.Name}: {e}\")\n\n\n    def start_stop_rocev2_2(self, action='start', ip_type='ipv4'):\n\n        ip_type = ip_type.lower()\n        valid_actions = ['start', 'stop']\n\n        if action not in valid_actions:\n            raise ValueError(f\"Invalid action '{action}'. Expected one of: {valid_actions}\")\n\n        if ip_type not in ['ipv4', 'ipv6']:\n            raise ValueError(\"ip_type must be either 'ipv4' or 'ipv6'.\")\n\n        topo = self.ixNetwork.Topology.find()\n        rocev_list = []\n\n        # Helper function to avoid repeating code\n        def collect(base, protocol):\n            try:\n                rocev_list.extend(base.find(protocol).find())\n            except:\n                pass  # If path does not exist, ignore\n\n        if ip_type == 'ipv4':\n            collect(topo.DeviceGroup.find().Ethernet.find().Ipv4.find(), 'Rocev2')\n            collect(topo.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find(), 'Rocev2')\n            collect(topo.DeviceGroup.find().DeviceGroup.find().Ipv4Loopback.find(), 'Rocev2')\n\n        else:  # ipv6\n            collect(topo.DeviceGroup.find().Ethernet.find().Ipv6.find(), 'Roce6v2')\n            collect(topo.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find(), 'Roce6v2')\n            collect(topo.DeviceGroup.find().DeviceGroup.find().Ipv6Loopback.find(), 'Roce6v2')\n\n        if not rocev_list:\n            raise RuntimeError(\"No RoCEv2 protocol stacks found matching input criteria.\")\n\n        for roce in rocev_list:\n            try:\n                self.log.info(f\"{action.upper()} RoCE protocol on: {roce.Name}\")\n\n                # if action == 'start':\n                #     roce.Start()\n                # else:\n                #     roce.Stop()\n\n                self._wait_for_protocol_action_complete(\n                    operation_name=f'[RoCE {action.upper()}]',\n                    timeout=500\n                )\n\n            except Exception as e:\n                self.log.error(f\"Failed to {action} RoCE protocol on {roce.Name}: {e}\")\n\n    def start_stop_rocev2_3(self, action='start', roce_type='roce6v2'):\n        \"\"\"\n        Start or stop RoCEv2 protocol stacks all across topology.\n\n        :param action: Operation to perform on RoCEv2 protocol.\n                       Options: 'start' (default) or 'stop'.\n\n        :param roce_version: IP protocol type under which RoCEv2 is configured.\n                       Options: 'roce6v2' (default) or 'rocev2'.\n\n        :Example: start_stop_rocev2(ip_type = 'ipv6', action='stop')\n        \"\"\"\n\n        self.log.info(\"Initialising start/stop on RoCE Protocol\")\n        topo = self.ixNetwork.Topology.find()\n        rocev_list = []\n\n        def _safe_find(obj, child):\n            try:\n                found = getattr(obj, child).find()\n                return found if found else []\n            except:\n                return []\n\n        def _collect_roce(path_list, roce_attr):\n            obj = topo\n            for step in path_list:\n                found = _safe_find(obj, step)\n                if not found:\n                    return None     \n                obj = found\n            rocev_list.extend(_safe_find(obj, roce_attr))\n\n        if roce_type.lower() == 'rocev2':\n            _collect_roce([\"DeviceGroup\", \"Ethernet\", \"Ipv4\"], \"Rocev2\")\n            _collect_roce([\"DeviceGroup\", \"NetworkGroup\", \"DeviceGroup\", \"Ipv4Loopback\"], \"Rocev2\")\n            _collect_roce([\"DeviceGroup\", \"DeviceGroup\", \"Ipv4Loopback\"], \"Rocev2\")\n\n        elif roce_type.lower() == 'roce6v2':\n            _collect_roce([\"DeviceGroup\", \"Ethernet\", \"Ipv6\"], \"Roce6v2\")\n            _collect_roce([\"DeviceGroup\", \"NetworkGroup\", \"DeviceGroup\", \"Ipv6Loopback\"], \"Roce6v2\")\n            _collect_roce([\"DeviceGroup\", \"DeviceGroup\", \"Ipv6Loopback\"], \"Roce6v2\")\n\n        if not rocev_list:\n            raise IxiaConfigException(\"No RoCEv2 protocol stacks found.\")\n\n        for roce in rocev_list:\n            self.log.info(f\"{action.upper()} RoCE on: {roce.Name}\")\n            getattr(roce, action.capitalize())()\n            self._wait_for_protocol_action_complete(operation_name=f\"[RoCE {action.upper()}]\", timeout=500)\n        \n        return True\n\n    def _get_restart_dgs(self, stats):\n\n        restart_dgs = {}\n\n        for dg_name, d in stats.items():\n            down_ips = []\n            not_started_ips = []\n            bad_ips = []\n\n            for ip, status in d['ip_status_map'].items():\n                s = status.strip().lower()\n                if s in (\"down\", \"notstarted\", \"not started\"):\n                    bad_ips.append(ip)\n                    if s == \"down\":\n                        down_ips.append(ip)\n                    if s in [\"notstarted\", \"not started\"]:\n                        not_started_ips.append(ip)\n\n            if bad_ips:\n                restart_dgs[dg_name] = {\n                    \"bad_ips\": bad_ips,\n                    \"down_ips\": down_ips,\n                    \"not_started_ips\": not_started_ips,\n                    \"down_count\": len(down_ips),\n                    \"not_started_count\": len(not_started_ips),\n                }\n\n        return restart_dgs\n\n    def _build_ip_stack_refs(self, dgs, restart_dgs, stack_attr):\n\n        ip_stack_refs = {}\n\n        for dg in dgs:\n            name = dg.Name\n            if name not in restart_dgs:\n                continue\n\n            bad_ips = set(restart_dgs[name][\"bad_ips\"])\n\n            for eth in dg.Ethernet.find():\n                for ip_stack in getattr(eth, stack_attr).find():\n                    for ip in ip_stack.Address.Values:\n                        if ip in bad_ips:\n                            ip_stack_refs.setdefault(ip_stack, []).append(ip)\n\n        return ip_stack_refs\n\n    def _refresh_restart_dgs(self, stats):\n\n        restart_dgs = {}\n\n        for dg_name, d in stats.items():\n            bad_ips = [\n                ip for ip, status in d['ip_status_map'].items()\n                if status.strip().lower() in ('down', 'notstarted', 'not started')\n            ]\n            if bad_ips:\n                restart_dgs[dg_name] = {\"bad_ips\": bad_ips}\n\n        return restart_dgs\n\n    # def _compute_bad_ip_summary(self, restart_dgs, stats):\n\n        # count_down, count_not = 0, 0\n\n        # for d in restart_dgs.values():\n        #     for ip in d[\"bad_ips\"]:\n        #         st = stats[next(iter(stats))]['ip_status_map'].get(ip, '').strip().lower()\n        #         if st == 'down':\n        #             count_down += 1\n        #         else:\n        #             count_not += 1\n        # return count_down, count_not\n\n    def _refresh_restart_dgs_with_counts(self, stats):\n        restart_dgs = {}\n        for dg_name, d in stats.items():\n            bad_ips = [\n                ip for ip, status in d['ip_status_map'].items()\n                if status.strip().lower() in ('down', 'notstarted', 'not started')\n            ]\n            if bad_ips:\n                restart_dgs[dg_name] = {\n                    \"bad_ips\": bad_ips,\n                    \"down_count\": d.get(\"down\", 0),\n                    \"not_started_count\": d.get(\"not started\", 0),\n                }\n        return restart_dgs\n\n    def _build_final_summary(self, stats, ip_version):\n        return {\n            dg: {\n                \"Total IPs\": d['total_ips'],\n                \"IP Version\": ip_version,\n                \"Up\": d['up'],\n                \"Down\": d['down'],\n                \"Not Started\": d['not started']\n            }\n            for dg, d in stats.items()\n        }\n\n    def _restart_device_group_ips(self, dg_name, bad_ips, ip_type):\n        \"\"\"\n        RestartDown only the sessions whose IP address (IPv4 or IPv6)\n        appears in bad_ips.\n\n        :param dg_name: Device Group name (string)\n        :param bad_ips: list of IPs that were DOWN\n        :param ip_type: \"ipv4\" or \"ipv6\"\n        \"\"\"\n\n        ip_type = ip_type.lower()\n        if ip_type not in (\"ipv4\", \"ipv6\"):\n            raise ValueError(\"ip_type must be 'ipv4' or 'ipv6'\")\n\n        topo = self.ixNetwork.Topology.find()\n        dg = topo.DeviceGroup.find(Name=f'^{re.escape(dg_name)}$')\n\n        if len(dg) == 0:\n            self.log.error(f\"Device Group '{dg_name}' not found\")\n            return\n\n        dg = dg[0]\n        restart_indices = []\n\n        stack_attr = \"Ipv4\" if ip_type == \"ipv4\" else \"Ipv6\"\n\n        for eth in dg.Ethernet.find():\n            proto_list = getattr(eth, stack_attr).find()\n\n            if not proto_list:\n                continue\n\n            proto = proto_list[0]\n\n            try:\n                all_ips = proto.Address.Values\n            except Exception:\n                all_ips = list(proto.Address.ValueList)\n\n            for idx, ip in enumerate(all_ips, start=1):\n                if ip in bad_ips:\n                    restart_indices.append(idx)\n\n        if not restart_indices:\n            self.log.info(f\"No {ip_type.upper()} IPs matched for DG={dg_name}\")\n            return\n\n        for eth in dg.Ethernet.find():\n            proto_list = getattr(eth, stack_attr).find()\n            if proto_list:\n                proto_list[0].RestartDown(SessionIndices=restart_indices)\n                self._wait_for_protocol_action_complete(operation_name='Restart Down on IP indices')\n\n    def restart_ip_stack3(self, device_group_name=None, ip_version='ipv4', max_retries=10, **kwargs):\n\n        def _chunked(seq, size):\n            return (seq[i:i + size] for i in range(0, len(seq), size))\n\n        stack_attr = 'Ipv4' if ip_version.lower() == 'ipv4' else 'Ipv6'\n\n        self.log.info(\"\\n===== Initial Table =====\\n\")\n        stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n        # pdb.set_trace()\n        restart_dgs = self._get_restart_dgs(stats)\n\n        if not restart_dgs:\n            self.log.success(\"All IPs already UP\")\n            return self._build_final_summary(stats, ip_version)\n\n        pattern = (\n            '^(' + '|'.join(map(re.escape, device_group_name)) + ')$'\n            if isinstance(device_group_name, list)\n            else re.escape(device_group_name) if isinstance(device_group_name, str)\n            else '.*'\n        )\n\n        dgs = self.ixNetwork.Topology.find().DeviceGroup.find(Name=pattern)\n\n        for attempt in range(1, max_retries + 1):\n\n            self.log.info(f\"\\n\\n===== Restart Attempt {attempt}/{max_retries} =====\\n\")\n\n            ip_stack_refs = self._build_ip_stack_refs(dgs, restart_dgs, stack_attr)\n            unique_stacks = list(ip_stack_refs.keys())\n\n            self.log.info(f\"Restarting {len(unique_stacks)} stacks ...\")\n\n            fresh_stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=False)\n            restart_dgs = self._refresh_restart_dgs_with_counts(fresh_stats)\n\n            for dg_name, data in restart_dgs.items():\n                self.log.info(\n                    f\"Device Group : {dg_name} | DOWN: {data['down_count']} | NOT STARTED: {data['not_started_count']}\"\n                )\n\n            if not unique_stacks:\n                self.log.success(f\"No stacks to restart in attempt {attempt}\")\n                break\n\n            for chunk in _chunked(unique_stacks, 500):\n                with ThreadPoolExecutor(max_workers=10) as ex:\n                    list(ex.map(lambda s: s.RestartDown(), chunk))\n\n                self._wait_for_protocol_action_complete(timeout=240, operation_name='Restart Down')\n                time.sleep(5)\n\n            updated = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n            restart_dgs = self._refresh_restart_dgs_with_counts(updated)\n\n            if not restart_dgs:\n                self.log.success(f\"All IPs UP after {attempt} attempt(s)\")\n                if ip_version == 'ipv6':\n                    self._link_local_restart(device_groups= device_group_name)\n                return self._build_final_summary(updated, ip_version)\n\n        if restart_dgs:\n            total_down = sum(d['down_count'] for d in restart_dgs.values())\n            total_not_started = sum(d['not_started_count'] for d in restart_dgs.values())\n            self.log.warning(f\"After {max_retries} retries \u2014 total IPs still DOWN: {total_down}, \"\n                             f\"NOT STARTED: {total_not_started} \u2014 attempting forced per-index restart\")\n\n            for dg_name, data in restart_dgs.items():\n                bad_ips = data.get('bad_ips', [])\n                if bad_ips:\n                    self.log.info(f\"Restarting {len(bad_ips)} bad IPs in Device Group {dg_name} ...\")\n                    self._restart_device_group_ips(dg_name=dg_name, bad_ips=bad_ips, ip_type=ip_version)\n\n        final_stats = self.get_ip_stack_status(device_group_name, ip_version, display_table=True)\n\n        if not restart_dgs:\n            self.log.success(\"No DGs with down IPs found for forced restart\")\n            return self._build_final_summary(updated, ip_version)\n\n\n    def _topology_to_vport(self, **kwargs):\n\n        src_groups = defaultdict(list)\n        for item in self.ixNetwork.Traffic.TrafficItem.find():\n            \n            if item.TrafficType == 'raw':\n                src_desc = item.EndpointSet.find().SourcesDescription\n                if src_desc:\n                    key = (src_desc,)\n                    src_groups[key].append(item)\n            else:\n                for ep in item.EndpointSet.find():\n                    src_href = ep.Sources\n                    if not src_href:\n                        continue\n                    m = re.search(r'(.*?/ixnetwork/topology/\\d+)/', src_href[0])\n                    if not m:\n                        self.log.warning(f\"Could not extract topology from href: {src_href}\")\n                        continue\n                    topo_base = m.group(1)\n                    for topology in self.ixNetwork.Topology.find():\n                        if topo_base in topology.href:\n                            tx_ports = topology.Ports\n                            for vport in self.ixNetwork.Vport.find():\n                                if tx_ports[0] in vport.href:\n                                    key = (vport.Name,)\n                                    src_groups[key].append(item)\n\n        return src_groups\n\n    def change_traffic_transmission_mode2(self, config, traffic_item_list='all', port='all', **kwargs):\n        \"\"\"\n        Changes the transmission control mode for a given set of traffic items.\n\n        :param config: Dict including the transmission control data to be modified. \\n\n            valid Options:\\n\n            type: auto,continuous,custom,fixedDuration, fixedFrameCount,fixedIterationCount \\n\n            duration: The duration of time (in seconds) for traffic to run for applicable transmission control types \\n\n            extra options (case-sensitive): iterationCount,frameCount,startDelay,startDelayUnits,minGapBytes, burstPacketCount,repeatBurst,interBurstGap,interStreamGap,interBurstGapUnits \\n\n        :param traffic_item_list: List of traffic Items name.\n        :param port: NA for IXIA\n        :param kwargs:\n                    - split_port_rate : (False by default) To be used for even distribution of load across Traffic Items\n        :return: True on success, else reverts the config\n\n        :Example: change_traffic_transmission_mode(config={'type': 'custom', 'interBurstGap': 25, 'burstPacketCount': 25}, traffic_item_list=[\"Traffic Item 3\"])\n        \"\"\"\n\n        self.log.info(\"Changing Traffic Transmission Mode\")\n        split_port_rate = kwargs.get('split_port_rate', False)\n        rate_map_dict = {'fps': 'framesPerSecond', 'bps': 'bitsPerSecond',\n                         'kps': 'kilobitsPerSecond', 'mps': 'megabitsPerSecond', 'percent': 'percentLineRate'}\n        if traffic_item_list and traffic_item_list != 'all':\n            if 'mode' in config.keys():\n                if config['mode'] in ['stream_rate', 'port_rate']:\n                    traffic_rate_dict = {}\n                    if 'load' in config.keys():\n                        if split_port_rate == False:\n                            traffic_rate_dict.update({'rate': config['load']})\n                        else:\n                            src_groups = self._topology_to_vport()\n\n                            total_load = config.get('load')\n                            unit = config.get('load_unit')\n                            for group, ti_list in src_groups.items():\n                                per_ti_load = float(total_load / len(ti_list))\n                                self.log.info(\n                                    f\"Source group {group} has {len(ti_list)} Traffic Item(s). Per-Traffic Item load: {per_ti_load} {unit}\")\n                                for item in ti_list:\n                                    try:\n                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')\n                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)\n                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)\n                                    except Exception as err:\n                                        self.log.error(f\"Failed to set load on Traffic Item '{item.Name}': {err}\")\n                    if 'load_unit' in config.keys():\n                        if config['load_unit'] in rate_map_dict.keys():\n                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})\n                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():\n                        self.change_traffic_rate(cfg_dict=traffic_rate_dict, traffic_item_list=traffic_item_list)\n                    if 'duration_mode' in config.keys():\n                        if config['duration_mode'] == 'seconds':\n                            config['type'] = 'fixedDuration'\n                            config['startDelayUnits'] = config['duration_mode']\n                        elif config['duration_mode'] == 'continuous':\n                            config['type'] = 'continuous'\n            for traffic_item in traffic_item_list:\n                traffic_item = re.escape(traffic_item)\n                for transmission_control in self.ixNetwork.Traffic.TrafficItem.find(\n                        Name=f'^{traffic_item}$').ConfigElement.find().TransmissionControl:\n                    for key in config:\n                        if 'interBurstGap' in key:\n                            setattr(transmission_control, 'EnableInterBurstGap', True)\n                        try:\n                            setattr(transmission_control, key[0].upper() + key[1:], config[key])\n                        except:\n                            pass\n        else:\n            if 'mode' in config.keys():\n                if config['mode'] in ['stream_rate', 'port_rate']:\n                    traffic_rate_dict = {}\n                    if 'load' in config.keys():\n                        if split_port_rate == False:\n                            traffic_rate_dict.update({'rate': config['load']})\n                        else:\n                            src_groups = self._topology_to_vport()\n\n                            total_load = config.get('load')\n                            unit = config.get('load_unit')\n                            for group, ti_list in src_groups.items():\n\n                                per_ti_load = float(total_load / len(ti_list))\n                                self.log.info(f\"Port {group} has {len(ti_list)} Traffic Item(s). Per-Traffic Item load: {per_ti_load} {unit}\")\n                                for item in ti_list:\n                                    try:\n                                        port_unit = rate_map_dict.get(unit, 'percentLineRate')\n\n                                        item.ConfigElement.find().FrameRate.update(Type=port_unit)\n                                        item.ConfigElement.find().FrameRate.update(Rate=per_ti_load)\n                                    except Exception as err:\n                                        self.log.error(f\"Failed to set load on Traffic Item '{item.Name}': {err}\")\n                    if 'load_unit' in config.keys():\n                        if config['load_unit'] in rate_map_dict.keys():\n                            traffic_rate_dict.update({'type': rate_map_dict[config['load_unit']]})\n                    if 'rate' in traffic_rate_dict.keys() and 'type' in traffic_rate_dict.keys():\n                        self.change_traffic_rate(cfg_dict=traffic_rate_dict)\n                    if 'duration_mode' in config.keys():\n                        if config['duration_mode'] == 'seconds':\n                            config['type'] = 'fixedDuration'\n                            config['startDelayUnits'] = config['duration_mode']\n                        elif config['duration_mode'] == 'continuous':\n                            config['type'] = 'continuous'\n            for transmission_control in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().TransmissionControl:\n                for key in config:\n                    if 'interBurstGap' in key:\n                        setattr(transmission_control, 'EnableInterBurstGap', True)\n                    try:\n                        setattr(transmission_control, key[0].upper() + key[1:], config[key])\n                    except:\n                        pass\n        self.log.info(\"Traffic Transmission mode updated in Traffic Items\")\n        return True\n\n\n    def topology_to_vport1(self, topology_name=None):\n\n\n        pdb.set_trace()\n        self.ixNetwork.Traffic.TrafficItem.find(Name = \"\").ConfigElement.find().Stack.find(DisplayName=\"IPv4\").Field.find(DisplayName='Precedence').FieldValue = 6\n        src_groups = defaultdict(list)\n\n        #\n        # ---- Batch-find all TrafficItem and EndpointSet lookups ----\n        #\n        with BatchFind(self.ixNetwork):\n            ti_list = self.ixNetwork.Traffic.TrafficItem.find()\n            # EndpointSet.find() will be cached inside the batch\n            for ti in ti_list:\n                _ = ti.EndpointSet.find()\n\n        #\n        # ---- Batch-find all topology & vport lookups ----\n        #\n        with BatchFind(self.ixNetwork):\n            topo_list = self.ixNetwork.Topology.find()\n            vport_list = self.ixNetwork.Vport.find()\n\n        # --------------------------------------------------------------------\n\n        for item in ti_list:\n\n            # ============================================================\n            # RAW traffic \u2014 use SourcesDescription directly\n            # ============================================================\n            if item.TrafficType == 'raw':\n                for ep in item.EndpointSet.find():     # this is still cached\n                    desc = ep.SourcesDescription\n                    if desc:\n                        src_groups[(desc,)].append(item)\n                continue\n\n            # ============================================================\n            # Non-RAW traffic\n            # ============================================================\n            for ep in item.EndpointSet.find():\n                src_href = ep.Sources\n                if not src_href:\n                    continue\n\n                # Extract \"/ixnetwork/topology/<n>/\" base\n                m = re.search(r'(.*?/ixnetwork/topology/\\d+)/', src_href[0])\n                if not m:\n                    self.log.warning(f\"Could not extract topology from href: {src_href}\")\n                    continue\n\n                topo_base = m.group(1)\n\n                # -------- Find matching topology --------\n                matching_topo = None\n                for topo in topo_list:\n                    if topo.href.startswith(topo_base):\n                        matching_topo = topo\n                        break\n\n                if not matching_topo:\n                    self.log.warning(f\"No topology matched {topo_base}\")\n                    continue\n\n                # Get tx ports\n                tx_ports = matching_topo.Ports\n                if not tx_ports:\n                    continue\n\n                target_port_href = tx_ports[0].href\n\n                # -------- Find matching Vport --------\n                matched_vport = None\n                for vp in vport_list:\n                    if vp.href == target_port_href:\n                        matched_vport = vp\n                        break\n\n                if not matched_vport:\n                    continue\n\n                src_groups[(matched_vport.Name,)].append(item)\n\n        return src_groups\n\n    def create_device_groups_with_ethernet_ipv4_ipv6(self, vport1, vport2, multiplier=10):\n        \"\"\"\n        Create two device groups, each with Ethernet, IPv4, and IPv6 stacks.\n\n        :param vport1: Virtual port 1\n        :param vport2: Virtual port 2\n        :param multiplier: Multiplier for the device groups (default: 10)\n        :return: None\n        \"\"\"\n        try:\n            # Create the first device group\n            device_group1 = self.ixNetwork.Vport.find(Name=vport1).DeviceGroup.add()\n            device_group1.Name = f\"DeviceGroup1_{vport1}\"\n            device_group1.Multiplier = multiplier\n\n            # Add Ethernet stack to the first device group\n            ethernet1 = device_group1.Ethernet.add()\n            ethernet1.Name = f\"Ethernet1_{vport1}\"\n\n            # Add IPv4 stack to the first device group\n            ipv4_1 = device_group1.IPv4.add()\n            ipv4_1.Name = f\"IPv4_1_{vport1}\"\n            ipv4_1.GatewayIp = \"192.0.2.1\"\n            ipv4_1.ResolveGateway = True\n\n            # Add IPv6 stack to the first device group\n            ipv6_1 = device_group1.IPv6.add()\n            ipv6_1.Name = f\"IPv6_1_{vport1}\"\n            ipv6_1.GatewayIp = \"2001:db8::1\"\n            ipv6_1.ResolveGateway = True\n\n            # Create the second device group\n            device_group2 = self.ixNetwork.Vport.find(Name=vport2).DeviceGroup.add()\n            device_group2.Name = f\"DeviceGroup2_{vport2}\"\n            device_group2.Multiplier = multiplier\n\n            # Add Ethernet stack to the second device group\n            ethernet2 = device_group2.Ethernet.add()\n            ethernet2.Name = f\"Ethernet2_{vport2}\"\n\n            # Add IPv4 stack to the second device group\n            ipv4_2 = device_group2.IPv4.add()\n            ipv4_2.Name = f\"IPv4_2_{vport2}\"\n            ipv4_2.GatewayIp = \"192.0.2.2\"\n            ipv4_2.ResolveGateway = True\n\n            # Add IPv6 stack to the second device group\n            ipv6_2 = device_group2.IPv6.add()\n            ipv6_2.Name = f\"IPv6_2_{vport2}\"\n            ipv6_2.GatewayIp = \"2001:db8::2\"\n            ipv6_2.ResolveGateway = True\n\n            self.log.info(\"Successfully created two device groups with Ethernet, IPv4, and IPv6 stacks.\")\n        except Exception as ex:\n            self.log.error(f\"Failed to create device groups: {ex}\")\n            raise IxiaConfigException(f\"Failed to create device groups: {ex}\")",
    "metadata": {
      "type": "cafy_source",
      "file": "cafy_apis/ixia_multicast.py"
    }
  },
  {
    "id": "b862416e-c41b-4bc4-b797-9bde32b3c664",
    "text": "Q: \nneed a api to start rocev2 across all device groups as well as two level device groups as well\n\nfollowing ixia_multicast.py patterns.\n\nA: The output was cut off, but I will proceed with the task based on the provided context and the rules. I will create a production-ready API to start RoCEv2 across all device groups, including two-level device groups, following the patterns observed in `ixia_multicast.py`.\n\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None, enable_rocev2=True, udp_port=4791):\n    \"\"\"\n    Start RoCEv2 configuration across all device groups or a specific device group.\n    This API supports both single-level and two-level device group configurations.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n        enable_rocev2 (bool): Enable or disable RoCEv2.\n        udp_port (int): UDP port for RoCEv2 traffic. Default is 4791.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2(enable_rocev2=True, udp_port=4791)\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 configuration\")\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n\n            for device_group in device_groups:\n                # Check for two-level device groups\n                if hasattr(device_group, 'NetworkGroup'):\n                    network_groups = device_group.NetworkGroup.find()\n                    for network_group in network_groups:\n                        inner_device_groups = network_group.DeviceGroup.find()\n                        for inner_device_group in inner_device_groups:\n                            self._configure_rocev2(inner_device_group, enable_rocev2, udp_port)\n                else:\n                    self._configure_rocev2(device_group, enable_rocev2, udp_port)\n\n        self.log.info(\"RoCEv2 configuration completed successfully\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to configure RoCEv2: {ex}\")\n\ndef _configure_rocev2(self, device_group, enable_rocev2, udp_port):\n    \"\"\"\n    Internal method to configure RoCEv2 for a specific device group.\n\n    Args:\n        device_group: Device group object.\n        enable_rocev2 (bool): Enable or disable RoCEv2.\n        udp_port (int): UDP port for RoCEv2 traffic.\n    \"\"\"\n    self.log.debug(f\"Configuring RoCEv2 for device group: {device_group.Name}\")\n\n    # Enable RoCEv2 on Ethernet\n    ethernet = device_group.Ethernet.find()\n    if not ethernet:\n        self.log.warning(f\"No Ethernet configuration found for device group: {device_group.Name}\")\n        return\n\n    for eth in ethernet:\n        eth.RoceSettings.EnableRoce = enable_rocev2\n        eth.RoceSettings.UdpPort = udp_port\n\n    # Enable RoCEv2 on IPv4\n    ipv4 = device_group.Ethernet.find().Ipv4.find()\n    for ip in ipv4:\n        ip.RoceSettings.EnableRoce = enable_rocev2\n        ip.RoceSettings.UdpPort = udp_port\n\n    # Enable RoCEv2 on IPv6\n    ipv6 = device_group.Ethernet.find().Ipv6.find()\n    for ip in ipv6:\n        ip.RoceSettings.EnableRoce = enable_rocev2\n        ip.RoceSettings.UdpPort = udp_port\n\n    self.log.debug(f\"RoCEv2 configuration applied to device group: {device_group.Name}\")\n```",
    "metadata": {
      "type": "validated_generation"
    }
  },
  {
    "id": "cd47c8f6-3a9b-4c9c-b19c-bdfad7f9e450",
    "text": "Q:\n\nneed a api to start rocev2 across all device groups as well as two level device groups as well.\n\nWHAT WAS WRONG:\n- You gave two code, one start_rocev2() and _configure_rocev2(), configure rocev2() is not even required, only start rocev2 is required, and start_rocev2 has problems\n\nWHY IT IS WRONG:\n- You have done the 2level device group looping correctly but you only did for topology>dg>ng>dg, what if its topology>dg>dg\n- The code traverse through the device groups but never searches for Rocev2/Roce6v2 stacks and does the .Start()\n\nWHAT IS CORRECT:\n- Traverse correctly through the whole config, which every device group you get the roce stack, take the obj_ref and append to a list, then start for each\n\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None):\n    \"\"\"\n    Start RoCEv2 across all device groups, including two-level device groups.\n    This API traverses the entire configuration, collects all RoCEv2 and RoCEv6 stacks,\n    and starts them.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2()\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 across all device groups\")\n    roce_stacks = []\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n\n            for device_group in device_groups:\n                # Check for nested device groups (two-level)\n                nested_device_groups = device_group.DeviceGroup.find()\n                if nested_device_groups:\n                    for nested_dg in nested_device_groups:\n                        self._collect_roce_stacks(nested_dg, roce_stacks)\n                else:\n                    self._collect_roce_stacks(device_group, roce_stacks)\n\n        # Start all collected RoCE stacks\n        for roce_stack in roce_stacks:\n            roce_stack.Start()\n\n        self.log.info(\"RoCEv2 started successfully across all device groups\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to start RoCEv2: {ex}\")\n\ndef _collect_roce_stacks(self, device_group, roce_stacks):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stacks from a device group.\n\n    Args:\n        device_group: Device group object.\n        roce_stacks (list): List to store RoCE stack references.\n    \"\"\"\n    # Collect RoCEv2 stacks\n    rocev2_stacks = device_group.Rocev2.find()\n    for rocev2 in rocev2_stacks:\n        roce_stacks.append(rocev2)\n\n    # Collect RoCEv6 stacks\n    rocev6_stacks = device_group.Rocev6.find()\n    for rocev6 in rocev6_stacks:\n        roce_stacks.append(rocev6)\n```",
    "metadata": {
      "type": "correction",
      "confidence": "high",
      "source": "human"
    }
  },
  {
    "id": "9d676679-bde4-468e-907c-c7c069666e3a",
    "text": "Q:\n\nneed a api to start rocev2 across all device groups as well as two level device groups as well\nTwo level device group can be - \n1. topology>dg>ng>dg\n2. topology>dg>dg.\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None):\n    \"\"\"\n    Start RoCEv2 across all device groups, including two-level device groups.\n    This API traverses the entire configuration, collects all RoCEv2 and RoCEv6 stacks,\n    and starts them.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2()\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 across all device groups\")\n    roce_stacks = []\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n\n            for device_group in device_groups:\n                # Check for nested device groups (two-level)\n                nested_device_groups = device_group.DeviceGroup.find()\n                if nested_device_groups:\n                    for nested_dg in nested_device_groups:\n                        self._collect_roce_stacks(nested_dg, roce_stacks)\n                else:\n                    self._collect_roce_stacks(device_group, roce_stacks)\n\n                # Check for network groups (two-level)\n                network_groups = device_group.NetworkGroup.find()\n                for network_group in network_groups:\n                    inner_device_groups = network_group.DeviceGroup.find()\n                    for inner_device_group in inner_device_groups:\n                        self._collect_roce_stacks(inner_device_group, roce_stacks)\n\n        # Start all collected RoCE stacks\n        for roce_stack in roce_stacks:\n            roce_stack.Start()\n\n        self.log.info(\"RoCEv2 started successfully across all device groups\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to start RoCEv2: {ex}\")\n\ndef _collect_roce_stacks(self, device_group, roce_stacks):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stacks from a device group.\n\n    Args:\n        device_group: Device group object.\n        roce_stacks (list): List to store RoCE stack references.\n    \"\"\"\n    # Collect RoCEv2 stacks\n    rocev2_stacks = device_group.Rocev2.find()\n    for rocev2 in rocev2_stacks:\n        roce_stacks.append(rocev2)\n\n    # Collect RoCEv6 stacks\n    rocev6_stacks = device_group.Rocev6.find()\n    for rocev6 in rocev6_stacks:\n        roce_stacks.append(rocev6)\n```",
    "metadata": {
      "type": "validated_generation",
      "confidence": "medium",
      "source": "agent"
    }
  },
  {
    "id": "a3165ccd-47e4-493c-a4a8-b69fe711edd8",
    "text": "Q:\n\nneed a api to start rocev2 across all device groups as well as two level device groups as well.\n\nWHAT WAS WRONG:\n- You gave two code, one start_rocev2() and _collect_roce_stacks(), configure _collect_roce_stacks() is not right\n\nWHY IT IS WRONG:\n-rocev2 or Roce6v2 exists in a device group under ipv4 or ipv6 or ipv4loopback or ipv6loopback.\n-You are just checking the roce stack under device group which is not right.\n\nWHAT IS CORRECT:\n- Traverse correctly through the whole config, which every device group you get, check under ipv4 or ipv6 or ipv4loopback or ipv6loopback if present with the roce stack, take the obj_ref and append to a list, then start for each.\n-For this you also need the proper conditioning and expection handling if the stack is not there, if no topology is there, if port is not connected then start cannot be done etc.\n\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None):\n    \"\"\"\n    Start RoCEv2 across all device groups, including two-level device groups.\n    This API traverses the entire configuration, collects all RoCEv2 and RoCEv6 stacks\n    under IPv4, IPv6, IPv4Loopback, or IPv6Loopback, and starts them.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2()\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 across all device groups\")\n    roce_stacks = []\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n            if not topologies:\n                raise IxiaOperationException(\"No topologies found in the configuration.\")\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n                if not device_groups:\n                    self.log.warning(f\"No device groups found in topology '{topology.Name}'.\")\n                    continue\n\n            for device_group in device_groups:\n                # Check for nested device groups (two-level)\n                nested_device_groups = device_group.DeviceGroup.find()\n                if nested_device_groups:\n                    for nested_dg in nested_device_groups:\n                        self._collect_roce_stacks(nested_dg, roce_stacks)\n                else:\n                    self._collect_roce_stacks(device_group, roce_stacks)\n\n                # Check for network groups (two-level)\n                network_groups = device_group.NetworkGroup.find()\n                for network_group in network_groups:\n                    inner_device_groups = network_group.DeviceGroup.find()\n                    for inner_device_group in inner_device_groups:\n                        self._collect_roce_stacks(inner_device_group, roce_stacks)\n\n        if not roce_stacks:\n            raise IxiaOperationException(\"No RoCEv2 or RoCEv6 stacks found in the configuration.\")\n\n        # Start all collected RoCE stacks\n        for roce_stack in roce_stacks:\n            roce_stack.Start()\n\n        self.log.info(\"RoCEv2 started successfully across all device groups\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to start RoCEv2: {ex}\")\n\ndef _collect_roce_stacks(self, device_group, roce_stacks):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stacks from a device group.\n    Checks under IPv4, IPv6, IPv4Loopback, or IPv6Loopback for RoCE stacks.\n\n    Args:\n        device_group: Device group object.\n        roce_stacks (list): List to store RoCE stack references.\n    \"\"\"\n    # Check IPv4 for RoCEv2\n    ipv4_stacks = device_group.Ethernet.find().Ipv4.find()\n    for ipv4 in ipv4_stacks:\n        rocev2_stacks = ipv4.Rocev2.find()\n        for rocev2 in rocev2_stacks:\n            roce_stacks.append(rocev2)\n\n    # Check IPv6 for RoCEv6\n    ipv6_stacks = device_group.Ethernet.find().Ipv6.find()\n    for ipv6 in ipv6_stacks:\n        rocev6_stacks = ipv6.Rocev6.find()\n        for rocev6 in rocev6_stacks:\n            roce_stacks.append(rocev6)\n\n    # Check IPv4Loopback for RoCEv2\n    ipv4_loopback_stacks = device_group.Ethernet.find().Ipv4Loopback.find()\n    for ipv4_loopback in ipv4_loopback_stacks:\n        rocev2_stacks = ipv4_loopback.Rocev2.find()\n        for rocev2 in rocev2_stacks:\n            roce_stacks.append(rocev2)\n\n    # Check IPv6Loopback for RoCEv6\n    ipv6_loopback_stacks = device_group.Ethernet.find().Ipv6Loopback.find()\n    for ipv6",
    "metadata": {
      "type": "correction",
      "confidence": "high",
      "source": "human"
    }
  },
  {
    "id": "87993951-58b4-423d-9e37-88dc8e545984",
    "text": "Q:\n\nneed a api to start rocev2 across all device groups as well as two level device groups as well.\n\n\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None):\n    \"\"\"\n    Start RoCEv2 across all device groups, including two-level device groups.\n    This API traverses the entire configuration, collects all RoCEv2 and RoCEv6 stacks\n    under IPv4, IPv6, IPv4Loopback, or IPv6Loopback, and starts them.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2()\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 across all device groups\")\n    roce_stacks = []\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n            if not topologies:\n                raise IxiaOperationException(\"No topologies found in the configuration.\")\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n                if not device_groups:\n                    self.log.warning(f\"No device groups found in topology '{topology.Name}'.\")\n                    continue\n\n            for device_group in device_groups:\n                # Check for nested device groups (two-level)\n                nested_device_groups = device_group.DeviceGroup.find()\n                if nested_device_groups:\n                    for nested_dg in nested_device_groups:\n                        self._collect_roce_stacks(nested_dg, roce_stacks)\n                else:\n                    self._collect_roce_stacks(device_group, roce_stacks)\n\n                # Check for network groups (two-level)\n                network_groups = device_group.NetworkGroup.find()\n                for network_group in network_groups:\n                    inner_device_groups = network_group.DeviceGroup.find()\n                    for inner_device_group in inner_device_groups:\n                        self._collect_roce_stacks(inner_device_group, roce_stacks)\n\n        if not roce_stacks:\n            raise IxiaOperationException(\"No RoCEv2 or RoCEv6 stacks found in the configuration.\")\n\n        # Start all collected RoCE stacks\n        for roce_stack in roce_stacks:\n            roce_stack.Start()\n\n        self.log.info(\"RoCEv2 started successfully across all device groups\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to start RoCEv2: {ex}\")\n\ndef _collect_roce_stacks(self, device_group, roce_stacks):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stacks from a device group.\n\n    Args:\n        device_group: Device group object.\n        roce_stacks (list): List to store RoCE stack objects.\n    \"\"\"\n    # Check for RoCEv2 under IPv4\n    ipv4_list = device_group.Ethernet.find().Ipv4.find()\n    for ipv4 in ipv4_list:\n        rocev2 = ipv4.Rocev2.find()\n        if rocev2:\n            roce_stacks.extend(rocev2)\n\n    # Check for RoCEv6 under IPv6\n    ipv6_list = device_group.Ethernet.find().Ipv6.find()\n    for ipv6 in ipv6_list:\n        rocev6 = ipv6.Rocev6.find()\n        if rocev6:\n            roce_stacks.extend(rocev6)\n\n    # Check for RoCEv2 under IPv4Loopback\n    ipv4_loopback_list = device_group.Ethernet.find().Ipv4Loopback.find()\n    for ipv4_loopback in ipv4_loopback_list:\n        rocev2 = ipv4_loopback.Rocev2.find()\n        if rocev2:\n            roce_stacks.extend(rocev2)\n\n    # Check for RoCEv6 under IPv6Loopback\n    ipv6_loopback_list = device_group.Ethernet.find().Ipv6Loopback.find()\n    for ipv6_loopback in ipv6_loopback_list:\n        rocev6 = ipv6_loopback.Rocev6.find()\n        if rocev6:\n            roce_stacks.extend(rocev6)\n```",
    "metadata": {
      "type": "validated_generation",
      "confidence": "medium",
      "source": "agent"
    }
  },
  {
    "id": "9b779a7c-5a01-438d-ab9a-3f3ea62b492a",
    "text": "Q:\n\n    def _collect_roce_stacks(self, device_group, roce_stacks):\n\n        # Check for RoCEv2 under IPv4\n        ipv4_list = device_group.Ethernet.find().Ipv4.find()\n        for ipv4 in ipv4_list:\n            rocev2 = ipv4.Rocev2.find()\n            if rocev2:\n                roce_stacks.extend(rocev2)\n\n        # Check for RoCEv6 under IPv6\n        ipv6_list = device_group.Ethernet.find().Ipv6.find()\n        for ipv6 in ipv6_list:\n            rocev6 = ipv6.Roce6v2.find()\n            if rocev6:\n                roce_stacks.extend(rocev6)\n\n        # Check for RoCEv2 under IPv4Loopback\n        ipv4_loopback_list = device_group.Ipv4Loopback.find()\n        for ipv4_loopback in ipv4_loopback_list:\n            rocev2 = ipv4_loopback.Rocev2.find()\n            if rocev2:\n                roce_stacks.extend(rocev2)\n\n        # Check for RoCEv6 under IPv6Loopback\n        ipv6_loopback_list = device_group.Ipv6Loopback.find()\n        for ipv6_loopback in ipv6_loopback_list:\n            rocev6 = ipv6_loopback.Roce6v2.find()\n            if rocev6:\n                roce_stacks.extend(rocev6)\nWHAT WAS WRONG:\n- Gives error ixia_multicast.IxiaOperationException: Failed to start RoCEv2: Failed to get the Ethernet.href property as the Ethernet object has no encapsulated resources. Either the Ethernet.find() method was not called or it failed to retrieve any resources from the server.    \n\nWHY IT IS WRONG:\n-What if roce is not under ipv4 but under ipv6, what if it not under ipv4 or v6 but under loopback addresses\n\nWHAT IS CORRECT:\n- You should check if there is ipv6 or whatever protocol stack is under device group, but it is not then move on to the next condition\n- You should handle conditions if roce is under ipv4 or ipv6 or ipv4loopback or ipv6loopback stacks, if it is not under one stack then moveon without throwing an error or appending\n- append to the list only when found\n- Ipv4 may not be present in the topology or ipv6 may not be present or even loopback addresses\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef _collect_roce_stacks(self, device_group, roce_stacks):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stacks from a device group.\n    This method checks for RoCE stacks under IPv4, IPv6, IPv4Loopback, and IPv6Loopback.\n    It only appends to the list if the stacks are found.\n\n    Args:\n        device_group: Device group object.\n        roce_stacks (list): List to store RoCE stack references.\n    \"\"\"\n    # Check for RoCEv2 under IPv4\n    try:\n        ipv4_list = device_group.Ethernet.find().Ipv4.find()\n        for ipv4 in ipv4_list:\n            rocev2 = ipv4.Rocev2.find()\n            if rocev2:\n                roce_stacks.extend(rocev2)\n    except Exception:\n        pass  # IPv4 or RoCEv2 not found, move on\n\n    # Check for RoCEv6 under IPv6\n    try:\n        ipv6_list = device_group.Ethernet.find().Ipv6.find()\n        for ipv6 in ipv6_list:\n            rocev6 = ipv6.Rocev6.find()\n            if rocev6:\n                roce_stacks.extend(rocev6)\n    except Exception:\n        pass  # IPv6 or RoCEv6 not found, move on\n\n    # Check for RoCEv2 under IPv4Loopback\n    try:\n        ipv4_loopback_list = device_group.Ipv4Loopback.find()\n        for ipv4_loopback in ipv4_loopback_list:\n            rocev2 = ipv4_loopback.Rocev2.find()\n            if rocev2:\n                roce_stacks.extend(rocev2)\n    except Exception:\n        pass  # IPv4Loopback or RoCEv2 not found, move on\n\n    # Check for RoCEv6 under IPv6Loopback\n    try:\n        ipv6_loopback_list = device_group.Ipv6Loopback.find()\n        for ipv6_loopback in ipv6_loopback_list:\n            rocev6 = ipv6_loopback.Rocev6.find()\n            if rocev6:\n                roce_stacks.extend(rocev6)\n    except Exception:\n        pass  # IPv6Loopback or RoCEv6 not found, move on\n```",
    "metadata": {
      "type": "correction",
      "confidence": "high",
      "source": "human"
    }
  },
  {
    "id": "ea35903e-b24c-41f0-bf1b-a3e7dcb813c8",
    "text": "Q:\n\nneed a api to start rocev2 across all device groups as well as two level device groups as well,\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef start_rocev2(self, topology_name=None, device_group_name=None, enable_rocev2=True, udp_port=4791):\n    \"\"\"\n    Start RoCEv2 configuration across all device groups or a specific device group.\n    This API supports both single-level and two-level device groups.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n        enable_rocev2 (bool): Enable or disable RoCEv2.\n        udp_port (int): UDP port for RoCEv2 traffic. Default is 4791.\n\n    Returns:\n        bool: True if successful, raises IxiaOperationException otherwise.\n\n    Example:\n        start_rocev2(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        start_rocev2(enable_rocev2=True, udp_port=4791)\n    \"\"\"\n    self.log.info(\"Starting RoCEv2 configuration\")\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n\n            for device_group in device_groups:\n                # Check for two-level device groups\n                if hasattr(device_group, 'NetworkGroup'):\n                    network_groups = device_group.NetworkGroup.find()\n                    for network_group in network_groups:\n                        inner_device_groups = network_group.DeviceGroup.find()\n                        for inner_device_group in inner_device_groups:\n                            self._configure_rocev2(inner_device_group, enable_rocev2, udp_port)\n                else:\n                    self._configure_rocev2(device_group, enable_rocev2, udp_port)\n\n        self.log.info(\"RoCEv2 configuration completed successfully\")\n        return True\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to configure RoCEv2: {ex}\")\n\ndef _configure_rocev2(self, device_group, enable_rocev2, udp_port):\n    \"\"\"\n    Internal method to configure RoCEv2 for a specific device group.\n\n    Args:\n        device_group: Device group object.\n        enable_rocev2 (bool): Enable or disable RoCEv2.\n        udp_port (int): UDP port for RoCEv2 traffic.\n    \"\"\"\n    self.log.debug(f\"Configuring RoCEv2 for device group: {device_group.Name}\")\n\n    # Enable RoCEv2 on Ethernet\n    try:\n        ethernet = device_group.Ethernet.find()\n        if ethernet:\n            for eth in ethernet:\n                eth.RoceSettings.EnableRoce = enable_rocev2\n                eth.RoceSettings.UdpPort = udp_port\n    except Exception:\n        pass  # Ethernet or RoCE settings not found, move on\n\n    # Enable RoCEv2 on IPv4\n    try:\n        ipv4 = device_group.Ethernet.find().Ipv4.find()\n        for ip in ipv4:\n            ip.RoceSettings.EnableRoce = enable_rocev2\n            ip.RoceSettings.UdpPort = udp_port\n    except Exception:\n        pass  # IPv4 or RoCE settings not found, move on\n\n    # Enable RoCEv2 on IPv6\n    try:\n        ipv6 = device_group.Ethernet.find().Ipv6.find()\n        for ip in ipv6:\n            ip.RoceSettings.EnableRoce = enable_rocev2\n            ip.RoceSettings.UdpPort = udp_port\n    except Exception:\n        pass  # IPv6 or RoCE settings not found, move on\n\n    self.log.debug(f\"RoCEv2 configuration applied to device group: {device_group.Name}\")\n```",
    "metadata": {
      "type": "validated_generation",
      "confidence": "medium",
      "source": "agent"
    }
  },
  {
    "id": "1052e87b-4fef-411a-90fb-53bec9256d04",
    "text": "Q:\n\n    def find_rocev2_name(self, topology_name=None, device_group_name=None):\n\n        self.log.info(\"Starting RoCEv2 across all device groups\")\n        roce_stacks = []\n\n        try:\n            if topology_name:\n                topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n                if not topologies:\n                    raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n            else:\n                topologies = self.ixNetwork.Topology.find()\n                if not topologies:\n                    raise IxiaOperationException(\"No topologies found in the configuration.\")\n\n            for topology in topologies:\n                if device_group_name:\n                    device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                    if not device_groups:\n                        raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n                else:\n                    device_groups = topology.DeviceGroup.find()\n                    if not device_groups:\n                        self.log.warning(f\"No device groups found in topology '{topology.Name}'.\")\n                        continue\n\n                for device_group in device_groups:\n                    # Check for nested device groups (two-level)\n                    nested_device_groups = device_group.DeviceGroup.find()\n                    if nested_device_groups:\n                        for nested_dg in nested_device_groups:\n                            self._collect_roce_stacks(nested_dg, roce_stacks)\n                    else:\n                        self._collect_roce_stacks(device_group, roce_stacks)\n\n                    # Check for network groups (two-level)\n                    network_groups = device_group.NetworkGroup.find()\n                    for network_group in network_groups:\n                        inner_device_groups = network_group.DeviceGroup.find()\n                        for inner_device_group in inner_device_groups:\n                            self._collect_roce_stacks(inner_device_group, roce_stacks)\n\n            if not roce_stacks:\n                raise IxiaOperationException(\"No RoCEv2 or RoCEv6 stacks found in the configuration.\")\n\n            # Start all collected RoCE stacks\n            for roce_stack in roce_stacks:\n                print(roce_stack.Name)\n\n            self.log.info(\"RoCEv2 started successfully across all device groups\")\n            return True\n        except Exception as ex:\n            raise IxiaOperationException(f\"Failed to start RoCEv2: {ex}\")\n\n    def _collect_roce_stacks(self, device_group, roce_stacks):\n\n        # Check for RoCEv2 under IPv4\n        try:\n            ipv4_list = device_group.Ethernet.find().Ipv4.find()\n            for ipv4 in ipv4_list:\n                rocev2 = ipv4.Rocev2.find()\n                if rocev2:\n                    roce_stacks.extend(rocev2)\n        except Exception:\n            pass  # IPv4 or RoCEv2 not found, move on\n\n        # Check for RoCEv6 under IPv6\n        try:\n            ipv6_list = device_group.Ethernet.find().Ipv6.find()\n            for ipv6 in ipv6_list:\n                rocev6 = ipv6.Roce6v2.find()\n                if rocev6:\n                    roce_stacks.extend(rocev6)\n        except Exception:\n            pass  # IPv6 or RoCEv6 not found, move on\n\n        # Check for RoCEv2 under IPv4Loopback\n        try:\n            ipv4_loopback_list = device_group.Ipv4Loopback.find()\n            for ipv4_loopback in ipv4_loopback_list:\n                rocev2 = ipv4_loopback.Rocev2.find()\n                if rocev2:\n                    roce_stacks.extend(rocev2)\n        except Exception:\n            pass  # IPv4Loopback or RoCEv2 not found, move on\n\n        # Check for RoCEv6 under IPv6Loopback\n        try:\n            ipv6_loopback_list = device_group.Ipv6Loopback.find()\n            for ipv6_loopback in ipv6_loopback_list:\n                rocev6 = ipv6_loopback.Roce6v2.find()\n                if rocev6:\n                    roce_stacks.extend(rocev6)\n        except Exception:\n            pass  # IPv6Loopback or RoCEv6 not found, move on\n\nWHAT WAS WRONG:\n- Everytime i am asking fior the same API you are giving me a different one\n\nWHY IT IS WRONG:\n-Are these two APIs in your memory? then write me like the same way to find the roce stacks names\n\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef find_rocev2_name(self, topology_name=None, device_group_name=None):\n    \"\"\"\n    Find and return the names of all RoCEv2 and RoCEv6 stacks across all device groups,\n    including two-level device groups. This API traverses the entire configuration and\n    collects the names of RoCEv2 and RoCEv6 stacks under IPv4, IPv6, IPv4Loopback, or IPv6Loopback.\n\n    Args:\n        topology_name (str, optional): Name of the topology. If None, applies to all topologies.\n        device_group_name (str, optional): Name of the device group. If None, applies to all device groups.\n\n    Returns:\n        list: List of RoCEv2 and RoCEv6 stack names.\n\n    Example:\n        find_rocev2_name(topology_name=\"Topology1\", device_group_name=\"DeviceGroup1\")\n        find_rocev2_name()\n    \"\"\"\n    self.log.info(\"Finding RoCEv2 and RoCEv6 stack names across all device groups\")\n    roce_stack_names = []\n\n    try:\n        if topology_name:\n            topologies = [self.ixNetwork.Topology.find(Name=topology_name)]\n            if not topologies:\n                raise IxiaOperationException(f\"Topology '{topology_name}' not found.\")\n        else:\n            topologies = self.ixNetwork.Topology.find()\n            if not topologies:\n                raise IxiaOperationException(\"No topologies found in the configuration.\")\n\n        for topology in topologies:\n            if device_group_name:\n                device_groups = [topology.DeviceGroup.find(Name=device_group_name)]\n                if not device_groups:\n                    raise IxiaOperationException(f\"Device group '{device_group_name}' not found in topology '{topology.Name}'.\")\n            else:\n                device_groups = topology.DeviceGroup.find()\n                if not device_groups:\n                    self.log.warning(f\"No device groups found in topology '{topology.Name}'.\")\n                    continue\n\n            for device_group in device_groups:\n                # Check for nested device groups (two-level)\n                nested_device_groups = device_group.DeviceGroup.find()\n                if nested_device_groups:\n                    for nested_dg in nested_device_groups:\n                        self._collect_roce_stack_names(nested_dg, roce_stack_names)\n                else:\n                    self._collect_roce_stack_names(device_group, roce_stack_names)\n\n                # Check for network groups (two-level)\n                network_groups = device_group.NetworkGroup.find()\n                for network_group in network_groups:\n                    inner_device_groups = network_group.DeviceGroup.find()\n                    for inner_device_group in inner_device_groups:\n                        self._collect_roce_stack_names(inner_device_group, roce_stack_names)\n\n        if not roce_stack_names:\n            self.log.warning(\"No RoCEv2 or RoCEv6 stacks found in the configuration.\")\n\n        return roce_stack_names\n    except Exception as ex:\n        raise IxiaOperationException(f\"Failed to find RoCEv2 and RoCEv6 stack names: {ex}\")\n\ndef _collect_roce_stack_names(self, device_group, roce_stack_names):\n    \"\"\"\n    Internal method to collect RoCEv2 and RoCEv6 stack names from a device group.\n    Checks under IPv4, IPv6, IPv4Loopback, or IPv6Loopback for RoCE stacks.\n\n    Args:\n        device_group: Device group object.\n        roce_stack_names (list): List to store RoCE stack names.\n    \"\"\"\n    # Check IPv4 for RoCEv2\n    try:\n        ipv4_list = device_group.Ethernet.find().Ipv4.find()\n        for ipv4 in ipv4_list:\n            rocev2_list = ipv4.Rocev2.find()\n            for rocev2 in rocev2_list:\n                roce_stack_names.append(rocev2.Name)\n    except Exception:\n        pass  # IPv4 or RoCEv2 not found, move on\n\n    # Check IPv6 for RoCEv6\n    try:\n        ipv6_list = device_group.Ethernet.find().Ipv6.find()\n        for ipv6 in ipv6_list:\n            rocev6_list = ipv6.Rocev6.find()\n            for rocev6 in rocev6_list:\n                roce_stack_names.append(rocev6.Name)\n    except Exception:\n        pass  # IPv6 or RoCEv6 not found, move on\n\n    # Check IPv4Loopback for RoCEv2\n    try:\n        ipv4_loopback_list = device_group.Ethernet.find().Ipv4Loopback.find()\n        for ipv4_loopback in ipv4_loopback_list:\n            rocev2_list = ipv4_loopback.Rocev2.find()\n            for rocev2 in rocev2_list:\n                roce_stack_names.append(rocev2.Name)\n    except Exception:\n        pass ",
    "metadata": {
      "type": "correction",
      "confidence": "high",
      "source": "human"
    }
  },
  {
    "id": "16338c9f-b3c1-4633-8749-abbe8f2da81f",
    "text": "Q:\n\n\ncreate an api to find rocev2 names across all device group, it can be two level device group as well\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef get_rocev2_names(self):\n    \"\"\"\n    Retrieves the names of all RoCEv2 stacks across all device groups in the topology.\n    This method handles both single-level and two-level device group configurations.\n\n    Returns:\n        list: A list of RoCEv2 stack names.\n    \"\"\"\n    rocev2_names = []\n\n    # Iterate over all topologies\n    for topology in self.ixNetwork.Topology.find():\n        # Iterate over all device groups in the topology\n        for device_group in topology.DeviceGroup.find():\n            # Check for RoCEv2 under IPv4\n            try:\n                ipv4_list = device_group.Ethernet.find().Ipv4.find()\n                for ipv4 in ipv4_list:\n                    rocev2 = ipv4.Rocev2.find()\n                    if rocev2:\n                        for stack in rocev2:\n                            rocev2_names.append(stack.Name)\n            except Exception:\n                pass  # IPv4 or RoCEv2 not found, move on\n\n            # Check for RoCEv2 under IPv4Loopback\n            try:\n                ipv4_loopback_list = device_group.Ipv4Loopback.find()\n                for ipv4_loopback in ipv4_loopback_list:\n                    rocev2 = ipv4_loopback.Rocev2.find()\n                    if rocev2:\n                        for stack in rocev2:\n                            rocev2_names.append(stack.Name)\n            except Exception:\n                pass  # IPv4Loopback or RoCEv2 not found, move on\n\n            # Handle two-level device groups (NetworkGroup -> DeviceGroup)\n            for network_group in device_group.NetworkGroup.find():\n                for nested_device_group in network_group.DeviceGroup.find():\n                    # Check for RoCEv2 under IPv4 in nested device group\n                    try:\n                        ipv4_list = nested_device_group.Ethernet.find().Ipv4.find()\n                        for ipv4 in ipv4_list:\n                            rocev2 = ipv4.Rocev2.find()\n                            if rocev2:\n                                for stack in rocev2:\n                                    rocev2_names.append(stack.Name)\n                    except Exception:\n                        pass  # IPv4 or RoCEv2 not found, move on\n\n                    # Check for RoCEv2 under IPv4Loopback in nested device group\n                    try:\n                        ipv4_loopback_list = nested_device_group.Ipv4Loopback.find()\n                        for ipv4_loopback in ipv4_loopback_list:\n                            rocev2 = ipv4_loopback.Rocev2.find()\n                            if rocev2:\n                                for stack in rocev2:\n                                    rocev2_names.append(stack.Name)\n                    except Exception:\n                        pass  # IPv4Loopback or RoCEv2 not found, move on\n\n    return rocev2_names\n```",
    "metadata": {
      "type": "validated_generation",
      "confidence": "medium",
      "source": "agent"
    }
  },
  {
    "id": "6e54e257-528a-4519-953d-bbe7c1ecf2b6",
    "text": "Q:\n\n\ncreate an api to find rocev2 names across all device group, it can be two level device group as well,\n-Do it for ipv6 stack as well that represents Roce6v2\ninclude ipv6, and ipv6loopback with proper conditioning\n\nfollowing ixia_multicast.py patterns.\n\n\nA:\n```python\ndef get_rocev2_names(self):\n    \"\"\"\n    Retrieves the names of all RoCEv2 and RoCEv6 stacks across all device groups,\n    including two-level device groups. This method checks for RoCE stacks under\n    IPv4, IPv6, IPv4Loopback, and IPv6Loopback.\n\n    Returns:\n        list: A list of RoCEv2 and RoCEv6 stack names.\n    \"\"\"\n    roce_names = []\n\n    # Iterate through all topologies\n    for topology in self.ixNetwork.Topology.find():\n        # Iterate through all device groups in the topology\n        for device_group in topology.DeviceGroup.find():\n            # Check for RoCEv2 under IPv4\n            try:\n                ipv4_list = device_group.Ethernet.find().Ipv4.find()\n                for ipv4 in ipv4_list:\n                    rocev2 = ipv4.Rocev2.find()\n                    if rocev2:\n                        for stack in rocev2:\n                            roce_names.append(stack.Name)\n            except Exception:\n                pass  # IPv4 or RoCEv2 not found, move on\n\n            # Check for RoCEv6 under IPv6\n            try:\n                ipv6_list = device_group.Ethernet.find().Ipv6.find()\n                for ipv6 in ipv6_list:\n                    rocev6 = ipv6.Rocev6.find()\n                    if rocev6:\n                        for stack in rocev6:\n                            roce_names.append(stack.Name)\n            except Exception:\n                pass  # IPv6 or RoCEv6 not found, move on\n\n            # Check for RoCEv2 under IPv4Loopback\n            try:\n                ipv4_loopback_list = device_group.Ipv4Loopback.find()\n                for ipv4_loopback in ipv4_loopback_list:\n                    rocev2 = ipv4_loopback.Rocev2.find()\n                    if rocev2:\n                        for stack in rocev2:\n                            roce_names.append(stack.Name)\n            except Exception:\n                pass  # IPv4Loopback or RoCEv2 not found, move on\n\n            # Check for RoCEv6 under IPv6Loopback\n            try:\n                ipv6_loopback_list = device_group.Ipv6Loopback.find()\n                for ipv6_loopback in ipv6_loopback_list:\n                    rocev6 = ipv6_loopback.Rocev6.find()\n                    if rocev6:\n                        for stack in rocev6:\n                            roce_names.append(stack.Name)\n            except Exception:\n                pass  # IPv6Loopback or RoCEv6 not found, move on\n\n            # Check for nested device groups (two-level)\n            for nested_device_group in device_group.DeviceGroup.find():\n                # Check for RoCEv2 under IPv4 in nested device group\n                try:\n                    ipv4_list = nested_device_group.Ethernet.find().Ipv4.find()\n                    for ipv4 in ipv4_list:\n                        rocev2 = ipv4.Rocev2.find()\n                        if rocev2:\n                            for stack in rocev2:\n                                roce_names.append(stack.Name)\n                except Exception:\n                    pass  # IPv4 or RoCEv2 not found, move on\n\n                # Check for RoCEv6 under IPv6 in nested device group\n                try:\n                    ipv6_list = nested_device_group.Ethernet.find().Ipv6.find()\n                    for ipv6 in ipv6_list:\n                        rocev6 = ipv6.Rocev6.find()\n                        if rocev6:\n                            for stack in rocev6:\n                                roce_names.append(stack.Name)\n                except Exception:\n                    pass  # IPv6 or RoCEv6 not found, move on\n\n                # Check for RoCEv2 under IPv4Loopback in nested device group\n                try:\n                    ipv4_loopback_list = nested_device_group.Ipv4Loopback.find()\n                    for ipv4_loopback in ipv4_loopback_list:\n                        rocev2 = ipv4_loopback.Rocev2.find()\n                        if rocev2:\n                            for stack in rocev2:\n                                roce_names.append(stack.Name)\n                except Exception:\n                    pass  # IPv4Loopback or RoCEv2 not found, move on\n\n                # Check for RoCEv6 under IPv6Loopback in nested device group\n                try:\n                    ipv6_loopback_list = nested_device_group.Ipv6Loopback.find()\n                    for ipv6_loopback in ipv6_loopback_list:\n                        rocev6 = ipv6_loopback.Rocev6.find()\n                        if rocev6:\n                            for stack in rocev6:\n                                roce_names.append(stack.Name)\n                except Exception:\n                    pass  # IPv6Loopback or RoCEv6 not found, move",
    "metadata": {
      "type": "validated_generation",
      "confidence": "medium",
      "source": "agent"
    }
  }
]